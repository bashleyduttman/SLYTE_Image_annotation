{"version":3,"file":"components/javascript/home-comp.js","mappings":";;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;;;;;;;AA1HA;AAAA;AAAA;AA8HA;AA9HA;;;;;;;;;;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAr/CA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAu/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAhnDA;;;;;;;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AA/gBA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmhBA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA3jBA;;;;;;;;;;;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AA7/DA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkgEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA3hEA;;;;;;;;;;;;;;;;;;;;;;;;ACtOA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAjbA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAobA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAlfA","sources":["webpack://Imageannotation/./components/javascript/home-comp.js","webpack://Imageannotation/./node_modules/@zoho/lyte-ui-component/components/javascript/lyte-fileupload.js","webpack://Imageannotation/./node_modules/@zoho/lyte-ui-component/components/javascript/lyte-hovercard.js","webpack://Imageannotation/./node_modules/@zoho/lyte-ui-component/components/javascript/lyte-popover.js","webpack://Imageannotation/./node_modules/@zoho/lyte-ui-component/components/javascript/lyte-text.js"],"sourcesContent":["import './../../node_modules/@zoho/lyte-ui-component/components/javascript/lyte-fileupload.js';\nimport './loading-comp.js';\nimport {Component} from \"@slyte/component\";\nimport { prop } from \"@slyte/core\";\nimport { ImagesSchema } from \"/data-store/schemas/Images\";\nclass HomeComp extends Component {\n\tconstructor() {\n\t\tsuper();\n\t}\n\tinit(){\n\t\tthis.setData(\"images\",this.data.data)\n\t\t// const temp=this.getData(\"images\")\n\t\tvar images=this.getData(\"images\");\n\t\tthis.setData(\"size\",images.reduce((sum,img)=>sum+parseInt(img.size),0))\n\t\tconsole.log(\"image. \",images)\n\t\t\n\t\t\n\t\t\n\t}\n\tdata() {\n\t\treturn {\n\t\t\timages:prop(\"array\",{watch:true}),\n\t\t\tselectedFile:prop(\"object\"),\n\t\t\tpreviewUrl:prop(\"string\",{default:\"none\"}),\n\t\t\ttotal:prop(\"number\",{default:0}),\n\t\t\tsize:prop(\"number\",{default:0})\n\t\t\t\n\t\t}\t\n\t}\n\n\tstatic methods() {\n\t\treturn {\n\t\t\tonRemove:function(){\n\t\t\t\tconsole.log(\"dropped\");\n\t\t\t\tthis.setData(\"previewUrl\",\"none\");\n\t\t\t},\n\t\t\tonSuccess:function(event){\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic actions() {\n\t\treturn {\n\t\t\tonImageChange:function(event){\n\t\t\t\tconsole.log(\"event\",event)\n\t\t\t\tvar file=event.target.files[0];\n\t\t\t\tconst urls=[];\n\t\t\t\t\n\t\t\t\tif(file && file.type.startsWith(\"image/\")){\n\t\t\t\t\tconst url=URL.createObjectURL(file);\n\t\t\t\t\tthis.setData(\"previewUrl\",url);\n\t\t\t\t\tthis.setData(\"selectedFile\",file)\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t},\n\t\t\tonUploadImage: function(event) {\n\t\t\t\tfunction convertToBase64(file) {\n\t\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\t\tconst reader = new FileReader();\n\t\t\t\t\t\treader.onload = () => resolve(reader.result);\n\t\t\t\t\t\treader.onerror = (error) => reject(error);\n\t\t\t\t\t\treader.readAsDataURL(file);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst file = this.data.selectedFile;\n\t\t\t\tconsole.log(\"on upload image\", file);\n\n\t\t\t\tif (file) {\n\t\t\t\t\tconsole.log(\"file pushed\");\n\t\t\t\t\tconst rec = this.$db.newEntity({ schema: ImagesSchema });\n\n\t\t\t\t\tconst size = file.size.toString();\n\n\t\t\t\t\tconvertToBase64(file).then((base64) => {\n\t\t\t\t\t\tconsole.log(\"base64:\", base64);\n\n\t\t\t\t\t\trec.$.set(\"name\", file.name);\n\t\t\t\t\t\trec.$.set(\"size\", size);\n\t\t\t\t\t\trec.$.set(\"file\", file);\n\t\t\t\t\t\trec.$.set(\"data\", base64);\n\n\t\t\t\t\t\trec.$.save().then(\n\t\t\t\t\t\t\tfunction(){\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfunction(){\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.setData(\"selectedFile\",null)\n\t\t\t\t\t\tvar filetag=document.getElementById(\"image-file\");\n\t\t\t\t\t\tfiletag.value=\"\"\n\t\t\t\t\t\tvar images=this.getData(\"images\");\n\t\t\t\t\t\tthis.setData(\"size\",images.reduce((sum,img)=>sum+parseInt(img.size),0))\n\t\t\t\t\t\t// this.setData(\"size\",this.getData(\"size\")+parseInt(size));\n\t\t\t\t\t\tthis.setData(\"previewUrl\",\"none\");\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tdocument.querySelector('lyte-fileupload').removeUpload();\n\t\t\t\t\t}).catch((err) => {\n\t\t\t\t\t\tconsole.error(\"Error converting file to Base64:\", err);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t\thandleEdit:function(event,data,id){\n\t\t\t\tlocalStorage.setItem(\"imageData\",data)\n\t\t\t\tlocalStorage.setItem(\"imageId\",id)\n\t\t\t\t// console.log(\"id. \",id)\n\t\t\t\tthis.$router.navigateTo(\"index.image\")\n\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t,\n\t\t\n\n\t\t}\n\t}\n\t\n\tstatic observers() {\n\t\treturn {\n\t\t\timageObserver:function(change){\n\t\t\t\tthis.setData(\"total\",this.getData(\"images\").length)\n\t\t\t}.observes('images.length')\n\t\t}\n\t}\n\n}\n\nexport {HomeComp}; \n","import './../helpers/helpers-dev.js';\nimport './lyte-text.js';\nimport { prop } from \"@slyte/core\";\nimport { Component } from \"../component.js\";\nimport $L from \"@zoho/lyte-dom\";\n\n/**\n * Renders a fileupload\n * @component lyte-fileupload\n * @dependency lyte-text, lyte-tooltip\n * @version 2.2.9\n * @utility upload,removeUpload\n * @methods beforeRender,afterRender,onBeforeAdd,onAdd,onBeforeRemove,onRemove,onBeforeSend,onSend,onFileSuccess,onFileRemove,onRequestSuccess,onRequestFailure,onSuccess,onFailure,\n * onProgress,onRetry,onReject,onChunkSuccess,onChunkError,onBeforeOpen,onDragEnter,onDragOver,onDragLeave,onBeforeDrop,onDrop,onBeforePaste,onPaste\n */\nclass LyteFileuploadComponent extends Component {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\tinit() {\n\t\tthis.getMethods('beforeRender') && this.executeMethod('beforeRender', this.$node)\n\t}\n\n\tdidConnect() {\n\t\tvar lyteSelf = this;\n\t\tthis._file = this.$node.querySelector('input.fileuploadInput');\n\t\tthis.$node.upload = this.processqueue.bind(this);\n\t\tthis.$node.removeUpload = function (id) {\n\t\t\tif (id) {\n\t\t\t\tthis.removeFrmUpload(id, 'queueList');\n\t\t\t} else {\n\t\t\t\tthis.removeFrmUpload(this.data.queueList, 'queueList', true);\n\t\t\t}\n\t\t\tthis._file.value = \"\";\n\t\t}.bind(this)\n\t\tthis.$node.predefined = function (files) {\n\t\t\tif (!Array.isArray(files)) {\n\t\t\t\tfiles = [files]\n\t\t\t}\n\t\t\tfor (var index = 0; index < files.length; index++) {\n\t\t\t\tlyteSelf.$addon.arrayUtils(this.data.predefinedList, \"push\", files[index]);\n\t\t\t}\n\t\t}.bind(this);\n        /**\n\t\t* @utility addFiles\n\t\t* @version 2.2.15\n\t\t*/\n\t\tthis.$node.addFiles = function (files) {\n\t\t\tif (!Array.isArray(files)) {\n\t\t\t\tfiles = [files]\n\t\t\t}\n\t\t\tthis.validate(files);\n\t\t}.bind(this);\n\t\tthis.folderUpload();\n\t\tthis.getMethods('afterRender') && this.executeMethod('afterRender', this.$node);\n\t}\n\n\tdidDestroy() {\n\t\tthis.$node.removeUpload();\n\t\tif (this._triggerId) {\n\t\t\tclearTimeout(this._triggerId);\n\t\t\tdelete this._triggerId;\n\t\t}\n\t\tif (this._resetId) {\n\t\t\tclearTimeout(this._resetId);\n\t\t\tdelete this._resetId;\n\t\t}\n\t\tdelete this._file;\n\t\tdelete this.$node.upload;\n\t\tdelete this.$node.removeUpload;\n\t\tdelete this.$node.predefined;\n\t\tdelete this.$node.addFiles;\n\t}\n\n\taddAriaForButton(aria, key, dataName, defaultValue) {\n\t\tif (aria.hasOwnProperty(key)) {\n\t\t\tdefaultValue = aria[key];\n\t\t\tdelete aria[key];\n\t\t}\n\t\tthis.setData(dataName, defaultValue);\n\t}\n\n\taddAriaValues(newAria) {\n\t\tvar oldAria = this.data.commonAriaLabel;\n\t\tvar fileUploadWrapper = this.$node.querySelector(\".fileUploadWrapper\");\n\t\tnewAria = Object.assign({}, newAria);\n\t\tthis.addAriaForButton(newAria, \"close-label\", \"ariaCloseLabel\", \"remove\");\n\t\twindow._lyteUiUtils.setAttribute(fileUploadWrapper, newAria, oldAria);\n\t\tthis.setData(\"commonAriaLabel\", newAria);\n\t}\n\n\tdata() {\n\t\treturn {\n\t\t\t// file input property\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropName=file\n\t\t\t */\n\t\t\tltPropName: prop('string', { \"default\": \"file\" }),\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropMultiple=true\n\t\t\t */\n\t\t\tltPropMultiple: prop('boolean', { \"default\": true }),\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropAccept\n\t\t\t */\n\t\t\tltPropAccept: prop('string', { \"default\": '' }),\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropId\n\t\t\t*/\n\t\t\tltPropId: prop('string', { \"default\": '' }),\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropClass\n\t\t\t */\n\t\t\tltPropClass: prop('string', { \"default\": '' }),\n\t\t\t/**\n\t\t\t * @componentProperty {Box | Btn | Input} ltPropAppearance=Box\n\t\t\t */\n\t\t\tltPropAppearance: prop('string', {\n\t\t\t\t\"default\": window._lyteUiUtils.resolveDefaultValue('lyte-fileupload', 'appearance', \"Box\")\n\t\t\t}),\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropDisabled=false\n\t\t\t */\n\t\t\tltPropDisabled: prop('boolean', { \"default\": false }),\n\t\t\t// file uploader data\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropYield=false\n\t\t\t */\n\t\t\tltPropYield: prop('boolean', { \"default\": false }),\n\t\t\t// ltPropMultipleUpload : Lyte.attr( 'boolean', { default : true } ),\n\t\t\t/**\n\t\t\t * @componentProperty {number} ltPropFileLimit\n\t\t\t*/\n\t\t\tltPropFileLimit: prop('number', { \"default\": undefined }),\n\t\t\t/**\n\t\t\t * @componentProperty {number} ltPropMinimumFileSize=0\n\t\t\t * @version 2.2.11\n\t\t\t*/\n\t\t\tltPropMinimumFileSize: prop('number', { \"default\": 0 }),\n\t\t\t/**\n\t\t\t * @componentProperty {number} ltPropTotalFilesSize\n\t\t\t * @version 3.2.1\n\t\t\t*/\n\t\t\tltPropTotalFilesSize: prop('string'),\n\t\t\t/**\n\t\t\t * @componentProperty {number} ltPropParallel=2\n\t\t\t*/\n\t\t\tltPropParallel: prop('number', { \"default\": 2 }),\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropAutoUpload=true\n\t\t\t*/\n\t\t\tltPropAutoUpload: prop('boolean', { \"default\": true }),\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropTriggerUpload=false\n\t\t\t*/\n\t\t\tltPropTriggerUpload: prop('boolean', { \"default\": false }),\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropParamName=file\n\t\t\t */\n\t\t\tltPropParamName: prop('string', {\n\t\t\t\t\"default\": window._lyteUiUtils.resolveDefaultValue('lyte-fileupload', 'paramName', 'file')\n\t\t\t}),\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropThumb=false\n\t\t\t */\n\t\t\tltPropThumb: prop('boolean', { \"default\": false }),\n\t\t\t/**\n\t\t\t * @componentProperty {number} ltPropTabindex=0\n\t\t\t */\n\t\t\tltPropTabindex: prop('number', { \"default\": 0 }),\n\t\t\t/**\n\t\t\t * @componentProperty {number} ltPropRetry=2\n\t\t\t */\n\t\t\tltPropRetry: prop('number', {\n\t\t\t\t\"default\": window._lyteUiUtils.resolveDefaultValue('lyte-fileupload', 'retry', 2)\n\t\t\t}),\n\t\t\t/**\n\t\t\t * @componentProperty {Bytes | KB | MB | GB | TB | PB | EB | ZB | YB} ltPropFileUnit\n\t\t\t */\n\t\t\tltPropFileUnit: prop('string', { \"default\": '' }),\n\t\t\t/**\n\t\t\t * @componentProperty {number} ltPropDigits=1\n\t\t\t */\n\t\t\tltPropDigits: prop('number', {\n\t\t\t\t\"default\": window._lyteUiUtils.resolveDefaultValue('lyte-fileupload', 'digits', 1)\n\t\t\t}),\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropMessage\n\t\t\t * @default Drag file here or browse to upload\n\t\t\t */\n\t\t\tltPropMessage: prop('string', {\n\t\t\t\t\"default\": window._lyteUiUtils.resolveDefaultValue('lyte-fileupload', 'message', \"Drag file here or browse to upload\")\n\t\t\t}),\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropFailureMessage\n\t\t\t * @default Attachment failed\n\t\t\t */\n\t\t\tltPropFailureMessage: prop('string', {\n\t\t\t\t\"default\": window._lyteUiUtils.resolveDefaultValue('lyte-fileupload', 'failureMessage', \"Attachment failed\")\n\t\t\t}),\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropRetryText=Retry\n\t\t\t */\n\t\t\tltPropRetryText: prop('string', {\n\t\t\t\t\"default\": window._lyteUiUtils.resolveDefaultValue('lyte-fileupload', 'retryText', \"Retry\")\n\t\t\t}),\n\t\t\tltPropFiles: prop(\"array\", { \"default\": [] }),\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropChunk=false\n\t\t\t */\n\t\t\tltPropFolder: prop(\"boolean\", { \"default\": false }),\n\t\t\t// chunking\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropChunk=false\n\t\t\t */\n\t\t\tltPropChunk: prop('boolean', { \"default\": false }),\n\t\t\t/**\n\t\t\t * @componentProperty {number} ltPropChunkSize=2000000\n\t\t\t */\n\t\t\tltPropChunkSize: prop('number', { \"default\": 2000000 }),\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropParallelChunkUpload=false\n\t\t\t */\n\t\t\tltPropParallelChunkUpload: prop('boolean', { \"default\": false }),\n\t\t\t/**\n\t\t\t * @componentProperty {number} ltPropParallelChunkCount=Infinity\n\t\t\t */\n\t\t\tltPropParallelChunkCount: prop('number', { \"default\": Infinity }),\n\t\t\t/**\n\t\t\t * @componentProperty {number} ltPropChunkRetry=2\n\t\t\t */\n\t\t\tltPropChunkRetry: prop('number', { \"default\": 2 }),\n\n\t\t\t// preventing multiple upload\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropUploadMultiple=false\n\t\t\t */\n\t\t\tltPropUploadMultiple: prop('boolean', { \"default\": false }),\n\t\t\t/**\n\t\t\t * @componentProperty {number} ltPropUploadMultipleCount=Infinity\n\t\t\t */\n\t\t\tltPropUploadMultipleCount: prop('number', { \"default\": Infinity }),\n\t\t\t/**\n\t\t\t\t * @typedef {Object} ajaxConfig\n\t\t\t * @property {string} url=''\n\t\t\t */\n\t\t\t/**\n\t\t\t * @componentProperty {ajaxConfig} ltPropAjax\n\t\t\t */\n\t\t\tltPropAjax: prop('object', { \"default\": { url: '' } }),\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropAllowReplace=false\n\t\t\t */\n\t\t\tltPropAllowReplace: prop(\"boolean\", { \"default\": false }),\n\t\t\t/**\n\t\t\t * @componentProperty {number} ltPropFilesCount=Infinity\n\t\t\t * @version 3.25.0\n\t\t\t */\n\t\t\tltPropFilesCount: prop(\"number\", { \"default\": Infinity }),\n\t\t\t/**\n\t\t\t* @componentProperty {object} ltPropAriaAttributes\n\t\t\t* @version 3.1.0\n\t\t\t* @default {}\n\t\t\t*/\n\t\t\tltPropAriaAttributes: prop('object', {\n\t\t\t\tdefault: {\n\t\t\t\t\trole: \"button\",\n\t\t\t\t\t'aria-roledescription': \"fileupload\"\n\t\t\t\t}, watch: true\n\t\t\t}),\n\t\t\t/**\n\t\t\t* @componentProperty {boolean} ltPropReset=false\n\t\t\t* @version 3.59.0\n\t\t\t*/\n\t\t\tltPropReset: prop(\"boolean\", { default: false }),\n\t\t\t/**\n\t\t\t* @componentProperty {boolean} ltPropPreventDuplicate=false\n\t\t\t* @version 3.93.0\n\t\t\t*/\n\t\t\tltPropPreventDuplicate: prop(\"boolean\", { default: false }),\n\t\t\tltPropListErrorFiles : prop(\"boolean\", { default : false}),\n\n\t\t\tltPropResetFileValue: prop(\"boolean\", { default: false }),\n\t\t\tltPropAria: prop(\"boolean\", { default: false }),\n\t\t\tltPropDataTabindex: prop(\"string\", { default: \"\" }),\n\t\t\t// system data\n\t\t\tqueueList: prop('array', { \"default\": [] }),\n\t\t\tpredefinedList: prop('array', { \"default\": [] }),\n\t\t\tcurrentUpload: prop('array', { \"default\": [] }),\n\t\t\tchunkUpload: prop('array', { \"default\": [] }),\n\t\t\tfileClass: prop('string', { \"default\": '' }),\n\t\t\tchunkCount: prop('number', { \"default\": 0 }),\n\t\t\tabort: prop(\"boolean\", { \"default\": false }),\n\t\t\tlxhrs: prop(\"array\", { \"default\": [] }),\n\t\t\tuploadedFiles: prop(\"array\", { \"default\": [] }),\n\t\t\tmanualUpdFiles: prop(\"array\", { \"default\": [] }),\n\t\t\tuploadMultipleRetry: prop('number', { \"default\": 0 }),\n\t\t\tretryFiles: prop('array', { \"default\": [] }),\n\t\t\tretry: prop('boolean', { \"default\": false }),\n\t\t\tmanualUpload: prop('boolean', { \"default\": false }),\n\t\t\ttotalFilesSize: prop('number'),\n\t\t\tcurTotFilesSize: prop('number', { \"default\": 0 }),\n\t\t\tariaCloseLabel: prop(\"string\"),\n\t\t\tcommonAriaLabel: prop(\"object\", { \"default\": {} }),\n\t\t\tariaSelectedFiles: prop(\"string\", { \"default\": \"0\" }),\n\t\t\trandomAriaId: prop(\"string\")\n\t\t};\n\t}\n\n\tgetFileDataAsString(array) {\n\t\tvar string = \"\";\n\t\tvar sizeHelper = this.$component.registeredHelpers.lyteUiFileSize;\n\t\tvar ltPropFileUnit = this.data.ltPropFileUnit;\n\t\tvar ltPropDigits = this.data.ltPropDigits;\n\t\tarray.forEach(function (item) {\n\t\t\tstring += (\"name \" + item.name + \" size \" + sizeHelper(item.size, ltPropFileUnit, ltPropDigits)) + \" \"\n\t\t});\n\t\treturn string;\n\t}\n\n\tconstructAriaString() {\n\t\tif (this.data.ltPropAria) {\n\t\t\tvar selectFiles = this.getFileDataAsString(this.data.predefinedList);\n\t\t\tselectFiles = this.getFileDataAsString(this.data.queueList);\n\t\t\tif (selectFiles) {\n\t\t\t\tthis.setData(\"ariaSelectedFiles\", selectFiles);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.setData(\"ariaSelectedFiles\", \"0\");\n\t\t\t}\n\t\t}\n\t}\n\n\texceedTotalCount() {\n\t\tvar fileCount =  this.data.ltPropFilesCount;\n\t\tif(fileCount !== Infinity)  {\n\t\t\tvar predefinedList = this.data.predefinedList || [];\n\t\t\tvar noOfFiles = predefinedList.length + this.getValidQueueListCount();\n\t\t\tif(noOfFiles < fileCount) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n \t\t}\n\t\treturn false;\n\t}\n\n\tfolderUpload() {\n\t\tvar folder = this.data.ltPropFolder\n\t\tif (folder) {\n\t\t\tthis._file.setAttribute(\"webkitdirectory\", true);\n\t\t}\n\t\telse {\n\t\t\tthis._file.removeAttribute(\"webkitdirectory\");\n\t\t}\n\t}\n\n\tvalidateAndGetType(fileName, fileType, reason) {\n\t\tvar acceptRegex = new RegExp(this.data.ltPropAccept.replace(/\\s+/g, \"\").split(\",\").join(\"|\"));\n\t\tvar extension = \"\", type, extensionWithDot;\n\t\tif (fileName) {\n\t\t\textension = fileName.substring(fileName.lastIndexOf('.') + 1, fileName.length);\n\t\t\textensionWithDot = \".\" + extension;\n\t\t}\n\t\tif (acceptRegex.test(fileType)) {\n\t\t\ttype = fileType.match(/(video|image|pdf|zip)/ig);\n\t\t\ttype = type && type[0] ? type[0] : extension;\n\t\t}\n\t\telse if (acceptRegex.test(extension) || acceptRegex.test(extensionWithDot)) {\n\t\t\ttype = extension;\n\t\t}\n\t\telse {\n\t\t\treason.type = \"Invalid_Type\";\n\t\t}\n\t\treturn type;\n\t}\n\n\tvalidateSize(file, reason) {\n\t\tif (file.size < this.data.ltPropMinimumFileSize) {\n\t\t\treason.size = \"Lower_Size\";\n\t\t}\n\t\telse if (file.size > this.data.ltPropFileLimit) {\n\t\t\treason.size = \"Higher_Size\";\n\t\t}\n\t\telse if (this.checkTotalFilessize(file.size)) {\n\t\t\treason.totalSize = \"Exceeds\";\n\t\t}\n\t}\n\n\tcheckFileName(fileName, fileObject) {\n\t\treturn fileName === fileObject.name;\n\t}\n\n\tfindDuplicateInArray(array, fileName) {\n\t\tvar index = this.findIndex(array, this.checkFileName.bind(this, fileName))\n\t\treturn index > -1;\n\t}\n\n\tvalidateDuplicateFile(fileObject, reason) {\n\t\tif(this.data.ltPropPreventDuplicate) {\n\t\t\tvar predefinedList =  this.data.predefinedList;\n\t\t\tvar queueList =  this.data.queueList;\n\t\t\tvar fileName = fileObject.name;\n\t\t\tvar duplicate = this.findDuplicateInArray(predefinedList, fileName);\n\t\t\tduplicate = duplicate || this.findDuplicateInArray(queueList, fileName);\n\t\t\tif (duplicate) {\n\t\t\t\treason.duplicate = true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tvalidate(files) { \n\t\tvar promises = [],clearflag=false, listErrorFiles = this.data.ltPropListErrorFiles;\n\t\tfor( var j = 0; j < files.length; j++ ) {\n\t\t\tvar reason = {}, isChunk=this.data.ltPropChunk,\n\t\t\tfileName=files[ j ].name,fileType=files[ j ].type,\n\t\t\ttype;\n\t\t\tif(this.exceedTotalCount())  {\n\t\t\t\treason.fileCount = \"Exceeds\"; \n\t\t\t\ttype = fileType ? fileType : fileName.substring(fileName.lastIndexOf('.')+1, fileName.length);\n\t\t\t}\n\t\t\telse if(this.validateDuplicateFile(files[ j ], reason)){\n\t\t\t\ttype = this.validateAndGetType(fileName, fileType, reason);\n\t\t\t\tthis.validateSize(files[ j ], reason);\n\t\t\t}\n\t\t\tif ( Object.keys(reason).length > 0 ){ \n\t\t\t\tvar rejectedFile =  files[ j ],\n\t\t\t\tfileObject = listErrorFiles ? this.constructFileObject(rejectedFile, isChunk, type, this.constructReasonAsStr(reason)) : void 0;\n\t\t\t\tclearflag = true;\n\t\t\t\tthis.getMethods( 'onReject' ) && this.executeMethod( 'onReject', rejectedFile, reason, this.$node, fileObject);\n\t\t\t\tif(listErrorFiles) { \n\t\t\t\t\tthis.$addon.arrayUtils( this.data.queueList, 'push', fileObject );\n\t\t\t\t}\n\t\t\t\telse if(reason.fileCount) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar ret, fileObject = this.constructFileObject(files[ j ], isChunk, type);\n\t\t\t\tif( this.getMethods( 'onBeforeAdd' ) ) {\n\t\t\t\t\tret = this.executeMethod( 'onBeforeAdd', files[ j ], this.$node, fileObject);\n\t\t\t\t}\n\t\t\t\tif (ret == false) {\n\t\t\t\t\tclearflag = true;\n\t\t\t\t\tif(listErrorFiles) { \n\t\t\t\t\t\tfileObject.lyteErrorMsg = fileObject.lyteErrorMsg || \"Invalid File\"\n\t\t\t\t\t\tthis.$addon.arrayUtils( this.data.queueList, 'push', fileObject );\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ret && ret.then) {\n\t\t\t\t\tpromises.push(ret);\n\t\t\t\t\tvar cur = files[j];\n\t\t\t\t\tPromise.resolve(ret).then(this.add.bind(this, cur, isChunk, type))\n\t\t\t\t} else {\n\t\t\t\t\tthis.add(files[ j ], fileObject);\n\t\t\t\t}\n\t\t\t\tif (!this.data.ltPropMultiple) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (clearflag || this.data.ltPropResetFileValue) {\n\t\t\tthis._file.value = \"\";\n\t\t}\n\t\tif( this.data.ltPropAutoUpload ){\n\t\t\tpromises.length ? this.$addon.resolvePromises( promises ).then( this.processqueue.bind( this ) ) : this.processqueue();\n\t\t} \n\t\tthis.constructAriaString();\n \t}\n\n\tgetValidQueueListCount() {\n\t\tvar queueList = this.data.queueList;\n\t\tvar ltPropListErrorFiles =  this.data.ltPropListErrorFiles;\n\t\tif(ltPropListErrorFiles) {\n\t\t\tvar array = queueList.filter(function(item){\n\t\t\t\treturn !item.lyteErrorMsg;\n\t\t\t});\n\t\t\treturn array.length;\n\t\t}\n\t\treturn queueList.length;\n\t}\n\n    constructFileObject(file, isChunk, fileType, errorMsg) {\n\t\tvar fileObject = { id : 'lyte' + new Date().getTime() + parseInt( Math.random() * 10E10 ), file : file, size : file.size, name : file.name, isChunk: isChunk, retry : 0, fileType : ( fileType? fileType:'document') };\n \t\tif( this.data.ltPropThumb && /image/i.test( file.type ) ) {\n            this.$component.set( fileObject, 'src', URL.createObjectURL( file ) );\n\t\t}\n\t\tif(errorMsg) {\n\t\t\tfileObject.lyteErrorMsg =  errorMsg;\n\t\t}\n\t\treturn fileObject;\n\t}\n\n\tadd(file, fileObject) { //fileobject => file info,  file =>File Constructor\n\t\tthis.$addon.arrayUtils( this.data.queueList, 'push', fileObject );\n\t\tthis.addToTotalFilesSize(file.size);\n\t\tthis.$addon.arrayUtils( this.data.uploadedFiles, 'push', fileObject );\n\t\tthis.$addon.arrayUtils( this.data.ltPropFiles, 'push' , file);\n\t\tthis.getMethods( 'onAdd' ) && this.executeMethod( 'onAdd', file, this.$node, fileObject );\n \t}\n\n\tchkId(id, obj) {\n\t\treturn obj.id == id;\n\t}\n\n\tSendingFile() {\n\t\tvar data = this.data,\n\t\t\tmanualUpdFiles = data.manualUpdFiles;\n\t\tfor (var index = 0; index < manualUpdFiles.length;) {\n\t\t\tvar current = manualUpdFiles[index];\n\t\t\tif (!current.status || (current.isChunk && current.status == \"uploading\")) {\n\t\t\t\tif (current.isChunk) {\n\t\t\t\t\tif (!current.status) {\n\t\t\t\t\t\tthis.setData(\"manualUpload\", true);\n\t\t\t\t\t\tthis.uploadFile(current);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (current.finished + current.currentUploadingChunks < current.chunks.length) {\n\t\t\t\t\t\tthis.setData(\"manualUpload\", true);\n\t\t\t\t\t\tthis.uploadFile(current);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (data.currentUpload.length < data.ltPropParallel) {\n\t\t\t\t\t\tthis.setData(\"manualUpload\", true);\n\t\t\t\t\t\tthis.$addon.arrayUtils(data.currentUpload, 'push', current);\n\t\t\t\t\t\tthis.uploadFile(current);\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t\tif (index === manualUpdFiles.length) {\n\t\t\tthis.finishcallback(manualUpdFiles);\n\t\t}\n\t}\n\n\tprocessqueue(id, check, frmRetry) {\n\t\tvar data = this.data, idx = 0,\n\t\t\tmultiple = [];\n\t\tif (id && !frmRetry) {\n\t\t\tif (id.constructor != Array) {\n\t\t\t\tid = [id];\n\t\t\t}\n\t\t\tfor (var i = 0; i < id.length; i++) {\n\t\t\t\tvar fileId = id[i].id || id[i];\n\t\t\t\tvar file = data.queueList[this.findIndex(data.queueList, this.chkId.bind(this, fileId))];\n\t\t\t\tif (file) {\n\t\t\t\t\tthis.$addon.arrayUtils(this.data.manualUpdFiles, 'push', file);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.data.manualUpdFiles.length) {\n\t\t\t\tthis.SendingFile();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (data.manualUpload) {\n\t\t\tthis.SendingFile();\n\t\t\treturn;\n\t\t}\n\t\twhile (((data.currentUpload.length < data.ltPropParallel) || (data.ltPropUploadMultiple && data.currentUpload.length < data.ltPropUploadMultipleCount) /*|| ( !data.ltPropMultipleUpload && !data.currentUpload.length ) */) || frmRetry && data.queueList.length) {\n\t\t\tvar current = data.queueList[idx];\n\t\t\tif (id) {\n\t\t\t\tid = id.constructor == Object ? id.id : id;\n\t\t\t\tcurrent = data.queueList[this.findIndex(data.queueList, this.chkId.bind(this, id))]\n\t\t\t\tif (frmRetry && current) {\n\t\t\t\t\tthis.$addon.arrayUtils(this.data.retryFiles, 'push', current);\n\t\t\t\t\tthis.$component.set(current, 'status', 'reloading');\n\t\t\t\t\tif (data.uploadedFiles.indexOf(current) < 0) {\n\t\t\t\t\t\tthis.$addon.arrayUtils(this.data.uploadedFiles, 'push', current);\n\t\t\t\t\t\tthis.retrySendingFile();\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (current) {\n\t\t\t\tif (/uploading|success/.test(current.status)) {\n\t\t\t\t\tif (id) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (/uploading/.test(current.status) && current.isChunk && current.finished + current.currentUploadingChunks < current.chunks.length) {\n\t\t\t\t\t\tthis.processChunkQueue(current.chunks);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tidx++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else if (current.status == 'error' && (this.data.ltPropUploadMultiple || (current.retry >= (data.ltPropRetry - 1) || current.isChunk)) && !id) {\n\t\t\t\t\tidx++;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (current.status == 'reloading') {\n\t\t\t\t\tidx++;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (current.lyteErrorMsg) {\n\t\t\t\t\tidx++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!current.isChunk) {\n\t\t\t\t\tthis.$addon.arrayUtils(data.currentUpload, 'push', current);\n\t\t\t\t}\n\t\t\t\tif (!this.data.ltPropUploadMultiple) {\n\t\t\t\t\tthis.uploadFile(current)\n\t\t\t\t\tif (id || current.isChunk) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmultiple.push(current);\n\t\t\t\t}\n\t\t\t\tidx++;\n\t\t\t} else {\n\t\t\t\tthis.data.retryFiles.length && this.retrySendingFile();\n\t\t\t\tif (check) {\n\t\t\t\t\tthis.finishcallback();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (this.data.ltPropUploadMultiple && multiple.length) {\n\t\t\tthis.uploadFile(multiple);\n\t\t}\n\n\t}\n\n\tretrySendingFile() {\n\t\tvar data = this.data,\n\t\t\tretryFiles = data.retryFiles;\n\t\tfor (var index = 0; index < retryFiles.length;) {\n\t\t\tvar current = retryFiles[index];\n\t\t\tif (current.status == \"reloading\" || current.status == \"uploading\") {\n\t\t\t\tif (current.isChunk) {\n\t\t\t\t\tif (current.finished + current.currentUploadingChunks < current.chunks.length) {\n\t\t\t\t\t\tthis.setData(\"retry\", true);\n\t\t\t\t\t\tthis.processChunkQueue(current.chunks);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (data.currentUpload.length < data.ltPropParallel) {\n\t\t\t\t\t\tthis.setData(\"retry\", true);\n\t\t\t\t\t\tthis.$addon.arrayUtils(retryFiles, \"removeAt\", index);\n\t\t\t\t\t\tthis.$addon.arrayUtils(data.currentUpload, 'push', current);\n\t\t\t\t\t\tthis.getMethods('onRetry') && this.executeMethod('onRetry', {}, current, this.$node);\n\t\t\t\t\t\tthis.uploadFile(current);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.$addon.arrayUtils(retryFiles, \"removeAt\", index);\n\t\t\t}\n\t\t}\n\t\tif (!retryFiles.length) {\n\t\t\tthis.setData(\"retry\", false);\n\t\t\tthis.processqueue(undefined, true);\n\t\t}\n\t}\n\n\tfindIndex(array, condition) {\n\t\tif (condition.constructor == Function) {\n\t\t\tfor (var i = 0; i < array.length; i++) {\n\t\t\t\tvar ret = condition.call(array[i], array[i]);\n\t\t\t\tif (ret) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn array.indexOf(condition);\n\t\t}\n\t}\n\n\tabortChunksFrmUpload(id) {\n\t\tvar data = this.data, chunkUpload = data.chunkUpload;\n\t\tfor (var index = 0; index < chunkUpload.length;) {\n\t\t\tvar chunk = chunkUpload[index];\n\t\t\tif (chunk.chunkProp.origin.id === id && chunk.xhr) {\n\t\t\t\tthis.setData(\"abort\", true);\n\t\t\t\tchunk.xhr.ret.abort();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\n\n\tremoveFrmUpload(idd, arrnme, prevent, check) {//need to be checked\n\t\tif (idd.constructor != Array) {\n\t\t\tidd = [idd];\n\t\t}\n\t\tfor (var i = 0; i < idd.length; i++) {\n\t\t\tvar id = idd[i].id || idd[i];\n\t\t\tvar arr = this.data[arrnme], crct = this.findIndex(arr, this.chkId.bind(this, id)), flag, cur;\n\t\t\tif (crct === undefined || crct < 0) {\n\t\t\t\tarr = this.data.predefinedList;\n\t\t\t\tcrct = this.findIndex(arr, this.chkId.bind(this, id));\n\t\t\t\tif (crct > -1) {\n\t\t\t\t\tarrnme = \"predefinedList\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (crct >= 0) {\n\t\t\t\tif (!prevent && this.getMethods('onBeforeRemove') && this.executeMethod('onBeforeRemove', arrnme, arr[crct], this.$node) == false) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcur = arr[crct];\n\t\t\t\tif (arrnme === \"queueList\") {\n\t\t\t\t\tthis.removeFromTotalFileSize(cur.size)\n\t\t\t\t}\n\t\t\t\tif (cur.status == 'uploading') {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tif (cur.xhr) {\n\t\t\t\t\t\tthis.setData(\"abort\", true);\n\t\t\t\t\t\tcur.xhr.ret.abort();\n\t\t\t\t\t}\n\t\t\t\t\tif (cur.isChunk) {\n\t\t\t\t\t\tthis.abortChunksFrmUpload(cur.id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$addon.arrayUtils(arr, 'removeAt', crct);\n\t\t\t\tif (arrnme === \"queueList\") {\n\t\t\t\t\tvar lxhrs = this.getData(\"lxhrs\");\n\t\t\t\t\tvar lxhr = $L.search(lxhrs, \"fileId\", cur.id)[0], index;\n\t\t\t\t\tif (cur.isChunk && flag) {\n\t\t\t\t\t\tthis.getMethods(\"onFileFailure\") && this.executeMethod('onFileFailure', lxhr, cur, this.$node, true);\n\t\t\t\t\t}\n\t\t\t\t\tthis.$addon.arrayUtils(this.data.ltPropFiles, 'removeAt', crct);\n\t\t\t\t\tvar temparray = this.data.uploadedFiles, tempId = this.findIndex(temparray, this.chkId.bind(this, id))\n\t\t\t\t\tif (tempId >= 0) {\n\t\t\t\t\t\tthis.$addon.arrayUtils(temparray, 'removeAt', tempId);\n\t\t\t\t\t}\n\t\t\t\t\tvar temparray = this.data.retryFiles, tempId = this.findIndex(temparray, this.chkId.bind(this, id))\n\t\t\t\t\tif (tempId >= 0) {\n\t\t\t\t\t\tthis.$addon.arrayUtils(temparray, 'removeAt', tempId);\n\t\t\t\t\t}\n\t\t\t\t\tindex = lxhrs.indexOf(lxhr);\n\t\t\t\t\tindex > -1 && this.$addon.arrayUtils(lxhrs, 'removeAt', index);\n\t\t\t\t\tif (crct <= i) {\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t!prevent && this.getMethods('onRemove') && this.executeMethod('onRemove', arrnme, cur, this.$node);\n\t\t\t}\n\t\t}\n\t\tif (!this.data.ltPropUploadMultiple && ((arrnme == \"queueList\" && flag) || check)) {\n\t\t\t//check is a flag to used to trigger the finishcallback\n\t\t\tthis.data.retry ? this.retrySendingFile() : this.processqueue(undefined, true);\n\t\t}\n\t\tif (arrnme === \"queueList\" || arrnme === \"predefinedList\") {\n\t\t\tthis.constructAriaString();\n\t\t}\n\t}\n\n\tuploadFile(file) {\n\t\tvar props = this.$addon.deepCopyObject(this.data.ltPropAjax);\n\t\tfile.isChunk ? this.proceedChunk(file, props) : this.proceedUpload(file, props, false);\n\t\t//comments may be need in future please check git\n\t\t// if( this.getMethods( 'onBeforeUpload' ) ) {\n\t\t// \tret = this.executeMethod( 'onBeforeUpload', file, props, this.$node );\n\t\t// }\n\t\t// if( ret && ret.then ) {\n\t\t// \tPromise.resolve( ret ).then( function(){\n\t\t// \t\tfile.isChunk ? this.proceedChunk( file, props ) : this.proceedUpload( file, props );\n\t\t// \t}.bind( this ))\n\t\t// } else if( ret != false ) {\n\n\t\t// } else {\n\t\t// \tif( file.constructor != Array ){\n\t\t// \t\tfile = [ file ];\n\t\t// \t}\n\t\t// \tfor( var i = 0; i < file.length; i++ ){\n\t\t// \t\t//this.removeFrmUpload( file[ i ].id, 'queueList' );\n\t\t// \t\tthis.removeFrmUpload( file[ i ].id, 'currentUpload',true);//need to be checked\n\t\t// \t}\n\t\t// }\n\t}\n\n\tsuccFunc(evt) {\n\t\tif (this.$node) {\n\t\t\tvar file = arguments[2].xhr.file, ret = arguments[2].xhr.ret, tempRet = [], duplicate;\n\t\t\tfile.xhr && delete file.xhr;\n\t\t\tthis.getMethods('onRequestSuccess') && this.executeMethod('onRequestSuccess', ret, file, this.$node);\n\t\t\tif (file.constructor != Array) {\n\t\t\t\tfile = [file];\n\t\t\t}\n\t\t\tfor (var i = 0; i < file.length; i++) {\n\t\t\t\tthis.$component.set(file[i], 'status', 'success');\n\t\t\t\tthis.$addon.objectUtils(file[i], 'delete', 'xhr');\n\t\t\t\tif (!this.data.ltPropUploadMultiple) {\n\t\t\t\t\tvar lxhrs = this.getData(\"lxhrs\");\n\t\t\t\t\tduplicate = $L.search(lxhrs, \"fileId\", file[i].id);\n\t\t\t\t\tduplicate.length && this.$addon.arrayUtils(lxhrs, 'removeAt', lxhrs.indexOf(duplicate[0]));\n\t\t\t\t\tret.fileId = file[i].id;\n\t\t\t\t\tthis.$addon.arrayUtils(this.getData(\"lxhrs\"), 'push', ret);\n\t\t\t\t\tthis.getMethods('onFileSuccess') && this.executeMethod('onFileSuccess', ret, file[i], this.$node);\n\t\t\t\t\tthis.removeFrmUpload(file[i].id, 'currentUpload', true, true); //need to be checked\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttempRet.push(file[i].id);\n\t\t\t\t\tthis.removeFrmUpload(file[i].id, 'currentUpload', true); //need to be checked\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.data.ltPropUploadMultiple) {\n\t\t\t\tret.fileId = tempRet;\n\t\t\t\tthis.$addon.arrayUtils(this.getData(\"lxhrs\"), 'push', ret);\n\t\t\t\tthis.setData(\"uploadMultipleRetry\", 0);\n\t\t\t\tthis.processqueue(undefined, true);\n\t\t\t}\n\t\t\tdelete arguments[2].xhr.file;\n\t\t}\n\t}\n\n\treject(evt) {\n\t\tif (this.$node) {\n\t\t\tvar file = evt.xhr.file, ret = evt.xhr.ret, retry = file.retry, tempRet = [], duplicate;\n\t\t\tif (this.data.abort || retry >= this.data.ltPropRetry || (this.data.ltPropUploadMultiple && this.data.uploadMultipleRetry >= this.data.ltPropRetry)) {\n\t\t\t\tfile.xhr && delete file.xhr;\n\t\t\t\tthis.getMethods('onRequestFailure') && this.executeMethod('onRequestFailure', ret, file, this.$node, this.data.abort);\n\t\t\t\tif (file.constructor != Array) {\n\t\t\t\t\tfile = [file];\n\t\t\t\t}\n\t\t\t\tfor (var i = 0; i < file.length; i++) {\n\t\t\t\t\tthis.$component.set(file[i], 'status', 'error');\n\t\t\t\t\tthis.$addon.objectUtils(file[i], 'delete', 'xhr');\n\t\t\t\t\tif (!this.data.ltPropUploadMultiple) {\n\t\t\t\t\t\tvar lxhrs = this.getData(\"lxhrs\");\n\t\t\t\t\t\tduplicate = $L.search(lxhrs, \"fileId\", file[i].id);\n\t\t\t\t\t\tduplicate.length && this.$addon.arrayUtils(lxhrs, 'removeAt', lxhrs.indexOf(duplicate[0]));\n\t\t\t\t\t\tret.fileId = file[i].id;\n\t\t\t\t\t\tthis.getMethods(\"onFileFailure\") && this.executeMethod('onFileFailure', ret, file[i], this.$node, this.data.abort);\n\t\t\t\t\t\t!this.data.abort && this.$addon.arrayUtils(this.getData(\"lxhrs\"), 'push', ret);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttempRet.push(file[i].id);\n\t\t\t\t\t}\n\t\t\t\t\tthis.removeFrmUpload(file[i].id, 'currentUpload', true, !this.data.abort); //need to be checked\n\n\t\t\t\t}\n\t\t\t\tif (this.data.ltPropUploadMultiple) {\n\t\t\t\t\tret.fileId = tempRet;\n\t\t\t\t\tthis.$addon.arrayUtils(this.getData(\"lxhrs\"), 'push', ret);\n\t\t\t\t\tthis.setData(\"uploadMultipleRetry\", 0);\n\t\t\t\t\tthis.processqueue(undefined, true);\n\t\t\t\t}\n\t\t\t\tif (this.data.abort) {\n\t\t\t\t\tthis.$addon.objectUtils(evt.xhr.file, 'add', 'retry', this.data.ltPropRetry);\n\t\t\t\t\tthis.setData(\"abort\", false);\n\t\t\t\t}\n\t\t\t\tdelete evt.xhr.file;\n\t\t\t} else {\n\t\t\t\tif (!this.data.ltPropUploadMultiple) {\n\t\t\t\t\tthis.$component.set(evt.xhr.file, 'status', 'retrying');\n\t\t\t\t\tthis.$addon.objectUtils(evt.xhr.file, 'add', 'retry', retry + 1);\n\t\t\t\t\tthis.getMethods('onRetry') && this.executeMethod('onRetry', ret, file, this.$node);\n\t\t\t\t\tthis.uploadFile(file);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdelete file.xhr;\n\t\t\t\t\tfor (var i = 0; i < file.length; i++) {\n\t\t\t\t\t\tthis.$component.set(evt.xhr.file[i], 'status', 'retrying');\n\t\t\t\t\t\tthis.$component.set(evt.xhr.file[i], 'retry', evt.xhr.file[i].retry + 1);\n\t\t\t\t\t}\n\t\t\t\t\tthis.setData(\"uploadMultipleRetry\", this.data.uploadMultipleRetry + 1);\n\t\t\t\t\tthis.getMethods('onRetry') && this.executeMethod('onRetry', ret, file, this.$node);\n\t\t\t\t\tthis.uploadFile(file);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprogress(evt) {\n\t\tif (evt.lengthComputable) {\n\t\t\tvar total = evt.total, upload = evt.loaded, xhr = evt.target.xhr,\n\t\t\t\tfile = xhr.file;\n\n\t\t\tif (file.constructor != Array) {\n\t\t\t\tfile = [file];\n\t\t\t}\n\t\t\tfor (var i = 0; i < file.length; i++) {\n\t\t\t\tif (this.data.ltPropUploadMultiple) {\n\t\t\t\t\tthis.$component.set(file[i], { loaded: file[i].size, percentage: 100 });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.$component.set(file[i], { loaded: upload, percentage: Math.round(upload * 100 / total) });\n\t\t\t\t}\n\t\t\t\tthis.getMethods('onProgress') && this.executeMethod('onProgress', evt, xhr, file[i], this.$node);\n\t\t\t}\n\t\t}\n\t}\n\n\tremoveChunk(id, origin, prevent) {\n\t\tvar arr = this.data.chunkUpload, cur = this.findIndex(arr, function (obj) {\n\t\t\treturn obj.chunkProp.chunkId == id\n\t\t})\n\t\tif (cur > -1) {\n\t\t\tthis.$addon.arrayUtils(arr, 'removeAt', cur);\n\t\t\t!prevent && this.processChunkQueue(origin.chunks)\n\t\t}\n\t}\n\n\tchunkReject(evt) {\n\t\tif (this.$node) {\n\t\t\tvar file = evt.xhr.file, origin = file.chunkProp.origin, ret = arguments[0].xhr.ret;\n\t\t\tif (!this.data.abort && file.retry < this.data.ltPropChunkRetry) {\n\t\t\t\tthis.$component.set(file, 'status', 'retrying');\n\t\t\t\tthis.$addon.objectUtils(file, 'add', 'retry', file.retry + 1);\n\t\t\t\tthis.removeChunk(file.chunkProp.chunkId, origin, true);\n\t\t\t\tthis.getMethods('onRetry') && this.executeMethod('onRetry', ret, file, this.$node);\n\t\t\t\tthis.$component.set(origin, 'currentUploadingChunks', origin.currentUploadingChunks - 1);\n\t\t\t\tthis.processChunkQueue(file, true);\n\t\t\t} else {\n\t\t\t\tthis.getMethods('onRequestFailure') && this.executeMethod('onRequestFailure', ret, file, this.$node, this.data.abort);\n\t\t\t\tthis.$component.set(file, 'status', 'error');\n\t\t\t\tthis.removeChunk(file.chunkProp.chunkId, origin, true);\n\t\t\t\tthis.getMethods('onChunkError') && this.executeMethod('onChunkError', ret, file, origin, this.$node, this.data.abort);\n\t\t\t\tthis.$addon.objectUtils(file, 'delete', 'xhr');\n\t\t\t\tdelete evt.xhr.file;\n\t\t\t\tthis.$component.set(origin, 'currentUploadingChunks', origin.currentUploadingChunks - 1);\n\t\t\t\tthis.$component.set(origin, 'error', origin.error + 1);\n\t\t\t\tif (origin.status != 'error') {\n\t\t\t\t\tvar lxhrs = this.getData(\"lxhrs\"), duplicate;\n\t\t\t\t\tthis.$component.set(origin, 'status', 'error');\n\t\t\t\t\tduplicate = $L.search(lxhrs, \"fileId\", origin.id);\n\t\t\t\t\tduplicate.length && this.$addon.arrayUtils(lxhrs, 'removeAt', lxhrs.indexOf(duplicate[0]));\n\t\t\t\t\tret.fileId = origin.id;\n\t\t\t\t\tthis.$addon.arrayUtils(this.getData(\"lxhrs\"), 'push', ret);\n\t\t\t\t}\n\t\t\t\tif (!this.data.abort) {\n\t\t\t\t\tthis.abortChunksFrmUpload(origin.id);\n\t\t\t\t\tthis.getMethods(\"onFileFailure\") && this.executeMethod('onFileFailure', ret, origin, this.$node, this.data.abort);\n\t\t\t\t\tthis.data.retry ? this.retrySendingFile()\n\t\t\t\t\t\t: this.processqueue(undefined, true);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.setData(\"abort\", false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tchunkSuccess(evt) {\n\t\tif (this.$node) {\n\t\t\tvar file = arguments[2].xhr.file, origin = file.chunkProp.origin, ret = arguments[2].xhr.ret;\n\t\t\tthis.getMethods('onRequestSuccess') && this.executeMethod('onRequestSuccess', ret, file, this.$node);\n\t\t\tthis.$component.set(file, 'status', 'success');\n\t\t\tthis.removeChunk(file.chunkProp.chunkId, origin, true);\n\t\t\tthis.getMethods('onChunkSuccess') && this.executeMethod('onChunkSuccess', ret, file, origin, this.$node);\n\t\t\tthis.$addon.objectUtils(file, 'delete', 'xhr');\n\t\t\tdelete arguments[2].xhr.file;\n\t\t\tthis.$component.set(origin, 'finished', origin.finished + 1);\n\t\t\tthis.$component.set(origin, 'currentUploadingChunks', origin.currentUploadingChunks - 1);\n\t\t\tif (origin.finished == origin.total) {\n\t\t\t\tvar lxhrs = this.getData(\"lxhrs\"), duplicate;\n\t\t\t\tthis.$component.set(origin, 'status', 'success');\n\t\t\t\tduplicate = $L.search(lxhrs, \"fileId\", origin.id);\n\t\t\t\tduplicate.length && this.$addon.arrayUtils(lxhrs, 'removeAt', lxhrs.indexOf(duplicate[0]));\n\t\t\t\tret.fileId = origin.id;\n\t\t\t\tthis.$addon.arrayUtils(this.getData(\"lxhrs\"), 'push', ret);\n\t\t\t\tthis.getMethods('onFileSuccess') && this.executeMethod('onFileSuccess', ret, origin, this.$node);\n\t\t\t\tthis.data.retry ? this.retrySendingFile()\n\t\t\t\t\t: this.processqueue(undefined, true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.processChunkQueue(origin.chunks, true);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tchunkProgress(evt) {\n\t\tif (evt.lengthComputable) {\n\t\t\tvar total = evt.total, upload = evt.loaded, file = evt.target.xhr.file, origin = file.chunkProp.origin, diff = upload - file.loaded;\n\t\t\tthis.$component.set(file, 'loaded', upload);\n\t\t\tthis.$component.set(origin, { loaded: Math.min(origin.loaded + diff, origin.size), percentage: Math.min(Math.round((origin.loaded + diff) * 100 / origin.size), 100) });\n\t\t\tthis.getMethods('onProgress') && this.executeMethod('onProgress', evt, evt.target.xhr, origin, this.$node)\n\t\t}\n\t}\n\n\tproceedChunk(files, props) {\n\t\tvar data = this.data, chunkSize = data.ltPropChunkSize, oriSize = files.size, size = 0, blobs = [];\n\t\twhile (size <= oriSize) {\n\t\t\tvar start = size, end = Math.min(oriSize, size += chunkSize), totalChunkSize = end - start;\n\t\t\tblobs.push({\n\t\t\t\tfile: files.file.slice(start, end), chunkProp: {\n\t\t\t\t\tchunkOffset: start,\n\t\t\t\t\tchunkEnd: end,\n\t\t\t\t\tchunkSize: totalChunkSize,\n\t\t\t\t\tchunkId: \"lyteChunk\" + new Date().getTime() + parseInt(Math.random() * 10E10),\n\t\t\t\t\tchunkIndex: blobs.length,\n\t\t\t\t\torigin: files,\n\t\t\t\t\tchunkCount: Math.ceil(files.size / chunkSize),\n\t\t\t\t\ttotalSize: files.size\n\t\t\t\t}, name: files.file.name, loaded: 0, retry: 0\n\t\t\t});\n\t\t}\n\t\tthis.$component.set(files, { chunks: blobs, error: 0, finished: 0, total: blobs.length });\n\t\tif (data.ltPropParallelChunkCount === Infinity) {\n\t\t\tthis.setData(\"chunkCount\", blobs.length);\n\t\t}\n\t\tthis.processChunkQueue(blobs)\n\t}\n\n\tprocessChunkQueue(blobs, frmFail) {\n\t\tvar data = this.data, idx = 0;\n\t\tif (blobs.constructor != Array) {\n\t\t\tblobs = [blobs];\n\t\t}\n\t\twhile ((!data.ltPropParallelChunkUpload && data.chunkUpload.length < 1) || (data.ltPropParallelChunkUpload && (data.ltPropParallelChunkCount === Infinity) || (data.ltPropParallelChunkCount != Infinity &&/*data.ltPropMultipleUpload &&*/ data.chunkUpload.length < data.ltPropParallelChunkCount) /*|| ( !data.ltPropMultipleUpload && !data.currentUpload.length )*/)) {\n\t\t\tvar bb = blobs[idx];\n\t\t\tif (!bb) {\n\t\t\t\tif (data.retry) {\n\t\t\t\t\tthis.retrySendingFile();\n\t\t\t\t}\n\t\t\t\telse if (data.ltPropParallelChunkUpload) {\n\t\t\t\t\tdata.ltPropParallelChunkCount != Infinity && data.chunkUpload.length < data.ltPropParallelChunkCount && this.processqueue();\n\t\t\t\t\tdata.ltPropParallelChunkCount == Infinity && this.processqueue();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!/success|uploading/.test(bb.status) && (!frmFail || (frmFail && !/error/.test(bb.status)))) {\n\t\t\t\tvar file = bb.chunkProp.origin;\n\t\t\t\tthis.$component.set(file, { status: 'uploading', percentage: file.percentage || 0, loaded: file.loaded || 0, size: file.size, currentUploadingChunks: file.currentUploadingChunks + 1 || 1 })\n\t\t\t\tthis.proceedUpload(bb, this.$addon.deepCopyObject(data.ltPropAjax), true);\n\t\t\t\tthis.$addon.arrayUtils(data.chunkUpload, 'push', bb);\n\t\t\t\tidx++;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\tgetRelativePath(fileInfo) {\n\t\tvar file = fileInfo.file;\n\t\treturn file.webkitRelativePath || file.relativePath;\n\t}\n\n\tproceedUpload(file, props, isChunk) {\n\t\tif (/success|uploading/.test((file[0] && file[0].status) || file.status)) {\n\t\t\treturn;\n\t\t}\n\t\tvar formdata = new FormData(), callback, keys = [\"chunkOffset\", \"chunkSize\", \"chunkIndex\", \"chunkCount\", \"totalSize\"], fileName;\n\t\tif (file.constructor == Array) {\n\t\t\tfor (var j = 0; j < file.length; j++) {\n\t\t\t\tfileName = this.data.ltPropFolder ? this.getRelativePath(file[j]) : file[j].name;\n\t\t\t\tformdata.append(this.data.ltPropParamName + '[' + j + ']', file[j].file, fileName);\n\t\t\t}\n\t\t} else {\n\t\t\tfileName = this.data.ltPropFolder && !isChunk ? this.getRelativePath(file) : file.name;\n\t\t\tformdata.append(this.data.ltPropParamName, file.file, fileName);\n\t\t}\n\t\tif (isChunk) {\n\t\t\tfor (var index = 0; index < keys.length; index++) {\n\t\t\t\tformdata.append(keys[index], file.chunkProp[keys[index]]);\n\t\t\t}\n\t\t\tvar origin = file.chunkProp.origin;\n\t\t\tformdata.append(\"fileId\", origin.id);\n\t\t\tfileName = this.data.ltPropFolder ? this.getRelativePath(origin) : origin.name;\n\t\t\tformdata.append(\"fileName\", fileName);\n\t\t}\n\t\tprops.success = isChunk ? this.chunkSuccess.bind(this) : this.succFunc.bind(this);\n\t\tprops.error = isChunk ? this.chunkReject.bind(this) : this.reject.bind(this);\n\t\tvar xhr = new window.XMLHttpRequest();\n\t\tprops.type = 'POST';\n\t\tfile.xhr = xhr;\n\t\txhr.file = file;\n\t\txhr.upload.xhr = xhr;\n\t\txhr.upload.addEventListener('progress', isChunk ? this.chunkProgress.bind(this) : this.progress.bind(this), false);\n\t\tprops.xhr = xhr;\n\t\tprops.data = formdata;\n\t\tprops.processData = false;\n\t\t// set content-type false and make sure browser\n\t\tprops.contentType = false;\n\t\tif (this.getMethods('onBeforeSend')) {\n\t\t\tcallback = this.executeMethod('onBeforeSend', xhr, file, isChunk, this.$node, formdata, props);\n\t\t}\n\t\tif (callback && callback.then) {\n\t\t\tPromise.resolve(callback).then(function () {\n\t\t\t\tthis.finishSend(props, xhr, file);\n\t\t\t}.bind(this))\n\t\t} else if (callback == false) {\n\t\t\tif (file.constructor != Array) {\n\t\t\t\tfile = [file];\n\t\t\t}\n\t\t\tfor (var i = 0; i < file.length; i++) {\n\t\t\t\t//this.removeFrmUpload( file[ i ].id, 'queueList' );\n\t\t\t\tthis.removeFrmUpload(file[i].id, 'currentUpload', true); //need to be checked\n\t\t\t}\n\t\t\treturn\n\t\t} else {\n\t\t\tif (callback && callback.constructor == FormData) {\n\t\t\t\tprops.data = callback;\n\t\t\t}\n\t\t\tthis.finishSend(props, xhr, file, isChunk)\n\t\t}\n\n\t}\n\n\tfinishSend(props, xhr, file, isChunk) {\n\t\tif (file.constructor == Array) {\n\t\t\tfor (var i = 0; i < file.length; i++) {\n\t\t\t\tthis.$component.set(file[i], 'status', 'uploading');\n\t\t\t}\n\t\t} else {\n\t\t\tthis.$component.set(file, 'status', 'uploading');\n\t\t}\n\t\tvar ret = $L.ajax(props);\n\t\tret.xhr = xhr;\n\t\txhr.ret = ret;\n\t\tthis.getMethods('onSend') && this.executeMethod('onSend', xhr, ret, file, !!isChunk, this.$node, props);\n\t}\n\n\tfinishcallback(files) {\n\t\tvar currentFiles = files || this.data.uploadedFiles, chunk = this.data.chunkUpload, lxhr = this.data.lxhrs, flag;\n\t\tif (!currentFiles.length) {\n\t\t\treturn;\n\t\t}\n\t\tfor (var index = 0; index < currentFiles.length; index++) {\n\t\t\tif (!currentFiles[index].status || currentFiles[index].status == \"uploading\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (currentFiles[index].status == \"error\") {\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\tfor (var index = 0; index < chunk.length; index++) {\n\t\t\tif (chunk[index].status == \"uploading\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (chunk[index].status == \"error\") {\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\tif (!this.data.ltPropMultiple) {\n\t\t\tcurrentFiles = currentFiles[0];\n\t\t\tlxhr = lxhr[0];\n\t\t}\n\t\tif (flag) {\n\t\t\tthis.getMethods('onFailure') && this.executeMethod('onFailure', currentFiles, this.$node, lxhr);\n\t\t\tthis.setData(\"uploadedFiles\", []);\n\t\t\tthis.setData(\"lxhrs\", []);\n\t\t}\n\t\telse {\n\t\t\tthis.getMethods(\"onSuccess\") && this.executeMethod('onSuccess', currentFiles, this.$node, lxhr);\n\t\t\tthis.setData(\"uploadedFiles\", []);\n\t\t\tthis.setData(\"lxhrs\", []);\n\t\t}\n\t\tif (this.data.manualUpload == true) {\n\t\t\tthis.setData(\"manualUpdFiles\", []);\n\t\t\tthis.setData(\"manualUpload\", false);\n\t\t}\n\t}\n\n\tgetTotalFileSize(array) {\n\t\tvar fileSize = 0;\n\t\tarray.forEach(function (file) {\n\t\t\tvar size = file.size;\n\t\t\tif (typeof size === \"number\") {\n\t\t\t\tfileSize += size;\n\t\t\t}\n\t\t});\n\t\treturn fileSize;\n\t}\n\n\taddPredefinedListSize(array) {\n\t\tvar totalListSize = this.getTotalFileSize(array);\n\t\tthis.addToTotalFilesSize(totalListSize);\n\t}\n\n\tremovePredefindListSize(array) {\n\t\tvar totalListSize = this.getTotalFileSize(array);\n\t\tthis.removeFromTotalFileSize(totalListSize);\n\t}\n\n\tcheckTotalFilessize(fileSize) {\n\t\tvar size = this.getData(\"totalFilesSize\"),\n\t\t\ttotalSize = this.getData(\"curTotFilesSize\");\n\t\tif (size && (totalSize + fileSize) > size) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\taddToTotalFilesSize(fileSize) {\n\t\tvar size = this.getData(\"totalFilesSize\");\n\t\tif (size) {\n\t\t\tvar total = this.getData(\"curTotFilesSize\");\n\t\t\tthis.setData(\"curTotFilesSize\", total + fileSize);\n\t\t}\n\t}\n\n\tremoveFromTotalFileSize(fileSize) {\n\t\tvar size = this.getData(\"totalFilesSize\");\n\t\tif (size) {\n\t\t\tvar total = this.getData(\"curTotFilesSize\");\n\t\t\tthis.setData(\"curTotFilesSize\", total - fileSize);\n\t\t}\n\t}\n\n\topenFileWindow(evt, fromEnter) {\n\t\tif (!this.data.ltPropYield && this.data.ltPropMultiple) {\n\t\t\tif (!evt.shiftKey) {\n\t\t\t\t$L('#lyteFileUpdSelectedFile.lyteFileUpdListFile').removeAttr('id');\n\t\t\t} else {\n\t\t\t\tevt.preventDefault();\n\t\t\t}\n\t\t\tif (evt.target.className != \"lyteFileUpdRetryMsg\") {\n\t\t\t\t$L(evt.target).closest('.lyteFileUpdListFile').attr('id', 'lyteFileUpdSelectedFile');\n\t\t\t}\n\t\t}\n\t\tif (evt.ctrlKey || evt.shiftKey || evt.metaKey) {\n\t\t\treturn\n\t\t}\n\t\tvar isSelectArea, close = $L(evt.target).closest('lyte-file-close');\n\t\tif (close.length) {\n\t\t\tthis.$node.removeUpload(close.eq(0).attr('data-value'))\n\t\t\treturn;\n\t\t}\n\t\tvar retry = $L(evt.target).closest('lyte-file-retry');\n\t\tif (retry.length) {\n\t\t\tthis.$node.upload(retry.eq(0).attr('data-value'), undefined, true);\n\t\t\treturn;\n\t\t}\n\t\tisSelectArea = $L(evt.target).closest('lyte-file-select-area').length || fromEnter;\n\t\tif (isSelectArea && this.data.ltPropMultiple || (this.data.queueList.length == 0 && this.data.predefinedList.length == 0) || this.data.ltPropAllowReplace) {\n\t\t\tif (this.getMethods('onBeforeOpen') && this.executeMethod('onBeforeOpen', evt, this.$node) == false) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tthis._file.click();\n\t\t}\n\t}\n\n\tgetFilesFromEntry(entry, fileList, path) {\n\t\treturn new Promise(function (resolve) {\n\t\t\tentry.file(function (file) {\n\t\t\t\tif (file.name.substring(0, 1) !== '.') { // will not read hidden files\n\t\t\t\t\tfile.relativePath = path + \"/\" + file.name;\n\t\t\t\t\tfileList.push(file);\n\t\t\t\t}\n\t\t\t\tresolve();\n\t\t\t}, function (error) {\n\t\t\t\tconsole.warn(error);\n\t\t\t\tresolve();\n\t\t\t});\n\t\t});\n\t}\n\n\tgetFilesFromDirectory(directory, path, fileList) {\n\t\tvar self = this;\n\t\tvar dirReader = directory.createReader(), promises = [];\n\t\treturn new Promise(function (resolve) {\n\t\t\tdirReader.readEntries(function (entries) {\n\t\t\t\tvar length = entries.length;\n\t\t\t\tif (length > 0) {\n\t\t\t\t\tvar entry;\n\t\t\t\t\tfor (var index = 0; index < length; index++) {\n\t\t\t\t\t\tentry = entries[index];\n\t\t\t\t\t\tif(entry) {\n\t\t\t\t\t\t\tif (entry.isFile) {\n\t\t\t\t\t\t\t\tpromises.push(self.getFilesFromEntry(entry, fileList, path));\n\t\t\t\t\t\t\t} else if (entry.isDirectory) {\n\t\t\t\t\t\t\t\tpromises.push(self.getFilesFromDirectory(entry, path + \"/\" + entry.name, fileList));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (promises.length) {\n\t\t\t\t\t\tPromise.all(promises).then(function () {\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, function (error) {\n\t\t\t\tconsole.warn(error);\n\t\t\t\tresolve();\n\t\t\t});\n\t\t});\n\t}\n\n\tfilterDropItems(items) {\n\t\tvar self = this;\n\t\tvar fileList = [], promises = [];;\n\t\treturn new Promise(function (resolve) {\n\t\t\tvar item;\n\t\t\tfor (let index = 0; index < items.length; index++) {\n\t\t\t\tvar item = items[index];\n\t\t\t\tif (item.webkitGetAsEntry != null) {\n\t\t\t\t\tvar entry = item.webkitGetAsEntry();\n\t\t\t\t\tif(entry) {\n\t\t\t\t\t\tif (entry.isFile) {\n\t\t\t\t\t\t\tfileList.push(item.getAsFile());\n\t\t\t\t\t\t} else if (entry.isDirectory && self.data.ltPropFolder) {\n\t\t\t\t\t\t\tpromises.push(self.getFilesFromDirectory(entry, entry.name, fileList));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (item.getAsFile != null && (item.kind == null || item.kind === \"file\")) {// firefox android\n\t\t\t\t\tfileList.push(item.getAsFile());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (promises.length) {\n\t\t\t\tPromise.all(promises).then(function () {\n\t\t\t\t\tresolve(fileList);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresolve(fileList);\n\t\t\t}\n\t\t});\n\t}\n\n\tgetValidDroppedItems(dataTransfer, event) { // Valid file and folder\n\t\tvar self = this;\n\t\tvar files = dataTransfer.files;\n\t\treturn new Promise(function (resolve) {\n\t\t\tvar items = dataTransfer.items;\n\t\t\tif (items && items.length && (items[0].webkitGetAsEntry !== null)) {\n\t\t\t\tself.filterDropItems(items).then(function (validFiles) {\n\t\t\t\t\tresolve(validFiles);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tresolve(files);\n\t\t\t}\n\t\t});\n\t}\n\n\tstatic actions() {\n\t\treturn {\n\t\t\tchange: function (evt, _this) {\n\t\t\t\tif (_this.files.length) {\n\t\t\t\t\tif (!this.data.ltPropMultiple && this.data.ltPropAllowReplace) {\n\t\t\t\t\t\tthis.removeFrmUpload(this.data.queueList, 'queueList', true);\n\t\t\t\t\t\tthis.data.predefinedList.length && this.removeFrmUpload(this.data.predefinedList, 'predefinedList', true);\n\t\t\t\t\t}\n\t\t\t\t\tvar files = Array.from(_this.files);\n\t\t\t\t\tif (this.getMethods(\"onSelect\") && this.executeMethod(\"onSelect\", files, evt) === false) {\n\t\t\t\t\t\tthis._file.value = \"\";\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.validate(files);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tdrag: function (evt) {\n\t\t\t\tvar type = evt.type, nwStr = \"onDrag\", match = type.match(/drag(.+)/);\n\t\t\t\tif (match && match[1]) {\n\t\t\t\t\tnwStr += match[1].slice(0, 1).toUpperCase() + match[1].slice(1);\n\t\t\t\t\tif (/enter|over/.test(evt.type)) {\n\t\t\t\t\t\tif (evt.type == 'dragover') {\n\t\t\t\t\t\t\tvar tran = evt.dataTransfer;\n\t\t\t\t\t\t\tif (tran) {\n\t\t\t\t\t\t\t\tvar effect = tran.effectAllowed;\n\t\t\t\t\t\t\t\ttran.dropEffect = 'move' === effect || 'linkMove' === effect ? 'move' : 'copy';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tevt.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (type == \"dragenter\") {\n\t\t\t\t\tthis.setData('fileClass', 'fileDragEnter');\n\t\t\t\t} else if (type == \"dragleave\") {\n\t\t\t\t\tthis.setData('fileClass', '');\n\t\t\t\t}\n\t\t\t\tthis.getMethods(nwStr) && this.executeMethod(nwStr, evt, this.$node);\n\t\t\t},\n\n\t\t\tdrop: function (evt) {\n\t\t\t\tthis.setData('fileClass', '');\n\t\t\t\tvar dT = evt.dataTransfer;\n\t\t\t\tif (dT.files.length) {\n\t\t\t\t\tvar self = this;\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t\tthis.getValidDroppedItems(dT).then(function (validList) {\n\t\t\t\t\t\tif (validList.length) {\n\t\t\t\t\t\t\tif (self.getMethods('onBeforeDrop') && self.executeMethod('onBeforeDrop', evt, self.$node, validList) == false) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tevt.preventDefault();\n\t\t\t\t\t\t\tif (!self.data.ltPropMultiple) {\n\t\t\t\t\t\t\t\tself.$node.removeUpload();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tself.validate(validList);\n\t\t\t\t\t\t\tself.getMethods('onDrop') && self.executeMethod('onDrop', evt, self.$node, validList);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tclick: function (evt) {\n\t\t\t\tthis.openFileWindow(evt);\n\t\t\t},\n\n\t\t\tpaste: function (evt) {\n\t\t\t\tvar clip = evt.clipboardData || window.clipboardData, items = clip.items, files = [];\n\t\t\t\tfor (var i = 0; i < items.length; i++) {\n\t\t\t\t\tvar file = items[i].getAsFile();\n\t\t\t\t\tif (file) {\n\t\t\t\t\t\tfiles.push(file)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (files.length) {\n\t\t\t\t\tif (this.getMethods('onBeforePaste') && this.executeMethod('onBeforePaste', evt, files, this.$node) == false) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (!this.data.ltPropMultiple) {\n\t\t\t\t\t\tthis.$node.removeUpload();\n\t\t\t\t\t}\n\t\t\t\t\tthis.validate(files);\n\t\t\t\t\tthis.getMethods('onPaste') && this.executeMethod('onPaste', evt, files, this.$node);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tkeydown: function (evt) {\n\t\t\t\tif (evt.which == 8) {\n\t\t\t\t\tvar elem = $L(\"#lyteFileUpdSelectedFile lyte-file-close\", this.$node)\n\t\t\t\t\tfor (var i = 0; i < elem.length; i++) {\n\t\t\t\t\t\tthis.$node.removeUpload(elem.eq(i).attr('data-value'));\n\t\t\t\t\t}\n\t\t\t\t\telem.length && evt.preventDefault();\n\t\t\t\t}\n\t\t\t\telse if (evt.which === 13) {\n\t\t\t\t\tthis.openFileWindow(evt, true);\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tstatic observers() {\n\t\treturn {\n\t\t\tariaObserver: function (change) {\n\t\t\t\tvar newAria = this.data.ltPropAriaAttributes;\n\t\t\t\tif (this.data.ltPropAria) {\n\t\t\t\t\tif (!change) {\n\t\t\t\t\t\tthis.setData(\"randomAriaId\", new Date().getTime() + parseInt(Math.random() * 10E10));\n\t\t\t\t\t}\n\t\t\t\t\tthis.addAriaValues(newAria);\n\t\t\t\t}\n\t\t\t}.observes('ltPropAriaAttributes.*').on('didConnect'),\n\n\t\t\tdisableDataObserver: function () {\n\t\t\t\tvar ltPropDisabled = this.data.ltPropDisabled;\n\t\t\t\tvar fileUploadWrapper = this.$node.querySelector(\".fileUploadWrapper\");\n\t\t\t\tif (ltPropDisabled) {\n\t\t\t\t\tfileUploadWrapper.setAttribute(\"aria-disabled\", true);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfileUploadWrapper.removeAttribute(\"aria-disabled\");\n\t\t\t\t}\n\n\t\t\t}.observes('ltPropDisabled').on('didConnect'),\n\n\t\t\tfolderUploadObserver: function () {\n\t\t\t\tthis.folderUpload();\n\t\t\t}.observes('ltPropFolder'),\n\n\t\t\ttrigUpl: function (arg) {\n\t\t\t\tif (arg.newValue) {\n\t\t\t\t\tthis.processqueue();\n\t\t\t\t\tvar compRef = this;\n\t\t\t\t\tthis._triggerId = setTimeout(function () {\n\t\t\t\t\t\tcompRef.setData('ltPropTriggerUpload', false);\n\t\t\t\t\t\tdelete compRef._triggerId;\n\t\t\t\t\t}, 0);\n\t\t\t\t}\n\t\t\t}.observes('ltPropTriggerUpload'),\n\n\t\t\tresetObserver: function (changeObject) {\n\t\t\t\tif (changeObject.newValue) {\n\t\t\t\t\tthis.$node.removeUpload();\n\t\t\t\t\tvar compRef = this;\n\t\t\t\t\tthis._resetId = setTimeout(function () {\n\t\t\t\t\t\tcompRef.setData(\"ltPropReset\", false);\n\t\t\t\t\t\tdelete compRef._resetId;\n\t\t\t\t\t}, 0);\n\t\t\t\t}\n\t\t\t}.observes('ltPropReset'),\n\n\t\t\tconvertToBytes: function () {\n\t\t\t\tvar size = this.getData(\"ltPropTotalFilesSize\");\n\t\t\t\tif (size) {\n\t\t\t\t\tvar fileUnit = size.substring(size.length - 2),\n\t\t\t\t\t\ttotalSize = parseInt(size.substring(0, size.length - 2)),\n\t\t\t\t\t\tvalidFormat = [\"KB\", \"MB\", \"GB\"],\n\t\t\t\t\t\tindexOf = validFormat.indexOf(fileUnit);\n\t\t\t\t\tvar predefinedList = this.data.predefinedList;\n\t\t\t\t\tif (indexOf > -1) {\n\t\t\t\t\t\tthis.setData(\"totalFilesSize\", totalSize * (Math.pow(1000, indexOf + 1)))\n\t\t\t\t\t}\n\t\t\t\t\tif (Array.isArray(predefinedList)) {\n\t\t\t\t\t\tthis.addPredefinedListSize(predefinedList);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}.observes(\"ltPropTotalFilesSize\").on(\"init\"),\n\n\t\t\tpredefinedListObserver: function (changeObject) {\n\t\t\t\tvar size = this.getData(\"totalFilesSize\");\n\t\t\t\tif (size) {\n\t\t\t\t\tvar oldValue = changeObject.oldValue;\n\t\t\t\t\tvar newValue = changeObject.newValue;\n\t\t\t\t\tif (Array.isArray(oldValue)) {\n\t\t\t\t\t\tthis.removePredefindListSize(oldValue);\n\t\t\t\t\t}\n\t\t\t\t\tif (Array.isArray(newValue)) {\n\t\t\t\t\t\tthis.addPredefinedListSize(newValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}.observes('predefinedList'),\n\n\t\t\tpredefinedArrayListObserver: function (changeObject) {\n\t\t\t\tvar size = this.getData(\"totalFilesSize\");\n\t\t\t\tif (size) {\n\t\t\t\t\tvar oldValue = changeObject.removedItems;\n\t\t\t\t\tvar newValue = changeObject.insertedItems;\n\t\t\t\t\tif (Array.isArray(oldValue)) {\n\t\t\t\t\t\tthis.removePredefindListSize(oldValue);\n\t\t\t\t\t}\n\t\t\t\t\tif (Array.isArray(newValue)) {\n\t\t\t\t\t\tthis.addPredefinedListSize(newValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}.observes('predefinedList.[]')\n\t\t};\n\t}\n}\n/**\n * @syntax nonYielded\n * <lyte-fileupload></lyte-fileupload>\n */\n/**\n * @syntax\n * @attribute ltPropYield=true\n * @attribute ltPropMultiple=true\n *\t<lyte-fileupload lt-prop-yield=true lt-prop-multiple = true>\n *  \t<template is = \"registerYield\" yield-name = \"file\">\n *\t \t<lyte-file-select-area>\n *\t  \t \t<lyte-file-message class=\"lyteFileUpdMsgWrap\"> <span class=\"lyteFileUpdMsg\"> Drag file here or browse to upload </span> </lyte-file-message>\n *\t \t</lyte-file-select-area>\n *\t\t<div class=\"lyteFileUpdList\">\n *\t\t\t<template lyte-for=\"{{predefinedList}} as item index\">\n *\t\t\t\t<div class=\"lyteFileUpdListFile\">\n *\t\t\t\t\t<div class=\"lyteFileUpdTypePreview\">\n *\t\t\t\t\t\t<template lyte-if=\"{{item.src}}\">\n *\t\t\t\t\t\t\t\t<img class=\"lyteFileUpdThumb\" src={{item.src}}>\n *\t\t\t\t\t\t</template>\n *\t\t\t\t\t\t<template lyte-else>\n *\t\t\t\t\t\t\t<span class=\"lyteFileUpdTypeIcon {{item.fileType}}\"></span>\n *\t\t\t\t\t\t</template>\n *\t\t\t\t\t</div>\n *\t\t\t\t\t<lyte-text class = \"lyteFileUpdFileName\" lt-prop-value = {{item.name}}></lyte-text>\n *\t\t\t\t\t<span class=\"lyteFileUpdFileSize\">( {{lyteUiFileSize(item.size, ltPropFileUnit, ltPropDigits)}} )</span>\n *\t\t\t\t\t<lyte-file-close data-value = {{item.id}} class = {{item.status}}></lyte-file-close>\n *\t\t\t\t</div>\n *\t\t\t</template>\n *\t  \t  \t<template lyte-for=\"{{queueList}} as item index\">\n *\t  \t  \t\t<div class=\"lyteFileUpdListFile {{item.status}}\">\n *\t  \t\t\t\t<div class=\"lyteFileUpdTypePreview\">\n *\t  \t  \t  \t \t\t<template lyte-if=\"{{item.src}}\">\n *\t  \t  \t  \t  \t  \t\t<img class=\"lyteFileUpdThumb\" src={{item.src}}>\n * \t\t\t\t\t\t</template>\n *\t  \t  \t  \t  \t  \t<template lyte-else>\n *\t  \t  \t  \t  \t  \t\t<span class=\"lyteFileUpdTypeIcon {{item.fileType}}\"></span>\n *\t  \t  \t  \t  \t  \t</template>\n *\t  \t  \t  \t  \t</div>\n *\t  \t  \t  \t  \t<lyte-text class = \"lyteFileUpdFileName\" lt-prop-value = {{item.name}}> </lyte-text>\n *\t  \t  \t  \t  \t<span class=\"lyteFileUpdFileSize\"> ( {{lyteUiFileSize(item.size, 'KB', 2)}} ) </span>\n *\t  \t  \t  \t  \t<template lyte-if=\"{{!ltPropUploadMultiple && item.percentage != undefined}}\">\n *\t  \t  \t  \t  \t\t<div class=\"lyteFileUpdFileStatus\" data-completed = {{item.percentage}}>\n *\t  \t  \t  \t  \t  \t\t<div class=\"lyteFileUpdProgressBar {{item.status}}\">\n *\t  \t  \t  \t  \t  \t  \t\t<div class=\"lyteFileUpdProgressFill\" style=\"width: {{item.percentage}}%\"> </div>\n *\t  \t  \t  \t  \t  \t\t</div>\n *\t  \t  \t  \t  \t\t</div>\n *\t\t\t\t\t</template>\n * \t\t\t\t\t<template lyte-if='{{item.status==\"error\"}}'>\n *\t  \t  \t  \t  \t\t<lyte-file-retry data-value = {{item.id}}>\n *\t  \t  \t  \t  \t  \t\t<span class=\"lyteFileUpdFailMsg\">Attachment failed </span>\n *\t  \t  \t  \t  \t  \t\t<template lyte-if=\"{{!ltPropUploadMultiple}}\">\n *\t  \t  \t  \t  \t  \t\t\t<span class=\"lyteFileUpdRetryMsg\"> Retry </span>\n *\t  \t  \t  \t  \t  \t\t</template>\n *\t  \t  \t  \t  \t\t</lyte-file-retry>\n *\t  \t  \t  \t  \t</template>\n *               \t<template lyte-if='{{(!ltPropUploadMultiple)||(!item.status||item.status==\"error\"||item.status==\"success\")}}'>\n *\t  \t  \t  \t  \t\t<lyte-file-close data-value = {{item.id}} class = {{item.status}}> </lyte-file-close>\n *\t  \t  \t  \t  \t</template>\n *\t  \t  \t  \t</div>\n *\t  \t\t</template>\n *\t \t</div>\n *\t\t</template>\n *\t</lyte-fileupload>\n */\n/**\n * @syntax\n * @attribute ltPropYield=true\n * @attribute ltPropMultiple=false\n *\t<lyte-fileupload lt-prop-yield = true lt-prop-multiple = false>\n *\t\t<template is = \"registerYield\" yield-name = \"file\">\n *\t  \t\t<lyte-file-select-area>\n *\t  \t  \t\t<lyte-file-message class=\"lyteFileUpdMsgWrap{{if(queueList.length, 'lyteHide', '')}}\">\n *\t  \t  \t  \t\t<span class=\"lyteFileUpdMsg\"> Drag file here or browse to upload </span>\n *\t  \t  \t  \t</lyte-file-message>\n *\t  \t  \t  \t<div class=\"lyteFileUpdList\">\n *\t\t\t\t\t<template lyte-for=\"{{predefinedList}} as item index\">\n *\t\t\t\t\t\t<div class=\"lyteFileUpdListFile\">\n *\t\t\t\t\t\t\t<div class=\"lyteFileUpdTypePreview\">\n *\t\t\t\t\t\t\t\t<template lyte-if=\"{{item.src}}\">\n *\t\t\t\t\t\t\t\t\t\t<img class=\"lyteFileUpdThumb\" src={{item.src}}>\n *\t\t\t\t\t\t\t\t</template>\n * \t\t\t\t\t\t\t\t<template lyte-else>\n *\t\t\t\t\t\t\t\t\t<span class=\"lyteFileUpdTypeIcon {{item.fileType}}\"></span>\n *\t\t\t\t\t\t\t\t</template>\n *\t\t\t\t\t\t\t</div>\n *\t\t\t\t\t\t\t<lyte-text class = \"lyteFileUpdFileName\" lt-prop-value = {{item.name}}></lyte-text>\n *\t\t\t\t\t\t\t<span class=\"lyteFileUpdFileSize\">( {{lyteUiFileSize(item.size, ltPropFileUnit, ltPropDigits)}} )</span>\n *\t\t\t\t\t\t\t<lyte-file-close data-value = {{item.id}} class = {{item.status}}></lyte-file-close>\n *\t\t\t\t\t\t</div>\n *\t\t\t\t\t</template>\n *\t\t\t\t\t<template lyte-for=\"{{queueList}} as item index\">\n *\t  \t  \t  \t  \t\t<div class=\"lyteFileUpdListFile {{item.status}}\">\n *\t  \t  \t  \t  \t \t\t<div class=\"lyteFileUpdTypePreview\">\n *\t  \t  \t  \t  \t  \t  \t\t<template lyte-if=\"{{item.src}}\">\n *\t  \t  \t  \t  \t  \t  \t\t\t<img class=\"lyteFileUpdThumb\" src={{item.src}}>\n *\t  \t  \t  \t  \t  \t  \t\t</template>\n *\t\t\t\t\t\t\t\t<template lyte-else>\n *\t  \t  \t  \t  \t  \t  \t\t\t<span class=\"lyteFileUpdTypeIcon {{item.fileType}}\"> </span>\n *\t  \t  \t  \t  \t  \t  \t\t</template>\n *\t  \t  \t  \t  \t  \t\t</div>\n *\t  \t  \t  \t  \t  \t\t<lyte-text class = \"lyteFileUpdFileName\" lt-prop-value = {{item.name}}> </lyte-text>\n *\t  \t  \t  \t  \t  \t\t<span class=\"lyteFileUpdFileSize\"> ( {{lyteUiFileSize(item.size, 'KB', 2)}} ) </span>\n *\t  \t  \t  \t  \t  \t\t<div lyte-if=\"{{item.percentage != undefined}}\" class=\"lyteFileUpdFileStatus\" data-completed = {{item.percentage}}>\n *\t  \t  \t  \t  \t  \t \t\t<div class=\"lyteFileUpdProgressBar {{item.status}}\">\n *\t  \t  \t  \t  \t  \t  \t\t\t<div class=\"lyteFileUpdProgressFill\" style=\"width: %\"> </div>\n *\t  \t  \t  \t  \t  \t \t\t</div>\n *\t  \t  \t  \t  \t  \t\t</div>\n *\t  \t  \t  \t  \t  \t\t<lyte-file-retry lyte-if='{{item.status==\"error\"}}' data-value = {{item.id}}>\n *\t  \t  \t  \t  \t  \t  \t\t<span class=\"lyteFileUpdFailMsg\"> Attachment failed </span>\n *\t  \t  \t  \t  \t  \t  \t\t<span class=\"lyteFileUpdRetryMsg\"> Retry </span>\n *\t  \t  \t  \t  \t  \t\t</lyte-file-retry>\n *\t  \t  \t  \t  \t  \t\t<lyte-file-close data-value = {{item.id}} class = {{item.status}}> </lyte-file-close>\n *\t  \t  \t  \t \t\t</div>\n *\t  \t  \t  \t\t</template>\n *\t \t\t\t</div>\n *\t  \t\t</lyte-file-select-area>\n *\t\t</template>\n *\t</lyte-fileupload>\n */\n\nexport { LyteFileuploadComponent };","import './lyte-wormhole.js';\nimport './lyte-popover.js';\nimport { prop } from \"@slyte/core\";\nimport { Component } from \"../component.js\";\nimport $L from \"@zoho/lyte-dom\"\n/**\n * Renders a hovercard\n * @component lyte-hovercard\n * @dependencies lyte-popover\n * /components/lyte-popover.js\n * /theme/compiledCSS/default/ltr/lyte-ui-popover.css\n * @version  3.1.0\n * @methods beforeRender,afterRender,onHovercardShow,onHovercardHide,onHovercardBeforeHide\n */\nclass LyteHovercardComponent extends Component {\n  constructor() {\n    super();\n  }\n\n  data() {\n    return {\n      /** \n       * @componentProperty {boolean} ltPropDisplay=true\n       * @version 3.1.0\n       */\n      'ltPropDisplay' : prop( 'boolean', { 'default' : true } ),\n      /** \n       * @componentProperty {boolean} ltPropShow=false\n       * @version 3.1.0\n       */\n        'ltPropShow' : prop( 'boolean', { 'default' : false } ),\n        /** \n       * @componentProperty {string} ltPropOriginElem=''\n       * @version 3.1.0\n       */\n        'ltPropOriginElem' : prop( 'string', { 'default' : '' } ),\n        /** \n       * @componentProperty {string} ltPropMaxHeight=''\n       * @version 3.1.0\n       */\n        'ltPropMaxHeight' : prop( 'string', { 'default' : '' } ),\n        /** \n       * @componentProperty {string} ltPropWidth=''\n       * @version 3.1.0\n       */\n        'ltPropWidth' : prop( 'string', { 'default' : '' } ),\n        /** \n       * @componentProperty {string} ltPropHeight=auto\n       * @version 3.1.0\n       */\n        'ltPropHeight' : prop( 'string', { 'default' : 'auto' } ),\n        /** \n       * @componentProperty {string} ltPropPlacement=''\n       * @version 3.1.0\n       */\n        'ltPropPlacement' : prop( 'string', { 'default' : '' } ),\n        /** \n       * @componentProperty {number} ltPropClass=''\n       * @version 3.1.0\n       */\n        'ltPropClass' : prop( 'string', { 'default' : window._lyteUiUtils.resolveDefaultValue( 'lyte-hovercard', 'class', '' ) } ),\n        /** \n       * @componentProperty {string} ltPropId=''\n       * @version 3.1.0\n       */\n        'ltPropId' : prop( 'string', { 'default' : '' } ),\n        /** \n       * @componentProperty {number} ltPropShowDelay=0\n       * @version 3.1.0\n       */\n        'ltPropShowDelay' : prop( 'number', { 'default': 0 } ),\n        /** \n       * @componentProperty {number} ltPropHideDelay=0\n       * @version 3.1.0\n       */\n        'ltPropHideDelay' : prop( 'number', { 'default': 0 } ),\n        /** \n       * @componentProperty {number} ltPropMaxDisplayTime=5000\n       * @version 3.1.0\n       */\n        'ltPropMaxDisplayTime' : prop( 'number', { 'default' : 5000 } ),\n        /** \n       * @componentProperty {boolean} ltPropKeepAlive=false\n       * @version 3.1.0\n       */\n        'ltPropKeepAlive' : prop( 'boolean', { 'default' : false } ),\n        /** \n       * @componentProperty {boolean} ltPropFollowCursor=false\n       * @version 3.1.0\n       */\n        'ltPropFollowCursor' : prop( 'boolean', { 'default' : false } ),\n        /** \n       * @componentProperty {string} ltPropPopoverWrapperClass\n       * @version 3.1.0\n       */\n        'ltPropPopoverWrapperClass' : prop( 'string',{'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-hovercard', 'popoverWrapperClass', '' ) }),\n        /** \n       * @componentProperty {object} ltPropOffset={}\n       * @version 3.1.0\n       */\n        'ltPropOffset' : prop( 'object', { 'default' : {} } ),\n        /** \n       * @componentProperty {boolean} ltPropCloseOnEscape=true\n       * @version 3.1.0\n       */\n        'ltPropCloseOnEscape' : prop( 'boolean', { 'default' : true } ),\n        /** \n        * @componentProperty {boolean} ltPropAutoShow=false\n        * @version 3.1.0\n        */\n        'ltPropAutoShow' : prop( 'boolean', { 'default' : false}),\n         /** \n        * @componentProperty {boolean} ltPropHideOnClick=false\n        * @version 3.1.0\n        */\n        'ltPropHideOnClick' : prop( 'boolean', { 'default' : window._lyteUiUtils.resolveDefaultValue( 'lyte-hovercard', 'hideOnClick', false ) } ),\n         /**\n          * @componentProperty {boolean} ltPropAria\n          * @version 3.1.0\n          * @default false\n          *\n          */\n        \"ltPropAria\" : prop( 'boolean', { default : false } ),\n        /**\n         * @componentProperty {object} ltPropAriaAttributes={}\n         * @version 3.1.0\n         */\n        \"ltPropAriaAttributes\" : prop( 'object', { default : {} } ),\n         /**\n         * @componentProperty {boolean} ltPropPreventFocus=true\n         */\n        \"ltPropPreventFocus\" : prop('boolean', { default : true } ),\n         /**\n         * @componentProperty {string} ltPropMaxWidth\n         */\n        \"ltPropMaxWidth\" : prop('string',{default:''}),\n        \"ltPropType\" : prop('string',{default :'callout'}),\n        \"ltPropDimmer\":prop(\"object\",{\"default\":{\"color\":\"black\",\"opacity\":\"0.4\"}}),\n        \"ltPropAnimation\":prop(\"string\",{\"default\":\"fade\"}), //fade,zoom\n        \"ltPropAutoAlign\" : prop('boolean', {default : false}),\n\n        'mousePosition' : prop( 'array', { 'default' : [] } ),\n        'mouseover' : prop( 'boolean', { 'default' : false } ),\n        'originEle' : prop( 'string', { 'default' : ''})\n\n    };   \n  }\n\n  init() {\n    if( this.getMethods( 'beforeRender' ) ){\n            this.executeMethod( 'beforeRender', this.$node );\n      }\n  }\n\n  didConnect() {\n    this._popover = this.$node.getElementsByTagName('lyte-popover')[0]\n    this._hovercardScroll = this.hovercardScroll.bind( this );\n    this._hovercardHideOnClick = this.hovercardHideOnClick.bind(this)\n    this._mousemove = this.mousemove.bind(this);\n    this._oriEleMouseMove = this.oriEleMousemove.bind(this)\n    if(this.getData('ltPropAutoShow') && this.getData('ltPropOriginElem')){\n      this.setMouseMove()\n    }\n    $L.fastdom.measure( function() {\n         var fg = window.getComputedStyle( this.$node ).getPropertyValue( 'direction' ) == 'rtl';\n         $L.fastdom.mutate( function(){\n           if( fg ) {\n             this.direction = true;\n           }\n         }.bind( this ) )\n    }.bind( this ) )\n    window._lyteUiUtils.dispatchEvent( 'afterrender', this.$node ); \n\n    if( this.getMethods( 'afterRender' ) ) {\n       this.executeMethod('afterRender', this.$node);\n    }\n  }\n\n  didDestroy() {\n    this.$node.classList.remove('lyteActive')\n    if( this.getData( 'ltPropHideOnClick') ){\n      document.removeEventListener( 'click' , this._hovercardHideOnClick )\n    }\n    var originElem = document.querySelector( this.$node.ltProp( 'originElem' ) ) \n\n    if(originElem ){\n      this._closeHoverCard && originElem.removeEventListener( 'mouseleave', this._closeHoverCard )\n      this.removeEventListenerForOriginElem(originElem)\n\n    }\n    if(this._popover){\n      this._popover.setData('ltPropShow',false)\n    }\n    if(window._lyteUiUtils.lyteHovercard){\n      delete window._lyteUiUtils.lyteHovercard[this.$node.ltProp( 'originElem' ) ]\n\n    }\n    if( this._childComp ){\n      this._childComp.remove()\n    }\n    if(this.getData('ltPropAutoShow')){\n      document.removeEventListener('mousemove',this._mousemove)\n    }\n    delete this.prevHoverCardNode;\n    delete this._childComp;\n    delete this._popover;\n  }\n\n  setMaxHeightAndWidth(div) {\n    if(this.getData('ltPropMaxWidth')){\n      div.style.maxWidth = this.getData('ltPropMaxWidth')\n    }\n    if(this.getData('ltPropMaxHeight')){\n      div.style.maxHeight = this.getData('ltPropMaxHeight')\n    }\n  }\n\n  isNode(target) {\n   return target instanceof HTMLElement || target instanceof Node;  \n\n }\n\n  addEventListenerForOriginElem(originElem) {\n    if(originElem){\n      originElem.addEventListener( 'mousemove', this._oriEleMouseMove )\n    }\n  }\n\n  removeEventListenerForOriginElem(originElem) {\n    if(originElem){\n      originElem.removeEventListener( 'mousemove', this._oriEleMouseMove )\n    }\n    this.setData( 'mousePosition', [] )\n    this.setData( 'mouseover', false )\n\n  }\n\n  hovercardHideOnClick(event) {\n    var target = event.target,\n    popoverWormhole = this._popover.component.actualModalDiv;\n    if( this.getData( 'ltPropHideOnClick' ) && this.getData( 'ltPropShow' ) && this.isNode(target) && !( target === popoverWormhole || popoverWormhole.contains( target ) ) ){\n          this.setData( 'ltPropShow', false )\n      }\n  }\n\n  oriEleMousemove(eve) {\n\n    if( !this.getData( 'mouseover' ) ) {\n        this.mouseovereve( eve )\n        this.setData( 'mouseover', true )\n    }\n    var currMpos = [ eve.clientX, eve.clientY ];\n    var mpos = this.getData( 'mousePosition' );\n    var diff = [ currMpos[ 0 ] - ( mpos[ 0 ]? mpos[ 0 ] : 0 ), currMpos[ 1 ] - ( mpos[ 1 ] ? mpos[ 1 ] : 0 ) ];\n    if( this._popover.ltProp( 'show' ) && this._popover.component.childComp) {\n      var popupEle = $L( '.lyteHoverCardFollowCursor .lytePopover' ,this._popover.component.childComp)[ 0 ];\n      var clientRect = popupEle.getBoundingClientRect();\n      popupEle.style.top = clientRect.top + diff[ 1 ] + 'px';\n      popupEle.style.left = clientRect.left + diff[ 0 ] + 'px';\n    }\n    this.setData( 'mousePosition', currMpos );\n  }\n\n  mouseovereve(eve) {\n    var mpos = [ eve.clientX, eve.clientY ];\n    var pos = '';\n    var clientRect = document.querySelector( this.$node.ltProp( 'originElem' ) )\n    \n    this._popover.ltProp( {\n      offset : { left : mpos[ 0 ] - 9, top : mpos[ 1 ] - 9, height : 18, width : 18 }\n    } )\n    this.setData('ltPropOffset',{ left : mpos[ 0 ] , top : mpos[ 1 ] , height : 18, width : 18 })\n    this.setData( 'mousePosition', mpos );\n  }\n\n  mousemove(event) {\n    var nodeName1 = event.target.correspondingElement || event.target;\n    while(nodeName1 && nodeName1.tagName != 'BODY' && nodeName1 != document && nodeName1.tagName != 'HTML' ){\n        \n        var iHovercard = nodeName1.getAttribute( 'lyte-hovercard' );\n\n        if( iHovercard ){\n          var hovercard = this.findMatchingHoverCard(nodeName1);\n          if( hovercard && !hovercard.getData('ltPropShow')){\n             hovercard.setData('ltPropShow',true);\n          } \n          break;\n          \n        }\n        else {\n            nodeName1 = nodeName1.parentNode;\n        }  \n    }\n  \n}\n\n  findMatchingHoverCard(node) {\n    for(var item in window._lyteUiUtils.lyteHovercard){\n       if(node.matches(item)){\n         return window._lyteUiUtils.lyteHovercard[item];\n       }\n   }\n  }\n\n  setMouseMove() {\n     var map = window._lyteUiUtils.lyteHovercard ? window._lyteUiUtils.lyteHovercard : []\n     map[this.$node.ltProp( 'originElem' )] = this.$node;\n     window._lyteUiUtils.lyteHovercard = map;\n     document.addEventListener('mousemove',this._mousemove)\n   }\n\n  compouteOffset(popover) {\n      var arr = [ 'ltPropWidth', 'ltPropHeight' ];\n      for( var i = 0; i < arr.length; i++ ) {\n            if( this.getData( arr[ i ] ) ) {\n                  popover.setData( arr[ i ], this.getData( arr[ i ] ) )\n            }\n       }\n  }\n\n  createHoverCard(event, popoverWormhole) {\n    var popover = this._popover\n    if(popover){\n      window._lyteUiUtils.dispatchEvent( 'beforeshow', this.$node, { originalEvent: event } ); \n       var res = true;\n        if( this.getMethods( 'onBeforeHovercardShow' ) ) {\n          res = this.executeMethod('onBeforeHovercardShow', this.$node );\n        }\n        if(!res){\n          return false\n        }\n        popover.ltProp( 'show', true )\n        popover.ltProp( 'allowMultiple', true)\n        this.$node.classList.add( 'lyteActive' )\n        if( this.getMethods( 'onHovercardShow' ) ) {\n                this.executeMethod('onHovercardShow', this.$node );\n        }\n    }\n    if( !this.getData( 'ltPropKeepAlive' ) && !this.getData('ltPropFollowCursor')) {\n          var originElem = document.querySelector( this.$node.ltProp( 'originElem' ) )\n\n          popover._maxdisp = setTimeout( function() {\n            this.removeHoverCard(popover, originElem, event, popoverWormhole)\n          }.bind( this ), this.getData( 'ltPropMaxDisplayTime' ) );\n    }\n    \n  }\n\n  removeTimeout(popover) {\n        clearTimeout( popover._settime )\n        clearTimeout( popover._maxdisp )\n        clearTimeout( popover._bodyTimeout )\n  }\n\n  closeHoverCard(event) {\n      var wormHole = this._childComp,\n       popoverWormhole = this._popover.component.actualModalDiv,\n       popover = this._popover,\n       originElem = document.querySelector( this.$node.ltProp( 'originElem' ) )\n      if(  this.prevHoverCardNode && this.isNode(event.target) && ( this.getData('ltPropFollowCursor') || event.target == this.prevHoverCardNode || this.prevHoverCardNode.contains( event.target ) ) && popoverWormhole && event.relatedTarget != popoverWormhole && !popoverWormhole.contains( event.relatedTarget )) {\n                popover._bodyTimeout = setTimeout( this.removeHoverCard.bind( this ), this.getData( 'ltPropHideDelay' ), popover, originElem, event ) ;\n\n          } else if( popoverWormhole  && this.isNode(event.relatedTarget ) && (event.relatedTarget == popoverWormhole || popoverWormhole.contains( event.relatedTarget )  )  ) {  \n              this.removeTimeout( popover )\n              this._popovermouseleave = this.popoverMouseLeave.bind( this )\n              popoverWormhole.addEventListener( 'mouseleave', this._popovermouseleave )\n              originElem.removeEventListener( 'mouseleave', this._closeHoverCard )\n  \n           } \n  }\n\n  removeHoverCard(popover, originElem, event, popoverWormhole) {\n    var res = true\n    if(this.getMethods( 'onHovercardBeforeHide' ) ) {\n          res = this.executeMethod( 'onHovercardBeforeHide', this.$node, event );\n          if( !res && originElem){\n              originElem.removeEventListener( 'mouseleave', this._closeHoverCard )\n              if( this._popovermouseleave && popoverWormhole ){\n                popoverWormhole.removeEventListener( 'mouseleave', this._popovermouseleave )\n              }\n          }\n    }\n    if( res && ( ( this.prevHoverCardNode  && this.isNode(event.target) && ( event.target == this.prevHoverCardNode || this.prevHoverCardNode.contains( event.target ) ) ) || ( popoverWormhole  && this.isNode(event.target) && ( event.target == popoverWormhole || popoverWormhole.contains( event.target ) ) ) ) ){\n            this.removeTimeout( popover )\n\n            if( this.getData( 'ltPropShow' ) && popover ) {\n                    this.setData( 'ltPropShow', false )\n                    popover.setData( 'ltPropShow',false )\n                }  \n    }\n  }\n\n  popoverMouseLeave(event) {\n    var wormHole = this._childComp ,\n    popoverWormhole = this._popover.component.actualModalDiv ,\n    popover = this._popover ,\n    originElem = document.querySelector( this.$node.ltProp( 'originElem' ) ),\n    element =document.elementFromPoint(event.clientX, event.clientY)\n   if( popoverWormhole  && this.isNode(event.target) && !popoverWormhole.contains(element) && ( event.target == popoverWormhole || popoverWormhole.contains( event.target ) ) && event.relatedTarget != this.prevHoverCardNode && !this.prevHoverCardNode.contains( event.relatedTarget ) ) {\n     popover._bodyTimeout = setTimeout( this.removeHoverCard.bind( this ), this.getData( 'ltPropHideDelay' ), popover, originElem, event, popoverWormhole );\n   }\n   else if( this.prevHoverCardNode  && this.isNode(event.relatedTarget) && ( event.relatedTarget == this.prevHoverCardNode || this.prevHoverCardNode.contains( event.relatedTarget ) ) ) {\n         popover._settime = setTimeout( this.createHoverCard.bind( this ), this.getData( 'ltPropShowDelay' ), event, popoverWormhole );\n         this._closeHoverCard = this.closeHoverCard.bind( this )\n         originElem.addEventListener( 'mouseleave', this._closeHoverCard )\n         if( this._popovermouseleave ){\n           popoverWormhole.removeEventListener( 'mouseleave', this._popovermouseleave )\n         }\n\n   }\n  }\n\n  hovercardScroll(event) {\n    if($L(this.$node).hasClass(\"lyteActive\")){\n    var res = true\n        var component = this,\n            wormHole = component._childComp ,\n            popoverWormhole = component._popover.component.actualModalDiv ,\n            popover =component._popover ,\n            originElem = document.querySelector( this.getData('ltPropOriginElem') )\n            \n        if(component.getMethods( 'onHovercardBeforeHide' ) ) {\n            res = component.executeMethod( 'onHovercardBeforeHide', component.$node );\n            if( !res && originElem){\n                originElem.removeEventListener( 'mouseleave', component._closeHoverCard )\n                if(  component._popovermouseleave && popoverWormhole ){\n                    popoverWormhole.removeEventListener( 'mouseleave', component._popovermouseleave )\n                  }\n            }\n        }\n        if(res ){\n            \n            if( component.getData( 'ltPropShow' ) && popover ) {\n                component.setData( 'ltPropShow', false )\n                \n            }\n            if( component.prevHoverCardNode ) {\n              delete component.prevHoverCardNode\n            }\n            component.removeTimeout( popover )\n        }\n      \n      }\n  }\n\n  static methods() {\n    return {\n      beforeWormholeAppend : function(args){\n        this._childComp = args\n      }\n    };\n  }\n\n  static observers() {\n    return {\n      originEleObs : function(arg){\n        \n        if( window._lyteUiUtils.lyteHovercard){\n          var originElem = document.querySelector( arg.oldValue  )  \n          if(originElem ){\n            this._closeHoverCard && originElem.removeEventListener( 'mouseleave', this._closeHoverCard )\n            this.removeEventListenerForOriginElem(originElem)\n\n          }\n          delete window._lyteUiUtils.lyteHovercard[ arg.oldValue ]\n          window._lyteUiUtils.lyteHovercard[this.getData( 'ltPropOriginElem' )] = this.$node\n          this.setData('ltPropShow', false)\n        } else {\n          this.setMouseMove()\n        }\n    \n       \n      }.observes('ltPropOriginElem'),\n\n      showToggled : function() {\n\n          var popover = this._popover\n          if( popover.component && !popover.getData( 'ltPropBindToBody' ) ) {\n              popover.ltProp( 'bindToBody', true )\n          }\n          var wormHole = this._childComp.querySelector('.hoverCardWrapper' ),\n           popoverWormhole = this._popover.component.actualModalDiv,\n           originElem = document.querySelector( this.$node.ltProp( 'originElem' ) ) \n          if( this.getData( 'ltPropShow' ) && originElem ) {\n              this.prevHoverCardNode = originElem;\n              if( this.getData( 'ltPropHideOnClick') ){\n                  document.addEventListener( 'click' , this._hovercardHideOnClick )\n              }\n             \n              window._lyteUiUtils.appendChild( popoverWormhole, wormHole )\n\n              popover.ltProp( 'originElem', this.getData( 'ltPropOriginElem' ) )\n              popover.ltProp( 'freeze', false )\n              popover.ltProp( 'duration', undefined )\n              // popover.ltProp('offset',this.getData('ltPropOffset'))\n              // popover.ltProp('preventFocus',this.getData('ltPropPreventFocus'))\n              // popover.ltProp( 'closeOnEscape', this.getData( 'ltPropCloseOnEscape' ) )\n              this.compouteOffset( popover );\n              this.setMaxHeightAndWidth(wormHole)\n              // if(this.getData('ltPropPopoverWrapperClass')){\n              //    popover.setData( 'ltPropWrapperClass', popover.getData( 'ltPropWrapperClass' )+' '+ this.getData('ltPropPopoverWrapperClass'))\n              // }\n              if( this.getData( 'ltPropFollowCursor' ) ) {\n                  this.addEventListenerForOriginElem( originElem )\n                  // popover.setData( 'ltPropWrapperClass', popover.getData( 'ltPropWrapperClass' )+ ' lyteHoverCardFollowCursor' )\n              }\n            \n              popover._settime = setTimeout( this.createHoverCard.bind( this ), this.getData( 'ltPropShowDelay' ), window.event, popoverWormhole );\n              \n              this._closeHoverCard = this.closeHoverCard.bind( this )\n              originElem.addEventListener( 'mouseleave', this._closeHoverCard )\n          }\n          else{\n               popover.ltProp( 'show', false )\n\n              popover.ltProp( 'bindToBody', false )\n              // popover.setData( 'ltPropWrapperClass', 'lyteHovercardPopover' )\n              this.$node.classList.remove( 'lyteActive' )\n              if(originElem){\n                originElem.removeEventListener( 'mouseleave', this._closeHoverCard )\n              }\n              if( this._popovermouseleave ){\n                  popoverWormhole.removeEventListener( 'mouseleave', this._popovermouseleave )\n\n              }\n               if( this.getData( 'ltPropHideOnClick') ){\n                document.removeEventListener( 'click' , this._hovercardHideOnClick )\n              }\n              this.removeEventListenerForOriginElem( originElem )\n              if( this.getMethods( 'onHovercardHide' ) ) {\n                  this.executeMethod( 'onHovercardHide', this.$node );\n              }\n              if( this.prevHoverCardNode ) {\n                  delete this.prevHoverCardNode\n              }\n              delete this._childComp;\n              delete this._mousedownFlag;\n              this.removeTimeout( popover )\n          }\n      }.observes( 'ltPropShow' )\n    };\n  }\n}\n\n\nwindow.addEventListener( 'scroll', function(event) {\n   window.clearTimeout( window._lyteUiUtils._expressDebounce );\n\n  window._lyteUiUtils._expressDebounce = setTimeout( function() {\n\n    var activeHovercard = document.querySelector('lyte-hovercard.lyteActive')\n    if(activeHovercard){\n       var popover = activeHovercard.component._popover\n       if(popover){\n        var childComp = popover.component.actualModalDiv\n        var target = arguments[0].target\n        if(childComp.contains(target)){\n          return;\n        }\n       }\n    }\n\n\n      var hovercard = document.getElementsByTagName( 'lyte-hovercard' ),\n      i = 0;\n     \n          for( ; i < hovercard.length; i++ ) {\n              if( hovercard[ i ] ){\n                  hovercard[ i ].component.hovercardScroll();\n              }\n          \n      }   \n  }, 250,event );\n  \n}, true );\n/**\n * @syntax yielded\n * <lyte-hovercard>\n *     <template is = \"registerYield\" yield-name = \"hoverCardYield\">\n *         <lyte-hovercard-content>\n *             //Some Content\n *         </lyte-hovercard-content>\n *     </template>\n * </lyte-hovercard>\n */\nexport { LyteHovercardComponent };\n","import './lyte-wormhole.js';\nimport { prop } from \"@slyte/core\";\nimport { Component } from \"../component.js\";\nimport $L from \"@zoho/lyte-dom\";\n\nwindow.addPopoverEvent = function(event) {\n\n    document.addEventListener('click',function(event){\n        if(window.LytePopup._stopPropagation){\n            window.LytePopup._sourceComp.setData('ltPropStopClick', false);\n            return;\n        }\n        var ele = event.target;\n        while(!$L(ele).hasClass('popoverWrapper') && ele.tagName != \"LYTE-POPOVER-FREEZE\" && ele.tagName != 'LYTE-DROP-BOX' && ele.tagName != 'HTML'){\n            ele = ele.parentElement;\n            if(!ele){\n                return\n            }\n        }\n        if(ele.tagName == 'HTML' || ele.tagName == \"LYTE-POPOVER-FREEZE\"){\n            for(var i = window.LytePopup.components.length -1 ; i>=0; i--){\n                var dropdowns = $L(window.LytePopup.components[i].childComp).find('lyte-dropdown')\n                var dontClose = false;\n                if(dropdowns[0]){\n                    for(var j = 0;j<dropdowns.length;j++){\n                        if(dropdowns[j]){\n                            if(dropdowns[j].getData('ltPropIsOpen')){\n                                dontClose = true\n                            }\n                        }\n                    }\n                }\n                if(window.LytePopup.components[i].$node.tagName == \"LYTE-POPOVER\" && window.LytePopup.components[i].childComp.style.visibility == \"visible\" && !dontClose){\n                    // LytePopup.evt = event;\n                    var popover = window.LytePopup.components[i].$node;\n                    // if(popover && popover.component.getData('visible') && popover.component.getData('ltPropCloseOnBodyClick') && !popover.component.getData('dragRunning')){\n                    if((popover && popover.component.getData('visible') && popover.component.getData('ltPropCloseOnBodyClick') && !popover.component.getData('dragRunning')) && ((!$L(event.target).closest('lyte-input')[0]) || (!popover.component.getData('ltPropIgnoreInput')))){\n                        popover.component.setData('visible',false);\n                        popover.ltProp('show',false);\n                        break;\n                    }\n                }\n            }\n        }\n        /*  If ele is having popoverWrapper class ie. a popover and it is not the popover that is opened at last which is the current popover element in the page\n            this means the click has happened outside the current popover\n            so the current popover should be closed */\n        else if(ele.classList.contains('popoverWrapper') && window.LytePopup.components.length > 1 && window.LytePopup.components[window.LytePopup.components.length -1].$node.tagName == \"LYTE-POPOVER\"){\n            var comp = window.LytePopup.components[window.LytePopup.components.length -1];\n            var dropdowns = $L(comp.childComp).find('lyte-dropdown')\n            var dontClose = false;\n            if(dropdowns[0]){\n                for(var i = 0;i<dropdowns.length;i++){\n                    if(dropdowns[i]){\n                        if(dropdowns[i].getData('ltPropIsOpen')){\n                            dontClose = true\n                        }\n                    }\n                }\n            }\n            if(!(comp.childComp.contains(ele)) && comp.getData('visible') && comp.getData('ltPropCloseOnBodyClick')){\n                comp.setData('visible',false);\n                comp.$node.ltProp('show',false);\n            }\n        }\n    },true);\n\n    window.addEventListener('scroll',function(event){    //This is for closing the dropdown when an outside area is clicked(CODE HELP)\n       // console.log(\"called scroll\");\n       if(window.LytePopup.makingVisible) {\n        window.LytePopup.makingVisible = false;\n        return;\n       }\n        var wormhole;\n        for(var i=window.LytePopup.components.length-1;i>=0;i--){\n            if(window.LytePopup.components[i].$node && window.LytePopup.components[i].$node.nodeName == \"LYTE-POPOVER\" && window.LytePopup.components[i].childComp.style.visibility == \"visible\"){\n                wormhole = window.LytePopup.components[i].childComp;\n                if(window.LytePopup.components[i].data.ltPropCloseOnScroll){\n                  window.LytePopup.components[i].setData('ltPropShow' , false);\n                  return;\n                }\n                if(wormhole && wormhole._callee.component.$node.ltProp(\"scrollable\")){\n                    if(window.LytePopup.components[i].callOnScroll(event)){\n                        var ele =  wormhole.querySelector('.lytePopover');\n                        if(!ele/* || !wormhole._callee.ltProp('originElem')*/){\n                            return ;\n                        }\n                        while(ele.tagName != 'LYTE-WORMHOLE'){\n                            ele = ele.parentElement\n                        }\n                        var curscroll = event.target\n                        // if(curscroll.nodeName == \"#document\"){     //This probably happens because scrollIntoView is used to focus the dropdown which is open at the start so the event.target is #document(CODE HELP)\n                        //     return ;\n                        // }\n                        while(curscroll.tagName != \"LYTE-WORMHOLE\" && curscroll.tagName != 'HTML' && curscroll.nodeName != \"#document\"){\n                            curscroll = curscroll.parentElement\n                        }\n                        if(curscroll.tagName == 'LYTE-WORMHOLE' && curscroll.isEqualNode(ele)){\n                            return ;\n                        }\n                        // console.log(\"didnt return\");\n                        ele._callee.component.computeOffsetImpl();\n                        if(ele._callee.component.getData('ltPropForceScroll')){\n                            continue;\n                        }\n\n                        var par = document.querySelector(ele._callee.ltProp('originElem'));\n                        var screl = event.target\n                        var pbcr = par.getBoundingClientRect();\n\n                        var boundary = ele._callee.ltProp(\"boundary\");\n                        var popoverElem = ele.querySelector('.lytePopover');\n                        var windowSpacing = ele._callee.getData('ltPropWindowSpacing') || {};\n                        if(!windowSpacing.top){\n                            windowSpacing.top = 0\n                        }\n                        if(!windowSpacing.bottom){\n                            windowSpacing.bottom = 0\n                        }\n                        if(!windowSpacing.right){\n                            windowSpacing.right = 0\n                        }\n                        if(!windowSpacing.left){\n                            windowSpacing.left = 0\n                        }\n                        if(!(Object.keys(boundary).length === 0 && boundary.constructor === Object)){\n                            if(boundary.top && popoverElem.getBoundingClientRect().top < parseFloat(boundary.top)){\n                                ele._callee.ltProp('show',false);\n                            }\n                            else if(boundary.bottom && popoverElem.getBoundingClientRect().bottom > parseFloat(boundary.bottom)){\n                                ele._callee.ltProp('show',false);\n                            }\n                            else if(boundary.left && popoverElem.getBoundingClientRect().left < parseFloat(boundary.left)){\n                                ele._callee.ltProp('show',false);\n                            }\n                            else if(boundary.right && popoverElem.getBoundingClientRect().right > parseFloat(boundary.right)){\n                                ele._callee.ltProp('show',false);\n                            }\n                        }\n                        // console.log(\"for moving up\",sbcr.top,pbcr.top)\n                        // console.log(\"for moving down\",(sbcr.top+sbcr.height),(pbcr.top+pbcr.height))\n                        if(screl.contains(par)){\n                            var arrowEle = ele.querySelector('#lytePopoverArrow');\n                            if(arrowEle && arrowEle.classList.contains('lytePopoverArrowBottom') && ((pbcr.top+(pbcr.height/2)) > window.innerHeight)){\n                                ele._callee.ltProp('show',false);\n                            }\n                            if((arrowEle &&\n                                    (arrowEle.classList.contains('lytePopoverArrowLeft') || arrowEle.classList.contains('lytePopoverArrowRight')) &&\n                                    ((arrowEle.getBoundingClientRect().bottom >= ele.querySelector('.lytePopover').getBoundingClientRect().bottom) ||\n                                        (arrowEle.getBoundingClientRect().top <= ele.querySelector('.lytePopover').getBoundingClientRect().top))\n                                )){\n                                ele._callee.ltProp('show',false);\n                            }\n                            if(screl.nodeName == \"#document\"){     //This probably happens because scrollIntoView is used to focus the dropdown which is open at the start so the event.target is #document(CODE HELP)\n                                // console.log(\"pbcr.top ==> \",pbcr.top,\"   pbcr.bottom ==> \",pbcr.bottom);\n                                var winH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n                                var winW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n                                if(pbcr.top < windowSpacing.top || (pbcr.bottom+3) >= (winH - windowSpacing.bottom)){\n                                    ele._callee.ltProp('show',false);\n                                }\n                                // console.log(\"pbcr.left ==> \",pbcr.left,\"   pbcr.right ==> \",pbcr.right);\n                                if(pbcr.left < windowSpacing.left || (pbcr.right+3) >= (winW - windowSpacing.right)){\n                                    ele._callee.ltProp('show',false);\n                                }\n                            }\n                            else{\n                                var sbcr = screl.getBoundingClientRect();\n                                if((sbcr.top + windowSpacing.top) > pbcr.top || (sbcr.top + sbcr.height - windowSpacing.bottom) < (pbcr.top + pbcr.height)){\n                                    ele._callee.ltProp('show',false);\n                                }\n                                if((sbcr.left + windowSpacing.left) > pbcr.left || (sbcr.left + sbcr.width - windowSpacing.right) < (pbcr.left + pbcr.width)){\n                                    ele._callee.ltProp('show',false);\n                                }\n                            }\n                        }\n\n                    }\n                }\n            }\n        }\n\n\n    },true);\n\n    window.addEventListener(\"resize\",function(event){\n        if(window.LytePopup._lytePopoverRTId){\n            // console.log(LytePopup._lytePopoverRTId);\n            clearTimeout(window.LytePopup._lytePopoverRTId);\n            window.LytePopup._lytePopoverRTId = false;\n        }\n        for(var i = window.LytePopup.components.length - 1 ; i >= 0 ; i--){\n          var thDiv = window.LytePopup.components[i].$node.component\n          // if((thDiv.$node.ltProp(\"height\") === \"auto\" || thDiv.$node.ltProp(\"width\") === \"auto\")){\n          //   thDiv.setData('modalElemWidth' , thDiv.actualModalDiv.getBoundingClientRect().width)\n          //   thDiv.setData('modalElemHeight' , thDiv.actualModalDiv.getBoundingClientRect().height)\n          // }\n        }\n        window.LytePopup._lytePopoverRTId = setTimeout(function(){\n            for(var i = LytePopup.components.length - 1 ; i >= 0 ; i--){\n                if(LytePopup.components[i].$node && LytePopup.components[i].$node.nodeName == \"LYTE-POPOVER\" && LytePopup.components[i].childComp.style.visibility == \"visible\" && LytePopup.components[i].childComp.querySelector('.lytePopover')){\n                    LytePopup.components[i].$node.component.setData('resize', true);\n                    LytePopup.components[i].$node.component.updateScrollHandling(event);\n\n                    /*  Commented calling these functions from here and called them from inside updateScrollHandling\n                        so that the functions gets called in a synchronised manner and doesnt overlap each other. */\n\n                    // LytePopup.components[i].$node.component.computeOffsetImpl();\n                    // LytePopup.components[i].$node.component.callOnResize(event);\n                    // var origElemPosition = document.querySelector(LytePopup.components[i].$node.ltProp('originElem')).getBoundingClientRect();\n                    // var winH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n                    // if(origElemPosition.bottom + 3 >= winH){\n                    //     LytePopup.components[i].$node.ltProp(\"show\",false);\n                    // }\n                }\n            }\n            LytePopup._lytePopoverRTId = false;\n        },100);\n    },true);\n\n};\n\n/**\n * Renders a popover\n * @component lyte-popover\n * @version 1.0.0\n * @dependencies lyte-wormhole\n * @methods onBeforeShow,onShow,onBeforeClose,onClose,onResize,onScroll,onPositionChange\n * @utility alignPopover,calculateOffset,trapFocus\n */\n\nclass LytePopoverComponent extends Component {\n    constructor() {\n        super();\n    }\n\n    data() {\n        return {\n            //config from callee\n            /**\n             * @componentProperty {boolean} ltPropShow\n             * @version 1.0.0\n             * @default false\n             *\n             */\n            \"ltPropShow\":prop(\"boolean\",{\"default\": false}),\n\n            /**\n             * @componentProperty {callout|box} ltPropType\n             * @version 1.0.0\n             * @default callout\n             */\n            \"ltPropType\":prop(\"string\",{\"default\":\"callout\"}),\n\n            /**\n             * @componentProperty {boolean} ltPropFreeze\n             * @version 1.0.0\n             * @default true\n             *\n             */\n            \"ltPropFreeze\":prop(\"boolean\",{\"default\": true}),\n\n            /**\n             * @componentProperty {boolean} ltPropShowCloseButton\n             * @version 1.0.0\n             * @default true\n             *\n             */\n            \"ltPropShowCloseButton\":prop(\"boolean\",{\"default\": true}),\n\n            /**\n             * @componentProperty {boolean} ltPropCloseOnEscape\n             * @version 1.0.0\n             * @default true\n             *\n             */\n            \"ltPropCloseOnEscape\":prop(\"boolean\",{\"default\": true}),\n\n            /**\n             * @componentProperty {string} ltPropOriginElem\n             * @version 1.0.0\n             */\n            \"ltPropOriginElem\":prop(\"string\",{\"default\":\"\"}),\n\n            /**\n             * @experimental ltPropPosition\n             */\n            \"ltPropPosition\":prop(\"string\",{\"default\":\"bottom\"}),\n\n            /**\n             * @componentProperty {bottom|bottomLeft|bottomRight|top|topLeft|topRight|left|right} ltPropPlacement\n             * @version 1.0.0\n             */\n            \"ltPropPlacement\":prop(\"string\",{\"default\":\"\"}),\n\n            /**\n             * @typedef {object} dimmer\n             * @property {colorstring} color\n             * @property {string} opacity\n             */\n            /**\n             * @componentProperty {dimmer} ltPropDimmer\n             * @version 1.0.0\n             */\n            \"ltPropDimmer\":prop(\"object\",{\"default\":{}}),\n\n            /**\n             * @componentProperty {boolean} ltPropDraggable\n             * @version 1.0.0\n             * @default false\n             *\n             */\n            \"ltPropDraggable\":prop(\"boolean\",{\"default\": false}),\n\n            /**\n             * @componentProperty {boolean} ltPropAllowMultiple\n             * @version 1.0.0\n             * @default false\n             *\n             */\n            \"ltPropAllowMultiple\":prop(\"boolean\",{\"default\": false}),\n\n            /**\n             * @componentProperty {boolean} ltPropScrollable\n             * @version 1.0.0\n             * @default false\n             *\n             */\n            \"ltPropScrollable\":prop(\"boolean\",{\"default\": false}),\n\n            /**\n             * @componentProperty {string} ltPropMaxHeight\n             * @version 1.0.0\n             * @suffix px,pt,cm,mm,vh,vm,em\n             */\n            \"ltPropMaxHeight\":prop(\"string\",{\"default\":\"\"}),\n\n            /**\n             * @componentProperty {string} ltPropMaxWidth\n             * @version 1.0.0\n             * @suffix px,pt,cm,mm,vh,vm,em\n             */\n            \"ltPropMaxWidth\":prop(\"string\",{\"default\":\"\"}),\n\n            /**\n             * @componentProperty {string} ltPropWidth\n             * @version 1.0.0\n             * @suffix px,pt,cm,mm,vh,vm,em\n             */\n            \"ltPropWidth\":prop(\"string\",{\"default\":\"\"}),\n\n            /**\n             * @componentProperty {string} ltPropHeight\n             * @version 1.0.0\n             * @suffix px,pt,cm,mm,vh,vm,em\n             */\n            \"ltPropHeight\":prop(\"string\",{\"default\":\"auto\"}),\n\n            /**\n             * @componentProperty {string} ltPropWrapperClass\n             * @version 1.0.0\n             */\n            \"ltPropWrapperClass\":prop(\"string\",{\"default\":\"\"}),\n            /**\n             * @typedef {object} boundary\n             * @property {string} left\n             * @property {string} right\n             * @property {string} top\n             * @property {string} bottom\n             */\n            /**\n             * @componentProperty {boundary} ltPropBoundary\n             * @version 1.0.0\n             * @default {}\n             */\n            \"ltPropBoundary\" : prop(\"object\",{\"default\":{}}),\n\n            /**\n             * @componentProperty {boolean} ltPropCloseOnBodyClick\n             * @version 1.0.0\n             * @default true\n             *\n             */\n            \"ltPropCloseOnBodyClick\" : prop(\"boolean\",{\"default\" : true}),\n\n            /**\n             * @componentProperty {number} ltPropDuration\n             * @version 1.0.0\n             * @default 400\n             */\n            \"ltPropDuration\" : prop(\"number\",{\"default\" : 400}),\n            /**\n             * @typedef {object} popoverOffset\n             * @property {string} top\n             * @property {string} left\n             * @property {string} bottom\n             * @property {string} right\n             * @property {string} height\n             * @property {string} width\n             */\n            /**\n             * @componentProperty {object} ltPropOffset\n             * @version 1.0.0\n             */\n            \"ltPropOffset\" : prop(\"object\",{\"default\" : {}}),\n\n\n            /**\n              * @componentProperty {object} ltPropOffsetFromTarget\n            */\n            \"ltPropOffsetFromTarget\" : prop(\"object\" , {\"default\" : {}}),\n\n\n            /**\n             * @componentProperty {boolean} ltPropBindToBody\n             * @version 1.0.0\n             * @default false\n             *\n             */\n            \"ltPropBindToBody\" : prop(\"boolean\",{\"default\":false}),\n\n            /**\n             * @componentProperty {string} ltPropHeaderPadding\n             * @version 1.0.0\n             * @default \"\"\n             */\n            \"ltPropHeaderPadding\":prop(\"string\",{\"default\":\"\"}),\n\n            /**\n             * @componentProperty {string} ltPropContentPadding\n             * @version 1.0.0\n             * @default \"\"\n             */\n            \"ltPropContentPadding\":prop(\"string\",{\"default\":\"\"}),\n\n            /**\n             * @componentProperty {string} ltPropFooterPadding\n             * @version 1.0.0\n             * @default \"\"\n             */\n            \"ltPropFooterPadding\":prop(\"string\",{\"default\":\"\"}),\n\n            /**\n             * @componentProperty {fade|zoom} ltPropAnimation\n             * @version 2.1.0\n             * @default fade\n             */\n            \"ltPropAnimation\":prop(\"string\",{\"default\":\"fade\"}), //fade,zoom\n            /**\n             * @typedef {object} windowspacing\n             * @property {number} top\n             * @property {number} left\n             * @property {number} bottom\n             * @property {number} right\n             */\n            /**\n             * @componentProperty {object} ltPropWindowSpacing\n             * @version 2.1.1\n             * @default { \"top\" : \"30\",\"left\" : \"30\",\"bottom\":\"30\",\"right\" : \"30\"}\n             */\n            \"ltPropWindowSpacing\":prop(\"object\"),\n\n            /**\n             * @componentProperty {boolean} ltPropForceScroll\n             * @version 2.2.14\n             * @default false\n             *\n             */\n            \"ltPropForceScroll\" : prop('boolean', { default : false }),\n\n            /**\n             * @componentProperty {boolean} ltPropAutoAlign\n             * @version 2.2.15\n             * @default false\n             *\n             */\n            \"ltPropAutoAlign\" : prop('boolean', {default : false}),\n\n            /**\n             * @componentProperty {boolean} ltPropAria\n             * @version 3.1.0\n             * @default false\n             *\n             */\n            \"ltPropAria\" : prop( 'boolean', { default : false } ),\n\n            /**\n             * @componentProperty {object} ltPropAriaAttributes\n             * @version 3.1.0\n             */\n            \"ltPropAriaAttributes\" : prop( 'object', { default : {} } ),\n\n            /**\n             * @componentProperty {boolean} ltPropPreventFocus\n             * @version 3.2.0\n             * @default false\n             *\n             */\n            \"ltPropPreventFocus\" : prop('boolean', { default : false } ),\n\n            /**\n             * @componentProperty {boolean} ltPropStopClick\n             * @version 3.13.0\n             * @default false\n             *\n             */\n            \"ltPropStopClick\" : prop('boolean', {default : false}),\n\n            \"ltPropIgnoreBoundary\" : prop('boolean' , {default : false}),\n\n            \"ltPropMargin\" : prop('object'),\n\n            \"ltPropCloseOnScroll\" : prop('boolean' , {\n              default : false\n            }),\n\n            /**\n             * @componentProperty {boolean} ltPropAllowContainment\n             * @version 3.66.0\n             * @default false\n             *\n             */\n\n            \"ltPropAllowContainment\" : prop('boolean' , {\n                default : false\n            }),\n            \"ltPropIgnoreInput\" : prop('boolean' , {\n                default : false\n            }),\n            \"ltPropFocusOnClose\" : prop('boolean' , {\n                default : false\n            }),\n            //local properties\n            \"ltPropShowWormhole\" : prop('boolean' , {\n                default : false\n            }),\n            \n\n            \"buttons\":prop(\"array\",{\"default\":[{\"type\":\"accept\",\"text\":\"Ok\"}]}),\n            \"ltPropShowCopy\":prop(\"boolean\",{\"default\": false}),\n            \"visible\" : prop(\"boolean\",{\"default\" : true}),\n            \"timeOutId\" : prop(\"number\"),\n            \"classTobeAdded\" : prop(\"string\"),\n            \"keys\" : prop(\"object\", {\"default\" : {37: 1, 38: 1, 39: 1, 40: 1}}),\n            \"first\" : prop(\"boolean\",{\"default\":true}),\n            \"arrowHidden\" : prop(\"boolean\", {\"default\" : false}),\n            \"arrowEle\" : prop(\"object\"),\n            \"returnedFalse\" : prop(\"boolean\",{\"default\":false}),\n            \"transformOrigin\" : prop(\"string\"),\n            \"windowSpacing\" : prop(\"object\"),\n            \"lyteUnbound\": prop( 'boolean', { 'default': false } ),\n            \"prevOffsetVal\": prop(\"object\"),\n            \"calculateHW\": prop(\"boolean\", {'default': false}),\n            \"checkAria\" : prop(\"number\", {\"default\":0}),\n            \"prevRect\" : prop(\"object\", {'default' : undefined}),\n            \"margin\" : prop(\"object\"),\n            \"modalElemWidth\" : prop('string', {\"default\" : ''}),\n            \"modalElemHeight\" : prop('string', {\"default\" : ''}),\n            \"dragRunning\" : prop('boolean' , {\"default\" : false})\n        };\n    }\n\n    addDragHandler() {\n        var dragHeader = this.actualModalDiv.querySelector('lyte-popover-header');\n        if(dragHeader){\n            dragHeader.parentEle = this;\n            if(this.$node.ltProp(\"draggable\")){\n                dragHeader.addEventListener('mousedown',this.handleMove,true);\n                dragHeader.addEventListener('touchstart',this.handleMove,true);\n                dragHeader.classList.add('lytePopoverHeaderDraggable');\n            }\n            else{\n                dragHeader.removeEventListener('mousedown',this.handleMove,true);\n                dragHeader.removeEventListener('touchstart',this.handleMove,true);\n                dragHeader.classList.remove('lytePopoverHeaderDraggable');\n            }\n        }\n        else{\n            console.warn(\"This popover is not draggable because it has no header\");\n            this.$node.ltProp(\"draggable\",false);\n        }\n    }\n\n    handleMove(e) {\n        var drag = e.currentTarget.parentEle.actualModalDiv;\n        window.LytePopup.node=drag;\n        $L(e.target).addClass('lytePopoverDragRunning')\n        if(e.type == \"mousedown\"){\n            LytePopup.xPos=e.clientX-this.getBoundingClientRect().left;\n            LytePopup.yPos=e.clientY-this.getBoundingClientRect().top;\n        }\n        else if(e.type == \"touchstart\"){\n            LytePopup.xPos=e.touches[0].clientX-this.getBoundingClientRect().left;\n            LytePopup.yPos=e.touches[0].clientY-this.getBoundingClientRect().top;\n        }\n        var elePos = drag.getBoundingClientRect();\n        drag.style.transitionDuration = \"0s\";\n        var arrowEle = drag.parentElement.querySelector(\"#lytePopoverArrow\");\n        if(arrowEle){\n            this.parentEle.setData('arrowHidden',true);\n            this.parentEle.setData('arrowEle',arrowEle);\n            arrowEle.style.display = \"none\";\n        }\n        if(e.type == \"mousedown\"){\n            window.addEventListener('mousemove',e.currentTarget.parentEle.handleDrag,true);\n            window.addEventListener('mouseup',e.currentTarget.parentEle.stopDrag,true);\n        }\n        else if(e.type == \"touchstart\"){\n            document.body.addEventListener('touchmove',e.currentTarget.parentEle.handleDrag,true);\n            document.body.addEventListener('touchend',e.currentTarget.parentEle.stopDrag,true);\n        }\n    }\n\n    handleDrag(e) {\n        var drag = window.LytePopup.node;\n        var curComp = $L(drag).closest('lyte-wormhole')[0]._callee\n        curComp.setData('dragRunning' , true);\n        \n        var curleft = 0\n        var curtop = 0\n\n        if(e.type == \"mousemove\"){\n            curleft = e.clientX-drag.offsetParent.getBoundingClientRect().left - window.LytePopup.xPos\n            curtop = e.clientY-drag.offsetParent.getBoundingClientRect().top  - window.LytePopup.yPos\n        }\n        else if(e.type == \"touchmove\"){\n            curleft = e.touches[0].clientX-drag.offsetParent.getBoundingClientRect().left-window.LytePopup.xPos\n            curtop = e.touches[0].clientY-drag.offsetParent.getBoundingClientRect().top-window.LytePopup.yPos\n        }\n\n        if(!curComp.getData('ltPropAllowContainment')){\n            drag.style.left = curleft + 'px'\n            drag.style.top = curtop + 'px'\n        } else {\n            if(curleft + drag.getBoundingClientRect().width <= window.innerWidth && (curleft >= 0)){\n                drag.style.left = curleft + 'px';\n            }else if(curleft < 0){\n                drag.style.left = \"0px\";\n            } else {\n                drag.style.left = ( window.innerWidth - drag.getBoundingClientRect().width ) + 'px';\n            }\n    \n            if(curtop + drag.getBoundingClientRect().height <= window.innerHeight && (curtop >= 0)){\n                drag.style.top = curtop + 'px';\n            }else if(curtop < 0){\n                drag.style.top = \"0px\";\n            } else {\n                drag.style.top = ( window.innerHeight - drag.getBoundingClientRect().height ) + 'px';\n            }\n        }\n\n     \n\n        window.getSelection().removeAllRanges();\n    }\n\n    stopDrag(e) {\n        var targetElem = e.target;\n        if(!$L(targetElem).hasClass('lytePopoverDragRunning')){\n            targetElem = $L('.lytePopoverDragRunning')[0]\n        }\n        var drag = window.LytePopup.node;\n        var curComp = $L(drag).closest('lyte-wormhole')[0]._callee\n        while(targetElem && targetElem !== document){\n            if(targetElem.parentEle){\n                if(e.type == \"mouseup\"){\n                    window.removeEventListener('mousemove',targetElem.parentEle.handleDrag,true);\n                    window.removeEventListener('mouseup',targetElem.parentEle.stopDrag,true);\n                    curComp.setData('dragRunning' , false);\n                    $L('.lytePopoverDragRunning').removeClass('lytePopoverDragRunning');\n                }\n                else if(e.type == \"touchend\"){\n                    this.removeEventListener('touchmove',targetElem.parentEle.handleDrag,true);\n                    this.removeEventListener('touchend',targetElem.parentEle.stopDrag,true);\n                    $L('.lytePopoverDragRunning').removeClass('lytePopoverDragRunning');\n                }\n                break;\n            }\n            targetElem = targetElem.parentElement ? targetElem.parentElement : document;\n        }\n    }\n\n    setRTLPosition() {\n        var positions = this.getData('ltPropPlacement').trim().split(\" \");\n        if(positions.length > 1){\n            var newPosition = \"\";\n            for(var i = 0; i < positions.length; i++){\n                newPosition += this.getRTLPosition(positions[i]) + \" \";\n            }\n            this.setData('ltPropPlacement',newPosition.trim());\n        }\n        else{\n            this.setData('ltPropPlacement', this.getRTLPosition(positions[0]));\n        }\n    }\n\n    getRTLPosition(position) {\n        if(position == \"bottomLeft\"){\n            return \"bottomRight\";\n        }\n        else if(position == \"bottomRight\"){\n            return \"bottomLeft\";\n        }\n        else if(position == \"topLeft\"){\n            return \"topRight\";\n        }\n        else if(position == \"topRight\"){\n            return \"topLeft\";\n        }\n        else if(position == \"left\"){\n            return \"right\";\n        }\n        else if(position == \"right\"){\n            return \"left\";\n        }\n        return position;\n    }\n\n    clearFastdomBatch() {\n        if(this.fastdomfn1){\n            $L.fastdom.clear(this.fastdomfn1);\n            delete this.fastdomfn1;\n        }\n        if(this.fastdomfn2){\n            $L.fastdom.clear(this.fastdomfn2);\n            delete this.fastdomfn2;\n        }\n        if(this.fastdomfn3){\n            $L.fastdom.clear(this.fastdomfn3);\n            delete this.fastdomfn3;\n        }\n        if(this.fastdomfn4){\n            $L.fastdom.clear(this.fastdomfn4);\n            delete this.fastdomfn4;\n        }\n        if(this.fastdomfn5){\n            $L.fastdom.clear(this.fastdomfn5);\n            delete this.fastdomfn5;\n        }\n        if(this.fastdomfn6){\n            $L.fastdom.clear(this.fastdomfn6);\n            delete this.fastdomfn6;\n        }\n        if(this.fastdomfn7){\n            $L.fastdom.clear(this.fastdomfn7);\n            delete this.fastdomfn7;\n        }\n        if(this.initCompute){\n            clearTimeout(this.initCompute);\n            delete this.initCompute;\n        }\n    }\n\n    removeDOMReferences() {\n        if(this.childComp){\n            delete this.childComp;\n        }\n        if(this.actualModalDiv){\n            delete this.actualModalDiv;\n        }\n    }\n\n    callOnResize(event) {\n        if(this.getMethods('onResize')){\n            this.executeMethod('onResize',event,this);\n        }\n        var origElemPosition = this.getData('ltPropOriginElem') ? document.querySelector(this.$node.ltProp('originElem')).getBoundingClientRect() : null;\n        if(!!origElemPosition){\n            var winH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n            var winW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n            if( !(this.getData('ltPropForceScroll')) && ( (origElemPosition.bottom > winH) || (origElemPosition.right > winW) || (origElemPosition.left < 0) || (origElemPosition.top < 0) ) ){\n                this.$node.ltProp(\"show\",false);\n            }\n        }\n\n    }\n\n    callOnScroll(event) {\n        var returnVal;\n        if(this.getMethods('onScroll')){\n            returnVal = this.executeMethod('onScroll',event,this);\n        }\n        return (returnVal == undefined ? true : returnVal);\n    }\n\n    /**\n     * The method is going to set height and width to the popover\n     *\n     */\n    updateScrollHandling(event) {   //Sets the height and width of the popover\n\n        if(!this.$node.ltProp(\"freeze\") && this.$node.ltProp(\"forceScroll\")){\n            this.$node.ltProp(\"scrollable\",true);\n        }\n        var modalElem = this.actualModalDiv;\n        var oldHeight, oldWidth, newHeight, newWidth,\n        contentNode = modalElem.querySelector(\"lyte-popover-content\");\n\n        if(this.getData('resize') && this.getData('ltPropAutoAlign') && this.$node.mutobserver){\n            this.$node.mutobserver.disconnect();\n        }\n        // contentNode = contentNode ? contentNode : modalElem;\n        modalElem.style.maxWidth = \"\";\n        modalElem.style.maxHeight = \"\";\n        modalElem.style.height = this.$node.ltProp(\"height\") ? this.$node.ltProp(\"height\") : \"auto\";\n        modalElem.style.width = this.$node.ltProp(\"width\")?this.$node.ltProp(\"width\"):\"auto\";\n        if(this.getData('resize')){\n          modalElem.style.width = this.getData('modalElemWidth') + \"px\"\n          modalElem.style.height = this.getData('modalElemHeight') + \"px\"\n        }\n        /*------------------------------ MEASURE STARTS --------------------------*/\n        this.fastdomfn1 = $L.fastdom.measure(function(){   //Measures the initial height and width based on the content of popover\n            delete this.fastdomfn1;\n            var modalElemOffset = modalElem.getBoundingClientRect();\n            /*IF maxwidth or maxheigth given as a percentage then to calculate the actual width or height\n                                we need the modalElements parent element's width and height*/\n            var modalParentOff = modalElem.parentElement.getBoundingClientRect();\n            /*var totalHeight = ((modalElem.querySelector('lyte-popover-header') ? modalElem.querySelector('lyte-popover-header').getBoundingClientRect().height : 0) +\n                                    (modalElem.querySelector('lyte-popover-content') ? modalElem.querySelector('lyte-popover-content').getBoundingClientRect().height : 0) +\n                                        (modalElem.querySelector('lyte-popover-footer') ? modalElem.querySelector('lyte-popover-footer').getBoundingClientRect().height : 0))*/\n            var cs = window.getComputedStyle(modalElem);\n            var borderDimensionY = ((cs.borderTopWidth ? parseFloat(cs.borderTopWidth) : 0) +\n                                     (cs.borderBottomWidth ? parseFloat(cs.borderBottomWidth) : 0));\n            var windowSpacing = this.getData('windowSpacing');\n            var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0) - (windowSpacing.top + windowSpacing.bottom);\n            /*------------------------------ MUTATE STARTS --------------------------*/\n            this.fastdomfn2 = $L.fastdom.mutate(function(){  //Measures and sets the height and width based on the user provided max values\n                delete this.fastdomfn2;\n                if(this.$node.ltProp(\"maxWidth\")){\n                    // this.$node.ltProp(\"scrollable\",true);\n                    oldWidth = modalElemOffset.width;\n                    // modalElem.style.width = this.$node.ltProp(\"maxWidth\");\n                    newWidth = this.$node.ltProp(\"maxWidth\").indexOf('%') != -1 ? ((parseFloat(this.$node.ltProp(\"maxWidth\"))/100) * modalParentOff.width) : parseFloat(this.$node.ltProp(\"maxWidth\"));\n                    // if(oldWidth < newWidth){\n                    //     modalElem.style.width = oldWidth+\"px\";\n                    //     newWidth = oldWidth;\n                    // }\n                    modalElem.style.maxWidth = this.$node.ltProp(\"maxWidth\");\n                    if(contentNode){\n                        contentNode.style.overflowX = \"auto\";\n                    }\n                    else{\n                        modalElem.style.overflowX = \"auto\";\n                    }\n\n                }\n                // else{\n                //     newWidth = modalElemOffset.width;\n                // }\n\n                if(this.$node.ltProp(\"maxHeight\")/* && totalHeight >= parseInt(this.$node.ltProp(\"maxHeight\"))*/){\n                    this.childComp.querySelector(\".popoverWrapper\").classList.add(\"scrollable\");\n                    // this.$node.ltProp(\"scrollable\",true);\n                    this.setData(\"calculateHW\",true);\n                    oldHeight = modalElemOffset.height - borderDimensionY;\n                    var newH = this.$node.ltProp(\"maxHeight\").indexOf('%') != -1 ? ((parseFloat(this.$node.ltProp(\"maxHeight\"))/100) * modalParentOff.height) : parseFloat(this.$node.ltProp(\"maxHeight\"));\n                    modalElem.style.maxHeight = this.$node.ltProp(\"maxHeight\");\n                    newHeight = newH - borderDimensionY;\n                    if(!contentNode){\n                        modalElem.style.overflowY = \"auto\";\n                    }\n                }\n                else{\n                    oldHeight = modalElemOffset.height - borderDimensionY;\n                    /*  If height is provided in px or em then we dont compare if it is greater than window height as it is fixed\n                        And also we add a maxHeight to the content div so that if the elements inside the content is increased\n                        there wont be any issue in popover size as we have a fixed max height for popover.  */\n                    if(this.$node.ltProp('height') && ((this.$node.ltProp('height')).indexOf('px') != -1 || (this.$node.ltProp('height')).indexOf('em') != -1)){\n                        newHeight = oldHeight;\n                        this.setData(\"calculateHW\",true);\n                    }\n                    else{\n                        newHeight = h-20;\n                    }\n                }\n\n                if(this.getData(\"calculateHW\") && contentNode){\n                    var popoverHeader = this.actualModalDiv.querySelector(\"lyte-popover-header\"), popoverFooter = this.actualModalDiv.querySelector(\"lyte-popover-footer\");\n                    var popoverHOff = 0,popoverFOff = 0;\n                    /*------------------------------ MEASURE STARTS --------------------------*/\n                    this.fastdomfn3 = $L.fastdom.measure(function(){    //Measures the heaser and footer dimensions\n                        delete this.fastdomfn3;\n                        if(popoverHeader){\n                            if(this.$node.ltProp(\"maxWidth\")){\n                                popoverHeader.style.overflowX = \"auto\";\n                            }\n                            popoverHOff = popoverHeader.offsetHeight;\n                        }\n                        if(popoverFooter){\n                            if(this.$node.ltProp(\"maxWidth\")){\n                                popoverFooter.style.overflowX = \"auto\";\n                            }\n                            popoverFOff = popoverFooter.offsetHeight;\n                        }\n                        /*------------------------------ MUTATE STARTS --------------------------*/\n                        this.fastdomfn4 = $L.fastdom.mutate(function(){   //Sets the final height and width of the popover\n                            delete this.fastdomfn4;\n                            var newH = (newHeight - (popoverHOff + popoverFOff));\n                            contentNode.style.maxHeight = (newH > 0 ? newH : 50) +\"px\";\n                            contentNode.style.overflowY = \"auto\";\n                            // if(this.getData('ltPropHeight')){\n                            //     contentNode.style.height = (oldHeight - (popoverHOff + popoverFOff))+\"px\";\n                            // }\n                            // else{\n                            //     contentNode.style.height = \"auto\";\n                            // }\n                            // modalElem.style.width = this.$node.ltProp(\"width\")?this.$node.ltProp(\"width\"):\"auto\";\n                            // modalElem.style.maxWidth = newWidth > 0 ? (newWidth +\"px\"):(\"70%\");\n\n                            /*  Moved the calling of computeOffsetImpl function from here during resize so that\n                                the height and width calculation of the popover is completed and then we can position the popover.  */\n                            if(this.getData('resize')){\n                                // if(this.getData('ltPropAutoAlign') && this.$node.mutobserver){\n                                //     this.$node.mutobserver.disconnect();\n                                // }\n                                this.computeOffsetImpl(event);\n                            }\n\n                            /* Checks and adds mutation observer */\n                            // this.addMutationObserver();\n                            modalElem = null;\n                            contentNode = null;\n                            popoverHeader = null;\n                            popoverFooter = null;\n                        },this);\n                        /*------------------------------ MUTATE ENDS --------------------------*/\n                    },this);\n                    /*------------------------------ MEASURE ENDS --------------------------*/\n                }\n                else{\n                    this.childComp.querySelector(\".popoverWrapper\").classList.remove(\"scrollable\");\n                    /*  Moved the calling of computeOffsetImpl function from here during resize so that\n                        the height and width calculation of the popover is completed and then we can position the popover.  */\n                    if(this.getData('resize')){\n                        // if(this.getData('ltPropAutoAlign') && this.$node.mutobserver){\n                        //     this.$node.mutobserver.disconnect();\n                        // }\n                        this.computeOffsetImpl(event);\n                    }\n                    /* Checks and adds mutation observer */\n                    // this.addMutationObserver();\n                    modalElem = null;\n                    contentNode = null;\n                }\n            },this);\n            /*------------------------------ MUTATE ENDS --------------------------*/\n        },this);\n        /*------------------------------ MEASURE ENDS --------------------------*/\n    }\n\n    // Mutation observer\n    addMutationObserver() {\n        if(this.getData('ltPropAutoAlign')){\n            var popover = this.$node,\n            targetNode = this.actualModalDiv, reAlign, config;\n            this.setData('prevOffsetVal', {\n                    height : this.actualModalDiv.offsetHeight,\n                    width : this.actualModalDiv.offsetWidth\n                });\n            popover.mutobserver = new window.MutationObserver( function( mutations ) {\n                if(this.getData('ltPropAutoAlign')){\n                    var popoverElem = this.actualModalDiv;\n                    var prevOffsetVal = this.getData('prevOffsetVal');\n                    var offsetWidth = popoverElem.offsetWidth;\n                    var offsetHeight = popoverElem.offsetHeight;\n                    for( var i = 0; i < mutations.length; i++ ) {\n                        // console.log(mutations[ i ].type + \" ====== \" + mutations[i].attributeName);\n                        if( ((mutations[ i ].type === 'attributes')/* && mutations[ i ].attributeName === 'style'*/) || mutations[i].type == 'childList' || mutations[i].type == 'subtree' ) {\n                            if(prevOffsetVal.width != offsetWidth || prevOffsetVal.height != offsetHeight){\n                                reAlign = true;\n                                this.setData('prevOffsetVal', {\n                                    height : offsetHeight,\n                                    width : offsetWidth\n                                })\n                                break;\n                            }\n                        }\n                    }\n                    if(reAlign){\n                        reAlign = false;\n                        this.computeOffsetImpl(null, true);\n                    }\n                }\n            }.bind( this ) );\n\n            config = {\n                attributes: true,\n                childList : true,\n                subtree: true\n                // attributeFilter: ['style', 'class']\n            };\n\n            popover.mutobserver.observe( targetNode, config );\n            // Mutation observer ends\n        }\n    }\n\n    /**\n     * The method is going to do left and top computation and add it to the popover when it is opened\n     *\n     */\n    computeOffsetImpl(event, reAlign) {\n        var lyteSelf = this;\n        var classTobeAdded = \"\", offsetLeft=\"\",offsetTop=\"\";\n        var modalEle = this.actualModalDiv;\n        // modalEle.classList.remove('lytePopoverCenter','lytePopoverBottomCenter','lytePopoverBottomLeft','lytePopoverBottomRight','lytePopoverTopCenter','lytePopoverTopLeft','lytePopoverTopRight','lytePopoverLeft','lytePopoverRight');\n        // modalEle.style.left = \"\";\n        // modalEle.style.top = \"\";\n        /*------------------------------ MEASURE STARTS --------------------------*/\n        $L.fastdom.measure(function(){\n            if(this.$node.ltProp(\"showCopy\")){\n                if(this.$node.ltProp('originElem') != \"\" || !(lyteSelf.$component.registeredHelpers.lyteUiIsEmptyObject(this.$node.ltProp('offset')))){\n                    var ele = this.$node.ltProp('originElem') ? document.querySelector(this.$node.ltProp('originElem')) : null;\n                    if(!ele && lyteSelf.$component.registeredHelpers.lyteUiIsEmptyObject(this.$node.ltProp('offset'))){\n                        console.error(\"The origin element is either not present or may be removed. Kindly check.\")\n                        this.setData('ltPropShow',false);\n                        return;\n                    }\n                    var modalElemOffset = modalEle.getBoundingClientRect();\n                    var modalElePosition = {top: modalElemOffset.top,\n                                            right: modalElemOffset.right,\n                                            bottom: modalElemOffset.bottom,\n                                            left: modalElemOffset.left,\n                                            width: modalEle.offsetWidth,\n                                            height: modalEle.offsetHeight\n                                           };\n                    // var xscroll = window.pageXOffset || document.documentElement.scrollLeft;\n                    // var yscroll = window.pageYOffset || document.documentElement.scrollTop;\n                    var wrapperOffset = modalEle.parentElement.getBoundingClientRect();\n                    var windowSpacing = Object.assign({},this.getData('windowSpacing'));\n                    var bodyHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0) - windowSpacing.bottom;\n                    var bodyWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0) - windowSpacing.right;\n                    var origElemPosition;\n                    if(lyteSelf.$component.registeredHelpers.lyteUiIsEmptyObject(this.$node.ltProp('offset'))){  //If origin element is present and there is no ltPropOffset\n                        var eleOffset = ele.getBoundingClientRect();\n                        origElemPosition = {\n                                              top: eleOffset.top,\n                                              right: eleOffset.right,\n                                              bottom: eleOffset.bottom,\n                                              left: eleOffset.left,\n                                              width: eleOffset.width,\n                                              height: eleOffset.height\n                                            };\n                    }\n                    else{   //if ltPropOffset has value\n                        origElemPosition = {\n                                              width:parseInt(this.$node.ltProp('offset').width) || 0,\n                                              height:parseInt(this.$node.ltProp('offset').height) || 0,\n                                              top:parseInt(this.$node.ltProp('offset').top),\n                                              left:parseInt(this.$node.ltProp('offset').left),\n                                              bottom:(parseInt(this.$node.ltProp('offset').bottom) || parseInt(this.$node.ltProp('offset').top) + (parseInt(this.$node.ltProp('offset').height) || 0)),\n                                              right:(parseInt(this.$node.ltProp('offset').right) || parseInt(this.$node.ltProp('offset').left) + (parseInt(this.$node.ltProp('offset').width) || 0))\n                                            }\n                    }\n                    // if(!this.getData('ltPropFreeze')){\n                    //     origElemPosition.top = origElemPosition.top + yscroll;\n                    //     origElemPosition.left = origElemPosition.left + xscroll;\n                    // }\n                    var elementPosition = origElemPosition;\n                    var offObj = {}, newOffObj = {};\n                    var position =  this.$node.ltProp('positionNew');\n                    var flag = true;\n                    var count = 0,\n                    index = 0,\n                    props;\n                    do{\n                        if(this.$node.ltProp('placement')/* && !this.$node.ltProp('freeze')*/){\n                            props = this.$node.ltProp('placement').trim().split(\" \");\n                            if(props.length == 1){\n                                flag = true;\n                                offObj = this.positionPopover(this.$node.ltProp('placement'),elementPosition,modalElePosition);\n                                position = this.$node.ltProp('placement');\n                                switch(position){\n                                    case 'bottom':\n                                    case 'top':\n                                        if(offObj.offsetLeft+modalElePosition.width > bodyWidth){\n                                            offObj.offsetLeft = Math.max(windowSpacing.left, bodyWidth - modalElePosition.width);\n                                        }\n                                        if(offObj.offsetLeft < windowSpacing.left){\n                                            offObj.offsetLeft = windowSpacing.left;\n                                        }\n                                        break;\n                                    case 'left':\n                                    case 'right':\n                                        if(offObj.offsetTop+modalElePosition.height > bodyHeight){\n                                            offObj.offsetTop = Math.max(windowSpacing.top, bodyHeight - modalElePosition.height)/*origElemPosition.bottom - modalElePosition.height*/;\n                                        }\n                                        if(offObj.offsetTop < windowSpacing.top){\n                                            offObj.offsetTop = windowSpacing.top;\n                                        }\n                                        break;\n                                }\n                            }\n                            else{\n                                if(index < props.length){\n                                    position = props[index];\n                                    flag = true;\n                                    offObj = this.positionPopover(position,elementPosition,modalElePosition);\n                                    newOffObj = offObj;\n                                    switch(position){\n                                        case 'bottom':\n                                            if(bodyHeight < (newOffObj.offsetTop+modalElePosition.height) || (bodyHeight - (newOffObj.offsetTop+modalElePosition.height)) < windowSpacing.bottom){\n                                                index++;\n                                                flag = false;\n                                                break;\n                                            }\n\n                                            if((newOffObj.offsetLeft-modalElePosition.width) < windowSpacing.left /*0*/){\n                                                offObj.offsetLeft = elementPosition.left;\n                                                flag = true;\n                                            }\n                                            if(bodyWidth < (offObj.offsetLeft+modalElePosition.width)){\n                                                offObj.offsetLeft = bodyWidth - modalElePosition.width - 10;\n                                                flag = true;\n                                            }\n                                            break;\n                                        case 'bottomLeft':\n                                            if(bodyHeight < (newOffObj.offsetTop+modalElePosition.height) || (bodyHeight - (newOffObj.offsetTop+modalElePosition.height)) < windowSpacing.bottom){\n                                                index++;\n                                                flag = false;\n                                                break;\n                                            }\n\n                                            if((newOffObj.offsetLeft-modalElePosition.width) < windowSpacing.left /*0*/){\n                                                offObj.offsetLeft = elementPosition.left;\n                                                flag = true;\n                                            }\n                                            if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){\n                                                offObj.offsetLeft = bodyWidth - modalElePosition.width - 10;\n                                                flag = true;\n                                            }\n                                            break;\n                                        case 'bottomRight':\n                                            if(bodyHeight < (newOffObj.offsetTop+modalElePosition.height) || (bodyHeight - (newOffObj.offsetTop+modalElePosition.height)) < windowSpacing.bottom){\n                                                index++;\n                                                flag = false;\n                                                break;\n                                            }\n\n                                            if((newOffObj.offsetLeft-modalElePosition.width) < windowSpacing.left /*0*/){\n                                                offObj.offsetLeft = elementPosition.left;\n                                                flag = true;\n                                            }\n                                            if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){\n                                                offObj.offsetLeft = bodyWidth - modalElePosition.width - 10;\n                                                flag = true;\n                                            }\n                                            break;\n                                        case 'top':\n                                            if(newOffObj.offsetTop < windowSpacing.top /*0*/){\n                                                index++;\n                                                flag = false;\n                                                break;\n                                            }\n\n                                            if((newOffObj.offsetLeft-modalElePosition.width) < windowSpacing.left /*0*/){\n                                                offObj.offsetLeft = elementPosition.left;\n                                                flag = true;\n                                            }\n                                            if(bodyWidth < (offObj.offsetLeft+modalElePosition.width)){\n                                                offObj.offsetLeft = bodyWidth - modalElePosition.width - 10;\n                                                flag = true;\n                                            }\n                                            break;\n                                        case 'topLeft':\n                                            if(newOffObj.offsetTop < windowSpacing.top /*0*/){\n                                                index++;\n                                                flag = false;\n                                                break;\n                                            }\n\n                                            if((newOffObj.offsetLeft-modalElePosition.width) < windowSpacing.left /*0*/){\n                                                offObj.offsetLeft = elementPosition.left;\n                                                flag = true;\n                                            }\n                                            if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){\n                                                offObj.offsetLeft = bodyWidth - modalElePosition.width - 10;\n                                                flag = true;\n                                            }\n                                            break;\n                                        case 'topRight':\n                                            if(newOffObj.offsetTop < windowSpacing.top /*0*/){\n                                                index++;\n                                                flag = false;\n                                                break;\n                                            }\n\n                                            if((newOffObj.offsetLeft-modalElePosition.width) < windowSpacing.left /*0*/){\n                                                offObj.offsetLeft = elementPosition.left;\n                                                flag = true;\n                                            }\n                                            if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){\n                                                offObj.offsetLeft = bodyWidth - modalElePosition.width - 10;\n                                                flag = true;\n                                            }\n                                            break;\n                                        case 'left':\n                                            if(newOffObj.offsetTop < windowSpacing.top){\n                                                index++;\n                                                flag = false;\n                                                break;\n                                            }\n                                            if(newOffObj.offsetLeft < windowSpacing.left /*0*/){\n                                                index++;\n                                                flag = false;\n                                                offsetLeft = (elementPosition.left + elementPosition.width)+9;\n                                                offsetTop = elementPosition.top;\n                                                break;\n                                            }\n                                            if((newOffObj.offsetTop-modalElePosition.height) < windowSpacing.top /*0*/ ){\n                                                offObj.offsetTop = elementPosition.top;\n                                            }\n                                            if(bodyHeight < (offObj.offsetTop+modalElePosition.height)){\n                                                offObj.offsetTop = bodyHeight - modalElePosition.height;\n                                            }\n                                            break;\n                                        case 'leftCenter':\n                                        case 'leftBottom':\n                                            if(newOffObj.offsetTop < windowSpacing.top){\n                                                index++;\n                                                flag = false;\n                                                break;\n                                            }\n                                            if(newOffObj.offsetLeft < windowSpacing.left /*0*/){\n                                                index++;\n                                                flag = false;\n                                                break;\n                                            }\n                                            if(bodyHeight < (offObj.offsetTop+modalElePosition.height)){\n                                                index++;\n                                                flag = false;\n                                                break;\n                                            }\n                                            break;\n                                        case 'right':\n                                            if(newOffObj.offsetTop < windowSpacing.top){\n                                                index++;\n                                                flag = false;\n                                                break;\n                                            }\n                                            if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){\n                                                index++;\n                                                flag = false;\n                                                offObj.offsetLeft = (elementPosition.left - modalElePosition.width)-9;\n                                                offObj.offsetTop = elementPosition.top;\n                                                break;\n                                            }\n                                            if((newOffObj.offsetTop-modalElePosition.height) < windowSpacing.top /*0*/ ){\n                                                offObj.offsetTop = elementPosition.top;\n                                            }\n                                            if(bodyHeight < (offObj.offsetTop+modalElePosition.height)){\n                                                offObj.offsetTop = bodyHeight - modalElePosition.height;\n                                            }\n                                        break;\n                                        case 'rightCenter':\n                                        case 'rightBottom':\n                                            if(newOffObj.offsetTop < windowSpacing.top){\n                                                index++;\n                                                flag = false;\n                                                break;\n                                            }\n                                            if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){\n                                                index++;\n                                                flag = false;\n                                                break;\n                                            }\n                                            if(bodyHeight < (offObj.offsetTop+modalElePosition.height)){\n                                                index++;\n                                                flag = false;\n                                                break;\n                                            }\n                                        break;\n                                    }\n                                }\n                                else{\n                                    flag = true;\n                                }\n                            }\n                        }\n                        else{\n                           count++;\n                            flag = true;\n                            offObj = this.positionPopover(position,elementPosition,modalElePosition);\n                            // if(!this.$node.ltProp('freeze')){\n                            //     newOffObj.offsetTop = origElemPosition.top/* + origElemPosition.height*/;\n                            //     newOffObj.offsetLeft = origElemPosition.left/* + origElemPosition.width*/;\n                            // }\n                            // else{\n                                newOffObj = offObj;\n                            // }\n                            switch(position){\n                                case 'bottom':\n                                    if(bodyHeight < (newOffObj.offsetTop+modalElePosition.height) || (bodyHeight - (newOffObj.offsetTop+modalElePosition.height)) < windowSpacing.bottom){\n                                        position = \"top\";\n                                        flag = false;\n                                        break;\n                                    }\n\n                                    if((newOffObj.offsetLeft-modalElePosition.width) < windowSpacing.left /*0*/){\n                                        offObj.offsetLeft = elementPosition.left + (this.getData('ltPropOffsetFromTarget').left || 0);\n                                        flag = true;\n                                    }\n                                    if(bodyWidth < (offObj.offsetLeft+modalElePosition.width)){\n                                        offObj.offsetLeft = bodyWidth - modalElePosition.width - (this.getData('ltPropType') == \"box\" ? 0 : 9);\n                                        flag = true;\n                                    }\n                                    break;\n                                case 'bottomLeft':\n                                    if(bodyHeight < (newOffObj.offsetTop+modalElePosition.height) || (bodyHeight - (newOffObj.offsetTop+modalElePosition.height)) < windowSpacing.bottom){\n                                        position = \"top\";\n                                        flag = false;\n                                        break;\n                                    }\n\n                                    if((newOffObj.offsetLeft-modalElePosition.width) < windowSpacing.left /*0*/){\n                                        offObj.offsetLeft = elementPosition.left;\n                                        flag = true;\n                                    }\n                                    if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){\n                                        offObj.offsetLeft = bodyWidth - modalElePosition.width - (this.getData('ltPropType') == \"box\" ? 0 : 9);\n                                        flag = true;\n                                    }\n                                    break;\n                                case 'bottomRight':\n                                    if(bodyHeight < (newOffObj.offsetTop+modalElePosition.height) || (bodyHeight - (newOffObj.offsetTop+modalElePosition.height)) < windowSpacing.bottom){\n                                        position = \"top\";\n                                        flag = false;\n                                        break;\n                                    }\n\n                                    if((newOffObj.offsetLeft-modalElePosition.width) < windowSpacing.left /*0*/){\n                                        offObj.offsetLeft = elementPosition.left;\n                                        flag = true;\n                                    }\n                                    if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){\n                                        offObj.offsetLeft = bodyWidth - modalElePosition.width - (this.getData('ltPropType') == \"box\" ? 0 : 9);\n                                        flag = true;\n                                    }\n                                    break;\n                                case 'top':\n                                    if(newOffObj.offsetTop < windowSpacing.top /*0*/){\n                                        position = (window._lyteUiUtils.getRTL() ? \"left\" : \"right\");\n                                        flag = false;\n                                        break;\n                                    }\n\n                                    if((newOffObj.offsetLeft-modalElePosition.width) < windowSpacing.left /*0*/){\n                                        offObj.offsetLeft = elementPosition.left;\n                                        flag = true;\n                                    }\n                                    if(bodyWidth < (offObj.offsetLeft+modalElePosition.width)){\n                                        offObj.offsetLeft = bodyWidth - modalElePosition.width - (this.getData('ltPropType') == \"box\" ? 0 : 9);\n                                        flag = true;\n                                    }\n                                    break;\n                                case 'topLeft':\n                                    if(newOffObj.offsetTop < windowSpacing.top /*0*/){\n                                        position = \"right\";\n                                        flag = false;\n                                        break;\n                                    }\n\n                                    if((newOffObj.offsetLeft-modalElePosition.width) < windowSpacing.left /*0*/){\n                                        offObj.offsetLeft = elementPosition.left;\n                                        flag = true;\n                                    }\n                                    if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){\n                                        offObj.offsetLeft = bodyWidth - modalElePosition.width - (this.getData('ltPropType') == \"box\" ? 0 : 9);\n                                        flag = true;\n                                    }\n                                    break;\n                                case 'topRight':\n                                    if(newOffObj.offsetTop < windowSpacing.top /*0*/){\n                                        position = \"left\";\n                                        flag = false;\n                                        break;\n                                    }\n\n                                    if((newOffObj.offsetLeft-modalElePosition.width) < windowSpacing.left /*0*/){\n                                        offObj.offsetLeft = elementPosition.left;\n                                        flag = true;\n                                    }\n                                    if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){\n                                        offObj.offsetLeft = bodyWidth - modalElePosition.width - (this.getData('ltPropType') == \"box\" ? 0 : 9);\n                                        flag = true;\n                                    }\n                                    break;\n                                case 'left':\n                                    if(newOffObj.offsetTop < windowSpacing.top){\n                                        position = \"bottom\";\n                                        flag = false;\n                                        break;\n                                    }\n                                    if(newOffObj.offsetLeft < windowSpacing.left /*0*/){\n                                        position = \"right\";\n                                        offObj.offsetLeft = (elementPosition.left + elementPosition.width)+(this.getData('ltPropType') == \"box\" ? 0 : 9);\n                                        offObj.offsetTop = elementPosition.top;\n                                    }\n                                    if((newOffObj.offsetTop-modalElePosition.height) < windowSpacing.top /*0*/ ){\n                                        offObj.offsetTop = elementPosition.top;\n                                    }\n                                    if(bodyHeight < (offObj.offsetTop+modalElePosition.height)){\n                                        offObj.offsetTop = Math.max(windowSpacing.top, bodyHeight - modalElePosition.height) /*bodyHeight - modalElePosition.height*/;\n                                    }\n                                    break;\n                                case 'right':\n                                    if(newOffObj.offsetTop < windowSpacing.top){\n                                        position = \"bottom\";\n                                        flag = false;\n                                        break;\n                                    }\n                                    if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){\n                                        position = \"left\";\n                                        offObj.offsetLeft = (elementPosition.left - modalElePosition.width)-(this.getData('ltPropType') == \"box\" ? 0 : 9);\n                                        offObj.offsetTop = elementPosition.top;\n                                    }\n                                    if((newOffObj.offsetTop-modalElePosition.height) < windowSpacing.top /*0*/ ){\n                                        offObj.offsetTop = elementPosition.top;\n                                    }\n                                    if(bodyHeight < (offObj.offsetTop+modalElePosition.height)){\n                                        offObj.offsetTop = Math.max(windowSpacing.top, bodyHeight - modalElePosition.height) /*bodyHeight - modalElePosition.height*/;\n                                    }\n                                    break;\n                            }\n\n                            if(this.getData('ltPropIgnoreBoundary')){\n                              flag = true\n                            }\n\n                        }\n\n                    }while(!flag && count <= 8)\n                    var positions = [\"bottom\",\"bottomLeft\",\"bottomRight\",\"top\",\"topLeft\",\"topRight\",\"right\",\"left\"];\n                    if(this.getData('ltPropForceScroll')){\n                        if(position.indexOf(\"left\") != -1 || position.indexOf(\"right\") != -1){\n                            if(elementPosition.height <= modalElePosition.height){\n                                if(offObj.offsetTop > elementPosition.top){\n                                    offObj.offsetTop = elementPosition.top;\n                                }\n                                else if(offObj.offsetTop+modalElePosition.height < elementPosition.bottom){\n                                    offObj.offsetTop = elementPosition.bottom - modalElePosition.height;\n                                }\n                            }\n                            else{\n                                if(offObj.offsetTop < elementPosition.top){\n                                    offObj.offsetTop = elementPosition.top;\n                                }\n                                else if(offObj.offsetTop+modalElePosition.height > elementPosition.bottom){\n                                    offObj.offsetTop = elementPosition.bottom - modalElePosition.height;\n                                }\n                            }\n                        }\n                        else{\n                            if(offObj.offsetLeft > elementPosition.left){\n                                offObj.offsetLeft = elementPosition.left;\n                            }\n                            else if(offObj.offsetLeft+modalElePosition.width < elementPosition.right){\n                                offObj.offsetLeft = elementPosition.right - modalElePosition.width;\n                            }\n                        }\n                    }\n                    offsetLeft = offObj.offsetLeft;\n                    offsetTop = offObj.offsetTop;\n\n                    if(this.$node.ltProp('type') === \"callout\"){\n                        if(position.indexOf(\"bottom\") > -1){\n                            offObj.classTobeAdded = \"lytePopoverArrowTop\";\n                            offObj.posClass = \"lytePopBottomToOrig\";\n                        }\n                        else if(position.indexOf(\"top\") > -1){\n                            offObj.classTobeAdded = \"lytePopoverArrowBottom\";\n                            offObj.posClass = \"lytePopTopToOrig\";\n                        }\n                        else if(position.indexOf(\"left\") > -1){\n                             offObj.classTobeAdded = \"lytePopoverArrowRight\";\n                             offObj.posClass = \"lytePopLeftToOrig\";\n                        }\n                        else if(position.indexOf(\"right\") > -1){\n                             offObj.classTobeAdded = \"lytePopoverArrowLeft\";\n                             offObj.posClass = \"lytePopRightToOrig\";\n                        }\n                        var arrowIcon = modalEle.querySelector(\"#lytePopoverArrow\");\n                        arrowIcon.classList.remove(\"lytePopoverArrowTop\",\"lytePopoverArrowBottom\",\"lytePopoverArrowRight\",\"lytePopoverArrowLeft\");\n                        arrowIcon.classList.add(offObj.classTobeAdded);\n                        var arrowIconOffset;\n                        if(!(modalEle.parentElement.classList.contains(offObj.posClass))){\n                            modalEle.parentElement.classList.remove(\"lytePopBottomToOrig\",\"lytePopTopToOrig\",\"lytePopLeftToOrig\",\"lytePopRightToOrig\");\n                            modalEle.parentElement.classList.add(offObj.posClass);\n                        }\n                        /*------------------------------ MEASURE STARTS --------------------------*/\n                        $L.fastdom.measure(function(){\n                            arrowIconOffset = {height : arrowIcon.offsetHeight, width : arrowIcon.offsetWidth};\n                        });\n                        /*------------------------------ MEASURE ENDS --------------------------*/\n                        /*------------------------------ MUTATE STARTS --------------------------*/\n                        //Positions the arrowIcon of the popover and the popover too based on origin elem\n                        $L.fastdom.mutate(function(){   //If originElem -> height < arrowIcon -> height OR originElem -> width < arrowIcon -> width\n                            var diagonal = Math.floor(Math.sqrt((arrowIconOffset.height * arrowIconOffset.height) + (arrowIconOffset.width * arrowIconOffset.width)) - 2) ;\n                            if(offObj.classTobeAdded === \"lytePopoverArrowTop\" || offObj.classTobeAdded === \"lytePopoverArrowBottom\"){\n                                var leftVal = Math.abs(offsetLeft - (elementPosition.left+(elementPosition.width-diagonal)/2));\n                                arrowIcon.style.left = leftVal+\"px\";\n                                arrowIcon.style.top = \"\";\n                                if(leftVal < 13 && origElemPosition.width <= (diagonal+22) ){\n                                    var diff = 13 - leftVal;\n                                    // if(Math.round(origElemPosition.left) == Math.round(offsetLeft)/* && (offsetLeft - diff) >= 0*/){\n                                        leftVal += diff;\n                                        arrowIcon.style.left = leftVal + \"px\";\n                                        offsetLeft -= diff;\n                                    // }\n                                }\n                                else if(modalElePosition.width - (leftVal + diagonal) < 13 && origElemPosition.width <= (diagonal+22)){\n                                    var diff = 13 - (modalElePosition.width - (leftVal + diagonal));\n                                    // if(Math.round(origElemPosition.left + origElemPosition.width) == Math.round(modalElePosition.width + offsetLeft)){\n                                        leftVal -= diff;\n                                        arrowIcon.style.left = leftVal + \"px\";\n                                        offsetLeft += diff;\n                                    // }\n                                }\n                                if(leftVal > (modalElePosition.width - (2 * diagonal))){\n                                    leftVal =  (modalElePosition.width - (2 * diagonal));\n                                    arrowIcon.style.left = leftVal + \"px\";\n                                }\n                                if(offObj.classTobeAdded === \"lytePopoverArrowTop\"){\n                                    this.setData('transformOrigin',Math.round(leftVal)+\"px top\");\n                                }\n                                if(offObj.classTobeAdded === \"lytePopoverArrowBottom\"){\n                                    this.setData('transformOrigin',Math.round(leftVal)+\"px bottom\");\n                                }\n                            }\n                            else{\n                                var topVal = Math.abs(offsetTop - (elementPosition.top+(elementPosition.height-diagonal)/2));\n                                arrowIcon.style.left = \"\";\n                                arrowIcon.style.top = topVal +\"px\";\n                                if(topVal < 13 && origElemPosition.height <= (diagonal+22) ){\n                                    var diff = 13 - topVal;\n                                    // if(Math.round(origElemPosition.top) == Math.round(offsetTop)/* && (offsetTop - diff) >= 0*/){\n                                        topVal += diff;\n                                        arrowIcon.style.top = topVal + \"px\";\n                                        offsetTop -= diff;\n                                    // }\n                                }\n                                else if(modalElePosition.height - (topVal + diagonal) < 13 && origElemPosition.height <= (diagonal+22)){\n                                    var diff = 13 - (modalElePosition.height - (topVal + diagonal));\n                                    // if(Math.round(origElemPosition.top + origElemPosition.height) == Math.round(modalElePosition.height + offsetTop)){\n                                        topVal -= diff;\n                                        arrowIcon.style.top = topVal + \"px\";\n                                        offsetTop += diff;\n                                    // }\n                                }\n                                if(offObj.classTobeAdded === \"lytePopoverArrowLeft\"){\n                                    this.setData('transformOrigin',\"left \"+Math.round(topVal)+\"px\");\n                                }\n                                if(offObj.classTobeAdded === \"lytePopoverArrowRight\"){\n                                    this.setData('transformOrigin',\"right \"+Math.round(topVal)+\"px\");\n                                }\n                            }\n                        },this);\n                        /*------------------------------ MUTATE ENDS --------------------------*/\n\n                    }\n                    else{\n                        if(position.indexOf(\"bottom\") > -1){\n                            offObj.posClass = \"lytePopBottomToOrig\";\n                        }\n                        else if(position.indexOf(\"top\") > -1){\n                            offObj.posClass = \"lytePopTopToOrig\";\n                        }\n                        else if(position === \"left\"){\n                             offObj.posClass = \"lytePopLeftToOrig\";\n                        }\n                        else if(position === \"right\"){\n                             offObj.posClass = \"lytePopRightToOrig\";\n                        }\n                        if(!(modalEle.parentElement.classList.contains(offObj.posClass))){\n                            modalEle.parentElement.classList.remove(\"lytePopBottomToOrig\",\"lytePopTopToOrig\",\"lytePopLeftToOrig\",\"lytePopRightToOrig\");\n                            modalEle.parentElement.classList.add(offObj.posClass);\n                        }\n                        if(offObj.posClass == \"lytePopBottomToOrig\" || offObj.posClass == \"lytePopTopToOrig\"){\n                            var leftVal = Math.abs(offsetLeft - (elementPosition.left+elementPosition.width/2));\n                            if(offObj.posClass == \"lytePopBottomToOrig\"){\n                                this.setData('transformOrigin',Math.round(leftVal)+\"px top\");\n                            }\n                            if(offObj.posClass == \"lytePopTopToOrig\"){\n                                this.setData('transformOrigin',Math.round(leftVal)+\"px bottom\");\n                            }\n                        }\n                        else{\n                            var topVal = Math.abs(offsetTop - (elementPosition.top+elementPosition.height/2));\n                            if(offObj.posClass === \"lytePopRightToOrig\"){\n                                this.setData('transformOrigin',\"left \"+Math.round(topVal)+\"px\");\n                            }\n                            if(offObj.posClass === \"lytePopLeftToOrig\"){\n                                this.setData('transformOrigin',\"right \"+Math.round(topVal)+\"px\");\n                            }\n                        }\n\n                    }\n                    this.setData('classTobeAdded',offObj.classTobeAdded);\n                }\n                else{\n                    console.error(\"Please provide values for either ltPropOriginElem or ltPropOffset to open the popover at proper position.\")\n                    this.setData('ltPropShow',false);\n                    return;\n                }\n                this.$node.ltProp('positionNew',position);\n                /*------------------------------ MUTATE STARTS --------------------------*/\n                $L.fastdom.mutate(function(){\n                    offsetLeft -= wrapperOffset.left ? wrapperOffset.left : 0;\n                    offsetTop -= wrapperOffset.top ? wrapperOffset.top : 0;\n                    modalEle.style.left = offsetLeft+\"px\";\n                    modalEle.style.top = offsetTop+\"px\";\n                    if(this.getData(\"first\")){\n                        window.LytePopup.bindTransitionEnd(this.actualModalDiv);\n                        this.callOnShow();\n                        this.setOpacityAndVisibility();\n                        this.setData(\"first\",false);\n                        /* Checks and adds mutation observer */\n                        $L.fastdom.mutate(function(){\n                            this.addMutationObserver();\n                        },this);\n                    }\n                    else if(this.getData('resize')){\n                        this.callOnResize(event);\n                        this.setData('resize', false);\n                        modalEle.style.height = this.$node.ltProp(\"height\") ? this.$node.ltProp(\"height\") : \"auto\";\n                        modalEle.style.width = this.$node.ltProp(\"width\")?this.$node.ltProp(\"width\"):\"auto\";\n                        // this.setData('modalElemHeight' , '')\n                        // this.setData('modalElemWidth' , '')\n                        /* Checks and adds mutation observer */\n                        $L.fastdom.mutate(function(){\n                            this.addMutationObserver();\n                        },this);\n                    }\n                    else if(reAlign){\n                        var prevRect = this.getData('prevRect');\n                        if(prevRect && ( (prevRect.left != offsetLeft) || (prevRect.top != offsetTop) ) && this.getMethods('onPositionChange')){\n                            this.executeMethod('onPositionChange', this);\n                        }\n                    }\n                    this.setData('prevRect', {left : offsetLeft, top : offsetTop});\n                },this);\n                /*------------------------------ MUTATE ENDS --------------------------*/\n            }\n        },this);\n        /*------------------------------ MEASURE ENDS --------------------------*/\n        if(this.$node.ltProp(\"freeze\")){\n            document.body.classList.add('bodyWrapper');\n            // LytePopup.bodywrapperCount += 1;\n        }\n\n        var curSelf = this\n        var openTransFun = function(){\n          curSelf.setData('modalElemWidth' , curSelf.actualModalDiv.offsetWidth)\n          curSelf.setData('modalElemHeigh' , curSelf.actualModalDiv.offsetHeight)\n          curSelf.actualModalDiv.removeEventListener('transitionend' , openTransFun)\n        }\n\n        this.actualModalDiv.addEventListener('transitionend' , openTransFun)\n    }\n\n    /**\n     * The method is going to return the left and top values that can be set to the popover based on the origin element's position\n     *\n     */\n    positionPopover(position, elementPosition, modalElePosition) {\n        var  offsetLeft=0,offsetTop=0,classTobeAdded,margin=this.getData(\"margin\");\n        if(this.getData('ltPropOriginElem') == \"\"){\n            elementPosition.width = modalElePosition.width\n        }\n        switch(position){\n            case 'bottom':\n                offsetLeft = elementPosition.left - (modalElePosition.width - elementPosition.width)/2;\n                offsetTop = elementPosition.top+elementPosition.height+ (this.getData('ltPropType') == \"box\" ? 0 : 9) + margin.top;\n                classTobeAdded = \"lytePopoverArrowTop\";\n                break;\n            case 'bottomLeft':\n                offsetLeft = elementPosition.left;\n                offsetTop = elementPosition.top +elementPosition.height+(this.getData('ltPropType') == \"box\" ? 0 : 9) + margin.top;\n                classTobeAdded = 'lytePopoverArrowTop';\n                break;\n            case 'bottomRight':\n                offsetLeft = (elementPosition.left + elementPosition.width) - modalElePosition.width;\n                offsetTop =  elementPosition.top +elementPosition.height+(this.getData('ltPropType') == \"box\" ? 0 : 9) + margin.top;\n                classTobeAdded = 'lytePopoverArrowTop';\n                break;\n            case 'top':\n                offsetLeft = elementPosition.left - (modalElePosition.width - elementPosition.width)/2;\n                offsetTop = elementPosition.top - (modalElePosition.height+(this.getData('ltPropType') == \"box\" ? 0 : 9)) - margin.bottom;\n                classTobeAdded = 'lytePopoverArrowBottom';\n                break;\n            case 'topLeft':\n                offsetLeft = elementPosition.left;\n                offsetTop = elementPosition.top - (modalElePosition.height+(this.getData('ltPropType') == \"box\" ? 0 : 9)) - margin.bottom;\n                classTobeAdded = 'lytePopoverArrowBottom';\n                break;\n            case 'topRight':\n                offsetLeft = (elementPosition.left + elementPosition.width) - modalElePosition.width;\n                offsetTop = elementPosition.top - (modalElePosition.height+(this.getData('ltPropType') == \"box\" ? 0 : 9)) - margin.bottom;\n                classTobeAdded = 'lytePopoverArrowBottom';\n                break;\n            case 'left':\n                offsetLeft = (elementPosition.left - modalElePosition.width)-(this.getData('ltPropType') == \"box\" ? 0 : 9) + margin.left;\n                offsetTop = elementPosition.top;\n                classTobeAdded = 'lytePopoverArrowRight';\n                break;\n            case 'leftCenter':\n                offsetLeft = (elementPosition.left - modalElePosition.width)-(this.getData('ltPropType') == \"box\" ? 0 : 9) + margin.left;\n                offsetTop = elementPosition.top + (elementPosition.height - modalElePosition.height) / 2;\n                classTobeAdded = 'lytePopoverArrowRight';\n                break;\n            case 'leftBottom':\n                offsetLeft = (elementPosition.left - modalElePosition.width)-(this.getData('ltPropType') == \"box\" ? 0 : 9) + margin.left;\n                offsetTop = elementPosition.bottom  - modalElePosition.height;\n                classTobeAdded = 'lytePopoverArrowRight';\n                break;\n            case 'right':\n                offsetLeft = (elementPosition.left + elementPosition.width)+(this.getData('ltPropType') == \"box\" ? 0 : 9) - margin.right;\n                offsetTop = elementPosition.top;\n                classTobeAdded = 'lytePopoverArrowLeft';\n                break;\n            case 'rightCenter':\n                offsetLeft = (elementPosition.left + elementPosition.width)+(this.getData('ltPropType') == \"box\" ? 0 : 9) - margin.right;\n                offsetTop = elementPosition.top + (elementPosition.height - modalElePosition.height) / 2;\n                classTobeAdded = 'lytePopoverArrowLeft';\n                break;\n            case 'rightBottom':\n                offsetLeft = (elementPosition.left + elementPosition.width)+(this.getData('ltPropType') == \"box\" ? 0 : 9) - margin.right;\n                offsetTop = elementPosition.bottom - modalElePosition.height;\n                classTobeAdded = 'lytePopoverArrowLeft';\n                break;\n        }\n        return {offsetLeft:offsetLeft,offsetTop:offsetTop,classTobeAdded:classTobeAdded};\n    }\n\n    callOnShow() {\n        this.$node.classList.add('lytePopoverOpened');\n        if(this.getMethods(\"onShow\")){\n            this.executeMethod(\"onShow\",this);\n        }\n    }\n\n    setOpacityAndVisibility() {\n        if(this.getData('ltPropAnimation') === \"zoom\"){\n            this.actualModalDiv.style.transition = \"none\";\n            this.actualModalDiv.style.transform = \"scale(0)\";\n            // this.actualModalDiv.style.opacity = \"1\";\n            this.actualModalDiv.classList.add('lytePopoverVisible');\n            // this.actualModalDiv.classList.add('lyteZoom');\n            var self = this;\n            setTimeout(function(){\n                self.actualModalDiv.style.transition = \"\";\n                self.actualModalDiv.style.transitionDuration = (parseFloat(self.getData('ltPropDuration'))/1000) + \"s\";\n                window.LytePopup.makingVisible = true;\n\n                self.actualModalDiv.style.transformOrigin = self.getData('transformOrigin');\n                self.actualModalDiv.style.transform = \"scale(1)\";\n            },50);\n        }\n        else{\n            this.actualModalDiv.style.transitionDuration = (parseFloat(this.getData('ltPropDuration'))/1000) + \"s\";\n            window.LytePopup.makingVisible = true;\n            // this.actualModalDiv.style.opacity = \"1\";\n            this.actualModalDiv.classList.add('lytePopoverVisible');\n        }\n\n        /* ---- Commented for position error ---*/\n        /* if(!this.$node.ltProp('freeze') && this.getData('classTobeAdded') && (this.getData('classTobeAdded') == \"lytePopoverArrowLeft\" || this.getData('classTobeAdded') == \"lytePopoverArrowRight\")){\n            var actualModalDivOffset = this.actualModalDiv.getBoundingClientRect();\n            var origElemPosition = document.querySelector(this.getData('ltPropOriginElem')).getBoundingClientRect();\n            if(actualModalDivOffset.top != origElemPosition.top){\n                this.actualModalDiv.style.top = origElemPosition.top + \"px\";\n            }\n        } */\n    }\n\n    onBeforeCloseHandling(event) {\n        var result = true;\n        \n        if(this.getMethods(\"onBeforeClose\")){\n            result = this.executeMethod(\"onBeforeClose\",event,this);\n        }\n        var self = this;\n        if(result === undefined || result){\n            window._lyteUiUtils.dispatchEvent('lytePopoverBeforeClose' , this.actualModalDiv)\n            delete this.$node.alignPopover;\n            delete this.$node.calculateOffset;\n            if(this.getData('ltPropFreeze') && this.addedFreezeDetails){\n                window.LytePopup.hideOrShowFreeze(\"close\",this);\n                delete this.addedFreezeDetails;\n            }\n\n            if(this.getData('ltPropAutoAlign') && this.$node.mutobserver){\n                this.$node.mutobserver.disconnect();\n                delete this.$node.mutobserver;\n            }\n\n            if(this.getData('arrowHidden')){\n                this.getData('arrowEle').style.display = \"\";\n                this.setData('arrowHidden',false);\n                this.setData('arrowEle',null);\n            }\n            if(window._lyteUiUtils.getRTL() && this.getData('ltPropPlacement')){\n                this.setRTLPosition();\n            }\n            if(this.getData('ltPropDuration') == undefined){\n                // this.childComp.querySelector(\".popoverWrapper\").style.position = \"\";\n                this.$node.ltProp({\"showCopy\":false,\"show\":false});\n                this.$node.classList.remove('lytePopoverOpened');\n                if(this.getData('ltPropAnimation') == \"zoom\"){\n                    this.actualModalDiv.style.transform = \"scale(0)\";\n                }\n                else{\n                    // this.actualModalDiv.style.opacity = 0;\n                    this.actualModalDiv.classList.remove('lytePopoverVisible');\n\n                }\n                window.LytePopup.closePopup(this);\n                // LytePopup.bindTransitionEnd(this.actualModalDiv);\n                this.setData('visible',false);\n                if(this.$node.ltProp('freeze') && this.childComp.querySelector(\"lyte-popover-freeze\")){\n                    this.childComp.querySelector(\"lyte-popover-freeze\").style.opacity = 0;\n                    this.childComp.querySelector(\"lyte-popover-freeze\").style.visibility = \"\";\n                }\n                if(!this.$node.ltProp('freeze')){\n                    this.childComp.querySelector(\".popoverWrapper\").classList.remove('noFreeze');\n                }\n                if(!this.getData('ltPropFreeze') && document.body.classList.contains('lyteStopBodyScrolling')){\n                    document.body.classList.remove('lyteStopBodyScrolling');\n                }\n                if(this.getMethods(\"onClose\")){\n                    this.executeMethod(\"onClose\",event,this);\n                    if(this.childComp){\n                        this.setData('ltPropShowWormhole' , false)\n                    }\n                }\n                // if(this.$node.ltProp('freeze')){\n                //     LytePopup.bodywrapperCount -= 1;\n                //     if(LytePopup.bodywrapperCount == 0 || LytePopup.components.length == 0){\n                //         document.body.classList.remove('bodyWrapper');\n                //     }\n                // }\n                window.LytePopup.checkAndRemoveWrapper();\n                setTimeout(function(){\n                    if(!(self.getData('visible'))){\n                        if($L(self.childComp).find('.lytePopover')[0]){\n                            $L(self.childComp).find('.lytePopover')[0].style.left = \"\"\n                            $L(self.childComp).find('.lytePopover')[0].style.top = \"\"\n                        }\n                        if(self.childComp){\n                            self.childComp.classList.add(\"lytePopoverDispNone\");\n                            self.setData('ltPropShowWormhole' , false)\n                        }\n                    }\n                },20)\n            }\n            else{\n                var animDur = parseInt(this.getData('ltPropDuration'));\n                this.tIdClose = setTimeout(function(){\n                    self.tIdClose = false;\n                    if(self.getData('ltPropAnimation') == \"zoom\"){\n                        // self.actualModalDiv.style.opacity = \"0\";\n                        self.actualModalDiv.classList.remove('lytePopoverVisible');\n                        self.actualModalDiv.style.transform = \"\";\n                    }\n\n                    self.$node.ltProp({\"showCopy\":false,\"show\":false});\n                    self.$node.classList.remove('lytePopoverOpened');\n                    if(self.getMethods(\"onClose\")){\n                        self.executeMethod(\"onClose\",event,self);\n                        if(self.childComp){\n                            self.setData('ltPropShowWormhole' , false)\n                        }\n                    }\n                    // if(self.$node.ltProp('freeze')){\n                    //     LytePopup.bodywrapperCount -= 1;\n                    //     if(LytePopup.bodywrapperCount == 0 || LytePopup.components.length == 0){\n                    //         document.body.classList.remove('bodyWrapper');\n                    //     }\n                    // }\n                    window.LytePopup.checkAndRemoveWrapper();\n                    if(!(self.getData('ltPropBindToBody'))){\n                        self.removeDOMReferences();\n                    }\n                },animDur);\n                this.actualModalDiv.style.transitionDuration = ((animDur == 0 ? 0 : animDur > 300 ? animDur - 200 : 100) / 1000)+\"s\";\n                if(this.getData('ltPropAnimation') == \"zoom\"){\n                    this.actualModalDiv.style.transform = \"scale(0)\";\n                }\n                else{\n                    // this.actualModalDiv.style.opacity = 0;\n                    this.actualModalDiv.classList.remove('lytePopoverVisible');\n                }\n                window.LytePopup.closePopup(this);\n                // LytePopup.bindTransitionEnd(this.actualModalDiv);\n                this.setData('visible',false);\n                // this.actualModalDiv.addEventListener('transitionend', popoverCloseTransitionend)\n                // function popoverCloseTransitionend(){\n                //   self.actualModalDiv.removeEventListener('transitionend' , popoverCloseTransitionend)\n                //   if(!(self.getData('visible'))){\n                //     if($L(self.childComp).find('.lytePopover')[0]){\n                //       $L(self.childComp).find('.lytePopover')[0].style.left = \"\"\n                //       $L(self.childComp).find('.lytePopover')[0].style.top = \"\"\n                //     }\n                //     self.childComp.classList.add(\"lytePopoverDispNone\");\n                //   }\n                // }\n                setTimeout(function(){\n                  if(!(self.getData('visible'))){\n                      if($L(self.childComp).find('.lytePopover')[0]){\n                        $L(self.childComp).find('.lytePopover')[0].style.left = \"\"\n                        $L(self.childComp).find('.lytePopover')[0].style.top = \"\"\n                      }\n                      if(self.childComp){\n                        self.childComp.classList.add(\"lytePopoverDispNone\");\n                        self.setData('ltPropShowWormhole' , false)\n                        if(!self.$node.ltProp('freeze')){\n                            self.childComp.querySelector(\".popoverWrapper\").classList.remove('noFreeze');\n                        }\n                      }\n                    }\n                },(parseInt(self.getData('ltPropDuration'))+20))\n                if(this.$node.ltProp('freeze') && this.childComp.querySelector(\"lyte-popover-freeze\")){\n                    this.childComp.querySelector(\"lyte-popover-freeze\").style.opacity = 0;\n                    this.childComp.querySelector(\"lyte-popover-freeze\").style.visibility = \"\";\n                }\n                if(!this.getData('ltPropFreeze') && document.body.classList.contains('lyteStopBodyScrolling')){\n                    document.body.classList.remove('lyteStopBodyScrolling');\n                }\n            }\n        }\n        else{\n            // if(LytePopup.evt){\n            //     delete LytePopup.evt;\n            // }\n            this.setData('returnedFalse',true);\n            if(!this.getData('visible')){\n                this.setData('visible',true);\n            }\n            this.$node.ltProp('show',true);\n            this.setData('ltPropShowWormhole' , true)\n        }\n    }\n\n    onBeforeShowHandling() {\n        var result = true;\n        if(this.getMethods(\"onBeforeShow\")){\n            result = this.executeMethod(\"onBeforeShow\",this);\n        }\n        if(result === undefined || result){\n            this.childComp.classList.remove(\"lytePopoverDispNone\");\n            this.setData('checkAria', this.getData('checkAria')+1);\n            if(this.getData('ltPropDraggable')){\n                this.addDragHandler();\n            }\n            this.updateScrollHandling();\n            if(!this.$node.ltProp('freeze')){\n                this.childComp.querySelector(\".popoverWrapper\").classList.add('noFreeze');\n            }\n\n            this.$node.ltProp(\"positionNew\",this.$node.ltProp(\"position\"));\n            if(this.getData('ltPropDuration') == undefined){\n                this.$node.ltProp('showCopy',true);\n                this.fastdomfn5 = $L.fastdom.mutate(function(){\n                    delete this.fastdomfn5;\n                    this.fastdomfn6 = $L.fastdom.measure(function(){\n                        delete this.fastdomfn6;\n                        this.fastdomfn7 = $L.fastdom.mutate(function(){\n                            delete this.fastdomfn7;\n                            this.computeOffsetImpl();\n                        },this);\n                    },this);\n                },this);\n            }\n            else{\n                var self = this;\n                this.initCompute = setTimeout(function(){\n                    delete self.initCompute;\n                    /*------------------------------ MUTATE STARTS --------------------------*/\n                    self.$node.ltProp('showCopy',true);\n                    self.fastdomfn5 = $L.fastdom.mutate(function(){\n                        delete self.fastdomfn5;\n                        self.fastdomfn6 = $L.fastdom.measure(function(){\n                            delete self.fastdomfn6;\n                            self.fastdomfn7 = $L.fastdom.mutate(function(){\n                                delete self.fastdomfn7;\n                                self.computeOffsetImpl();\n                            },self);\n                        },self);\n                    },self);\n                    /*------------------------------ MUTATE ENDS --------------------------*/\n                },0);\n            }\n            if(!this.getData(\"first\")){\n                this.setData(\"first\",true);\n            }\n            $L.fastdom.measure(function(){\n                var scrollParent = this.$node.ltProp('originElem') ? window.LytePopup.getScrollParent(document.querySelector(this.$node.ltProp('originElem'))) : null;\n                if(!this.getData('ltPropFreeze') && !(scrollParent && scrollParent.isEqualNode(document.body))){\n                    document.body.classList.add('lyteStopBodyScrolling');\n                }\n            },this);\n            if(!this.getData('visible')){\n                this.setData('visible',true);\n            }\n            window.LytePopup.addPopup(this);\n            if(this.$node.ltProp('freeze')){\n                var freezeStyle = this.childComp.querySelector(\"lyte-popover-freeze\").style;\n                // freezeStyle.transitionDuration = (parseFloat(this.getData('ltPropDuration'))/1000) + \"s\";\n                // freezeStyle.opacity = this.getData('ltPropDimmer').opacity;\n                var dimmerValue = this.getData('ltPropDimmer');\n\n                if(!$L.isEmptyObject(dimmerValue)) {\n                    freezeStyle.background = dimmerValue.color;\n                    if(!this.addedFreezeDetails){\n                        freezeStyle.opacity = dimmerValue.opacity;\n                    }\n                }\n            }\n            this.$node.alignPopover = this.computeOffsetImpl.bind(this);\n            this.$node.calculateOffset = this.updateScrollHandling.bind(this);\n        }\n        else{\n            this.$node.ltProp({\"showCopy\":false,\"show\":false});\n        }\n    }\n\n    didDestroy() {\n       this.setData('ltPropShowWormhole', false);\n       this.$node.classList.remove('lytePopoverOpened');\n       if(this.childComp){\n           this.clearFastdomBatch();\n           if(this.getData('ltPropAutoAlign') && this.$node.mutobserver){\n               this.$node.mutobserver.disconnect();\n               delete this.$node.mutobserver;\n           }\n           if(this.tIdBeforeClose){\n               clearTimeout(this.tIdBeforeClose);\n               this.tIdBeforeClose = false;\n           }\n           if(this.tIdClose){\n               clearTimeout(this.tIdClose);\n               this.tIdClose = false;\n           }\n           if(this.getData('ltPropFreeze') && this.addedFreezeDetails){\n               window.LytePopup.hideOrShowFreeze(\"close\",this);\n               delete this.addedFreezeDetails;\n           }\n           // if(LytePopup.evt){\n           //     delete LytePopup.evt;\n           // }\n           window.LytePopup.closePopup(this)\n           this.childComp.remove();\n           // delete this.childComp;\n           // delete this.actualModalDiv;\n           this.removeDOMReferences();\n           // if(this.$node.ltProp('freeze')){\n           //     LytePopup.bodywrapperCount -= 1;\n           //     if(LytePopup.bodywrapperCount == 0 || LytePopup.components.length == 0){\n           //         document.body.classList.remove('bodyWrapper');\n           //     }\n           // }\n           window.LytePopup.checkAndRemoveWrapper();\n           if(!this.getData('ltPropFreeze') && document.body.classList.contains('lyteStopBodyScrolling')){\n               document.body.classList.remove('lyteStopBodyScrolling');\n           }\n       }\n   }\n\n    static actions() {\n        return {\n            close : function(){\n               this.$node.ltProp(\"show\",false);\n               this.setData('ltPropShowWormhole' , false)\n            }\n        };\n    }\n\n    static methods() {\n        return {\n            beforeWormholeAppend : function(arg){\n                this.childComp = arg;\n\n                //Sets the padding style based on user provide padding values\n                if(this.$node.parentElement && this.$node.parentElement.tagName == 'LYTE-COLORPICKER'){\n                    this.$node.parentElement.component.childComp = this.childComp;\n                }\n                if(this.childComp.querySelector('lyte-popover-header')){\n                    this.childComp.querySelector('lyte-popover-header').style.padding = this.getData('ltPropHeaderPadding');\n                }\n                if(this.childComp.querySelector('lyte-popover-content')){\n                    this.childComp.querySelector('lyte-popover-content').style.padding = this.getData('ltPropContentPadding');\n                }\n                if(this.childComp.querySelector('lyte-popover-footer')){\n                    this.childComp.querySelector('lyte-popover-footer').style.padding = this.getData('ltPropFooterPadding');\n                }\n                this.actualModalDiv = this.childComp.querySelector(\".lytePopover\");\n                if(this.childComp.querySelector('lyte-popover-header') && this.getData('ltPropShowCloseButton')){\n                    var headerHeight=0, closeHeight= 0;\n                    $L.fastdom.measure(function(){\n                        headerHeight = this.childComp.querySelector('lyte-popover-header').offsetHeight /*this.childComp.querySelector('lyte-popover-header').getBoundingClientRect().height*/;\n                        closeHeight = this.childComp.querySelector('.lytePopoverClose').offsetHeight /*this.childComp.querySelector('.lytePopoverClose').getBoundingClientRect().height*/;\n                    },this);\n                    $L.fastdom.mutate(function(){\n                        this.childComp.querySelector('.lytePopoverClose').style.top = (headerHeight - closeHeight) / 2 + \"px\";\n                    },this);\n                }\n            }\n        };\n    }\n\n    static observers() {\n        return {\n            computeSpacing : function(){\n                var windowSpacing = Object.assign({},this.getData('ltPropWindowSpacing'));\n                if(!windowSpacing.left){\n                    windowSpacing.left = 30;\n                }\n                if(!windowSpacing.right){\n                    windowSpacing.right = 30;\n                }\n                if(!windowSpacing.top){\n                    windowSpacing.top = 30;\n                }\n                if(!windowSpacing.bottom){\n                    windowSpacing.bottom = 30;\n                }\n                this.setData('windowSpacing',Object.assign({},windowSpacing));\n\n                var margin = Object.assign({},this.getData('ltPropMargin'));\n                if(!margin.left){\n                    margin.left = 0;\n                }\n                if(!margin.right){\n                    margin.right = 0;\n                }\n                if(!margin.top){\n                    margin.top = 0;\n                }\n                if(!margin.bottom){\n                    margin.bottom = 0;\n                }\n                this.setData('margin',Object.assign({},margin));\n            }.observes('ltPropWindowSpacing', 'ltPropMargin').on('init'),\n\n            showToggled : function(){\n                var event = event || window.event;\n                if(this.getData('returnedFalse')){\n                    this.setData('returnedFalse',false);\n                    return;\n                }\n                if(this.$node.ltProp(\"show\") && !this.$node.ltProp(\"showCopy\")){\n                    if(this.tIdBeforeClose){\n                        clearTimeout(this.tIdBeforeClose);\n                        delete this.tIdBeforeClose;\n                    }\n                    if(this.tIdBeforeShow){\n                        clearTimeout(this.tIdBeforeShow);\n                        delete this.tIdBeforeShow;\n                    }\n                    if(window._lyteUiUtils.getRTL() && this.getData('ltPropPlacement')){\n                        this.setRTLPosition();\n                    }\n                    this.$node.ltProp(\"bindToBody\",true);\n                    if(this.getData('ltPropDuration') == undefined){\n                        this.onBeforeShowHandling(event);\n                    }\n                    else{\n                        var self = this;\n                        this.tIdBeforeShow = setTimeout(function(){\n                            delete self.tIdBeforeShow;\n                            self.onBeforeShowHandling(event);\n                        },0);\n                    }\n                    this.setData('ltPropShowWormhole' , true);\n                    window._lyteUiUtils.dispatchEvent('lytePopoverBeforeOpen' , this.actualModalDiv)\n                }\n                else{\n                    this.setData('ltPropShowWormhole' , false)\n                    this.clearFastdomBatch();\n                    if(this.tIdBeforeShow){\n                        clearTimeout(this.tIdBeforeShow);\n                        delete this.tIdBeforeShow;\n                    }\n                    if(this.tIdBeforeClose){\n                        clearTimeout(this.tIdBeforeClose);\n                        delete this.tIdBeforeClose;\n                    }\n                    if(this.$node.ltProp(\"showCopy\")){\n                        // console.log(LytePopup.evt);\n                        if(this.getData('ltPropDuration') == undefined){\n                            this.onBeforeCloseHandling(/*LytePopup.evt || */event);\n                            if(!(this.getData('ltPropBindToBody'))){\n                                this.removeDOMReferences();\n                            }\n                        }\n                        else{\n                            var self = this;\n                            this.tIdBeforeClose = setTimeout(function(){\n                                delete self.tIdBeforeClose;\n                                self.onBeforeCloseHandling(event);\n                            },0);\n                        }\n                    }\n                    else{\n                        if(!(this.getData('ltPropBindToBody'))){\n                            this.removeDOMReferences();\n                        }\n                    }\n                }\n            }.observes(\"ltPropShow\").on('didConnect'),\n\n            changeShow : function(){\n                if(!this.getData('ltPropBindToBody')){\n                    this.clearFastdomBatch();\n                    if(this.tIdBeforeShow){\n                        clearTimeout(this.tIdBeforeShow);\n                        delete this.tIdBeforeShow;\n                    }\n                    if(this.tIdBeforeClose){\n                        clearTimeout(this.tIdBeforeClose);\n                        delete this.tIdBeforeClose;\n                    }\n                    if(this.getData('ltPropFreeze') && this.addedFreezeDetails){\n                        window.LytePopup.hideOrShowFreeze(\"close\",this,true);\n                        delete this.addedFreezeDetails;\n                    }\n                    if(this.getData('ltPropShow')){\n                        this.setData('ltPropShow',false);\n                    }\n                    else{\n                        this.setData('ltPropShowCopy', false);\n                        window.LytePopup.closePopup(this);\n                        this.setData('visible',false);\n                        this.removeDOMReferences();\n                    }\n                }\n            }.observes(\"ltPropBindToBody\"),\n\n            addAriaValues : function( arg ) {\n                if(this.getData('ltPropAria')){\n                    var ariaProp = this.getData('ltPropAriaAttributes') || {};\n                    window._lyteUiUtils.setAttribute( this.actualModalDiv, ariaProp, arg ? arg.oldValue : {} );\n                    var closeIcon = this.actualModalDiv.querySelector('.lytePopoverClose');\n                    if(closeIcon){\n                        closeIcon.setAttribute('aria-label', ariaProp['close-label'] || 'Close icon at top right position');\n                    }\n                }\n            }.observes('ltPropAriaAttributes','ltPropAriaAttributes.{}','checkAria'),\n\n            scrollHandling : function(){\n                if(!this.getData('ltPropShow')){\n                    return;\n                }\n                this.updateScrollHandling();\n            }.observes(\"ltPropWidth\",\"ltPropMaxWidth\",\"ltPropHeight\",\"ltPropMaxHeight\"),\n\n            computeOffset : function(){\n                if(this.getData('ltPropShow')){\n                  this.computeOffsetImpl();\n                } else {\n                  return\n                }\n            }.observes(\"ltPropOriginElem\"),\n\n            observeClickEvent : function(){\n                window.LytePopup._stopPropagation = this.getData('ltPropStopClick');\n                if(LytePopup._stopPropagation){\n                    LytePopup._sourceComp = this;\n                }\n                else{\n                    if(LytePopup._sourceComp){\n                        delete LytePopup._sourceComp;\n                    }\n                }\n            }.observes('ltPropStopClick')\n        };\n    }\n}\n\n\n\nif (document.readyState === \"complete\" || document.readyState === \"interactive\"){\n    window.addPopoverEvent();\n}\nelse{\n    document.addEventListener(\"DOMContentLoaded\", function(event){\n        window.addPopoverEvent(event);\n    });\n}\n\n;\n\n/**\n * @syntax yielded\n * <lyte-popover>\n *     <template is = \"registerYield\" yield-name = \"popover\">\n *         <lyte-popover-header> Create Profile </lyte-popover-header>\n *         <lyte-popover-content>\n *             //Some Content\n *         </lyte-popover-content>\n *         <lyte-popover-footer class = \"right\">\n *             //Some button\n *         </lyte-popover-footer>\n *     </template>\n * </lyte-popover>\n */\nexport { LytePopoverComponent };\n","import './lyte-hovercard.js';\nimport { prop } from \"@slyte/core\";\nimport { Component } from \"../component.js\";\nimport $L from \"@zoho/lyte-dom\";\n\n/**\n * This component is used to show tooltip when its content exceeds\n * @component lyte-text\n * @version 2.2.0\n */\n\nwindow._lyteUiUtils.measureFont = function( style ){\n\tvar str = [];\n\t\t\n\t[ 'fontStyle', 'fontVariant', 'fontWeight', 'fontSize', 'fontFamily' ].forEach( function( item ){\n\t\tvar __style = style[ item ];\n\t\t__style && str.push( __style );\n\t});\n\n\treturn str.join( ' ' );\n}\n\nwindow._lyteUiUtils.check4ellipsis = function( $node, to_value, force_allow, multiLine ){\n\tvar __width = multiLine ? \"Height\" : \"Width\",\n\toffwidth = $node[ \"offset\" + __width ],\n\tscrollwidth = $node[ \"scroll\" + __width ],\n\ttooltip = scrollwidth > offwidth;\n\n\tif( scrollwidth == offwidth && force_allow && !multiLine ){\n\t\tvar bcr_width = $node.getBoundingClientRect().width;\n\n\t\tif( offwidth - bcr_width <= 0.5 ){\n\t\t\tvar compStyle = window.getComputedStyle( $node ),\n\t\t\tfont = compStyle.font,\n\t\t\tctx = document.createElement( \"canvas\" ).getContext( \"2d\" );\n\n\t\t\tctx.font = font || window._lyteUiUtils.measureFont( compStyle );\n\t\t\tvar measured = ctx.measureText( to_value ).width;\n\n\t\t\tif( measured - bcr_width >= 0.015 ){\n\t\t\t\ttooltip = true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn tooltip;\n}\n\nclass LyteTextComponent extends Component {\n    constructor() {\n        super();\n    }\n\n    data() {\n\t\tvar default_values = window._lyteUiUtils.getDefault( 'lyte-text' );\n\n\t\treturn {\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropValue=''\n\t\t\t * @version 2.2.0\n\t\t\t */\n\t\t\tltPropValue : prop( 'string', { default : '' } ),\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropShow=true\n\t\t\t * @version 2.2.0\n\t\t\t */\n\t\t\tltPropShow : prop( 'boolean', { default : default_values.show ==false ? false : true } ),\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropYield=false\n\t\t\t * @version 2.2.20\n\t\t\t */\n\t\t\tltPropYield : prop( 'boolean', { default : default_values.yield || false } ),\n\t\t\t/**\n\t\t\t * @componentProperty {Boolean} ltPropText\n\t\t\t * @version 3.50.0\n\t\t\t */\n\t\t\tltPropText : prop( 'boolean', { default : default_values.text == false ? false : true } ),\n\t\t\t/**\n\t\t\t * @componentProperty {array} ltPropArray\n\t\t\t * @version 3.50.0\n\t\t\t */\n\t\t\tltPropArray : prop( 'array' ),\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropSuffix=\"\"\n\t\t\t * @version 3.50.0\n\t\t\t */\n\t\t\tltPropSuffix : prop( 'string', { default : default_values.suffix || \"\" } ),\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropHovercard='{}'\n\t\t\t * @component lyte-hovercard\n\t\t\t * @version 3.50.0\n\t\t\t */\n\t\t\tltPropHovercard : prop( 'string', { default : default_values.hovercard || '{}' } ),\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropSeparator=', '\n\t\t\t * @version 3.50.0\n\t\t\t */\n\t\t\tltPropSeparator : prop( 'string', { default : default_values.separator || \", \" } ),\n\t\t\t/**\n\t\t\t * @componentProperty {number} ltPropWidth=0\n\t\t\t * @version 3.50.0\n\t\t\t */\n\t\t\tltPropWidth : prop( 'number', { default : default_values.width || 0 } ),\n\t\t\t/**\n\t\t\t * @componentProperty {number} ltPropMinCount=0\n\t\t\t * @version 3.50.2\n\t\t\t */\n\t\t\tltPropMinCount : prop( 'number', { default : default_values.minCount || 0 } ),\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropTooltipConfig='{}'\n\t\t\t * @component lyte-tooltip ltPropTooltipConfig\n\t\t\t * @version 3.52.0\n\t\t\t */\n\t\t\tltPropTooltipConfig : prop( \"string\", { default : default_values.tooltipConfig || '{}' } ),\n\n\t\t\tltPropRerender : prop( 'boolean', { default : false } ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropTail\n\t\t\t * @version 3.98.0\n\t\t\t */\n\t\t\t\n\t\t\tltPropTail : prop( \"string\", { default : default_values.tail || \"\" } ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropFillAvailable=false\n\t\t\t * @version 3.98.0\n\t\t\t */\n\t\t\tltPropFillAvailable : prop( 'boolean', { default : default_values.fillAvailable || false } ),\n\n\t\t\t/**\n\t\t\t * @componentPropery {boolean} ltPropShowHovercardOnClick=false\n\t\t\t * @version 3.98.0\n\t\t\t */\n\n\t\t\tltPropShowHovercardOnClick : prop( 'boolean', { default : default_values.showHovercardOnClick || false } ),\n\n\t\t\t/**\n\t\t\t * @componentPropery {string} ltPropHovercardKey=\"Space\"\n\t\t\t * @version 3.98.0\n\t\t\t */\n\n\t\t\tltPropHovercardKey : prop( 'string', { default : default_values.hovercardKey || \" \" } ),\n\t\t\t\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropTag=false\n\t\t\t * @version 3.103.0\n\t\t\t */\n\t\t\tltPropTag : prop( 'boolean', { default : default_values.hoverCardArray || false } ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {number} ltPropAdditionalSpace=0\n\t\t\t * @version 3.103.0\n\t\t\t */\n\t\t\tltPropAdditionalSpace : prop( 'number', { default : 0 } ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropTabindex=\"-1\"\n\t\t\t * @version 3.103.0\n\t\t\t */\n\t\t\tltPropTabindex : prop( 'string', { default : \"-1\" } ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropMultiLine=false\n\t\t\t * @version 3.105.0\n\t\t\t */\n\t\t\tltPropMultiLine : prop( 'boolean', { default : default_values.multiLine || false } ),\n\n\t\t\trenderHover : prop( 'boolean', { default : false } ),\n\t\t\tlyteUnbound : prop( 'boolean', { default : false } ),\n\t\t\thoverCardArray : prop( 'array', { default : [] } ),\n\t\t\trender : prop( 'boolean' ),\n\t\t\tshow : prop( 'boolean', { default : false } ),\n\t\t\toriginElem : prop( 'string', { default : \"\" } ),\n\t\t\tsuffix : prop( 'string', { default : \"\" } ),\n\t\t\t\n\t\t\tdummyText : prop( 'string', { default : \"\" } ),\n\t\t\ttailText : prop( 'string', { default : \"\" } ),\n\t\t\trenderArray : prop( 'array', { default : [] } )\n\t\t};\t\t\n\t}\n\n    init() {\n\t\tvar __data = this.data,\n\t\tarr = __data.ltPropArray;\n\n\t\tif( arr ){\n\t\t\tvar $node = this.$node,\n\t\t\thovercard = JSON.parse( __data.ltPropHovercard );\n\n\t\t\t__data.ltPropText = !arr;\n\n\t\t\t__data.originElem = hovercard.originElem || ( function(){\n\t\t\t\tvar id = $node.id;\n\t\t\t\tif( !id ){\n\t\t\t\t\tid = $node.id = 'lyteText_' + parseInt( Math.random() * 10000 );\n\t\t\t\t}\n\t\t\t\treturn \"#\" + id + ' .lyteTextSuffix>span';\n\t\t\t})();\n\t\t}\n\t}\n\n    didDestroy() {\n\t\t$L.fastdom.clear( this.prev_fast );\n\t}\n\n    render_array() {\n\t\tvar __this = this,\n\t\t__data = __this.data,\n\t\tarray = __data.ltPropArray,\n\t\tsuffix = __data.ltPropSuffix,\n\t\tfastdom = $L.fastdom,\n\t\t__length = array.length,\n\t\tarr = [],\n\t\tseparator = __data.ltPropSeparator,\n\t\tfns = 'prev_fast';\n\n\t\t__this.setData( 'render', true );\n\t\t\n\t\tfastdom.clear( __this[ fns ] );\n\n\t\t__this[ fns ] = fastdom.measure( function(){\n\n\t\t\tdelete __this[ fns ];\n\n\t\t\tvar $node = __this.$node,\n\t\t\telem = $node.getElementsByClassName( 'lyteTextRenderDiv' )[ 0 ];\n\n\t\t\tif( !elem ){\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar __child = elem.children,\n\t\t\tns = 'getBoundingClientRect',\n\t\t\t__width = 'width',\n\t\t\tis_tag = __data.ltPropTag,\n\t\t\tadditional_space = __data.ltPropAdditionalSpace,\n\t\t\tsuffix_width = elem.nextElementSibling.children[ 0 ][ ns ]()[ __width ],\n\t\t\tact_width = __data.ltPropWidth || $node.offsetWidth,\n\t\t\tsum = 0,\n\t\t\tbreak_point,\n\t\t\ti = 0;\n\n\t\t\tfor( ; i < __length; i++ ){\n\t\t\t\tvar __div = __child[ i ],\n\t\t\t\tspans = __div.children,\n\t\t\t\tspan_elem = spans[ 0 ],\n\t\t\t\tspan_wid = span_elem[ ns ]()[ __width ],\n\t\t\t\tcomma_wid;\n\n\t\t\t\tif( is_tag ){\n\t\t\t\t\tvar __style = getComputedStyle( span_elem );\n\t\t\t\t\tspan_wid += ( parseFloat( __style.marginInlineStart ) + parseFloat( __style.marginInlineEnd ) );\n\t\t\t\t\tcomma_wid = 0;\n\t\t\t\t\tif( i + 1 != __length ){\n\t\t\t\t\t\tspan_wid += additional_space;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcomma_wid = spans[ 1 ][ ns ]()[ __width ];\n\t\t\t\t}\n\n\t\t\t\tarr.push({\n\t\t\t\t\twidth : span_wid,\n\t\t\t\t\tcomma : comma_wid\n\t\t\t\t});\n\n\t\t\t\tsum += ( span_wid + comma_wid );\n\n\t\t\t\tif( sum > act_width ){\n\t\t\t\t\tbreak_point = true;\n\t\t\t\t\tact_width -= suffix_width;\n\t\t\t\t\twhile( sum > act_width ){\n\t\t\t\t\t\tvar __last = arr.pop();\n\t\t\t\t\t\tif( __last ){\n\t\t\t\t\t\t\tsum -= ( __last.width + __last.comma - additional_space );\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfastdom.mutate( function(){\n\t\t\t\tvar str = '',\n\t\t\t\th_arr = [],\n\t\t\t\tsuffixText = \"\",\n\t\t\t\tto_render = [];\n\n\t\t\t\tif( break_point ){\n\n\t\t\t\t\tvar fn = \"remove\";\n\n\t\t\t\t\tif( __data.ltPropFillAvailable && !is_tag ){\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tfn = \"add\";\n\t\t\t\t\t} else if( i == -1 ){\n\t\t\t\t\t\ti = /*Math.max(  */Math.min( __length, __data.ltPropMinCount ) - 1/*, 0 )*/;\n\t\t\t\t\t\tfn = \"add\";\n\t\t\t\t\t}\n\n\t\t\t\t\t$L( $node )[ fn + 'Class' ]( 'lyteTextNoSpace' );\n\n\t\t\t\t\tfor( var k = 0; k < __length; k++ ){\n\t\t\t\t\t\tvar __cur = array[ k ];\n\t\t\t\t\t\tif( k <= i ){\n\t\t\t\t\t\t\tif( is_tag ){\n\t\t\t\t\t\t\t\tto_render.push( __cur );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstr += ( ( k ? separator : \"\" ) + __cur );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\th_arr.push( __cur );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif( i + 1 != __length ){\n\t\t\t\t\t\tsuffixText = ( suffix.replace( '{0}', ( __length - ++i ) ) );\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tis_tag ? to_render = array : void 0;\n\t\t\t\t\tstr = array.join( separator );\n\t\t\t\t}\n\n\t\t\t\t__this.setData({\n\t\t\t\t\tltPropValue : str,\n\t\t\t\t\tsuffix : suffixText,\n\t\t\t\t\trender : false,\n\t\t\t\t\thoverCardArray : h_arr,\n\t\t\t\t\trenderHover : break_point && __data.ltPropShow,\n\t\t\t\t\trenderArray : to_render\n\t\t\t\t});\n\n\t\t\t});\n\t\t});\n\t}\n\n\treset(__node, __value, frm_mid) {\n\t\tvar $node = __node || this.$node,\n\t\tdata = this.data;\n\n\t\tif( data.ltPropText || __node ){\n\t\t\tvar value_to = \"\",\n\t\t\ttooltip = window._lyteUiUtils.check4ellipsis( $node,  __value || data.ltPropValue, !data.ltPropYield, data.ltPropMultiLine );\n\n\t\t\tif( tooltip && data.ltPropShow ){\n\t\t\t\tvalue_to = __value || data.ltPropValue;\n\t\t\t}\n\t\t\t$node.setAttribute( 'lt-prop-title', frm_mid ? ( tooltip && data.ltPropShow ? data.ltPropValue : \"\" ) : value_to );\n\t\t} \n\t}\n\n    over(evt) {\n\t\tvar __data = this.data,\n\t\tis_click = __data.ltPropShowHovercardOnClick;\n\n\t\tswitch( evt.type ){\n\t\t\tcase \"click\" : {\n\t\t\t\tif( !is_click ){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak; \n\t\t\tcase \"keydown\" : {\n\t\t\t\tvar allow = true;\n\t\t\t\tif( is_click ){\n\t\t\t\t\tvar keys = ( __data.ltPropHovercardKey || \"\" ).split( /\\,|\\|/g );\n\t\t\t\t\tif( keys.indexOf( evt.key ) + 1 ){\n\t\t\t\t\t\tevt.preventDefault();\t\n\t\t\t\t\t\tallow = false;\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\tif( allow ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault : {\n\t\t\t\tif( is_click ){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif( !evt.target.closest( '.lyteTextSuffix' ) ){\n\t\t\treturn;\n\t\t}\n\n\t\tis_click ? window.requestAnimationFrame( function(){\n\t\t\tthis.setData( 'show', __data.ltPropShow );\n\t\t}.bind( this ) ) : this.setData( 'show', __data.ltPropShow );\n\t}\n\n    static actions() {\n        return {\n\t\t\tfocusout : function(){\n\t\t\t\tvar __data = this.data;\n\n\t\t\t\tif( __data.ltPropShowHovercardOnClick && __data.show ){\n\t\t\t\t\tthis.setData( \"show\", false );\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tmouse : function(){\n\t\t\t\tif( this.data.ltPropTail ){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.reset();\n\t\t\t},\n\n\t\t\tover : function( evt ){\n\t\t\t\tthis.data.ltPropArray && this.over( evt );\n\t\t\t},\n\n\t\t\tsubmouse : function( __this ){\n\t\t\t\tif( $L( this.$node ).hasClass( 'lyteTextNoSpace' ) /*&& data.ltPropMinCount*/ ){\n\t\t\t\t\tthis.reset( __this, this.data.ltPropValue );\n\t\t\t\t}\n\t\t\t},\n\n\t\t\ttailmouse : function( __this ){\n\t\t\t\tthis.reset( __this, this.data.dummyText, true );\n\t\t\t}\n        };\n    }\n\n    static methods() {\n        return {\n\t\t\tbeforeHide : function( __node, evt ){\n\t\t\t\tif( this.data.ltPropShowHovercardOnClick && ( evt || {} ).type == \"mouseleave\" ){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n        };\n\t}\n\n\tstatic observers() {\n        return {\n\t\t\tvalue_obs : function( arg ){\n\t\t\t\tvar text = this.data.ltPropValue,\n\t\t\t\ttail = this.data.ltPropTail;\n\t\t\n\t\t\t\tif( tail ){\n\t\t\t\t\tvar regx = new RegExp( tail ),\n\t\t\t\t\tmatch = text.match( regx )[ 0 ] || \"\";\n\t\t\n\t\t\t\t\tthis.setData({\n\t\t\t\t\t\tdummyText : text.slice( 0, -match.length ),\n\t\t\t\t\t\ttailText : match\n\t\t\t\t\t});\n\t\t\n\t\t\t\t\tif( !arg ){\n\t\t\t\t\t\tthis.$node.classList.add( \"lyteTextNoSpace\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\n\t\t\t}.observes( 'ltPropValue' ).on( 'init' ),\n\n\t\t\trerender_obs : function( arg ){\n\t\t\t\tif( arg.newValue && this.data.ltPropArray ){\n\t\t\t\t\tthis.render_array();\n\t\t\t\t\tthis.setData( arg.item, !1 );\n\t\t\t\t}\n\t\t\t}.observes( 'ltPropRerender' ),\n\t\t\n\t\t\tdidCnt : function( arg ){\n\t\t\t\tif( this.data.ltPropArray ){\n\t\t\t\t\tthis.render_array();\n\t\t\t\t} else if( !arg && this.data.ltPropMultiLine ){\n\t\t\t\t\tvar $node = this.$node,\n\t\t\t\t\t__attr = 'lt-prop-tooltip-style',\n\t\t\t\t\t__style = $node.getAttribute( __attr );\n\t\t\n\t\t\t\t\t$node.classList.add( \"lyteTextWithMultipleLineContent\" );\n\t\t\t\t\t!__style && ( __style = \"width:50%;\" ) && $node.setAttribute( __attr, __style );\n\t\t\t\t}\n\t\t\t}.observes( 'ltPropSuffix', 'ltPropArray', 'ltPropArray.[]', 'ltPropWidth' ).on( 'didConnect' )\n\t\t};\n\t}\n}\n\nwindow.addEventListener( \"resize\", function(){\n\tclearTimeout( window.__lyteTextTimeout );\n\twindow.__lyteTextTimeout = setTimeout( function(){\n\t\twindow.__lyteTextTimeout = void 0;\n\n\t\tvar elems = document.getElementsByTagName( \"lyte-text\" ),\n\t\tlen = elems.length;\n\n\t\tfor( var i = 0; i < len; i++ ){\n\t\t\tvar cur = elems[ i ];\n\n\t\t\tif( cur.ltProp( 'array' ) ){\n\t\t\t\tcur.component.render_array();\n\t\t\t}\n\t\t}\n\n\t}, 100 );\n}, true );\n\n/**\n * Now ellipsis tooltip can be extended for non lyte-text elements also. Elements having the mentioned class will be considered as ellipsis element\n */\n\ndocument.addEventListener( \"mouseover\", function( evt ){\n\tvar cls_name = 'lyteTextEllipsisNode',\n\ttarget = evt.target;\n\t\n\tif( $L( target ).hasClass( cls_name ) ){\n\t\tvar __attr = \"lt-prop-title\",\n\t\tto_value = target.getAttribute( \"data-lyte-text-tooltip\" ) || target.textContent.trim();\n\n\t\tif( window._lyteUiUtils.check4ellipsis( target, to_value, true, false ) ){\n\t\t\ttarget.setAttribute( __attr, to_value );\n\t\t} else {\n\t\t\ttarget.removeAttribute( __attr );\n\t\t}\n\t}\n}, true );\n\n/**\n* @syntax nonYielded\n* <lyte-text lt-prop-value = \"some long text having higher width\"></lyte-text>\n*/\n\n/**\n*  @syntax staticBuilder\n*  <lyte-text lt-prop-value = \"Some long text to be displayed\"></lyte-text>\n*/\n\n/**\n* @syntax yielded\n* <lyte-text lt-prop-yield = true lt-prop-value = \"some long text having higher width\">\n* \t <template is = \"registerYield\" yield-name = \"lyte-text\">\n*\t\tyour value\n*\t </template>\n* </lyte-text>\n*/\n\n/**\n* @syntax Array of text\n*\t<lyte-text lt-prop-array = '[ \"Text1\", \"Text2\", \"Text3\" ]'></lyte-text>\n*/\nexport { LyteTextComponent };"],"names":[],"sourceRoot":""}