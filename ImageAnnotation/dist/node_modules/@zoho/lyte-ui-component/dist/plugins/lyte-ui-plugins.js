(function (factory) {
	if (typeof define === "function" && define.amd) {
		define(["@zoho/lyte-dom"], factory);
	}
	else {
		factory($L);
	}
})(
	function ($L) {
		$L.snippets = {
			getBuilder: function (language, str) {
				return new builder(language, str);
			}
		};

		var builder = function (language, str) {
			this.tokenizer = $L.snippets.getTokenizer(language, str);
		}

		var space = {
			"value": " ",
			"tokenInfo": {
				"token": "whitespace"
			}
		};

		/**
		 * The tab spaces are added based on the number of nested blocks
		 * Used for CSS, HTML, JSON, XML, JS
		 * @param {int} nestedLoop the number of loops
		 * @returns the whitespace string after adding required number of tab spaces
		*/
		function addTabSpaces(nestedLoop) {
			var tabSpaces = "";
			for (let i = 0; i < nestedLoop; i++) {
				tabSpaces = tabSpaces + '\t';
			}
			tabSpaces = "\n" + tabSpaces
			return tabSpaces
		}

		/**
		 * Used to find the end of the corresponding Switch block of java and javascript
		 * @param {object} tokens The tokens array
		 * @param {int} startIndex The index where the corresponding block starts
		 * @returns the end index of switch block
		 */
		function identifySwitchEnd(tokens, startIndex) {
			var nestedBlocks = 0;
			for (var i = startIndex; i < tokens.length; i++) {
				var token = tokens[i];
				var value = token.value;

				if (value === '{') {
					nestedBlocks++;
				}
				else if (value === '}') {
					if (nestedBlocks === 1) {
						return i;
					}
					nestedBlocks--;
				}
			}
			return 0
		}

		/**
		 * used to identify each case blocks of a switch statements of Java and Javascript
		 * @param {object} tokens
		 * @param {int} index
		 * @returns the end index of the corresponding case block
		 */
		function identifyCaseBlocks(tokens, index) {
			for (let i = index; i < tokens.length; i++) {
				var token = tokens[i];
				var tokenValue = token.value;

				if (tokenValue === 'case' || tokenValue === 'default') {
					var endIndex = i - 1;
					return endIndex;
				}
			}
			return tokens.length - 1;
		}

		// CSS
		/**
		 * Add spaces, tab spaces and new line to indent the code
		 * @param {object} tokens
		 * @returns the indented tokens array
		 */
		function indentCss(tokens) {
			var nestedLoop = 0;
			for (var i = 0; i < tokens.length; i++) {
				var token = tokens[i];
				var tokenInfo = token.tokenInfo;
				var tokenType = tokenInfo.token;
				var tokenValue = token.value;
				let nextTokenType, nextTokenValue

				if (i + 1 < tokens.length) {
					nextTokenValue = tokens[i + 1].value;
					nextTokenType = tokens[i + 1].tokenInfo.token;
				}

				if (tokenType === 'punctuation') {
					// To add tab spaces rightly
					if (tokenValue === '{') {
						nestedLoop++;
					}
					else if (tokenValue === '}') {
						nestedLoop--;
					}
					if (tokenValue === '}') {
						if (nextTokenType && nextTokenType === "selector") {
							var indentedValue = addTabSpaces(nestedLoop);
							var temp = {
								"value": indentedValue,
								"tokenInfo": {
									"token": "whitespace"
								}
							}
							tokens.splice(i + 1, 0, temp);
							i++;
						}
						else if (i !== tokens.length - 1) {
							var indentedValue = addTabSpaces(nestedLoop - 1);
							var temp = {
								"value": indentedValue,
								"tokenInfo": {
									"token": "whitespace"
								}
							}
							tokens.splice(i + 1, 0, temp);
							i++;
						}
					}
					else if (tokenValue === '{') {
						var indentedValue = addTabSpaces(nestedLoop);
						var temp = {
							"value": indentedValue,
							"tokenInfo": {
								"token": "whitespace"
							}
						}
						tokens.splice(i + 1, 0, temp);
						i++;
					}

					else if (tokenValue === ';') {
						if (nextTokenValue === '}') {
							var indentedValue = addTabSpaces(nestedLoop - 1);
							var temp = {
								"value": indentedValue,
								"tokenInfo": {
									"token": "whitespace"
								}
							}
							tokens.splice(i + 1, 0, temp);
							i++;
						}
						else {
							var indentedValue = addTabSpaces(nestedLoop);
							var temp = {
								"value": indentedValue,
								"tokenInfo": {
									"token": "whitespace"
								}
							}
							tokens.splice(i + 1, 0, temp);
							i++;
						}
					}

					else if (tokenValue === ':') {
						tokens.splice(i + 1, 0, space);
						i++;
					}
					else if (tokenValue === '=') {
						tokens.splice(i, 0, space);
						tokens.splice(i + 2, 0, space);
						i = i + 2;
					}
				}

				else if (tokenType === 'whitespace') {
					if (!(/^[\s\t\n]*$/.test(tokenValue))) {
						tokens.splice(i + 1, 0, space);
					}
				}

				else if (tokenType === 'selector') {
					tokens.splice(i + 1, 0, space);
					tokenValue = tokenValue.replace(/,/g, ", ");
					token.value = tokenValue;
					tokens[i] = token;
				}

				else if (tokenType === 'rule-value') {
					if (!(tokens[i + 1].value.startsWith(';'))) {
						tokens.splice(i + 1, 0, space);
					}
				}

				else if (tokenType === 'rule-name') {
					if (!(tokens[i - 1].value.includes('\n')) && (tokens[i - 1].tokenInfo.token !== 'whitespace')) {
						var indentedValue = addTabSpaces(tokenValue, nestedLoop);
						var temp = {
							"value": indentedValue,
							"tokenInfo": {
								"token": "whitespace"
							}
						}
						tokens.splice(i, 0, temp);
						i++;
					}
				}
				else if (tokenType === 'comment') {
					if (nextTokenType && nextTokenType !== 'whitespace' && !nextTokenValue.includes('\n')) {
						tokens.splice(i + 1, 0, {
							"value": "\n",
							"tokenInfo": {
								"token": "whitespace"
							}
						});
					}
				}
				else if (tokenType === "media-words") {
					if (nextTokenType && nextTokenType !== 'whitespace' && !nextTokenValue.includes('\n')) {
						tokens.splice(i + 1, 0, {
							"value": " ",
							"tokenInfo": {
								"token": "whitespace"
							}
						});
					}
				}
			}
			return tokens;
		}

		/**
		 * Manages the indentation of CSS code
		 * remove the whitespaces and clean the code
		 * @param {object} tokens
		 * @returns the indented array
		 */
		function handleCSS(tokens) {
			for (var i = 0; i < tokens.length; i++) {
				var token = tokens[i];
				var tokenInfo = token.tokenInfo;
				var tokenType = tokenInfo.token;
				var tokenValue = token.value;

				if (tokenType === 'whitespace') {
					if (/^[\s\t\n]*$/.test(tokenValue)) {
						tokens.splice(i, 1);
						i--;  // Decrement the index to account for the removed token
					}
					else {
						var replacedStr = tokenValue.replace(/[^\S\n\t]+/g, '').trim();
						var whitespace = { value: replacedStr, tokenInfo: { token: 'whitespace' } };
						tokens[i] = whitespace;
					}
				}

				else if (tokenType === 'selector' || tokenType === 'rule-name' || tokenType === 'rule-value') {
					tokenValue = tokenValue.trim();
					token.value = tokenValue;
					tokens[i] = token;
				}
			}
			tokens = indentCss(tokens);
			return tokens;
		}

		// JSON
		/**
		 * Find the json object blocks and indent them rightly
		 * @param {object} tokens
		 * @returns the tokens array
		*/
		function handleObject(tokens) {
			for (var i = 0; i < tokens.length; i++) {
				var token = tokens[i];
				var tokenInfo = token.tokenInfo;
				var tokenType = tokenInfo.token;

				if (tokenType === 'whitespace') {
					tokens.splice(i, 1);
					i--;  // Decrement the index to account for the removed token
				}
			}

			var nestedLoops = 0;
			for (var i = 0; i < tokens.length; i++) {
				var token = tokens[i];
				var tokenInfo = token.tokenInfo;
				var tokenType = tokenInfo.token;
				var tokenValue = token.value;

				//JSON
				if (tokenType === 'punctuation' || tokenType === 'punctuator') {
					if (tokenValue === '{') {
						nestedLoops++;
						if (tokens[i + 1].value !== "}") {
							var spaces = addTabSpaces(nestedLoops)
							var spaceToken = {
								"value": spaces,
								"tokenInfo": {
									"token": "whitespace"
								}
							};
							tokens.splice(i + 1, 0, spaceToken);
						}
					}

					else if (tokenValue === '}') {
						nestedLoops--;
						let prevToken = tokens[i - 1];
						let prevTokenValue = prevToken.value;
						let prevTokenType = prevToken.tokenInfo.token;
						if (prevTokenType !== 'whitespace' && prevTokenValue !== "{") {
							var spaces = addTabSpaces(nestedLoops)
							var spaceToken = {
								"value": spaces,
								"tokenInfo": {
									"token": "whitespace"
								}
							};
							tokens.splice(i, 0, spaceToken);
							i++;
						}
					}

					else if (tokenValue === ',') {
						var spaces = addTabSpaces(nestedLoops)
						var spaceToken = {
							"value": spaces,
							"tokenInfo": {
								"token": "whitespace"
							}
						};
						tokens.splice(i + 1, 0, spaceToken);
						i++;
					}

					else if (tokenValue === ':') {
						if (tokens[i + 1].tokenInfo.token !== 'whitespace') {
							tokens.splice(i + 1, 0, space);
							i++;
						}
					}
				}
			};
			return tokens;
		}

		// JS
		/**
		 * Manages the spacing of parenthesis, ie, the conditions of if, else if and while blocks
		 * @param {integer} startIndex
		 * @param {object(Array)} tokens
		 * @returns the updated tokens
		 */
		function handleCondBlock(startIndex, tokens) {
			var loop = 0;
			for (let i = startIndex; i < tokens.length; i++) {
				const token = tokens[i];
				var tokenValue = token.value;
				var tokenType = token.tokenInfo.token;
				let nextToken, nextTokenType;
				let prevToken, prevTokenType, prevTokenValue;

				if (i + 1 < tokens.length) {
					nextToken = tokens[i + 1];
					nextTokenType = nextToken.tokenInfo.token;
				}
				if (i > 0) {
					prevToken = tokens[i - 1];
					prevTokenType = prevToken.tokenInfo.token;
					prevTokenValue = prevToken.value;
				}

				if (tokenType === "punctuator") {
					if (tokenValue === "(") {
						if (nextTokenType !== "punctuator" && nextTokenType !== "whitespace") {
							tokens.splice(i + 1, 0, {
								"value": " ",
								"tokenInfo": {
									"token": "whitespace"
								}
							});
							i++;
						}
						loop++;
					}
					else if (tokenValue === ")") {
						loop--;
						if (prevTokenType !== "punctuator" && prevTokenType !== "whitespace") {
							tokens.splice(i, 0, {
								"value": " ",
								"tokenInfo": {
									"token": "whitespace"
								}
							});
							i++;
						}
						if (loop === 0) {
							return ({ endIndex: i, tokens });
						}
					}
					else if (tokenValue === ";") {
						if (nextToken) {
							if (nextTokenType !== "whitespace") {
								tokens.splice(i + 1, 0, {
									"value": " ",
									"tokenInfo": {
										"token": "whitespace"
									}
								});
							}
						}
						else {
							tokens.splice(i + 1, 0, {
								"value": " ",
								"tokenInfo": {
									"token": "whitespace"
								}
							});
						}

						if (prevTokenValue === "(") {
							tokens.splice(i, 0, {
								"value": " ",
								"tokenInfo": {
									"token": "whitespace"
								}
							});
						}
					}
				}
				else if (tokenType === "keyword" && nextTokenType !== "operator" && nextTokenType !== "punctuator") {
					tokens.splice(i + 1, 0, {
						"value": " ",
						"tokenInfo": {
							"token": "whitespace"
						}
					});
					i++;
				}

				else if (tokenType === "operator" && tokenValue !== ".") {
					if (prevTokenType !== "whitespace") {
						if (!(tokenValue === "++" || tokenValue === "--" || tokenValue === "**")) {

							tokens.splice(i, 0, {
								"value": " ",
								"tokenInfo": {
									"token": "whitespace"
								}
							});
							i++;
						}
					}
					if (tokenValue !== "!" && nextTokenType !== "whitespace") {
						tokens.splice(i + 1, 0, {
							"value": " ",
							"tokenInfo": {
								"token": "whitespace"
							}
						});
						i++;
					}
				}

			}
			return ({ endIndex: 0, tokens });
		}

		/**
		 * New line characters and tab spaces are added based on the number of blocks
		 * @param {object} tokens
		 * @returns the tokens with added new line, tab spaces and spaces as whitespace token
		 */
		function indentJs(tokens) {
			var nestedLoops = 0;
			for (var i = 0; i < tokens.length; i++) {
				var token = tokens[i];
				var tokenInfo = token.tokenInfo;
				var tokenType = tokenInfo.token;
				var tokenValue = token.value;
				let nextToken, nextTokenValue, nextTokenType, prevToken, prevTokenValue, prevTokenType;

				if (i + 1 < tokens.length) {
					nextToken = tokens[i + 1];
					nextTokenValue = nextToken.value;
					nextTokenType = nextToken.tokenInfo.token;
				}
				if (i - 1 >= 0) {
					prevToken = tokens[i - 1];
					prevTokenValue = prevToken.value;
					prevTokenType = prevToken.tokenInfo.token;
				}

				if (tokenType === "punctuator") {
					if (tokenValue === "{") {
						nestedLoops++;
					}
					else if (tokenValue === "}") {
						nestedLoops--;

					}
					if (tokenValue === ';') {
						if (i !== tokens.length - 1) {
							if (nextToken && nextTokenValue === "}" && nextTokenType !== "whitespace") {
								var tab_spaces = addTabSpaces(nestedLoops - 1)
								tokens.splice(i + 1, 0, {
									"value": tab_spaces,
									"tokenInfo": {
										"token": "whitespace"
									}
								});
								i++;
							}
							else if (nextToken && nextTokenType !== "whitespace") {
								var tab_spaces = addTabSpaces(nestedLoops)
								tokens.splice(i + 1, 0, {
									"value": tab_spaces,
									"tokenInfo": {
										"token": "whitespace"
									}
								});
								i++;
							}
						}
					}
					else if (tokenValue === '{') {
						if (nextToken && nextTokenValue !== "}" && nextTokenType !== "whitespace") {
							var tab_spaces = addTabSpaces(nestedLoops)
							tokens.splice(i + 1, 0, {
								"value": tab_spaces,
								"tokenInfo": {
									"token": "whitespace"
								}
							});
							i++;
						}
					}
					else if (tokenValue === '}') {
						if (prevTokenValue !== "{") {
							if (prevToken && prevTokenType !== "whitespace") {
								var tab_spaces = addTabSpaces(nestedLoops)
								tokens.splice(i, 0, {
									"value": tab_spaces,
									"tokenInfo": {
										"token": "whitespace"
									}
								});
								i++;
							}
							if (i - 1 >= 0) {
								prevToken = tokens[i - 1];
								prevTokenValue = prevToken.value;
								prevTokenType = prevToken.tokenInfo.token;
							}
							if (i + 1 < tokens.length) {
								nextToken = tokens[i + 1];
								nextTokenValue = nextToken.value;
								nextTokenType = nextToken.tokenInfo.token;
							}
							if (nextToken && nextTokenValue !== ")" && nextTokenValue !== "," && nextTokenValue !== "." && nextTokenValue !== ";" && nextTokenValue !== "]" && i !== tokens.length - 1) {
								if (prevToken && (prevTokenType !== "whitespace") && prevTokenValue !== "{") {
									var tab_spaces = addTabSpaces(nestedLoops)
									tokens.splice(i, 0, {
										"value": tab_spaces,
										"tokenInfo": {
											"token": "whitespace"
										}
									});
									i++;
								}

								if (nextToken && (nextTokenType === "function-call" || nextTokenType === "comment" || nextTokenType === "Indentifier" || nextTokenType === "keyword")) {
									var tab_spaces = addTabSpaces(nestedLoops)
									tokens.splice(i + 1, 0, {
										"value": tab_spaces,
										"tokenInfo": {
											"token": "whitespace"
										}
									});
									i++;
								}
								else if (nextToken && nextTokenType !== "whitespace") {
									var tab_spaces = addTabSpaces(nestedLoops - 1)
									tokens.splice(i + 1, 0, {
										"value": tab_spaces,
										"tokenInfo": {
											"token": "whitespace"
										}
									});
									i++;
								}
							}
							else if (nextToken && nextTokenValue === ")") {
								if (i + 2 < tokens.length && (tokens[i + 2].value === "," || tokens[i + 2].value === ";") && i + 2 !== tokens.length - 1) {
									if (i + 3 < tokens.length && tokens[i + 3].value !== "}" && tokens[i + 3].tokenInfo.token !== "whitespace") {
										var tab_spaces = addTabSpaces(nestedLoops)
										tokens.splice(i + 3, 0, {
											"value": tab_spaces,
											"tokenInfo": {
												"token": "whitespace"
											}
										});
										i = i + 2;
									}
								}
							}
							else if (nextToken && nextTokenValue === "," && i + 1 !== tokens.length - 1) {
								if (i + 2 < tokens.length && tokens[i + 2].value === "}") {
									var tab_spaces = addTabSpaces(nestedLoops - 1)
									tokens.splice(i + 2, 0, {
										"value": tab_spaces,
										"tokenInfo": {
											"token": "whitespace"
										}
									});
									i++;
								}
								else if (i + 2 < tokens.length && tokens[i + 2].tokenInfo.token !== "whitespace") {
									var tab_spaces = addTabSpaces(nestedLoops)
									tokens.splice(i + 2, 0, {
										"value": tab_spaces,
										"tokenInfo": {
											"token": "whitespace"
										}
									});
									i++;
								}
								else if (i + 2 < tokens.length) {
									var tab_spaces = addTabSpaces(nestedLoops)
									tokens.splice(i + 2, 0, {
										"value": tab_spaces,
										"tokenInfo": {
											"token": "whitespace"
										}
									});
									i++;
								}
							}
						}
						else if (nextToken && nextTokenValue === "," && i + 1 !== tokens.length - 1) {
							if (i + 2 < tokens.length && tokens[i + 2].tokenInfo.token !== "whitespace") {
								var tab_spaces = addTabSpaces(nestedLoops)
								tokens.splice(i + 2, 0, {
									"value": tab_spaces,
									"tokenInfo": {
										"token": "whitespace"
									}
								});
								i++;
							}
						}
					}
					else if (tokenValue === ",") {
						if (nextTokenType !== "whitespace") {
							tokens.splice(i + 1, 0, {
								"value": " ",
								"tokenInfo": {
									"token": "whitespace"
								}
							});
							i++;
						}
					}
					else if (tokenValue === "(" && nextTokenValue !== "{" && nextTokenValue !== "[" && nextTokenValue !== ")") {
						tokens.splice(i + 1, 0, {
							"value": " ",
							"tokenInfo": {
								"token": "whitespace"
							}
						});
						i++;
					}
					else if (tokenValue === ")" && prevTokenValue !== "}" && prevTokenValue !== ")" && prevTokenValue !== "]" && prevTokenValue !== "(") {
						tokens.splice(i, 0, {
							"value": " ",
							"tokenInfo": {
								"token": "whitespace"
							}
						});
						i++;
					}
					else if (tokenValue === '[' && (nextTokenType === "Indentifier" || nextTokenType === "keyword" || nextTokenType === "literal")) {
						tokens.splice(i + 1, 0, {
							"value": " ",
							"tokenInfo": {
								"token": "whitespace"
							}
						});
						i++;
					}
					else if (tokenValue === ']' && (prevTokenType === "Indentifier" || prevTokenType === "keyword" || prevTokenType === "literal")) {
						tokens.splice(i, 0, {
							"value": " ",
							"tokenInfo": {
								"token": "whitespace"
							}
						});
						i++;
					}
					// Dealing the objects of javascript
					else if (tokenValue === ":") {
						if (nextToken) {
							if (nextTokenType === "literal" || nextTokenType === "Indentifier") {
								if (i + 2 < tokens.length) {
									let next2Token = tokens[i + 2];
									let next2TokenValue = next2Token.value;
									if (next2TokenValue === ",") {
										var tab_spaces = addTabSpaces(nestedLoops)
										tokens.splice(i + 3, 0, {
											"value": tab_spaces,
											"tokenInfo": {
												"token": "whitespace"
											}
										});
									}
								}
							}
						}
						if (nextToken && nextTokenType !== "whitespace") {
							tokens.splice(i + 1, 0, {
								"value": " ",
								"tokenInfo": {
									"token": "whitespace"
								}
							});
							i++;
						}
					}
				}
				else if (tokenType === 'comment') {
					if (i !== 0 && prevToken && prevTokenType !== "whitespace") {
						var tab_spaces = addTabSpaces(nestedLoops)
						tokens.splice(i, 0, {
							"value": tab_spaces,
							"tokenInfo": {
								"token": "whitespace"
							}
						});
						i++;
					}
					else if (i !== 0 && prevToken && prevTokenType === "whitespace" && !prevTokenValue.includes("\n")) {
						var tab_spaces = addTabSpaces(nestedLoops)
						tokens[i - 1] = {
							"value": tab_spaces,
							"tokenInfo": {
								"token": "whitespace"
							}
						}
					}
					if (nextTokenValue === "}") {
						var tab_spaces = addTabSpaces(nestedLoops - 1)
						tokens.splice(i + 1, 0, {
							"value": tab_spaces,
							"tokenInfo": {
								"token": "whitespace"
							}
						});
					}
					else if (i !== tokens.length - 1 && nextTokenType !== "whitespace") {
						var tab_spaces = addTabSpaces(nestedLoops)
						tokens.splice(i + 1, 0, {
							"value": tab_spaces,
							"tokenInfo": {
								"token": "whitespace"
							}
						});
					}
				}
				else if (tokenType === "operator" && tokenValue !== ".") {
					if (prevTokenType !== "whitespace" && prevTokenType !== "operator" && tokenValue !== "++" && tokenValue !== "--" && tokenValue !== "**") {
						tokens.splice(i, 0, {
							"value": " ",
							"tokenInfo": {
								"token": "whitespace"
							}
						});
						i++;
					}
					if (tokenValue !== "!" && nextTokenType !== "whitespace" && nextTokenType !== "operator" && nextTokenValue !== ";") {
						tokens.splice(i + 1, 0, {
							"value": " ",
							"tokenInfo": {
								"token": "whitespace"
							}
						});
						i++;
					}

				}
				else if (tokenType === "keyword" || tokenType === "function-call") {
					if (nextTokenType !== "operator" && nextTokenType !== "punctuator") {
						tokens.splice(i + 1, 0, {
							"value": " ",
							"tokenInfo": {
								"token": "whitespace"
							}
						});
						i++;
					}
					else if (tokenValue === "return") {
						tokens.splice(i + 1, 0, {
							"value": " ",
							"tokenInfo": {
								"token": "whitespace"
							}
						});
						i++;
					}
					if (tokenValue === "if" || tokenValue === "for" || tokenValue === "while") {
						if (prevToken && prevTokenType !== "whitespace") {
							var tab_spaces = addTabSpaces(nestedLoops)
							tokens.splice(i, 0, {
								"value": tab_spaces,
								"tokenInfo": {
									"token": "whitespace"
								}
							});
						}
						var result = handleCondBlock(i, tokens);
						if (result.endIndex !== 0) {
							i = result.endIndex;
							var j = result.endIndex;
							tokens = result.tokens
							if (i + 1 < tokens.length) {
								var tempToken = tokens[j + 1];
								var tempTokenValue = tempToken.value;

								if (tempTokenValue !== "{" && tempTokenValue !== ";") {
									var tab_spaces = addTabSpaces(nestedLoops + 1)
									tokens.splice(j + 1, 0, {
										"value": tab_spaces,
										"tokenInfo": {
											"token": "whitespace"
										}
									});
								}
							}
						}
					}
					if (tokenValue === "switch") {
						var switchEnd = identifySwitchEnd(tokens, i);
						if (switchEnd > 0) {
							var switchBlock = tokens.slice(i + 1, switchEnd + 1);
							const part1 = tokens.slice(0, i + 1);
							const newPart1 = JSON.parse(JSON.stringify(part1));
							const part3 = tokens.slice(switchEnd + 1, tokens.length);
							const newPart3 = JSON.parse(JSON.stringify(part3));
							var newPart2 = indentSwitchJs(switchBlock, nestedLoops);
							tokens = newPart1.concat(newPart2, newPart3);
						}
					}
				}
				else if (tokenType === "Indentifier") {
					if (nextToken && nextTokenType !== "operator" && nextTokenType !== "punctuator") {
						tokens.splice(i + 1, 0, {
							"value": " ",
							"tokenInfo": {
								"token": "whitespace"
							}
						});
						i++;
					}
				}
			}
			return tokens;
		}

		/**
		* Handles the indentation of the switch blocks in Js
		* @param {object} tokens
		* @returns the tokens array
		*/
		function indentSwitchJs(tokens, nestedLoops) {
			for (var i = 0; i < tokens.length; i++) {
				var token = tokens[i];
				var tokenValue = token.value;
				if (i > 0) {
					var prevTokenType = tokens[i - 1].tokenInfo.token
				}
				if (tokenValue === 'case' || tokenValue === 'default') {
					if (prevTokenType !== "whitespace") {
						var tab_spaces = addTabSpaces(nestedLoops + 1)
						tokens.splice(i, 0, {
							"value": tab_spaces,
							"tokenInfo": {
								"token": "whitespace"
							}
						});
						i++;
					}
					var startIndex = i + 1;
					var end = identifyCaseBlocks(tokens, startIndex);

					while (i < end) {
						var token = tokens[i];
						var tokenValue = token.value;
						var tokenType = token.tokenInfo.token
						let nextToken, nextTokenValue, nextTokenType;

						if (i + 1 < tokens.length) {
							nextToken = tokens[i + 1];
							nextTokenValue = tokens[i + 1].value;
							nextTokenType = tokens[i + 1].tokenInfo.token;
						}
						if (tokenType === "punctuator") {
							if (tokenValue === ":") {
								var tab_spaces = addTabSpaces(nestedLoops + 2)
								tokens.splice(i + 1, 0, {
									"value": tab_spaces,
									"tokenInfo": {
										"token": "whitespace"
									}
								});
								end++;
							}
							else if (tokenValue === ";" && nextTokenValue !== "case" && nextTokenValue !== "default") {
								if (nextToken && nextTokenValue === "}" && nextTokenType !== "whitespace") {
									var tab_spaces = addTabSpaces(nestedLoops)
									tokens.splice(i + 1, 0, {
										"value": tab_spaces,
										"tokenInfo": {
											"token": "whitespace"
										}
									});
									end++;
								}
								else if (nextToken && nextTokenType !== "whitespace") {
									var tab_spaces = addTabSpaces(nestedLoops + 2)
									tokens.splice(i + 1, 0, {
										"value": tab_spaces,
										"tokenInfo": {
											"token": "whitespace"
										}
									});
									end++;
								}
							}

						}
						else if (tokenType === "comment") {
							if (nextToken && nextTokenValue !== "}") {
								var tab_spaces = addTabSpaces(nestedLoops + 2)
								tokens.splice(i + 1, 0, {
									"value": tab_spaces,
									"tokenInfo": {
										"token": "whitespace"
									}
								});
								end++;
							}
							if (nextToken && nextTokenValue === "}") {
								var tab_spaces = addTabSpaces(nestedLoops)
								tokens.splice(i + 1, 0, {
									"value": tab_spaces,
									"tokenInfo": {
										"token": "whitespace"
									}
								});
								end++;
							}
						}
						i++;
					}
				}
			}
			return tokens;
		}

		/**
		 * Remove the whitespaces of Js and add the right indentation
		 * @param {object} tokens
		 * @returns the tokens array
		 */
		function handleJs(tokens) {
			// Remove end trailing whitespace
			var whitespacePattern = /^[\s\n\t]*$/;
			var endIndex = tokens.length;
			if (tokens[endIndex - 1].tokenInfo.token === 'whitespace' && whitespacePattern.test(tokens[endIndex - 1].value)) {
				tokens.splice(endIndex - 1, 1)
			}

			//remove all the whitespaces
			for (var i = 0; i < tokens.length; i++) {
				var token = tokens[i];
				var tokenInfo = token.tokenInfo;
				var tokenType = tokenInfo.token;

				if (tokenType === 'whitespace') {
					tokens.splice(i, 1);
					i--;  // Decrement the index to account for the removed token
				}
			}
			tokens = indentJs(tokens);
			return tokens;
		}

		// HTML
		/**
		 * Identify the end index of the corresponding html tag
		 * Used in the case of style and script tags
		 * @param {object} tokens
		 * @param {int} startIndex
		 * @param {*string} startingTag
		 * @returns the end index of the html tag block
		 */
		function identifyEndHtml(tokens, startIndex, startingTag) {
			var nestedBlocks = 0;
			for (var i = startIndex + 2; i < tokens.length; i++) {
				var token = tokens[i];

				var tokenInfo = token.tokenInfo;
				var tokenType = tokenInfo.token;
				var tokenValue = token.value;

				if (tokenType === 'tag-name') {
					if (tokenValue === startingTag) {
						var prevValue = tokens[i - 1].value;
						if (prevValue === '</') {
							if ((i + 1 < tokens.length) && (tokens[i + 1].value === '>')) {
								if (nestedBlocks === 0) {
									return i + 1;
								}
								else {
									nestedBlocks--;
								}
							}
						}
						else {
							nestedBlocks++;
						}
					}
				}
			}
			return 0
		}

		/**
		 * Removes the unwanted spacings and remove them
		 * @param {object} tokens
		 * @returns the tokens array
		 */
		function trimSpacesHtml(tokens) {
			for (var i = 0; i < tokens.length; i++) {
				var token = tokens[i];
				var tokenInfo = token.tokenInfo;
				var tokenType = tokenInfo.token;
				var tokenValue = token.value;
				var pattern = /^[\n\t\s]*$/;

				if (tokenType === 'whitespace' || pattern.test(tokenValue)) {
					tokens.splice(i, 1);
				}
			}
			return tokens;
		}

		/**
		* Add indentation for tokens inside script and style tags
		* @param {object} tokens
		* @returns the tokens array
		*/
		function indentSpecialTagsHtml(tokens, nestedLoops, blockName) {
			var tabSpaces = addTabSpaces(nestedLoops)
			tabSpaces = tabSpaces.replace(/\n/g, '');
			var new_line_tabspace
			if (nestedLoops > 1) {
				var tab_spaces = tabSpaces;
				new_line_tabspace = {
					"value": "\n" + tabSpaces,
					"tokenInfo": {
						"token": "whitespace"
					}
				};
			}
			else {
				tab_spaces = "\t";
				new_line_tabspace = {
					"value": "\n\t",
					"tokenInfo": {
						"token": "whitespace"
					}
				};
			}

			// indent CSS can't be used because trailing spaces has to be eliminated
			if (blockName === "style") {
				tokens = handleCSS(tokens)
			}
			else if (blockName === "script") {
				tokens = indentJs(tokens)
			}

			for (var i = 0; i < tokens.length; i++) {
				var token = tokens[i];
				var tokenValue = token.value;
				var tokenType = token.tokenInfo.token;
				let nextTokenValue, nextToken;

				if (i + 1 < tokens.length) {
					nextToken = tokens[i + 1];
					nextTokenType = nextToken.tokenInfo.token;
					nextTokenValue = nextToken.value;
				}
				if (tokenType === "whitespace" && tokenValue.includes("\n")) {
					if (nextToken && nextTokenValue === '}') {
						tokenValue = tokenValue + tab_spaces;
					}
					else {
						tokenValue = tokenValue + tab_spaces;
					}
					token.value = tokenValue;
					tokens[i] = token;
				}
			}
			tokens.unshift(new_line_tabspace)
			return tokens;
		}

		/**
		 * Add indentation using the count of nested tags
		 * @param {object} tokens
		 * @returns
		 */
		function indentHtml(tokens) {
			var nestedLoops = 0;

			for (var i = 0; i < tokens.length; i++) {
				var token = tokens[i];
				var tokenValue = token.value;
				var tokenType = token.tokenInfo.token;
				let prevToken, prevTokenType, prevTokenValue;
				let nextToken, nextTokenType, nextTokenValue;

				var spaces = "";
				if (i + 1 < tokens.length) {
					nextToken = tokens[i + 1];
					nextTokenValue = nextToken.value;
					nextTokenType = nextToken.tokenInfo.token;
				}
				if (i > 0) {
					prevToken = tokens[i - 1];
					prevTokenValue = prevToken.value;
					prevTokenType = prevToken.tokenInfo.token;
				}

				if (tokenType === "punctuation") {
					if (tokenValue === "<") {
						if (nextToken && nextTokenType === "tag-name") {
							nestedLoops++;
						}
						if (prevToken && prevTokenType !== "whitespace") {
							spaces = addTabSpaces(nestedLoops - 1)
							var spaceToken = {
								"value": spaces,
								"tokenInfo": {
									"token": "whitespace"
								}
							};
							tokens.splice(i, 0, spaceToken);
							i++;
						}
					}
					else if (tokenValue === "</") {
						if (nextToken && nextTokenType !== "whitespace") {
							spaces = addTabSpaces(nestedLoops - 1)
							var spaceToken = {
								"value": spaces,
								"tokenInfo": {
									"token": "whitespace"
								}
							};
							tokens.splice(i, 0, spaceToken);
							i++;
						}
						else if (!nextToken) {
							spaces = addTabSpaces(nestedLoops - 1)
							var spaceToken = {
								"value": spaces,
								"tokenInfo": {
									"token": "whitespace"
								}
							};
							tokens.splice(i, 0, spaceToken);
							i++;
						}
						nestedLoops--;
					}

					else if (tokenValue === ">") {
						if (nextToken && (nextTokenValue === "<" || nextTokenType === "content" || nextTokenType === "comment")) {
							if (prevTokenValue === "/") {
								spaces = addTabSpaces(nestedLoops)
								var spaceToken = {
									"value": spaces,
									"tokenInfo": {
										"token": "whitespace"
									}
								};
								tokens.splice(i + 1, 0, spaceToken);
								i++;
							}
							else {
								spaces = addTabSpaces(nestedLoops)
								var spaceToken = {
									"value": spaces,
									"tokenInfo": {
										"token": "whitespace"
									}
								};
								tokens.splice(i + 1, 0, spaceToken);
								i++;
							}
						}
					}
					else if (tokenValue === '/>') {
						nestedLoops--;
						if (nextToken && nextTokenType !== "whitespace" && nextTokenValue !== "</") {
							spaces = addTabSpaces(nestedLoops)
							var spaceToken = {
								"value": spaces,
								"tokenInfo": {
									"token": "whitespace"
								}
							};
							tokens.splice(i + 1, 0, spaceToken);
							i++;
						}
						else if (!nextToken) {
							spaces = addTabSpaces(nestedLoops)
							var spaceToken = {
								"value": spaces,
								"tokenInfo": {
									"token": "whitespace"
								}
							};
							tokens.splice(i + 1, 0, spaceToken);
							i++;
						}
					}
				}
				else if (tokenType === "content" && nextToken && nextTokenValue === "<" && prevToken && prevTokenType !== "whitespace") {
					if (nextTokenType !== "whitespace") {
						spaces = addTabSpaces(nestedLoops)
						var spaceToken = {
							"value": spaces,
							"tokenInfo": {
								"token": "whitespace"
							}
						};
						tokens.splice(i + 1, 0, spaceToken);
						i++;
					}
				}

				else if (tokenType === 'tag-name' && prevTokenValue !== "</") {
					var blockName = tokenValue;
					if (blockName === "style" || blockName === "script") {
						var blockStartIndex = i - 1;
						var blockEndIndex = identifyEndHtml(tokens, blockStartIndex, blockName);

						var startIndex, endIndex;
						for (var j = blockStartIndex; i < blockEndIndex - 2; j++) {
							var token = tokens[j];
							var tokenValue = token.value;

							if (tokenValue === '>') {
								if ((tokens[j - 2].value !== ('</'))) {
									startIndex = j + 1;
									endIndex = blockEndIndex - 2;
									break;
								}
							}
						}
						if (startIndex !== endIndex) {
							var part1 = tokens.slice(0, startIndex);
							var part2 = tokens.slice(startIndex, endIndex);
							var part3 = tokens.slice(endIndex, tokens.length);

							if (blockName === "style" || blockName === "script") {
								part2 = indentSpecialTagsHtml(part2, nestedLoops, blockName)
							}
							tokens = part1.concat(part2, part3);
							i = blockEndIndex - 1;
						}
						else {
							i = blockEndIndex - 1;
							nestedLoops--;
						}
					}
				}

				else if (tokenType === 'attribute-name') {
					tokenValue = tokenValue.trim();
					token.value = tokenValue;
					tokens[i] = token;

					tokens.splice(i, 0, space);
					tokens.splice(i + 2, 0, space);
					i = i + 1;
				}

				else if (tokenType === 'attribute-equals') {
					tokenValue = tokenValue.trim();
					token.value = tokenValue;
					tokens[i] = token;
					tokens.splice(i + 1, 0, space);
					i++;
				}

				else if (tokenType === 'attribute-value') {
					tokenValue = tokenValue.replace(/:/g, ":").replace(/;/g, ";");
					token.value = tokenValue;
					tokens[i] = token;
				}

				else if (tokenType === 'comment') {
					if (prevToken && prevTokenType !== "whitespace") {
						spaces = addTabSpaces(nestedLoops)
						var spaceToken = {
							"value": spaces,
							"tokenInfo": {
								"token": "whitespace"
							}
						};
						tokens.splice(i, 0, spaceToken);
						i++;
					}
					if (nextToken && nextTokenType === "content") {
						spaces = addTabSpaces(nestedLoops)
						var spaceToken = {
							"value": spaces,
							"tokenInfo": {
								"token": "whitespace"
							}
						};
						tokens.splice(i + 1, 0, spaceToken);
						i++;
					}
				}
			}
			return tokens;
		}

		/**
		 * Add indentation to the html code
		 * @param {object} tokens
		 * @returns the tokens array
		 */
		function handleHtml(tokens) {
			tokens = trimSpacesHtml(tokens);
			tokens = indentHtml(tokens);
			return tokens;
		}

		// XML

		/**
		 * Add indentation using the count of nested tags
		 * @param {object} tokens
		 * @returns
		 */
		function indentXml(tokens) {
			var nestedLoops = 0;

			for (var i = 0; i < tokens.length; i++) {
				var token = tokens[i];
				var tokenValue = token.value;
				var tokenType = token.tokenInfo.token;
				let prevToken, prevTokenType, prevTokenValue;
				let nextToken, nextTokenType, nextTokenValue;

				var spaces = "";
				if (i + 1 < tokens.length) {
					nextToken = tokens[i + 1];
					nextTokenValue = nextToken.value;
					nextTokenType = nextToken.tokenInfo.token;
				}
				if (i > 0) {
					prevToken = tokens[i - 1];
					prevTokenValue = prevToken.value;
					prevTokenType = prevToken.tokenInfo.token;
				}

				if (tokenType === "punctuation") {
					if (tokenValue === "<") {
						if (nextToken && nextTokenType === "tag-name") {
							nestedLoops++;
						}
						if (prevToken && (prevTokenValue.trim() === "+" || prevTokenValue.trim() === "-")) {
							prevTokenValue = prevTokenValue.trim() + " ";
							tokens[i - 1].value = prevTokenValue;
						}
						else if (prevToken && prevTokenType !== "whitespace") {
							spaces = addTabSpaces(nestedLoops - 1)
							var spaceToken = {
								"value": spaces,
								"tokenInfo": {
									"token": "whitespace"
								}
							};
							tokens.splice(i, 0, spaceToken);
							i++;
						}
					}

					else if (tokenValue === "</") {
						if (prevToken && prevTokenType !== "whitespace") {
							spaces = addTabSpaces(nestedLoops - 1)
							var spaceToken = {
								"value": spaces,
								"tokenInfo": {
									"token": "whitespace"
								}
							};
							tokens.splice(i, 0, spaceToken);
							i++;
						}
						nestedLoops--;
					}

					else if (tokenValue === ">") {
						if (nextToken && (nextTokenValue === "<" || nextTokenType === "content" || nextTokenType === "comment")) {
							if (prevTokenValue === "/") {
								spaces = addTabSpaces(nestedLoops)
								var spaceToken = {
									"value": spaces,
									"tokenInfo": {
										"token": "whitespace"
									}
								};
								tokens.splice(i + 1, 0, spaceToken);
								i++;
							}
							else {
								spaces = addTabSpaces(nestedLoops)
								var spaceToken = {
									"value": spaces,
									"tokenInfo": {
										"token": "whitespace"
									}
								};
								tokens.splice(i + 1, 0, spaceToken);
								i++;
							}
						}
					}
					else if (tokenValue === '/>') {
						nestedLoops--;
						if (nextToken && nextTokenType !== "whitespace" && nextTokenValue !== "</") {
							spaces = addTabSpaces(nestedLoops)
							var spaceToken = {
								"value": spaces,
								"tokenInfo": {
									"token": "whitespace"
								}
							};
							tokens.splice(i + 1, 0, spaceToken);
							i++;
						}

						// This works only if the xml tokenizer is corrected
						else if (!nextToken) {
							spaces = addTabSpaces(nestedLoops)
							var spaceToken = {
								"value": spaces,
								"tokenInfo": {
									"token": "whitespace"
								}
							};
							tokens.splice(i + 1, 0, spaceToken);
							i++;
						}
					}
				}

				else if (tokenType === "content" && nextToken && nextTokenValue === "<" && prevToken && prevTokenType !== "whitespace") {
					if (nextTokenType !== "whitespace") {
						spaces = addTabSpaces(nestedLoops)
						var spaceToken = {
							"value": spaces,
							"tokenInfo": {
								"token": "whitespace"
							}
						};
						tokens.splice(i + 1, 0, spaceToken);
						i++;
					}
				}

				else if (tokenType === 'attribute-name') {
					tokenValue = tokenValue.trim();
					token.value = tokenValue;
					tokens[i] = token;
					tokens.splice(i, 0, space);
					tokens.splice(i + 2, 0, space);
					i = i + 1;
				}

				else if (tokenType === 'attribute-equals') {
					tokenValue = tokenValue.trim();
					token.value = tokenValue;
					tokens[i] = token;
					tokens.splice(i + 1, 0, space);
					i++;
				}

				else if (tokenType === 'attribute-value') {
					tokenValue = tokenValue.replace(/:/g, ": ").replace(/;/g, "; ");
					token.value = tokenValue;
					tokens[i] = token;
				}
			}
			return tokens;
		}

		/**
		 * Handle the xml blocks
		 * @param {object} tokens
		 * @returns the tokens array
		 */
		function handleXml(tokens) {
			tokens = trimSpacesHtml(tokens);
			tokens = indentXml(tokens);
			return tokens;
		}

		// Python
		/**
		 * The whitespace is added based on types of token
		 * Extra whitespaces are removed
		 * @param {object} tokens
		 * @returns the tokens array
		 */
		function manageSpacePy(tokens) {
			var excludePunctuators = ['(', ')', '{', '}', '[', ']', ';', ":"]
			var excludeOperators = ['.']
			for (var i = 0; i < tokens.length; i++) {
				var token = tokens[i];
				var tokenInfo = token.tokenInfo;

				var tokenType = tokenInfo.token;
				var tokenValue = token.value;
				let nextToken, nextTokenType;
				if (i + 1 < tokens.length) {
					nextToken = tokens[i + 1];
					nextTokenType = nextToken.tokenInfo.token;
					nextTokenValue = nextToken.value;
				}

				let prevToken, prevTokenType;
				if (i - 1 > -1) {
					prevToken = tokens[i - 1];
					prevTokenType = prevToken.tokenInfo.token;
					prevTokenValue = prevToken.value;
				}

				if (tokenType === 'punctuator') {
					if (!excludePunctuators.includes(tokenValue)) {
						if (nextToken && nextTokenType !== 'whitespace') {
							tokens.splice(i + 1, 0, space);
						}
					}
				}
				else if (tokenType === 'operator') {
					if (!excludeOperators.includes(tokenValue)) {
						if (prevToken && prevTokenType !== 'whitespace') {
							tokens.splice(i, 0, space);
							i++;
						}
						if (nextToken && nextTokenType !== 'whitespace') {
							tokens.splice(i + 1, 0, space);
						}
					}
				}
			}
			return tokens;
		}

		/**
		 * Indent the tokens and return the intended tokens of python code
		 * @param {object} tokens Array of all the tokens
		 * @returns the indented tokens
		 */
		function handlePython(tokens) {
			var whitespacePattern = /^[\s\n\t]*$/;

			var endIndex = tokens.length;
			if (tokens[endIndex - 1].tokenInfo.token === 'whitespace' && whitespacePattern.test(tokens[endIndex - 1].value)) {
				tokens.splice(endIndex - 1, 1)
			}
			// Remove the trailing spaces from the beginning
			if (tokens[0].tokenInfo.token === 'whitespace') {
				tokens.shift();
			}
			tokens = manageSpacePy(tokens)
			return tokens;
		}

		// Java
		/**
		 * Find the parenthesis of condition block of the for loop of Java
		 * @param {object} tokens
		 * @returns
		 */
		function identifyParenthesisOfForBlockJava(tokens) {
			for (var i = 0; i < tokens.length; i++) {

				var token = tokens[i];
				var tokenValue = token.value;

				if (tokenValue === '(') {
					// Start of the condition block
					var conditionStartIndex = i;
					var parenthesesCount = 1;

					// Iterate through the tokens to find the end of the condition block
					for (var j = i + 1; j < tokens.length; j++) {
						let nextToken = tokens[j];
						let nextValue = nextToken.value;

						if (nextValue === '(') {
							parenthesesCount++;
						}
						else if (nextValue === ')') {
							parenthesesCount--;
							if (parenthesesCount === 0) {
								// End of the condition block
								var conditionEndIndex = j;
								// Process the condition block as needed
								return ([conditionStartIndex, conditionEndIndex]);
							}
						}
					}
				}
			}
			return [];
		}

		/**
		 * The whitespace is added based on operators, identifiers, keywords and punctuators
		 * @param {object} tokens
		 * @returns the tokens array
		 */
		function manageSpaceJava(tokens) {
			var excludeOperators = ['.', '++', '--', '**']
			for (var i = 0; i < tokens.length; i++) {
				var token = tokens[i];
				var tokenInfo = token.tokenInfo;

				var tokenType = tokenInfo.token;
				var tokenValue = token.value;
				let nextToken, nextTokenType, nextTokenValue;
				if (i + 1 < tokens.length) {
					nextToken = tokens[i + 1];
					nextTokenType = nextToken.tokenInfo.token;
					nextTokenValue = nextToken.value;
				}

				let prevToken, prevTokenType, prevTokenValue;
				if (i - 1 > -1) {
					prevToken = tokens[i - 1];
					prevTokenType = prevToken.tokenInfo.token;
					prevTokenValue = prevToken.value;
				}

				if (tokenType === 'keyword') {
					if (nextToken && nextTokenType !== 'whitespace' && nextTokenValue !== '.') {
						tokens.splice(i + 1, 0, space);
					}
				}
				else if (tokenType === 'operator') {
					if (!excludeOperators.includes(tokenValue)) {
						if (prevToken && prevTokenType !== 'whitespace') {
							tokens.splice(i, 0, space);
							i++;
						}
						if (nextToken && nextTokenType !== 'whitespace') {
							tokens.splice(i + 1, 0, space);
						}
					}
				}
				else if (tokenType === 'punctuator') {
					if (tokenValue === ',' || tokenValue === '|') {
						if (nextToken && nextTokenType !== 'whitespace') {
							tokens.splice(i + 1, 0, space);
						}
					}
					else if (tokenValue === '->') {
						if (prevToken && prevTokenType !== 'whitespace') {
							tokens.splice(i, 0, space);
							i++;
						}
					}

				}
				else if (tokenType === 'identifier') {
					if (nextToken && !excludeOperators.includes(nextTokenValue)) {
						if (nextToken && nextTokenType !== 'whitespace' && nextTokenType !== 'punctuator' && nextTokenValue !== '.') {
							tokens.splice(i + 1, 0, space);
						}
					}
					if (prevToken && prevTokenType !== 'whitespace' && prevTokenValue !== '.' && prevTokenValue !== '(') {
						tokens.splice(i, 0, space);
						i++;
					}
				}
			}
			var lastToken = tokens[tokens.length - 1];
			if (lastToken) {
				var lastTokenType = lastToken.tokenInfo.token;
				if (lastTokenType === 'whitespace') {
					tokens.pop();
				}
			}
			return tokens;
		}

		/**
		 * New line character added after the semicolon
		 * @param {object} tokens
		 * @returns the tokens with added new line character as whitespace
		 */
		function identifyLinesJava(tokens) {
			for (var i = 0; i < tokens.length; i++) {
				var new_line = {
					"value": "\n",
					"tokenInfo": {
						"token": "whitespace"
					}
				};
				var token = tokens[i];
				var tokenInfo = token.tokenInfo;
				var tokenType = tokenInfo.token;
				var tokenValue = token.value;
				let nextToken, nextTokenValue, nextTokenType, prevToken, prevTokenValue, prevTokenType;
				if (i + 1 < tokens.length) {
					var next = i + 1;
					nextToken = tokens[i + 1];
					nextTokenValue = nextToken.value;
					nextTokenType = nextToken.tokenInfo.token;
				}
				if (i - 1 >= 0) {
					var prev = i - 1;
					prevToken = tokens[i - 1];
					prevTokenValue = prevToken.value;
					prevTokenType = prevToken.tokenInfo.token;
				}
				if (tokenValue === ';') {
					if (nextToken) {
						if (nextTokenType === 'whitespace') {
							nextToken.value = '\n' + nextTokenValue;
							tokens[i + 1] = nextToken;
						}
						else {
							tokens.splice(i + 1, 0, new_line);
							i++;
						}
					}
					else {
						tokens.splice(i + 1, 0, new_line);
						i++;
					}
				}
				else if (tokenValue === '{') {
					if (nextToken && nextTokenValue !== '}') {
						if (nextTokenType === 'whitespace') {
							nextToken.value = '\n' + nextTokenValue;
							tokens[i + 1] = nextToken;
						}
						else {
							tokens.splice(i + 1, 0, new_line);
							i++;
						}
					}
				}
				else if (tokenValue === '}') {
					if (nextToken && nextTokenValue !== ';' && nextTokenValue !== '{') {
						if (nextTokenType === 'whitespace') {
							nextToken.value = '\n' + nextTokenValue;
							tokens[i + 1] = nextToken;
						}
						else {
							tokens.splice(i + 1, 0, new_line);
							i++;
						}
					}
					else {
						// add check whether prevtoken is whitespace
						if (prevToken && prevTokenType !== 'whitespace') {
							tokens.splice(i, 0, new_line);
							i++;
						}
					}
				}
				else if (tokenType === 'comment') {

					if (i !== 0) {
						if (prevToken && prevTokenType === 'whitespace' && !prevTokenValue.includes('\n')) {
							prevToken.value = prevTokenValue + '\n';
							tokens[prev] = prevToken;
						}
						else if (prevToken && prevTokenType !== 'whitespace') {
							tokens.splice(i, 0, {
								"value": "\n",
								"tokenInfo": {
									"token": "whitespace"
								}
							});
							i++;
						}
					}
					if (nextToken && nextTokenType === 'whitespace' && !nextTokenValue.includes('\n')) {
						nextToken.value = '\n' + nextTokenValue;
						tokens[next] = nextToken;
					}
					else if (nextToken && nextTokenType !== 'whitespace') {
						tokens.splice(i + 1, 0, {
							"value": "\n",
							"tokenInfo": {
								"token": "whitespace"
							}
						});
						i++;
					}
				}
			}
			return tokens;
		}

		/**
		 * The tab spaces are add based on the number of blocks inside which the line is placed
		 * @param {string} tokenValue the whitespace value
		 * @param {int} nestedLoop the number of loops
		 * @returns the whitespace string after adding required number of tab spaces
		 */
		function addTabSpacesJava(tokenValue, nestedLoop) {
			for (let i = 0; i < nestedLoop; i++) {
				tokenValue = tokenValue + '\t';
			}
			return tokenValue
		}

		/**
		* Handles the indentation of the switch blocks in java
		* @param {object} tokens
		* @returns the tokens array
		*/
		function indentSwitchJava(tokens) {
			var new_line = {
				"value": "\n",
				"tokenInfo": {
					"token": "whitespace"
				}
			};
			for (var i = 0; i < tokens.length; i++) {
				var token = tokens[i];
				var tokenInfo = token.tokenInfo;

				var tokenType = tokenInfo.token;
				var tokenValue = token.value;
				if (tokenValue === 'case' || tokenValue === 'default') {
					if ((tokens[i - 1].value.includes('\n'))) {
						var value = tokens[i - 1].value + '\t'
						var whitespace = {
							"value": value,
							"tokenInfo": {
								"token": "whitespace"
							}
						};
						tokens[i - 1] = whitespace;
					}
					else if ((tokens[i - 1].value === ':')) {
						tokens.splice(i, 0, new_line);
					}
					var startIndex = i + 1;
					var end = identifyCaseBlocks(tokens, startIndex);

					while (i < end - 1) {
						token = tokens[i];
						tokenInfo = token.tokenInfo;
						tokenType = tokenInfo.token;
						tokenValue = token.value;

						if (tokenType === 'whitespace') {
							if (tokenValue.includes('\n')) {
								var value = tokens[i].value + '\t';
								var whitespace = {
									"value": value,
									"tokenInfo": {
										"token": "whitespace"
									}
								};
								tokens[i] = whitespace;
							}
						}
						if (tokenValue === ':') {
							var nextTokenValue = tokens[i + 1].value;
							var nextTokenType = tokens[i + 1].tokenInfo.token;

							if ((!nextTokenValue.includes('\n') && (nextTokenType !== 'comment') && (nextTokenType !== 'whitespace'))) {
								tokens.splice(i + 1, 0, new_line);
							}
						}
						i++;
						end = identifyCaseBlocks(tokens, startIndex);
					}
				}
			}

			var index = tokens.length - 2;
			if (index > -1) {
				let prevToken = tokens[index];
				let prevTokenValue = prevToken.value;
				let prevTokenType = prevToken.tokenInfo.token;
				if ((prevTokenType !== 'whitespace') && (!prevTokenValue.includes('\n'))) {
					tokens.splice(index + 1, 0, new_line);
				}
			}
			return tokens;
		}

		/**
		 * Add the right indentation for the java code
		 * @param {object} tokens
		 * @returns the indented array of tokens
		 */
		function indentJava(tokens) {
			var nestedLoop = 0;
			var switchEnd;
			for (let i = 0; i < tokens.length; i++) {
				var token = tokens[i];
				var tokenInfo = token.tokenInfo;
				var tokenType = tokenInfo.token;
				var tokenValue = token.value;

				if (tokenType === 'punctuator') {
					if (tokenValue === '{') {
						nestedLoop++;
					}
					else if (tokenValue === '}') {
						nestedLoop--;
					}
				}

				else if (tokenType === 'whitespace') {
					var nextToken, nextTokenValue;
					if (i + 1 < tokens.length) {
						nextToken = tokens[i + 1];
						nextTokenValue = nextToken.value;
					}
					if (nextToken && nextTokenValue !== '}' && nextTokenValue !== 'case' && nextTokenValue !== 'default') {
						if (tokenValue.includes("\n")) {
							var indentedValue = addTabSpacesJava(tokenValue, nestedLoop);
							tokens[i].value = indentedValue;
						}
					}

					if (nextToken && (nextTokenValue === '}' || nextTokenValue === 'case' || nextTokenValue === 'default')) {
						if (tokenValue.includes("\n")) {
							var indentedValue = addTabSpacesJava(tokenValue, nestedLoop - 1);
							tokens[i].value = indentedValue;
						}
					}
					else if (!nextToken) {
						if (tokenValue.includes("\n")) {
							var indentedValue = addTabSpacesJava(tokenValue, nestedLoop);
							tokens[i].value = indentedValue;
						}
					}
				}
				else if (tokenType === 'keyword') {
					if (tokenValue === 'switch') {
						switchEnd = identifySwitchEnd(tokens, i);
						if (switchEnd > 0) {
							var switchBlock = tokens.slice(i, switchEnd + 1);
							const part1 = tokens.slice(0, i);
							const newPart1 = JSON.parse(JSON.stringify(part1));
							const part3 = tokens.slice(switchEnd + 1, tokens.length);
							const newPart3 = JSON.parse(JSON.stringify(part3));
							var newPart2 = indentSwitchJava(switchBlock);
							tokens = newPart1.concat(newPart2, newPart3);
						}
					}
					else if (tokenValue === 'for') {
						var forBlock = tokens.slice(i, tokens.length);

						var startIndex, endIndex;
						var [startIndex, endIndex] = identifyParenthesisOfForBlockJava(forBlock);
						startIndex = i + startIndex;
						endIndex = i + endIndex;

						if (startIndex && endIndex) {
							for (let j = startIndex + 1; j < endIndex; j++) {
								var tempToken = tokens[j];
								var tempTokenValue = tempToken.value;
								var tempTokenType = tempToken.tokenInfo.token;
								if (tempTokenType === 'whitespace' && tempTokenValue.includes('\n')) {
									tempToken.value = ' '
									tokens[j] = tempToken;
								}
							}
						}
					}
				}
			}
			return tokens;
		}

		/**
		 * Remove the whitespaces of Java and add the right indentation
		 * @param {object} tokens
		 * @returns the tokens array
		 */
		function handleJava(tokens) {

			// Remove end trailing whitespace
			var whitespacePattern = /^[\s\n\t]*$/;
			var endIndex = tokens.length;
			if (tokens[endIndex - 1].tokenInfo.token === 'whitespace' && whitespacePattern.test(tokens[endIndex - 1].value)) {
				tokens.splice(endIndex - 1, 1)
			}

			//remove all the whitespaces
			for (var i = 0; i < tokens.length; i++) {
				var token = tokens[i];
				var tokenInfo = token.tokenInfo;
				var tokenType = tokenInfo.token;

				if (tokenType === 'whitespace') {
					tokens.splice(i, 1);
					i--;  // Decrement the index to account for the removed token
				}
			}
			tokens = identifyLinesJava(tokens);
			tokens = indentJava(tokens);
			tokens = manageSpaceJava(tokens)
			return tokens;
		}

		builder.prototype.indentCode = function (tokens) {
			var data = this.tokenizer;
			var language = data.language;

			if (language === 'json') {
				tokens = handleObject(tokens);
			}
			else if (language === 'js') {
				tokens = handleJs(tokens);
			}
			else if (language === 'html') {
				tokens = handleHtml(tokens);
			}
			else if (language === 'css') {
				tokens = handleCSS(tokens);
			}
			else if (language === 'xml') {
				tokens = handleXml(tokens);
			}
			else if (language === 'python') {
				tokens = handlePython(tokens);
			}
			else if (language === 'java') {
				tokens = handleJava(tokens);
			}
			return tokens;
		}

		builder.prototype.buildSnippets = function (tokens) {
			var result = document.createDocumentFragment(), that = this, curLineNumber = 1;

			var calculateLineNumber = function (value) {
				var numberOfLineBreaks = (value.match(/(\n)/g) || []).length;
				curLineNumber += numberOfLineBreaks;
			}

			tokens.forEach(function (token) {
				var value = token.value,
					tokenObject = token.tokenInfo,
					cls = tokenObject.class || that.getClassForCommonTokens(tokenObject),
					span = document.createElement('span');
				span.setAttribute('class', cls);

				calculateLineNumber(value);
				span.textContent = value;
				result.appendChild(span);
			});

			return {
				snippet: result,
				lineCount: curLineNumber
			};
		}

		builder.prototype.getClassForCommonTokens = function (tokenObject) {
			switch (tokenObject.token) {
				case 'whitespace':
					return 'lyteCSWhiteSpace';
				case 'unmatched-token':
					return 'lyteCSUnmatchedToken';
			}
		}

		builder.prototype.build = function () {
			var tokens = this.tokenizer.build();
			if ($L.snippets.indent) {
				if ($L.snippets.indent === true) {
					tokens = this.indentCode(tokens);
				}
			}
			else if ($L.snippets.indent === undefined) {
				tokens = this.indentCode(tokens);
			}
			return this.buildSnippets(tokens);
		}

	}
)
( function( factory ) {
    if( typeof define === "function" && define.amd ) {
        define( [ "@zoho/lyte-dom" ], factory );
    }
    else {
        factory( $L );
    }
} )( function( $L ) {
	if( $L.snippets.registerLanguage ) {
		return ;
	}

	var registeredTokenizers = {};


	$L.snippets.registerLanguage = function (language, config) {
		buildTokenizer(language, config);
	}

	$L.snippets.getTokenConfig = function (language) {
		return registeredTokenizers[language]._tokenConfig;
	}

	var buildTokenizer = function (language, config) {
		registeredTokenizers[language] = function (str) {
			this.code = str;
			this.tokenConfig = config.tokenConfig;
			this.language = language;
			this.tokenizer = {};
		}

		registeredTokenizers[language]._tokenConfig = config.tokenConfig;

		registeredTokenizers[language].prototype.build = function () {
			return this.buildTokens(this.code, this.tokenConfig, true);
		}

		registeredTokenizers[language].prototype.setCode = function (code) {
			this.code = code;
		}

		registeredTokenizers[language].prototype.buildTokens = function (code, tokenConfig, buildUnmatchedToken) {
			var tokenValue, tokenInfo, bestMatchIndex, bestMatch, reduceBy, result = [], that = this, isRemainingPresent = false, remainingToken,
				__fn = function (token) {
					var regex = token.regex, currentMatch,
						currentMatchIndex;

					if (regex === 'remaining') {
						isRemainingPresent = true;
						remainingToken = token;

						return;
					}

					currentMatch = regex.exec(code);

					if (!currentMatch) {
						return;
					}

					currentMatchIndex = currentMatch.index;

					if (isNaN(bestMatchIndex) || currentMatchIndex < bestMatchIndex || (currentMatchIndex === bestMatchIndex && currentMatch[0].length > bestMatch[0].length)) {
						bestMatchIndex = currentMatchIndex;
						bestMatch = currentMatch;
						tokenInfo = token;
					}
				};

			while (code.length != 0) {
				tokenConfig.forEach(__fn);

				if (bestMatchIndex != 0) {
					if (isRemainingPresent) {
						reduceBy = code.length;
						tokenValue = code;
						tokenInfo = remainingToken;
					}
					else {
						reduceBy = bestMatchIndex || code.length;
						tokenValue = code.substring(0, bestMatchIndex);

						if (that.isWhiteSpace(tokenValue)) {
							tokenInfo = {
								token: 'whitespace'
							};
						}
						else {
							tokenInfo = {
								token: 'unmatched-token'
							};
						}
					}
				}
				else {
					reduceBy = bestMatch[0].length;
					tokenValue = code.substring(0, bestMatch[0].length);
				}

				// We will buildUnmatched tokens at the top level
				if (!buildUnmatchedToken && tokenInfo.token === 'unmatched-token') {
					return result;
				}

				if (that.isToken(tokenInfo)) {
					result.push(that.createToken(tokenValue, tokenInfo));
					code = that.reduceStringBy(code, reduceBy);
				}

				if (that.isGroup(tokenInfo)) {
					result = result.concat(that.buildTokens(bestMatch[0], tokenInfo['matched-elements']));
					code = that.reduceStringBy(code, bestMatch[0].length);
				}

				if (that.shouldUseOtherTokenizer(tokenInfo, bestMatch)) {
					var tokenizerInfo = that.getTokenizerInfo(tokenInfo, bestMatch);

					var codeToParse = tokenizerInfo.regex.exec(code)[0];

					that.decorateTokenizer(tokenizerInfo);

					result = result.concat(that.useSubTokenizer(tokenizerInfo.parseWith, codeToParse));
					code = that.reduceStringBy(code, codeToParse.length);
				}


				if (that.hasNextTokens(tokenInfo)) {
					result = result.concat(that.buildTokens(code, tokenInfo.nextTokens));
					code = that.reduceStringBy(code, nextTokens);
				}

				tokenValue = tokenInfo = bestMatchIndex = bestMatch = reduceBy = undefined;

			}

			return result;
		}

		registeredTokenizers[language].prototype.isToken = function (token) {
			return 'token' in token;
		}

		registeredTokenizers[language].prototype.isWhiteSpace = function (value) {
			return /[\s]+/.test(value);
		}

		registeredTokenizers[language].prototype.isGroup = function (token) {
			return 'group' in token;
		}

		registeredTokenizers[language].prototype.hasNextTokens = function (token) {
			return 'nextTokens' in token;
		}

		registeredTokenizers[language].prototype.createToken = function (tokenValue, tokenObject) {
			return {
				value: tokenValue,
				tokenInfo: tokenObject
			}
		}

		registeredTokenizers[language].prototype.reduceStringBy = function (code, val) {

			if (Array.isArray(code)) {
				var tokens = code, result = '';

				tokens.forEach(function (token) {
					result += token.value;
				});

				return code.substring(result.length);
			}

			return code.substring(val);
		}

		registeredTokenizers[language].prototype.shouldUseOtherTokenizer = function (token, match) {
			return 'tokenizer' in token && this.getTokenizerInfo(token, match);
		}

		registeredTokenizers[language].prototype.getTokenizerInfo = function (token, match) {
			var groups = match.groups,
				tokenizerInfoList = token.tokenizer;

			for (var i = 0; i < tokenizerInfoList.length; i++) {
				var tokenizerInfo = tokenizerInfoList[i];

				if (this.hasMatchingGroup(tokenizerInfo, groups)) {
					return tokenizerInfo;
				}
			}
		}

		registeredTokenizers[language].prototype.hasMatchingGroup = function (tokenizer, groups) {
			for (var groupName in groups) {
				var value = groups[groupName];

				if (groupName === tokenizer['matched-group'] && value === tokenizer.value) {
					return true;
				}
			}

			return false;
		}

		registeredTokenizers[language].prototype.decorateTokenizer = function (tokenizerInfo) {
			var language = tokenizerInfo.parseWith;

			if (!this.tokenizer[language]) {
				this.tokenizer[language] = $L.snippets.getTokenizer(language);
			}
		}

		registeredTokenizers[language].prototype.useSubTokenizer = function (language, str) {
			this.tokenizer[language].setCode(str);

			return this.tokenizer[language].build();
		}
	}

	$L.snippets.getTokenizer = function (language, str) {
		return new registeredTokenizers[language](str);
	}

} )


(function (factory) {
	if (typeof define === "function" && define.amd) {
		define(["@zoho/lyte-dom"], factory);
	}
	else {
		factory($L);
	}
})(
	function ($L) {
		$L.snippets.registerLanguage('css', {
			tokenConfig: [
				{
					'token': 'comment',
					'class': 'lyteCSSComment',
					'regex': /\/\*([\s\S]*?)\*\//
				},
				{
					'token': 'punctuation',
					'class': 'lyteCSSPunctuation',
					'regex': /}/
				},
				{
					'group': 'media-rule',
					'regex': /@[\s\S]+?{/,
					'matched-elements': [{
						'token': 'punctuation',
						'regex': /@|{/,
						'class': 'lyteCSSPunctuation'
					}, {
						'token': 'media-words',
						'regex': /[^(@{]+/,
						'class': 'lyteCSSMediaWords'
					}, {
						'token': 'media-conditions',
						'regex': /\([\s\S]*?\)/,
						'class': 'lyteCSSMediaConditions'
					}]
				},
				{
					'group': 'ruleset',
					'regex': /[^@}\s\/][\s\S]+?(?={){[\s\S]*?(?=})}/,
					'matched-elements': [{
						'group': 'selector',
						'regex': /.+?(?={)/,
						'matched-elements': [{
							'token': 'combinator',
							'class': 'lyteCSSCombinator',
							'regex': /[+>~]/
						}, {
								'group': 'attribute-selector',
								'regex': /\[.+?(?=\])\]/,
								'matched-elements': [
									{
										'token': 'punctuation',
										'class': 'lyteCSSPunctuation',
										'regex': /[\[\]]/
									},
									{
										'token': 'attribute-name',
										'class': 'lyteCSSAttributeName',
										'regex': /[^\[\]=]+?(?==)/
									},
									{
										'group': 'attribute-value',
										'regex': /=.*?(?=])]/,
										'matched-elements': [
											{
												'token': 'punctuation',
												'class': 'lyteCSSPunctuation',
												'regex': /[=\]]/
											},
											{
												'token': 'attribute-value',
												'regex': /[^=]*?(?=])/,
												'class': 'lyteCSSAttributeValue'
											}
										]
									}
								]
							}, {
								'token': 'selector',
								'class': 'lyteCSSSelector',
								'regex': /[^+>~\[]*/
							}]
					}, {
							'group': 'rulebody',
							'regex': /{[\s\S]*?(?=})}/,
						'matched-elements': [{
							'class': 'lyteCSSPunctuation',
							'token': 'punctuation',
							'regex': /[{}]/
						}, {
								'group': 'declaration',
								'regex': /[^{}]+?(?=[;}]);?/,
							'matched-elements': [{
								'token': 'rule-name',
								'regex': /[\S]+?(?=:)/,
								'class': 'lyteCSSRuleName'
							}, {
									'group': 'rule-value',
									'regex': /:[\s\S]+?(?=[;}]);?/,
								'matched-elements': [{
									'group': 'rule-value',
									'regex': /[^:;][^;}]*/,
									'matched-elements': [{
										'token': 'color-value',
										'regex': /\s*#.*/,
										'class': 'lyteCSSColorValue'
									}, {
											'token': 'important-keyword',
											'regex': /!important/,
											'class': 'lyteCSSImportant'
										}, {
											'token': 'css-function',
											'regex': /[a-zA-Z0-9]+\([a-zA-Z0-9,%\s'"+-/.]+\)/,
											'class': 'lyteCSSValueFunction'
										}, {
											'token': 'rule-value',
											'regex': /[a-zA-Z0-9%'"+-./]+/,
											'class': 'lyteCSSRuleValue'
										}]
								}, {
										'token': 'punctuation',
										'regex': /[:;]/,
										'class': 'lyteCSSPunctuation'
												}]
										}]
								}]
						}]
				}]
		});
	}
);
(function (factory) {
	if (typeof define === "function" && define.amd) {
		define(["@zoho/lyte-dom"], factory);
	}
	else {
		factory($L);
	}
})(
	//new RegExp( "<" + NAME_RULE + "(" + SPACE_RULE + ATTRIBUTE_RULE + ")*" + SPACE_RULE + "?" + ">" )

	function ($L) {
		var NAME_START_CHAR = "A-Za-z:_",
			NAME_CHAR = NAME_START_CHAR + ".0-9-",
			NAME_RULE = "[" + NAME_START_CHAR + "]" + "[" + NAME_CHAR + "]*",
			SPACE_RULE = "(?:[\\s]+)",
			EQ_RULE = SPACE_RULE + "?=" + SPACE_RULE + "?",
			ATTRIBUTE_VALUE_RULE = "(?:'[^']*'|\"[^\"]*\"|[^<>=\\s][^>\\s]*)",
			ATTRIBUTE_RULE = NAME_RULE + EQ_RULE + ATTRIBUTE_VALUE_RULE;


		$L.snippets.registerLanguage('html', {
			tokenConfig: [{
				'group': 'start-tag',
				'regex': new RegExp("<(?<tagname>" + "(?:[\\s]*)" + NAME_RULE + ")(" + SPACE_RULE + ATTRIBUTE_RULE + ")*" + SPACE_RULE + "?" + "\/?" + SPACE_RULE + "?" + ">"),
				'matched-elements': [
					{
						'group': 'punctuator-name-tokens',
						'regex': new RegExp('<' + "(?:[\\s]*)" + NAME_RULE),
						'matched-elements': [
							{
								'token': 'punctuation',
								'regex': new RegExp(/</),
								'class': 'lytePunctuationCls'
							},
							{
								'token': 'tag-name',
								'regex': new RegExp(NAME_RULE),
								'class': 'lyteTagNameCls',
								'values': [{
									'value': 'style',
									'language': 'css'
								}]
							}
						]
					},
					{
						'token': 'attribute-name',
						'regex': new RegExp(SPACE_RULE + NAME_RULE),
						'class': 'lyteAttributeNameCls'
					},
					{
						'token': 'attribute-equals',
						'regex': new RegExp(EQ_RULE),
						'class': 'lyteAttributeEqualsCls'
					},
					{
						'token': 'attribute-value',
						'regex': new RegExp(ATTRIBUTE_VALUE_RULE),
						'class': 'lyteAttributeValueCls'
					},
					{
						'token': 'punctuation',
						// 'regex': new RegExp(/[/>]/),
						'regex': new RegExp(/\/>|\/|>/),
						'class': 'lytePunctuationCls'
					}
				],

				'tokenizer': [
					{
						'matched-group': 'tagname',
						'value': 'style',
						'parseWith': 'css',
						'regex': /[\s\S]*?(?=<\/style>)/
					},
					{
						'matched-group': 'tagname',
						'value': 'script',
						'parseWith': 'js',
						'regex': /[\s\S]*?(?=<\/script>)/
					}
				]
			}, {
					'group': 'end-tag',
				'regex': new RegExp("</" + "(?:[\\s]*)" + NAME_RULE + ">"),
				'matched-elements': [
					{
						'token': 'punctuation',
						'regex': new RegExp("(?:</|>)"),
						'class': 'lytePunctuationCls'
					},
					{
						'token': 'tag-name',
							'regex': new RegExp(NAME_RULE),
							'class': 'lyteTagNameCls'
						}
					]
				}, {
					'group': 'content',
				'regex': new RegExp(/[^<]+/),
				'matched-elements': [{
					'token': 'entity',
					'regex': new RegExp('&' + NAME_RULE + ';'),
					'class': 'lyteEntityCls'
				}, {
						'token': 'content',
					'regex': new RegExp(/[^&]+/),
					'class': 'lyteContentCls'
						}]
				}, {
					'token': 'comment',
					'class': 'lyteCommentCls',
					'regex': new RegExp(/<!--([\s\S]*?)-->/)
				}, {
					'token': 'doc-type',
					'class': 'lyteContentCls',
					'regex': /<!DOCTYPE\s+html\s*>/i
				}]
		});

	}
);
(function (factory) {
	if (typeof define === "function" && define.amd) {
		define(["@zoho/lyte-dom"], factory);
	}
	else {
		factory($L);
	}
})(
	function ($L) {
		$L.snippets.registerLanguage('js', {
			tokenConfig: [{
				'token': 'literal',
				// 'regex': /(?<stringStart>['"]).*?(?<!\\)(\\\\)*\k<stringStart>/,
				/*
					Match even number of slashes at the end
					If its odd number keep matching more stuff

					Eg: "abc\"abc" "abc\\\"abc" "abc\\\\\"abc" are valid strings
					"abc \\"abc" is not valid and the second double quote is the close of the string
				*/
				/**
				 * The strings to be matched after considering the escape characters
				 * Hence the number of backslashes has to be considered
				 * But the lookbehind assertions are removed
				 */
				'regex': /(['"])(.*?(?:(?:\\\\)*(\\\\)*)*)\1/, 'class': 'lyteJSStringLiteral'
			}, {
					'group': 'Indentifiers',
					'regex': /[a-zA-Z\_$][a-zA-Z\_$]*(\()?/,
				'matched-elements': [{
					'token': 'keyword',
					'regex': /\b(?:break|export|super|case|extends|switch|catch|finally|this|class|for|throw|const|function|try|continue|if|typeof|debugger|import|var|default|in|void|delete|instanceof|while|do|new|with|else|return|yield|enum|implements|package|public|interface|private|static|let|protected|await)\b/,
					'class': 'lyteJSKeyword'
				}, {
						'token': 'boolean',
						'regex': /\b(?:true|false)\b/,
						'class': 'lyteJSBoolean'
					}, {
						'token': 'undefined',
						'regex': /\b(?:undefined)\b/,
						'class': 'lyteJSUndefined'
					}, {
						'token': 'null',
						'regex': /\b(?:null)\b/,
						'class': 'lyteJSNull'
					}, {
						'group': 'function-call',
						'regex': /[a-zA-Z\_][a-zA-Z\_]*\(/,
					'matched-elements': [{
						'token': 'function-call',
						'regex': /[a-zA-Z\_][a-zA-Z\_]*/,
						'class': 'lyteJSFunction'
					}, {
							'token': 'punctuator',
							'regex': /\(/,
							'class': 'lyteJSPunctuator'
							}]
					}, {
						'token': 'Indentifier',
						'regex': 'remaining',
						'class': 'lyteJSIndentifier'
						}]
				}, {
					'token': 'comment',
					'regex': /(\/\/.*|\/\*[\s\S]*?\*\/)/,
					'class': 'lyteJSComment'
				}, {
					'token': 'operator',
					'regex': /(>>>=|===|!==|\*\*=|<<=|>>=|>>>|\.\.\.|\+=|-=|\*=|\/=|%=|&=|\^=|\|=|==|!=|>=|<=|\+\+|--|\*\*|<<|>>|&&|\|\||=>|\.|\?|~|>|<|=|!|\+|-|\*|%|&|\||\^|\\|\/)/,
					'class': 'lyteJSOperator'
				}, {
					'token': 'punctuator',
					'regex': /\(|\{|\[|\)|\}|\]|;|,|:|"|'/,
					'class': 'lyteJSPunctuator'
				}, {
					'token': 'number',
					'regex': /[0-9]+(\.[0-9]+)?/,
					'class': 'lyteJSNumber'
				}, {
					'token': 'regex',
					'class': 'lyteJSRegex',
					'regex': /\/(?![\/\*]).*?\//
				}]
		});
	}
);
(function (factory) {
	if (typeof define === "function" && define.amd) {
		define(["@zoho/lyte-dom"], factory);
	}
	else {
		factory($L);
	}
})(
	function ($L) {
		$L.snippets.registerLanguage('json', {
			tokenConfig: [
				{
					'token': 'punctuation',
					'regex': /({|}|\[|\]|:|,)/,
					'class': 'lyteJSONPunctuation'
				},
				{
					'token': 'literal',
					// 'regex': /(?<stringStart>["]).*?(?<!\\)(\\\\)*\k<stringStart>/,
					/*
						Match even number of slashes at the end
						If its odd number keep matching more stuff

						Eg: "abc\"abc" "abc\\\"abc" "abc\\\\\"abc" are valid strings
						"abc \\"abc" is not valid and the second double quote is the close of the string
					*/
					/**
					 * The strings to be matched after considering the escape characters
					 * Hence the number of backslashes has to be considered
					 * But the lookbehind assertions are removed
					 */
					'regex': /(['"])(.*?(?:(?:\\\\)*(\\\\)*)*)\1/, 'class': 'lyteJSONLiteral'
				},
				{
					'token': 'null',
					'regex': /null/,
					'class': 'lyteJSONNull'
				},
				{
					'token': 'boolean',
					'regex': /(?:true|false)/,
					'class': 'lyteJSONBoolean'
				},
				{
					'token': 'number',
					'regex': /[0-9]+(\.[0-9]+)?/,
					'class': 'lyteJSONNumber'
				}
			]
		});
	}
);
( function( factory ) {
	if( typeof define === "function" && define.amd ) {
        define( [ "@zoho/lyte-dom" ], factory );
    }
    else {
        factory( $L );
    }
} )( function( $L ) {
	$L.snippets.registerLanguage( 'lyte', {
		tokenConfig: [ 
			...$L.snippets.getTokenConfig( 'html' ),
			{
				'group': 'lyte-syntax',
				'regex': /<%[\s\S]*?%>/,
				'matched-elements': [ {
					'token': 'lyte-punctuator',
					'regex': /<%|%>|{|}/,
					'class': 'lyteCSPunctuator'
				}, {
					'group': 'if-block',
					'regex': /if\s*\([\s\S]*?\)\s*{/,
					'matched-elements': [ {
						'group': 'if-statement',
						'regex': /if\s*\([\s\S]*?\)\s*{/,
						'matched-elements': [ {
							'group': 'if-statement',
							'regex': /if\s*\(/,
							'matched-elements': [ {
								'token': 'if-statement',
								'regex': /if/,
								'class': 'lyteCSKeyword'
							}, {
								'token': 'punctuator',
								'regex': /\(/,
								'class': 'lyteCSPunctuator'
							} ]
						}, {
							'group': 'condition-statement',
							'regex': /[\s\S]*?\)\s*{/,
							'matched-elements': [ {
								'token': 'lyte-punctuator',
								'regex': /\(|\)|{/,
								'class': 'lyteCSPunctuator'
							}, {
								'token': 'condition',
								'regex': /[^(){]*/,
								'class': 'lyteCSIfBlock'
							} ]
						} ]
					} ]
				}, {
					'group': 'for-block',
					'regex': /[a-zA-Z][a-zA-Z0-9_-]*\s*\.\s*forEach\s*\(\s*function\s*\(\s*[\s\S]*?\){/,
					'matched-elements': [ {
						'group': 'loop-start',
						'regex': /[a-zA-Z][a-zA-Z0-9_-]*\s*\./,
						'matched-elements': [ {
							'token': 'lyte-variable',
							'regex': /[a-zA-Z][a-zA-Z0-9_-]*/,
							'class': 'lyteCSVariable'
						}, {
							'token': 'lyte-punctuator',
							'regex': /\./,
							'class': 'lyteCSPunctuator'
						} ]
					}, {
						'token': 'lyte-keywords',
						'regex': /(forEach|function)/,
						'class': 'lyteCSKeyword'
					}, {
						'token': 'lyte-punctuator',
						'regex': /\(|\)|{|,/,
						'class': 'lyteCSPunctuator'
					}, {
						'token': 'lyte-variable',
						'regex': /[a-zA-Z][a-zA-Z0-9_-]*/,
						'class': 'lyteCSVariable'
					} ]
				}, {
					'group': 'switch-block',
					'regex': /switch\s*\([a-zA-Z0-9_-]*\)\s*{/
				} ]
			}
		]
	} );
} );
(function (factory) {
	if (typeof define === "function" && define.amd) {
		define(["@zoho/lyte-dom"], factory);
	}
	else {
		factory($L);
	}
})(
	function ($L) {
		var SPACE_RULE = '\\s*',
			ATTRIBUTE_NAME_RULE = '([a-zA-Z_:][a-zA-Z0-9._:-]*)',
			EQUAL_RULE = '(' + SPACE_RULE + '=' + SPACE_RULE + ')',
			REFERENCE_RULE = '(&' + ATTRIBUTE_NAME_RULE + ';|&#[0-9]+;|&#x[0-9a-fA-F]+;)',
			ATTRIBUTE_VALUE_RULE = '"([^<&"]|' + REFERENCE_RULE + ')*"';

		$L.snippets.registerLanguage('xml', {
			tokenConfig: [
				{
					'group': 'prolog',
					'regex': new RegExp('<\\?xml(\\s+' + ATTRIBUTE_NAME_RULE + EQUAL_RULE + ATTRIBUTE_VALUE_RULE + ')*\\?>'),
					'matched-elements': [{
						'token': 'punctuation',
						'regex': /(<\?|\?>|=)/,
						'class': 'lyteXMLPunctuation'
					}, {
							'token': 'tag-name',
							'regex': /xml/,
							'class': 'lyteXMLTagName'
						}, {
							'token': 'attribute-name',
							'regex': new RegExp(ATTRIBUTE_NAME_RULE),
							'class': 'lyteXMLAttributeName'
						}, {
							'token': 'attribute-value',
						'regex': new RegExp(ATTRIBUTE_VALUE_RULE),
						'class': 'lyteXMLAttributeValue'
						}]
				}, {
					'token': 'comments',
					'regex': /<!--([\s\S]*?)-->/,
					'class': 'lyteXMLComments'
				},
				{
					'group': 'processing-instructions',
					'regex': new RegExp('<\\?' + ATTRIBUTE_NAME_RULE + '(' + SPACE_RULE + '[a-zA-Z0-9._:="\'-])*\\?>'),
					'matched-elements': [{
						'group': 'processing-instruction-name',
						'regex': new RegExp('<\\?' + ATTRIBUTE_NAME_RULE),
						'matched-elements': [{
							'token': 'punctuation',
							'regex': /<\?/,
							'class': 'lyteXMLPunctuation'
						}, {
								'token': 'processing-instruction-name',
							'regex': new RegExp(ATTRIBUTE_NAME_RULE),
							'class': 'lyteXMLProcessingInstructionName'
							}]
					}, {
							'token': 'punctuation',
							'class': 'lyteXMLPunctuation',
							'regex': /\?>/
						}, {
							'token': 'instruction-data',
							'class': 'lyteXMLPIData',
							'regex': 'remaining'
						}]
				},
				{
					'group': 'start-tag',
					'regex': new RegExp('<' + ATTRIBUTE_NAME_RULE + '(\\s+' + ATTRIBUTE_NAME_RULE + EQUAL_RULE + ATTRIBUTE_VALUE_RULE + ')*\\s*/?>'),
					'matched-elements': [{
						'group': 'start-tag',
						'regex': new RegExp('<' + ATTRIBUTE_NAME_RULE),
						'matched-elements': [{
							'token': 'punctuation',
							'class': 'lyteXMLPunctuation',
							'regex': /</
						}, {
								'token': 'tag-name',
								'class': 'lyteXMLTagName',
								'regex': new RegExp(ATTRIBUTE_NAME_RULE)
							}]
					}, {
							'group': 'attribute-name',
						'regex': new RegExp(ATTRIBUTE_NAME_RULE + EQUAL_RULE),
						'matched-elements': [
							{
								'token': 'attribute-name',
								'class': 'lyteXMLAttributeName',
									'regex': new RegExp(ATTRIBUTE_NAME_RULE)
								}, {
									'token': 'punctuation',
									'class': 'lyteXMLPunctuation',
									'regex': /=/
								}
							]
						}, {
							'token': 'punctuation',
							'class': 'lyteXMLPunctuation',
							// 'regex': /[/>]/
							'regex': /\/>|>/
						}, {
							'token': 'attribute-value',
							'class': 'lyteXMLAttributeValue',
							'regex': new RegExp(ATTRIBUTE_VALUE_RULE)
						}]
				},
				{
					'group': 'end-tag',
					'regex': new RegExp('</' + ATTRIBUTE_NAME_RULE + '>'),
					'matched-elements': [{
						'token': 'punctuation',
						// 'regex': /(<\/|>)/,
						'regex': /(<\/|\/>|>)/,
						'class': 'lyteXMLPunctuation'
					}, {
							'token': 'tag-name',
						'regex': new RegExp(ATTRIBUTE_NAME_RULE),
						'class': 'lyteXMLTagName'
						}]
				},
				{
					'group': 'content',
					'regex': new RegExp(/[^<]+/),
					'matched-elements': [{
						'token': 'entity',
						'regex': new RegExp('&' + ATTRIBUTE_NAME_RULE + ';'),
						'class': 'lyteEntityCls'
					}, {
							'token': 'content',
						'regex': new RegExp(/[^&]+/),
						'class': 'lyteContentCls'
						}]
				},
				{
					'group': 'cdata-sections',
					'regex': new RegExp('<!\[CDATA\[[a-zA-Z0-9._:="\'\\s<>&-]*?(?=\]\]>)\]\]>'),
					'matched-elements': [{
						'group': 'cdata-start',
						'regex': /(<!\[CDATA\[)/,
						'matched-elements': [{
							'token': 'punctuation',
							'regex': /[<!\[]/,
							'class': 'lyteXMLPunctuation'
						}, {
								'token': 'tag-name',
								'regex': /CDATA/,
								'class': 'lyteXMLTagName'
							}]
					}, {
							'token': 'punctuation',
							'regex': /[\]>]/,
							'class': 'lyteXMLPunctuation'
						}, {
							'token': 'cdata-content',
							'regex': /[a-zA-Z0-9._:="'\s<>&-]*?(?=\]\]>)/,
							'class': 'lyteXMLCDATAContent'
						}]
				},
				{
					'group': 'DTD',
					'regex': /<![a-zA-Z]*[a-zA-Z0-9._:="'\s&-]*?(?=>)>/,
					'matched-elements': [{
						'group': 'DTD-start',
						'regex': /<![a-zA-Z]*/,
						'matched-elements': [{
							'token': 'punctuation',
							'regex': /[<!]/,
							'class': 'lyteXMLPunctuation'
						}, {
								'token': 'start-tag',
								'regex': /[a-zA-Z]/,
								'class': 'lyteXMLTagName'
							}]
					}, {
							'token': 'punctuation',
							'regex': />/,
							'class': 'lyteXMLPunctuation'
						}, {
							'token': 'DTD-content',
							'regex': /[a-zA-Z0-9._:="'\s&-]*?(?=>)/,
							'class': 'lyteXMLDTDContent'
						}]
				}
			]
		});
	}
);
;( function( cb ){
	if( typeof define == "function" && define.amd ){
		define( [ "@zoho/lyte-dom" ], cb );
	} else {
		cb( window.$L );
	}
} )( function( $L ){
	if( $L ){
		var elData, AniData,
		curves = {
			'ease-in': function( t ) {
				return t * t;
			},

			'ease-out': function( t ) {
				return t * ( 2 - t );
			},

			'linear': function( t ) {
				return t;
			},

			'ease-in-out': function( t ) {
				return t < 0.5 ? ( 2 * t * t ) : ( -1 + ( 4 - 2 * t ) * t );
			}
		};

		$L.Tween = {
			propHooks: {}
		};

		function firecallback( item, forceRemove ) {
			if( forceRemove ) {
				return ;
			}
			
			var anidata = AniData.data[ item.lyteAnimateId ][ 0 ],
			opts = ( anidata || {} ).options,
			complete = ( opts || {} ).complete,
			props, param = {}, aniProp;

			if( complete ) {
				props = elData.get( item, 'animeProp', 'animate' );
				aniProp = elData.get( item, 'animeProp' );
				param.transitionProperty = props;
				param.from = aniProp.from;
				param.to = aniProp.to;
				param.startTime = aniProp.startTime;

				complete.call( item, param );
			}
		}

		function mapOnCurve( t, timingFunction ) {
			return curves[ timingFunction ]( t );
		}

		function progress( prop, final, before, diff, initial, total, remaining, timingFunction, obj, data ) {
			var now = Date.now(),
			change = now - before,
			remaining = remaining - change,
			elapsed = total - remaining,
			tweenProps = $L.Tween.propHooks[ prop ], t, multiplier;

			elapsed = remaining < 0 ? total : elapsed;
			t = elapsed / total;
			multiplier = mapOnCurve( t, timingFunction );

			if( 'set' in tweenProps ) {
				tweenProps.set( obj, initial + diff * multiplier, data );
			}
			else {
				this[ prop ] = initial + ( diff * multiplier );
			}

			/**
			 * When .stop is called inside the set in scrollTo plugin
			 * we were cancelling the current request animation frames instead
			 * of preventing the next one from happening
			 * so we are using this flag to determine when it needs to be stopped
			 * We still had to cancel the rAFs though because
			 * we register scrollLeft and scrollTop rAFs
			 * If the rAF of scrollLeft is responsible for cancelling the animation with .stop
			 * we need to prevent the rAF of scrollTop from firing and calling the .stop again
			 *
			 */
			if( data._stopped ) {
				return ;
			}
			
			if( remaining > 0 ) {
				this[ 'rAF' + prop ] = window.requestAnimationFrame( 
					progress.bind( 
						this, 
						prop, 
						final, 
						now, 
						diff, 
						initial, 
						total, 
						remaining, 
						timingFunction, 
						obj,
						data 
				) );

			}
			else {
				tryDequeue( obj.get( 0 ), false );
			}

		}

		function animateNonStandard( prop, final, element ) {
			var now = Date.now(),
			obj = $L( element ),
			tweenProps = $L.Tween.propHooks[ prop ],
			initial = getCurrentValueForNonStandards( prop, obj ),
			diff = final - initial,
			data = AniData.data[ element.lyteAnimateId ][ 0 ].options,

			// If duration is 0 make sure it is 1
			duration = data.duration || 1,
			aniProps = elData.get( element, 'animeProp' ),
			timingFunction,
			start = data.start,

			// fired is going to tell us whether start has fired or not
			fired = data.fired;

			// We don't do ease functions over here
			timingFunction = data.timingFunction = ( data.timingFunction === 'ease' ? 'ease-in-out' : data.timingFunction );

			if( start && !fired ) {
				data.fired = true;

				start.call( element, {
					options: data,
					from: aniProps.from,
					to: aniProps.to,
					value: data.value,
					startTime: now,

					// I think the target is wrong over here and over there in standard start section
					// TODO: fix target
					target: element,
					transitionProperty: Object.keys( aniProps.to )
				} );
			}

			element[ 'rAF' + prop ] = window.requestAnimationFrame( 
				progress.bind( 
					element, 
					prop, 
					final, 
					now, 
					diff, 
					initial, 
					duration, 
					duration, 
					timingFunction, 
					obj,
					data
			) );
		}

		// compStyles can be undefined when we are searching for a window
		function isStandard( prop, compStyles ) {
			return prop in ( compStyles || {} );
		}

		function getCurrentValueForNonStandards( key, obj ) {
			var tweenProps = $L.Tween.propHooks[ key ];

			if( 'get' in tweenProps ) {
				return tweenProps.get( obj );
			}
		
			return obj.get( 0 )[ key ];	
		}

		/**
		 * This tries to dequeue the animateProperty from the queue
		 * @param {DOMElement} item - item whose animation needs to be dequeued
		 * @param {Boolean} standard - whether it is a standard or a non standard property
		 *
		 */

		function tryDequeue( item, standard, forceRemove ) {
			if( !( AniData.data[ item.lyteAnimateId ] || [] )[ 0 ] ){
				return;
			}
			var anidata = AniData.data[ item.lyteAnimateId ][ 0 ],
			nsC = anidata.nonstandard || 0, 
			comp_standard = anidata.standard, 
			animates = elData.get( item, 'animeProp', 'animate' ) || [],
			comp_ns;

			// if( !animates.length ) {
			// 	return ;
			// }

			if( standard ) {
				anidata.standard = comp_standard = true;
			}
			else {
				nsC--;
				anidata.nonstandard = nsC;
			}

			// never going to be lesser but just a safety
			comp_ns = nsC <= 0 ? true : false; 

			// Both standard and non standard animations have completed
			if( forceRemove || comp_standard && comp_ns ) {
				AniData.dequeue( item, forceRemove );
			}
		}

		function getDefaultDisplay( elem ) {
			if( !elem.lyteAnimateId ) {
				AniData.add( elem );
			}
			var nodeName = elem.nodeName, display = elData.get( elem, 'displayValue' );

			if ( display ) {
				return display;
			}

			if( elem.hasAttribute( 'lyte-rendered' ) ){
				display = "block";
			} else {
				var owner = elem.ownerDocument,temp = owner.body.appendChild( owner.createElement( nodeName ) );
				display = owner.defaultView.getComputedStyle( temp ).display;
				owner.body.removeChild( temp );

				if ( display === "none" ) {
					display = "block";
				}
			}
			elData.set( elem, 'displayValue', display );
			return display;
		}

		function generateDummyProps ( prop, flag ) {
			var dummy = {};
			var arr = [ 'left', 'right', 'top', 'bottom' ];
			for( var i = 0; i < arr.length; i++ ){
				dummy[ 'margin-' + arr[ i ] ] = dummy[ 'padding-' + arr[ i ] ] = prop;
			}
			if( flag ){
				dummy.width = dummy.height = dummy.opacity = prop;
			}
			return dummy;
		}

		function showhide( elems, flag ) {
			var disps = []
			for( var i = 0; i < elems.length; i++ ) {
				var el = elems[ i ];
				AniData.add( el );
				var actDisp = el.style.display;
				if( flag ) {

					var $el = $L( el ),
					is_hidden;

					if( actDisp == 'none' ) {
						disps[ i ] = null || elData.get( el,'display' )
						if( !disps[ i ] ) {
							el.style.display = "";
							// this forced read is unavoidable. If that element contains another display none defined in class we need to find if its really hidden or not after modifying its inline display value
							if( is_hidden = ( $el.css( 'display' ) == "none" ) ){
								actDisp = "";
							} else {
								disps[ i ] = "";
							}
						}
					}
					if( actDisp == "" && ( is_hidden || $el.css( 'display' ) == "none" ) ){
						disps[ i ] = getDefaultDisplay( el );
					}
				}else if( actDisp != 'none' ) {
					disps[ i ] = 'none';
					elData.set( el,'display', actDisp );
				}
			}


			for( var j = 0; j < elems.length; j++ ) {
				$L( elems[ j ] ).css( 'display', disps[ j ] )
			}

			return elems;
		}

		function show() {
			return showhide( [ this ], true );
		}

		function hide() {
			return showhide( [ this ] );
		}

		function toggle( arg, prop ) {
			if( !isValid( arg, prop ) ) {
				return;
			}
			if( arg.constructor == Boolean ) {
				return showhide( [ this ], arg )
			}

			return $L.each( this, function() {
				toggle( this, $L( this ).css( 'display' ) != 'none' ) 
			})
		}

		function camelCase (string){
		return string.replace(/(-\w)/g, function (m) {
				return m[1].toUpperCase();
			});
		}

		function dasherize(string){
			return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
		}

		function AnimationData(){
			this.data = {};
		}

		function animationEnd(evt){
			if(evt.target == this){
				elData.get(this, 'endCallback').call(this, evt);
			}
		}

		AnimationData.prototype = {
			add : function(elem){
				if( elem.lyteAnimateId ){
					return elem.lyteAnimateId;
				}
				var randomId = 'lyteAnimate' + parseInt(Math.random() * Math.pow(10,6));
				elem.lyteAnimateId = randomId;
				this.data[randomId] = [];
				elem[elem.lyteAnimateId] = {}
				return randomId;
			},
			queue : function(elems, options, value){
				for(var i = 0; i < elems.length; i++){
					var el = elems[i];
					var id  = el.lyteAnimateId
					if(!id){
							id = this.add(el);
						}
					this.data[id].push({elem : el, options : options, value : value, properties : Object.keys(value)});
					if(this.data[id].length == 1){
						el.addEventListener('transitionend', animationEnd);
						this.next(el);	
					}
				}
			},
			dequeue : function(elem, forceRemove ){
				firecallback( elem, forceRemove );
				this.data[elem.lyteAnimateId].splice(0, 1);
				this.next(elem);
			},
			dequeueAll : function(elem){
				this.data[elem.lyteAnimateId] = this.data[elem.lyteAnimateId].splice();
				this.next(elem);
			},
			next : function(elems){
				clearTimeout( elems._nextime );
				elems._nextime = setTimeout(this.call.bind(this), 13, elems);
			},
			call : function(elem){
				delete elem._nextime;		
				if(elem.lyteAnimateId && this.data[elem.lyteAnimateId][0]){
						lyteAnimation.call(elem);
				}else{
					this.data[elem.lyteAnimateId] = [];
					elem.removeEventListener('transitionend', animationEnd);
				}	
			}
		}

		function ElementData(){
		}

		ElementData.prototype = {
			set :  function( arg0, arg1, arg2, arg3 ){

				var __length = arguments.length;

				if( __length < 3){
					return;
				}
				if( __length == 3){
					if( arg0[ arg0.lyteAnimateId] == undefined){
						arg0[ arg0.lyteAnimateId] = {};
					}
					arg0[ arg0.lyteAnimateId][ arg1 ] = arg2;
				}
				else if( __length == 4){
					if( arg0[ arg0.lyteAnimateId][ arg1 ] == undefined){
						arg0[ arg0.lyteAnimateId][ arg1 ] = {};
					}
					arg0[ arg0.lyteAnimateId][ arg1 ][ arg2 ] = arg3
				}

			},
			get : function( arg0, arg1, arg2 ){

				var __length = arguments.length;

				if( __length < 1){
					return;
				}
				if( __length == 1){
					return arg0[ arg0.lyteAnimateId];
				}
				else if( __length == 2){
					return arg0[ arg0.lyteAnimateId][ arg1 ];
				}
				else if( __length == 3){
					if( arg0[ arg0.lyteAnimateId][ arg1 ]){
						return arg0[ arg0.lyteAnimateId][ arg1 ][ arg2 ];
					}	
				}
				return;
			}
		}

		function checkCrctValue(value, key, camelCaseKey, compStyle){
			var valueCopy = value[key].toString();
			if(/^(\()/g.exec(valueCopy)){
				return valueCopy;
			}
			var operatorRegex = /^\+=|\-=|\*=|\/=/g, unitRegex = /cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|auto|vmin|vmax|%+$/ig, unit = valueCopy.match(unitRegex), finalVal = valueCopy.match(operatorRegex);
			if(compStyle[camelCaseKey] != "none" && !/matrix/ig.test(compStyle[camelCaseKey])){
				if(unit == null){
					var newUnit = compStyle[camelCaseKey].match(unitRegex);
					if(newUnit == null){
						unit = "";
					}else{
						if(newUnit[0] == 'auto'){
							unit = 'px';
						}else{
							unit = newUnit[0]
						}
					}
				}else{
					unit = unit[0];
					valueCopy = valueCopy.slice(0, valueCopy.indexOf(unit));
				}
			}else{
				unit = "";
			}
			if(finalVal){
				var temp = parseInt(compStyle[camelCaseKey]), split = valueCopy.split("=");
				temp = temp == NaN ? 0 : temp;
				switch(split[0]){
					case '/' : 
						valueCopy = temp  / parseFloat(split[1]);
						break;
					case '-' : 
						valueCopy = temp  - parseFloat(split[1]);
						break;
					case '*' : 
						valueCopy = temp  * parseFloat(split[1]);
						break;
					default : 
						valueCopy = temp  + parseFloat(split[1]);
				}
			}
			// return [valueCopy + unit, unit];
			return valueCopy + unit;

		}

		function lyteAnimation (){	
				var newObj = {}, 
				units = {},
				win = $L.isWindow( this ), 
				def = win ? false : this.ownerDocument.defaultView;

				$L.fastdom.measure( function(){
					// windows are not hidden but if it isn't a window, hidden is recaculated below
					var hidden = def;
					// We are ignoring if it is a window
					if( def ) {
						var compstyle = def.getComputedStyle( this );

						hidden = compstyle.display == "none";

						if( !hidden && !this.offsetParent ){
							autoAnimate.call( this )
							return;
						}
					}

					var anidata = AniData.data[this.lyteAnimateId][0];
					if( !anidata ){
						return;
					}
					var value = anidata.value, auto = [],
					keys = Object.keys( value ), value, animeProp = [], from = {}, to = {}, val,
					originalData = elData.get(this, 'animeProp', 'original');
					if( !originalData ){
						originalData = {};
						elData.set( this, 'animeProp', 'original', originalData )
					}

					$L.fastdom.mutate( function() {
						anidata = AniData.data[ this.lyteAnimateId ][ 0 ];
						if( !anidata ){
							return;
						}
						var flag = true, standardObj = {}, 
						compstyle, bcr, obj = $L( this ), standardPresent = false;

						for( var i = 0; i < keys.length; i++ ){
							var curkey = camelCase( keys[ i ] ), curval = value[ keys[ i ] ],

							// standard - properties that are present in the CSSStyleDeclaration
							// Non standard  - Eg: scrollTop
							val = null, standard;

							// Skipping if it is a window
							if( def && /show|hide|toggle/.test( curval ) ){
								if( curval == 'hide' || !hidden && curval == "toggle" ){
									val = "hide";
								} else if( curval == "show" || hidden && curval == "toggle" ){
									val = "show";
								}
								if( val == "show" && !hidden || val == "hide" && hidden ){
									continue;
								}
							}

							// Skipping if it is a window
							if( def && flag ){
								if( hidden ){
									if( this._lytedisplay == undefined ){
										this.style.display = getDefaultDisplay( this );
									} else {
										this.style.display = this._lytedisplay || '';

									}
								} else {
									this._lytedisplay = this.style.display;
								}
								// force measure needed
								compstyle = def.getComputedStyle( this );
								bcr = this.getBoundingClientRect();
								flag = false;
							}

							if( animeProp.indexOf( curkey ) == -1 ){
								animeProp.push( curkey );
							}

							standardObj[ curkey ] = standard = isStandard( curkey, compstyle );

							// We are checking if there is atleast 1 standard property
							// If there are no standard props we don't call autoanimate
							// else we do
							standardPresent = standardPresent || ( standard ? true : false );

							/* Element is not hidden */
							if( !hidden ) {
								if( val != "hide" ) {
									// There is a difference between getting a non standard from an object 
									// and a non standard from a DOM. If you are getting it from the DOM you need to use the getter
									// from tweenProps else you can just get it from the object.
									to[ curkey ] = !standard ? 
													value[ keys[ i ] ] : 
													checkCrctValue( value, keys[ i ], curkey, compstyle );
								} else{
									/* This gets fired when they are trying to hide an element 
									which doesn't happen with scrollTo or non standard animations */
									originalData[ curkey ] = this.style[ curkey ];
									to[ curkey ] =  0;
								}

								from[ curkey ] = !standard ? getCurrentValueForNonStandards( curkey, obj ) : compstyle[ curkey ];
							} else {
								if( val != "show" ){
									from[ curkey ] = !standard ? getCurrentValueForNonStandards( curkey, obj ) : compstyle[ curkey ];
								} else {
									originalData[ curkey ] = this.style[ curkey ];
									from[ curkey ] = 0;
								}

								to[ curkey ] = !standard ? 
												value[ keys[ i ] ] 
												: !val ? 
													checkCrctValue( value, keys[ i ], curkey, compstyle ) 
													: compstyle[ curkey ];
							}

							if( parseFloat( to[ curkey ] ) == parseFloat( from[ curkey ] ) || /auto/.test( to[ curkey ] ) || /auto/.test( from[ curkey ] ) ){
								delete from[ curkey ]; delete to[ curkey ]; 
								var index = animeProp.indexOf( curkey );

								if( index > -1 ) {
									animeProp.splice( index, 1 );
								}
							}
						}

						elData.set( this, 'animeProp', 'from', from );
						elData.set( this, 'animeProp', 'to', to );
						elData.set( this, 'animeProp', 'mode', val );
						elData.set( this, 'animeProp', 'animate', animeProp );
						elData.set( this, 'animeProp', 'standardObj', standardObj );


						// We just set this to true when we are about to animate any property( standard or nonstandard )
						// and set it to false inside autoanimate after standards finish animating
						// elData.set( this, 'animeProp', 'standard', false );
						// false as in standard has not finished
						// true as in there are no standards and we consider it to be finished
						anidata.standard = !standardPresent;

						if( !standardPresent && $L.isEmptyObject( to ) ) {
							// If there are no properties to animate just dumpster it 
							tryDequeue( this );
						}

						// Froms are used to animate standard properties, non-standards don't really care about them
						if( standardPresent ) {
							$L.each( from, function( prop, val ) {
								if( standardObj[ prop ] ) {
									this.style[ prop ] = val;
								}
							}.bind( this ) );

							autoAnimate.call( this );	
						}
						

						// Tos are used to animate non standard properties
						$L.each( to, function( prop, val ) {
							var nsC = anidata.nonstandard || 0;

							if( !standardObj[ prop ] ) {
								// Maintaining a count of the number of nonstandards that are getting animated
								// Will be decreased by 1 when their animation stops
								// We don't maintain a count for standards because they are all animated at once
								// which is not the case for nonstandards
								anidata.nonstandard = nsC + 1;
								animateNonStandard( prop, val, this );
							}
						}.bind( this ) );
						
						// When both standards and non standards finish we dequeue	

					}.bind( this ))
				}.bind( this ))
		}

		function constructCss(){
			if( !document.body.contains( this ) ){
				return;
			}
			var opts = AniData.data[this.lyteAnimateId][0].options,
			defaultOpts = ['timingFunction', 'duration', 'delay'], constyle="",
			value  =  Object.keys(AniData.data[this.lyteAnimateId][0].value || {});
			for(var i = 0; i < defaultOpts.length; i++){
				if(defaultOpts[i] in opts){
					var sec = '';
					if(defaultOpts[i] == 'delay' || defaultOpts[i] == 'duration'){
						if(!/[ms|s]+/ig.test(opts[defaultOpts[i]])){
							sec = 'ms'
						}
					}
					constyle += 'transition-' + dasherize(defaultOpts[i]) + ':' + opts [defaultOpts[i]] + sec + ";";
				}
			}
			if(value.length)
				{
					constyle += 'transition-property : ';
					for(var j = 0; j < value.length; j++){
						constyle += j > 0 ? ','+ dasherize(value[j]) : dasherize(value[j]);
					}
				}
			return constyle += ";";
		}

		function removeStyle(){
			this.style.removeProperty('transition');
		}

		function autoAnimate () {
			if( ( elData.get(this, 'animeProp', 'animate') || [] ).length) {

					removeStyle.call(this);
					var newstyle = constructCss.call(this);
					elData.set(this, 'endCallback', function(evt){				
						evt.type != 'timeout' && evt.stopPropagation();
						var props = elData.get(this, 'animeProp', 'animate');
						if( !AniData.data[this.lyteAnimateId].length ){
							return;
						}
						var propLength = elData.get(this, 'propertyCount');
						if( evt.type == 'timeout' ){
							propLength = props.length - 1;
						}
						elData.set(this, 'propertyCount', ++propLength);
						if(props.length == propLength)
							{
								clearTimeout( this._anitime ); delete this._anitime;
								// clearTimeout( this._styletime ); delete this._styletime;	
								removeStyle.call(this);
								var mode = elData.get(this, 'animeProp', 'mode'), original = elData.get(this, 'animeProp', 'original');
								if(mode){
									if(mode == 'hide'){
										if( evt.type == "timeout" ){
											hide.call(this);
											$L.each( original, function( prop, value ){
												$L( this ).css( prop, value );
											}.bind( this ))

											tryDequeue( this, true );
										} else {
											setTimeout(function(){
												hide.call(this);
												$L.each( original, function( prop, value ){
													$L( this ).css( prop, value );
												}.bind( this ))

												tryDequeue( this, true );
											}.bind(this), 20);
											}
										}
									else{
										$L.each( original, function( prop, value ){
											$L( this ).css( prop, value );
										}.bind( this ))

										tryDequeue( this, true );
									}
								}else{	

									tryDequeue( this, true );
								}
								
								setTimeout(function(){
									this.style.overflow = this._orioverflow;
									delete this._orioverflow;
								}.bind(this), 20);	
							}
					});
					this._orioverflow = this.style.overflow;
					this.style.overflow = "hidden";
					elData.set(this, 'propertyCount', 0);
					this._styletime =  setTimeout( function(){
						delete this._styletime;
						var sty = $L(this).attr('style');
						$L(this).attr('style', ( sty ? ( sty + ';' ) : "") + newstyle );
						setTimeout(dummy.bind(this), 20);
					}.bind( this ), 20 )
				}
			else{

				tryDequeue( this, true );
			}		

		}

		function dummy(){
				var anidata = AniData.data[this.lyteAnimateId][0];
				if(anidata){
					var options = anidata.options,
					currTime = Date.now(),

					// The fired is going to tell us whether the start callback has been fired or not
					fired = options.fired;

					elData.set(this, 'animeProp', 'startTime', currTime);
					var aniProp = elData.get(this, 'animeProp');

					if( options.start && !fired ) {
						options.fired = true;
						// TODO: fix target

						options.start.call(this, {options : options, from : aniProp.from, to : aniProp.to, value : AniData.data[this.lyteAnimateId][0].value, startTime : currTime, target : this, transitionProperty : Object.keys(aniProp.to)});
					}
					var elem = this;
					$L.each(elData.get(this, 'animeProp', 'to'), function(prop, val){
						$L(elem).css(prop, val);
					})
					this._anitime = setTimeout( animationEnd.bind( this, { type : "timeout", target : this } ), returntran( options.duration.toString() ) + 10 )
				}else{
					removeStyle.call(this);
					this.removeEventListener('transitionend', animationEnd);
				}
		}

		function returntran( prop ){
			var ret = 0;
			if( /\d+/.test( prop ) ){
				var match = prop.match( /(\d+)(s|ms){0,}$/ );
				ret = parseFloat( match[ 1 ] ) * ( match[ 2 ] == "s" ? 1000 : 1 );
			}
			return ret;
		} 

		elData = new ElementData();
		AniData = new AnimationData();

		function getCorrectOption (duration, ease, callbacks){
			var obj = {};
			if(callbacks){
				if(callbacks.constructor == Function){
					obj.complete = callbacks;
				}
			}
			if(ease){
				if(ease.constructor == Function){
					obj.complete = ease;
				}
				else if(ease.constructor == Object){
					$L.extend( obj, ease );
					// Object.assign(obj, ease);
				}
				else if(ease.constructor == String){
					obj.timingFunction = ease;
				}
			}
			if(duration != undefined){
				if(duration.constructor == Object){
					$L.extend( obj, duration );
					// Object.assign(obj, duration);
				}
				else if(duration.constructor == Number){
					obj.duration = duration
				}
				else if(duration.constructor == Function){
					obj.complete = duration
				}
			}
			if(obj.delay != undefined ){
				if(/[s]+/ig.test(obj.delay)){
					window.options.delay = parseInt(options.delay) * 1000;
				}
			}
			if(!('duration' in obj)){
				obj.duration = 400;
			}
			if(/[s]+/ig.test(obj.duration)){
					window.options.duration = parseInt(options.duration) * 1000;
				}
			if(!obj.timingFunction){
				obj.timingFunction = "ease";
			}	
			return obj;
		}

		function replaceStyle( props, from, percent ) {
			$L(this).css(props, this.style[props].replace(/([0-9.-]+)/, function(arg){
				return ((parseFloat(arg) - from) * percent + from);
			}))
		}

		function stopAnimation(jumpToEnd, clearQueue){
			if(jumpToEnd){
				var propLength = elData.get(this, 'propertyCount');
				elData.set(this, 'propertyCount', ( elData.get(this, 'animeProp', 'animate') || [] ).length - 1);
				// this.dispatchEvent(new Event('transitionend'));
				animationEnd.call( this, { target : this, type : 'timeout' } );
				if(clearQueue){
					AniData.dequeueAll(this);
				}
			}else{
				// issues in stop with JumpToEnd false. Need to be fixed after 2.0 release
				var data = AniData.data[this.lyteAnimateId];
				if( !data ) {
					return
				}
				clearTimeout( this._anitime ); delete this._anitime;
				var options = data[0].options, animate = elData.get(this, 'animeProp');
				var currTime = Date.now(), val, from = animate.from, to = animate.to;
				var startTime = animate.startTime;
				var remain = Math.max(0, startTime + options.duration - currTime);
				var percent = 1 - (remain / options.duration);
				var props = Object.keys(animate.to || {});
				var standardObj = elData.get( this, 'animeProp', 'standardObj' );


				for(var i = 0; i < props.length; i++){
					if( !standardObj[ props[ i ] ] ) {
						window.cancelAnimationFrame( this[ 'rAF' + props[ i ] ] );
						tryDequeue( this, false );
						continue;
					}

					tryDequeue( this, true );
					var from1 = from[props[i]];
					if( from1 == 'none' && !( /deg/ig.test( from1 ) ) ){
						from1 = 1
					}
					from1 = parseInt( from1 )
					from1 = isNaN(from1) ? 0 : from1;
					replaceStyle.call( this, props[ i ], from1, percent )
				}
				$L(this).css('transition', '');
				if(clearQueue){
					AniData.dequeueAll(this);
				}
				// else{
				// 	AniData.dequeue(this);
				// }
			}
		}

		function isValid( bol, prop ){
			if( ( prop == 'hide' && bol ) || ( prop == 'show' && !bol ) ){
				return false;
			}
			return true
		}

		// if( $L ){
			$L.prototype.animate = function(){
				if(arguments.length)
					{
						var opts = getCorrectOption(arguments[1], arguments[2], arguments[3]);
						AniData.queue(this, opts, arguments[0]);
					}
				return this;
			}

			$L.prototype.fadeTo = function( value, duration, ease, callback){
				if( duration != undefined && duration.constructor == Number ){
					if( duration < 1 ){
						var temp = duration;
						duration = value;
						value = temp;
					}
				}
				value = value || 0;
				var opts = getCorrectOption(duration, ease, callback);
				AniData.queue(this, opts, value.constructor == Object ? value :  {opacity : value});
				return this;
			}

			$L.each({
					fadeIn : { opacity : 'show'}, 
					fadeOut : { opacity : 'hide' }, 
					fadeToggle : { opacity : 'toggle'},
					slideUp : { height : 'hide', paddingTop : "hide", paddingBottom : "hide", marginTop : "hide", marginBottom : "hide" },
					slideDown : {height : 'show', paddingTop : "show", paddingBottom : "show", marginTop : "show", marginBottom : "show" },
					slideToggle :  { height : 'toggle', paddingTop : "toggle", paddingBottom : "toggle", marginTop : "toggle", marginBottom : "toggle"}
				}, function(property, value){
					$L.prototype[property] = function(duration, ease, callback){
					return this.animate(value, duration, ease, callback);
					}
			})

			$L.prototype.stop = function(clearQueue, jumpToEnd){
				return $L.each(this, function(){
					stopAnimation.call(this, jumpToEnd != undefined ? jumpToEnd : true, clearQueue);
				})
			}

			$L.prototype.finish = function( jumpToEnd ){
				return $L.each(this, function(){
					var queues = AniData.data[this.lyteAnimateId];
					if( queues && queues.length )
						{
							for(var i = 1; i < queues.length; i++){
								queues[i].options.duration = 1;
							}
							// setTimeout( stopAnimation.bind( this, true, false ), 13 );
							stopAnimation.call(this, true, false);
						}
				})
			}

			$L.each({
					show : generateDummyProps('show', true), 
					hide : generateDummyProps('hide', true), 
					toggle : generateDummyProps('toggle', true)
				}, function(property, value){
					$L.prototype[property] = function(duration, ease, callback){
					if(duration && duration.constructor != Boolean){
							return this.animate(value, duration, ease, callback);
						}
					return $L.each(this, function(){
							toggle.call(this, $L(this).css('display') == 'none', property);
						})
					}
			})
		// }

		$L.animate = {
			tryDequeue: tryDequeue
		};
	}
} );
( function( factory ) {
    if( typeof define === "function" && define.amd ) {
        define( [ "@zoho/lyte-dom" ], factory );
    }
    else {
        factory( $L );
    }
} )( function( $L ) {
    if( $L.media ) {
        return ;
    }

    var audioContext, intervalId, config, microphone, inputNode, wavProcessingNode, worker, stopped;

    var isSafari = /^((?!chrome|android).)*safari/i.test(window.navigator.userAgent);

    $L.media = {};

    var sendBlobToUser = function( event ) {
        var blob = event.data[ 0 ],
        samples = event.data[ 1 ];

        if( stopped && config.onStop ) {
            config.onStop( blob, samples );
        }

        if( config.onEnd ) {
            config.onEnd( blob, samples );
        }

        // var a = document.createElement( 'a' );
        // a.setAttribute( 'download', 'testing' );
        // var url = window.URL.createObjectURL( blob );
        // a.setAttribute( 'href', url );
        // document.body.appendChild( a );
        // a.click();
        // a.remove();
    }

    

    $L.media.record = async function( options ) {
        config = options || {};

        var audioContextConstructor =  window.AudioContext || window.webkitAudioContext,
        basePath = config.workletBasePath || '';

        audioContext = new audioContextConstructor();

        microphone = await window.navigator.mediaDevices.getUserMedia( {
            audio: true
        } );

        registerWorker();

        inputNode = audioContext.createMediaStreamSource( microphone );

        if( isSafari ) {
            useScriptProcessorNode( inputNode.context, inputNode );
        }
        else {
            useAudioWorklet( audioContext, basePath, inputNode );
        }
        
    }

    function useScriptProcessorNode( context, inputNode ) {
        var bufferSize = 4096,
        inputChannel = 1,
        outputChannel = 1, 
        node = ( context.createScriptProcessor || context.createJavascriptProcessor ).call( context, bufferSize, inputChannel, outputChannel );

        inputNode.connect( node );
        node.connect( context.destination );

        node.onaudioprocess = ( audioProcessingEvent ) => {
            for( var i = 0; i < inputChannel; i++ ) {
                var channelData = audioProcessingEvent.inputBuffer.getChannelData( i );

                if( config.onProgress ) {
                    config.onProgress( channelData );
                }

                worker.postMessage( { type: 'data', data: channelData } );
            }
        };
    }

    async function useAudioWorklet( audioContext, basePath, inputNode ) {
        await audioContext.audioWorklet.addModule( basePath + 'audioSampleSender.js' );

        wavProcessingNode = new window.AudioWorkletNode( audioContext, 'audio-sample-processor' );

        inputNode.connect( wavProcessingNode );

        wavProcessingNode.connect( audioContext.destination );

        wavProcessingNode.port.onmessage = function ( e ) {
            if( config.onProgress ) {
                config.onProgress( e.data );
            }

            worker.postMessage( { type: 'data', data: e.data } );
        }

        enableChunking();
    }

    function registerWorker() {
        var basePath = config.workerBasePath || '';

        worker = new window.Worker( basePath + 'wavProcessor.js' );

        worker.onmessage = sendBlobToUser;
    }

    function enableChunking() {
        var timeslice = config.timeslice;

        if( !isNaN( timeslice ) ) {
            intervalId = setInterval( function() {
                worker.postMessage( { type: 'process' } );
            }, timeslice );
        }
    }

    $L.media.pause = function() {
        audioContext.suspend();
        window.clearTimeout( intervalId );
    }

    $L.media.resume = function() {
        /* pause, resume only works with this line. 
           Sometimes resuming(resuming after pausing it for a while) is not sending any data to audioWorkletProcessor(input is empty array)
        */ 
        inputNode.connect( wavProcessingNode );
        enableChunking();
        audioContext.resume();        
    }

    $L.media.stop = function() {
        stopped = true;
        stopMediaStream();
        
        window.clearTimeout( intervalId );

        worker.postMessage( { type: 'process' } );
    }

    function stopMediaStream() {
        var tracks = microphone.getAudioTracks();

        for( var i = 0; i < tracks.length; i++ ) {
            tracks[ i ].stop();
        }

        audioContext.close();
    }
} );


( function( factory ) {
    if( typeof define === "function" && define.amd ) {
        define( [ "@zoho/lyte-dom" ], factory );
    }
    else {
        factory( $L );
    }
} )(function( $L ) {

	var lyteCaretHelper = {
		isPlainObject : function(obj){
			if (typeof obj == 'object' && obj !== null) {
				if (typeof Object.getPrototypeOf == 'function') {	// If Object.getPrototypeOf supported, use it
					var proto = Object.getPrototypeOf(obj);
					return proto === Object.prototype || proto === null;
				}
				// Otherwise, use internal class
			    // This should be reliable as if getPrototypeOf not supported, is pre-ES5
				return Object.prototype.toString.call(obj) == '[object Object]';
			}
			return false;
		},

		contentEditable : function(inputElem){
			return !!(inputElem.contentEditable && inputElem.contentEditable === 'true');
		}
	}

	if($L){	
		
		$L.prototype.caret = function(query,value,iframe) {
			var settings;

			var InputFn = function(){
				return {
					contentEditable : false,
					getIEPos : function(){
						var endRange, inputElem, len, msg, pos, range, textRange;
					    inputElem = settings.element;
					    range = settings.document.selection.createRange();
					    pos = 0;
					    if (range && range.parentElement() === inputElem) {
					    	msg = inputElem.value.replace(/\r\n/g, "\n");
					    	len = msg.length;
					    	textRange = inputElem.createTextRange();
					    	textRange.moveToBookmark(range.getBookmark());
					    	endRange = inputElem.createTextRange();
					    	endRange.collapse(false);
					    	if (textRange.compareEndPoints("StartToEnd", endRange) > -1) {
					    		pos = len;
					    	}
					    	else{
					    		pos = -textRange.moveStart("character", -len);
					    	}
					    }
					    return pos;
					},

					getPos : function() {
						if (settings.document.selection) {
							return this.getIEPos();
						} else {
							return settings.element.selectionStart;
						}
					},

					setPos : function(pos){
						var inputElem, range;
					    inputElem = settings.element;
					    if (settings.document.selection) {
					    	range = inputElem.createTextRange();
    						range.move("character", pos);
    						range.select();
					    } else if (inputElem.setSelectionRange) {
					    	inputElem.setSelectionRange(pos, pos);
					    }
					    return inputElem;
					},

					getIEOffset : function(pos){
						var h, textRange, x, y;
					    textRange = settings.element.createTextRange();
					    pos || (pos = this.getPos());
					    textRange.move('character', pos);
					    x = textRange.boundingLeft;
					    y = textRange.boundingTop;
					    h = textRange.boundingHeight;
					    return {
    						left: x,
    						top: y,
    						height: h
    					};
					},

					getOffset : function(pos){
						var inputElem, offset, position;
					    inputElem = settings.element;
					    if (settings.document.selection) {
					    	offset = this.getIEOffset(pos);
					    	offset.top += $L(settings.window).scrollTop() + settings.domObj.scrollTop();
					    	return offset;
					    } else {
					    	offset = settings.domObj.offset();
    						position = this.getPosition(pos);
    						return offset = {
    							left: offset.left + position.left - settings.domObj.scrollLeft(),
    							top: offset.top + position.top - settings.domObj.scrollTop(),
    							height: position.height
    						};
					    }
					},

					getPosition : function(pos){
						var inputElem, startString, endString, html, cloneObj;
					    inputElem = settings.element;
					    if (pos === undefined) {
					    	pos = this.getPos();
					    }
					    startString = settings.domObj.val().slice(0, pos);
					    endString = settings.domObj.val().slice(pos);
					    cloneObj = new Clone();
					    return cloneObj.createClone(this.createHTML(startString,endString)).getPosition();
					},

					getIEPosition : function(pos) {
					    var h, inputOffset, offset, x, y;
					    offset = this.getIEOffset(pos);
					    inputOffset = settings.domObj.offset();
					    x = offset.left - inputOffset.left;
					    y = offset.top - inputOffset.top;
					    h = offset.height;
					    return {
					    	left: x,
					    	top: y,
					    	height: h
					    };
					},

					createHTML : function(startString, endString){
						return ("<span style='position: relative; display: inline;'>" + this.htmlEncode(startString) + "</span>"+
								"<span id='caret' style='position: relative; display: inline;'>|</span>" +
								"<span style='position: relative; display: inline;'>" + this.htmlEncode(endString) + "</span>");
					},

					htmlEncode : function(value) {	//To replace special characters, break and space iwth their respective tags
				    	value = value.replace(/<|>|`|"|&/g, '?').replace(/\r\n|\r|\n/g, "<br/>");
				    	if (/firefox/i.test(window.navigator.userAgent)) {
					        value = value.replace(/\s/g, '&nbsp;');
					    }
					    return value;
				    }
				};
			};

			var Clone = function(){
				return {
					css_attr : ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopStyle", "borderRightStyle", "borderBottomStyle", "borderLeftStyle", "borderTopWidth", "boxSizing", "fontFamily", "fontSize", "fontWeight", "height", "letterSpacing", "lineHeight", "marginBottom", "marginLeft", "marginRight", "marginTop", "outlineWidth", "overflow", "overflowX", "overflowY", "paddingBottom", "paddingLeft", "paddingRight", "paddingTop", "textAlign", "textOverflow", "textTransform", "whiteSpace", "wordBreak", "wordWrap","wordSpacing"],

					copyCss : function() {
					    var css;
					    css = {
					    	position: 'absolute',
					    	left: -9999,
					    	top: 0,
					    	zIndex: -20000
					    };
					    if (settings.domObj.prop('tagName') === 'TEXTAREA') {
					    	this.css_attr.push('width');
					    }
					    $L(this.css_attr).each(function(i, p) {
					    	return css[p] = settings.domObj.css(p);
					    });
					    return css;
					},

					createClone : function(html){
						this.clone = $L('<div></div>');
					    this.clone.css(this.copyCss());
					    this.clone[0].innerHTML = html;
					    window._lyteUiUtils.insertAfter(settings.element,this.clone[0]);
					    return this;
					},

					getPosition : function() {
					    var flag, pos, rect;
					    flag = this.clone.find("#caret");
					    pos = flag.position();
					    rect = {
					    	left: pos.left,
					    	top: pos.top,
					    	height: flag.height()
					    };
					    this.clone[0].remove();
					    return rect;
					}
				};
			};

			var EditableFn = function(){
				return{
					contentEditable : true,
					setPos : function(pos) {
						var offset, found, result, fun, sel = settings.window.getSelection();
						if(sel){
							offset = 0;
							found = false;
							fun = function(pos, parent){
								var node, range, i, len, childNodes, result;
						        childNodes = parent.childNodes;
						        result = [];
						        for (i = 0, len = childNodes.length; i < len; i++) {
						        	node = childNodes[i];
							        if (found) {
							            break;
							        }
							        if (node.nodeType === 3) {
							            if (offset + node.length >= pos) {
							            	found = true;
							            	range = settings.document.createRange();
							            	range.setStart(node, pos - offset);
							            	sel.removeAllRanges();
							            	sel.addRange(range);
							            	break;
							            } else {
							            	result.push(offset += node.length);
							            }
							        } else {
							            result.push(fun(pos, node));
							        }
						        }
						        return result;
							}
							result = fun.call(this,pos,settings.element);
						}
						return settings.element;
					},

					getIEPosition : function() {
					    return this.getPosition();
					},

					/*
						* get the caret offset 
						* subtract the content editable element's offset from that will give the position.
					*/
					getPosition : function() {
					    var inputElemffset, offset;
					    offset = this.getOffset();
					    inputElemffset = settings.domObj.offset();
					    offset.left -= inputElemffset.left;
					    offset.top -= inputElemffset.top;
					    return offset;
					},

					getIEPos : function() {
					    var preCaretTextRange, textRange;
					    textRange = settings.document.selection.createRange();
					    preCaretTextRange = settings.document.body.createTextRange();
					    preCaretTextRange.moveToElementText(settings.element);
					    preCaretTextRange.setEndPoint("EndToEnd", textRange);
					    return preCaretTextRange.text.length;
					},

					/*
						* if range available
							* clone range
							* make cloned range to contain the contents of the contentEditable element
							* set the end of the cloned range to the value of the endContainer's end offset (ie. caret position)
							* get the cloned range's string length which will be the position of the caret
							* detach (used to disable the Range object and enable the browser to release associated resources) it.
						* else its IE browser and call the respective getPos method.
					*/
					getPos : function() {
					    var clonedRange, pos, range;
					    if (range = this.getRange()) {
					    	clonedRange = range.cloneRange();
					    	clonedRange.selectNodeContents(settings.element);
					    	clonedRange.setEnd(range.endContainer, range.endOffset);
					    	pos = clonedRange.toString().length;
					    	clonedRange.detach();
					    	return pos;
					    } else if (settings.document.selection) {
					    	return this.getIEPos();
					    }
					},

					getIEOffset : function() {
					    var range, rect;
					    range = settings.document.selection.createRange().duplicate();
					    range.moveStart("character", -1);
					    rect = range.getBoundingClientRect();
					    return {
					    	height: rect.bottom - rect.top,
					    	left: rect.left,
					    	top: rect.top
					    };
					},

					/*
						* get the range Object - fragment of document that can contain nodes and parts of text nodes
						* if (caret is not at the strating position ie. 0)
							* clone the range object and set its start (=> start = end-1) and end
							* calculate the client rect of the clone
							* detach (used to disable the Range object and enable the browser to release associated resources) it.
						* else if (caret position == 0)
							* clone the range object
							* create a text node with pipe character('|') and insert it in the range node.
							* select the created node and calculate the client rect.
							* remove the created node 
							* detach (used to disable the Range object and enable the browser to release associated resources) it.
					*/
					getOffset : function(pos) {
					    var clonedRange, offset, range, rect, shadowCaret;
					    if (settings.window.getSelection && (range = this.getRange())) {
					    	if (range.endOffset - 1 > 0 && range.endContainer !== settings.element) {
						        clonedRange = range.cloneRange();
						        clonedRange.setStart(range.endContainer, range.endOffset - 1);
						        clonedRange.setEnd(range.endContainer, range.endOffset);
						        rect = clonedRange.getBoundingClientRect();
						        offset = {
						          height: rect.height,
						          left: rect.left + rect.width,
						          top: rect.top
						        };
						        clonedRange.detach();
					    	}
					    	if (!offset || (offset != null ? offset.height : undefined) === 0) {
						        clonedRange = range.cloneRange();
						        shadowCaret = settings.document.createTextNode("|");
						        clonedRange.insertNode(shadowCaret);
						        clonedRange.selectNode(shadowCaret);
						        rect = clonedRange.getBoundingClientRect();
						        offset = {
						          height: rect.height,
						          left: rect.left,
						          top: rect.top
						        };
						        shadowCaret.remove();
						        clonedRange.detach();
					    	}
					    } else if (settings.document.selection) {
					    	offset = this.getIEOffset();
					    }
					    if (offset) {
					    	offset.top += $L(settings.window).scrollTop();
					    	offset.left += $L(settings.window).scrollLeft();
					    }
					    return offset;
					},

					/*
						* if window.getSelection available
							* get the selection object and return the range object from that
						* else return null
					*/
					getRange : function() {
					    var sel;
					    if (!settings.window.getSelection) {
					      return;
					    }
					    sel = settings.window.getSelection();
					    if (sel.rangeCount > 0) {
					      return sel.getRangeAt(0);
					    } else {
					      return null;
					    }
					}
				};
			};

			var setContextBy = function(mode){
				if (!!mode) {
					var iframe = mode != null ? mode.iframe : undefined;
					var fWindow = iframe.contentWindow;
					return{
						iframe : iframe,
						window : fWindow,
						document : iframe.contentDocument || fWindow.document
					}
				} else {
					return{
						iframe : undefined,
						window : window,
						document : document
					}
				}
			};

			if(lyteCaretHelper.isPlainObject(value)){
				settings = setContextBy(value);
				value = undefined;
			}
			else{
				settings = setContextBy(iframe);
			}
			if(this[0].tagName == "LYTE-INPUT"){
				if(this[0].ltProp('type') == "textarea"){
					settings.element = this[0].querySelector('textarea');
				}
				if(this[0].ltProp('type') == "text"){
					settings.element = this[0].querySelector('text');
				}
				settings.domObj = $L(settings.element);
			}
			else{
				settings.element = this[0];
				settings.domObj = this;
			}
			
			var executableObj = lyteCaretHelper.contentEditable(this[0]) ? new EditableFn() : new InputFn();

			if(query === "pos"){
				if (value || value === 0) {
			    	return executableObj.setPos(value);
			    } else {
			    	return executableObj.getPos();
			    }
			} else if(query === "position"){
				if (settings.document.selection) {
			    	return executableObj.getIEPosition(value);
			    } else {
			    	return executableObj.getPosition(value);
			    }
			}else if(query === "offset"){
				var offset;
			    offset = executableObj.getOffset(value);
			    return offset;
			} else{
				console.error("Sorry! The method ",query," doesn\'t match the predefined set of methods. Kindly check.");
				return null;
			}

	    	return this;
		}
		
	}

})

( function( factory ) {
	if( typeof define === "function" && define.amd ) {
        define( [ "@zoho/lyte-dom" ], factory );
    }
    else {
        factory( $L );
    }
} )( function( $L ) {
  if($L){

    $L.prototype.cropper = function(aRD){

      if( (aRD === "destroy") || (aRD === "Destroy")){

        var userImage = this[0];
        var userImageParent = userImage.parentElement
        var cropperWrapperDiv = $L(userImageParent).find('.lyteCropArea')[0];

        userImageParent.removeChild(cropperWrapperDiv);
        $L(userImage).data('cropper' , {})
        userImage.style.display = "block";

      } else {
        if(aRD){
          if(!aRD.type){
            aRD.type = 'default'
          }
        }
        if(aRD.type === 'default'){

                        /*
                          * getBoundingClientRect function
                        */
                        function getBCR(elem){
                          return elem.getBoundingClientRect();
                        }

                        /*
                          * Cropper global variables
                        */

                        // Parent image variables

                        var imageTag = this[0],imageData,naturalAR = 1,cropperDiv = imageTag.parentElement,aspectRatio = 'n:n',aspectDiff = 1,imageType,aR = aRD,initialRotateAngle;
                        var useExif = false;

                        if(aRD){
                          if(aRD.useExif){
                            useExif = aRD.useExif;
                          }
                        }

                        var beforeRender = function(){};
                        var afterRender = function(){};

                        if(aRD){
                          if(aRD.beforeRender){
                            beforeRender = aRD.beforeRender;
                          }
                          if(aRD.afterRender){
                            afterRender = aRD.afterRender;
                          }
                        }


                        var exifRotate=0,gotRotateData = false,exifRotateY = 0;
                        var imageOrientation = '';


                        function getImageExif(){
                          if($L.exif){
                            $L.exif({
                                target : imageTag,
                                getData : function(obj){
                    							imageTag = obj.target;
                    							if(window.getComputedStyle(imageTag).imageOrientation !== "from-image"){
                    								var rValue = obj.exifdata.Orientation;
                    								switch(rValue) {
                                      case 1 :
                                        exifRotate = 0;
                    										break;
                    									case 2 :
                                        exifRotate = 0;
                                        exifRotateY = 180;
                    										break;
                    									case 3 :
                                        exifRotate = 180;
                    										break;
                    									case 4 :
                                        exifRotate = 180;
                                        exifRotateY = 180;
                    										break;
                    									case 5 :
                                        exifRotate = 270;
                                        exifRotateY = 180;
                    										break;
                    									case 6 :
                                        exifRotate = 90;
                    										break;
                    									case 7 :
                                        exifRotate = 90;
                                        exifRotateY = 180;
                    										break;
                    									case 8 :
                                        exifRotate = 270;
                                        break;
                    						        }
                                        beforeRender(obj.exifdata.Orientation);
                                        gotRotateData = true;
                                        if(gotRotateData){
                                          loadCropper();
                                          if($L(imageTag).data('cropper')){
                                            initialRotateAngle = $L(imageTag).data('cropper').angle;
                                            exifRotateY = $L(imageTag).data('cropper').exifAngle;
                                          } else {
                                            initialRotateAngle = exifRotate;
                                          }
                                          imageTag.style.display = "none";
                                          constructor();
                                          afterRender();
                                        }
                    							}
                    						}
                            })
                          }
                        }






                        // if($L(imageTag).data('cropper')){
                        //   initialRotateAngle = $L(imageTag).data('cropper').angle;
                        // } else {
                        //   if(aRD.angle){
                        //     initialRotateAngle = aRD.angle;
                        //   } else {
                        //     initialRotateAngle = 0;
                        //   }
                        //
                        // }

                        if(!aR) {

                          aR = {
                            'aspectRatio' : 'n:n'
                          }

                        }

                        // Cropper variables

                        var cropArea , box , fixedDiv , opacityDiv , cropper , divImage , displayArea , displayImageDiv,topEdge , bottomEdge , leftEdge , rightEdge , topRightCorner , bottomRightCorner , topLeftCorner , bottomLeftCorner,mainImage , fixedImage , divImageImg , displayImage,cropVerGrid1 , cropVerGrid2 , cropVerGrid3 , cropHorGrid1 , cropHorGrid2 , cropHorGrid3,cropperParent,modalDets,topSpan , bottomSpan , leftSpan , rightSpan,cropData = {},cropStart = function(){},cropDrag = function(){} , onSet = function(){} , cropEnd = function(){};

                        // Cropper Dimension variables

                        var leastHeight , leastWidth , maxHeight , maxWidth;


                        // imageData = getBCR(imageTag);
                        // imageTag.style.display = "none";
                        // imageTag.addEventListener('load' , loadCropper);

                        /*
                          * Re create cropper
                        */


                        if(cropperDiv.querySelectorAll('.lyteCropArea').length !==0 ){
                          var element = cropperDiv.querySelectorAll('.lyteCropArea')[0];
                          exifRotateY = $L(imageTag).data('cropper').exifAngle;
                          if($L(imageTag).data('cropper')){
                            initialRotateAngle = $L(imageTag).data('cropper').angle;
                            exifRotateY = $L(imageTag).data('cropper').exifAngle;
                          } else {
                            initialRotateAngle = exifRotate;
                          }
                          cropperDiv.removeChild(element);
                          imageTag.style.display = "block";
                          imageData = getBCR(imageTag);
                        }


                        function loadCropper(){
                          if((imageTag.complete)&&(cropperDiv.querySelectorAll('.lyteCropArea').length ===0)){
                            imageData = getBCR(imageTag);
                            imageTag.style.display = "none";
                          }
                          imageTag.removeEventListener('load' , loadCropper);
                        }


                        /*
                          * Cropper element Creation
                        */

                        // Creating cropper elements

                        function createCropperElements(){

                          cropArea = document.createElement("DIV");
                          box = document.createElement("DIV");
                          fixedDiv = document.createElement("DIV");
                          opacityDiv = document.createElement("DIV");
                          divImage = document.createElement("DIV")
                          cropper = document.createElement("DIV");
                          topEdge = document.createElement("DIV");
                          bottomEdge = document.createElement("DIV");
                          leftEdge = document.createElement("DIV");
                          rightEdge = document.createElement("DIV");
                          topRightCorner = document.createElement("DIV");
                          topLeftCorner = document.createElement("DIV");
                          bottomRightCorner = document.createElement("DIV");
                          bottomLeftCorner = document.createElement("DIV");
                          cropVerGrid1 = document.createElement("SPAN");
                          cropVerGrid2 = document.createElement("SPAN");
                          cropHorGrid1 = document.createElement("SPAN");
                          cropHorGrid2 = document.createElement("SPAN");
                          topSpan = document.createElement("SPAN");
                          bottomSpan = document.createElement("SPAN");
                          leftSpan = document.createElement("SPAN");
                          rightSpan = document.createElement("SPAN");
                          mainImage = document.createElement("IMG")
                          fixedImage = document.createElement("IMG")
                          divImageImg = document.createElement("IMG");

                        }

                        // Appending cropper elements to dom

                        function appendCropperElements(){

                          createCropperElements();

                          cropperParent = imageTag.parentElement;

                          cropperParent.appendChild(cropArea);
                          cropArea.appendChild(box);
                          box.appendChild(fixedDiv);
                          fixedDiv.appendChild(fixedImage);
                          box.appendChild(opacityDiv);
                          box.appendChild(cropper);
                          cropper.appendChild(topEdge);
                          topEdge.appendChild(topSpan);
                          cropper.appendChild(bottomEdge);
                          bottomEdge.appendChild(bottomSpan)
                          cropper.appendChild(leftEdge);
                          leftEdge.appendChild(leftSpan)
                          cropper.appendChild(rightEdge);
                          rightEdge.appendChild(rightSpan);
                          cropper.appendChild(topRightCorner);
                          cropper.appendChild(topLeftCorner);
                          cropper.appendChild(bottomLeftCorner);
                          cropper.appendChild(bottomRightCorner);
                          cropper.appendChild(cropVerGrid1);
                          cropper.appendChild(cropVerGrid2);
                          cropper.appendChild(cropHorGrid1);
                          cropper.appendChild(cropHorGrid2);
                          cropper.appendChild(divImage);
                          divImage.appendChild(divImageImg);

                        }

                        // Setting class for cropper elements

                        function setClassAttribute(){

                          appendCropperElements();

                          cropArea.setAttribute("class" , "lyteCropArea");
                          mainImage.setAttribute("class" , "lyteCropMainImage");
                          box.setAttribute("class" , "lyteCropBox");
                          fixedDiv.setAttribute("class" , "lyteCropFixedDiv");
                          fixedImage.setAttribute("class" , "lyteCropFixedImage");
                          opacityDiv.setAttribute("class" , "lyteCropOpacityDiv");
                          cropper.setAttribute("class" , "lyteCropCropper");
                          cropVerGrid1.setAttribute("class" , "lytecropVerGrid1");
                          cropVerGrid2.setAttribute("class" , "lytecropVerGrid2");
                          cropHorGrid1.setAttribute("class" , "lytecropHorGrid1");
                          cropHorGrid2.setAttribute("class" , "lytecropHorGrid2");
                          topEdge.setAttribute("class" , "lyteCropTopEdge");
                          topSpan.setAttribute("class" , "lyteCropTopSpan");
                          bottomEdge.setAttribute("class" , "lyteCropBottomEdge");
                          bottomSpan.setAttribute("class" , "lyteCropBottomSpan");
                          leftEdge.setAttribute("class" , "lyteCropLeftEdge");
                          leftSpan.setAttribute("class" , "lyteCropLeftSpan");
                          rightEdge.setAttribute("class" , "lyteCropRightEdge");
                          rightSpan.setAttribute("class" , "lyteCropRightSpan");
                          topRightCorner.setAttribute("class" , "lyteCropTopRightCorner");
                          topLeftCorner.setAttribute("class" , "lyteCropTopLeftCorner");
                          bottomRightCorner.setAttribute("class" , "lyteCropBottomRightCorner");
                          bottomLeftCorner.setAttribute("class" , "lyteCropBottomLeftCorner");
                          divImage.setAttribute("class" , "lyteCropDivImage");
                          divImageImg.setAttribute("class" , "lyteCropDivImageImg");

                        }


                        /*
                          * Constructing cropper and assigning global values
                        */

                        function constructor(){

                          if(aR){

                            aspectRatio = aR.aspectRatio;

                          }

                          if(aR.cropStart){
                              cropStart = aR.cropStart;
                          }
                          if(aR.cropDrag){
                              cropDrag = aR.cropDrag;
                          }
                          if(aR.onSet){
                              onSet = aR.onSet;
                          }
                          if(aR.cropEnd){
                              cropEnd = aR.cropEnd;
                          }

                          switch (aspectRatio) {
                            case 'n:n': aspectDiff = undefined; break;
                            case '1:1': aspectDiff = 1/1; break;
                            case '2:3': aspectDiff = 2/3; break;
                            case '3:2': aspectDiff = 3/2; break;
                            case '4:3': aspectDiff = 4/3; break;
                            case '3:4': aspectDiff = 3/4; break;
                            case '16:9': aspectDiff = 16/9; break;
                            case '9:16': aspectDiff = 9/16; break;
                          }

                          naturalAR = imageTag.naturalWidth / imageTag.naturalHeight;

                          if(imageTag.naturalWidth > imageTag.naturalHeight){
                            imageType = 'landscape';
                          } else if(imageTag.naturalWidth <= imageTag.naturalHeight){
                            imageType = 'portrait';
                          }

                          setClassAttribute();

                          setCropperValues();

                          setMinAndMaxDim();

                          setCropperData();

                        }

                        /*
                          * Setting up cropper
                        */

                        // Setting least and max hwight and width

                        function setMinAndMaxDim(){

                          switch (aspectRatio) {
                            case 'n:n': getMinDim(1);getMaxDim(1); break;
                            case '1:1': getMinDim(aspectDiff);getMaxDim(aspectDiff); break;
                            case '2:3': getMinDim(aspectDiff);getMaxDim(aspectDiff); break;
                            case '3:2': getMinDim(aspectDiff);getMaxDim(aspectDiff); break;
                            case '4:3': getMinDim(aspectDiff);getMaxDim(aspectDiff); break;
                            case '3:4': getMinDim(aspectDiff);getMaxDim(aspectDiff); break;
                            case '16:9': getMinDim(aspectDiff);getMaxDim(aspectDiff); break;
                            case '9:16': getMinDim(aspectDiff);getMaxDim(aspectDiff); break;
                          }

                        }

                        function getMinDim(diff){

                            if(aR.minSize){
                              leastWidth = aR.minSize;
                              leastHeight = aR.minSize / diff;
                            } else {
                              leastWidth = 15;
                              leastHeight = 15 / diff;
                            }


                        }

                        function getMaxDim(diff){

                          var fixedImageData = getBCR(fixedImage);

                          if(imageType === 'landscape'){

                            if(aR.maxSize){
                                if(aR.maxSize > fixedImageData.width){
                                  maxHeight = fixedImageData.height;
                                  maxWidth = fixedImageData.height * diff;
                                  if(aspectRatio === "n:n"){
                                    maxHeight = fixedImageData.height;
                                    maxWidth = fixedImageData.width;
                                  }
                                } else {
                                  maxWidth = aR.maxSize;
                                  maxHeight = aR.maxSize / diff;
                                  if(aspectRatio === "n:n"){
                                    maxHeight = aR.maxSize;
                                    maxWidth = aR.maxSize;
                                  }
                                }
                            } else {
                              maxHeight = fixedImageData.height;
                              maxWidth = fixedImageData.height * diff;
                              if(aspectRatio === "n:n"){
                                maxHeight = fixedImageData.height;
                                maxWidth = fixedImageData.width;
                              }
                            }

                          } else if(imageType === 'portrait'){

                            if(aR.maxSize){
                                if(aR.maxSize > fixedImageData.height){
                                  maxHeight = fixedImageData.width / diff;
                                  maxWidth = fixedImageData.width;
                                  if(aspectRatio === "n:n"){
                                    maxHeight = fixedImageData.height;
                                    maxWidth = fixedImageData.width;
                                  }
                                } else {
                                  maxWidth = aR.maxSize * diff;
                                  maxHeight = aR.maxSize;
                                  if(aspectRatio === "n:n"){
                                    maxHeight = aR.maxSize;
                                    maxWidth = aR.maxSize;
                                  }
                                }
                            } else {
                              maxHeight = fixedImageData.width / diff;
                              maxWidth = fixedImageData.width;
                              if(aspectRatio === "n:n"){
                                maxHeight = fixedImageData.height;
                                maxWidth = fixedImageData.width;
                              }
                            }
                          }

                        }

                        // Initial cropper values

                        function setInitialValues(){

                          var initialValue = {};


                          fixedImage.src = mainImage.src = divImageImg.src = imageTag.src;

                          initialValue.cropperWidth = getInitialWidth(aspectDiff);
                          initialValue.cropperHeight = getInitialHeight(aspectDiff);

                          return initialValue;

                        }

                        function getInitialWidth(diff){

                          var initialWidth;

                          if(aR.selection){

                            if(aR.selection.size){

                              initialWidth = parseFloat(aR.selection.size);

                              if(aR.maxSize){
                                if(parseFloat(aR.maxSize) < parseFloat(aR.selection.size)){
                                  initialWidth = parseFloat(aR.maxSize);
                                }
                              }
                              if(aR.minSize){
                                if(parseFloat(aR.minSize) > parseFloat(aR.selection.size)){
                                  initialWidth = parseFloat(aR.minSize);
                                }

                              }

                            } else {

                              window.initialValue = widthHeightCal().width;

                            }

                          } else {

                            if(aspectRatio === 'n:n'){
                              initialWidth = getBCR(fixedImage).width;
                            } else {
                              initialWidth = widthHeightCal().width;
                            }

                          }

                          return initialWidth;

                        }

                        function getInitialHeight(diff){

                          if(aspectRatio === 'n:n'){
                            diff = 1;
                          }

                          var initialHeight;

                          if(aR.selection){



                            if(aR.selection.size){

                              initialHeight = parseFloat(aR.selection.size) / diff;

                              if(aR.maxSize){
                                if(parseFloat(aR.maxSize) < parseFloat(aR.selection.size)){
                                  initialHeight = parseFloat(aR.maxSize) / diff;
                                }
                              }
                              if(aR.minSize){
                                if(parseFloat(aR.minSize) > parseFloat(aR.selection.size)){
                                  initialHeight = parseFloat(aR.minSize) / diff;
                                }
                              }

                            } else {

                              initialHeight = widthHeightCal().height;

                            }


                          } else {

                            if(aspectRatio === "n:n"){
                              initialHeight = getBCR(fixedImage).height;
                            } else {
                              initialHeight = widthHeightCal().height;
                            }

                          }

                          return initialHeight;

                        }

                        function widthHeightCal(){

                          var value = {};

                          if(imageType === "landscape"){

                            value.width = getBCR(fixedImage).height * aspectDiff
                            value.height = getBCR(fixedImage).height;

                          } else {

                            value.width = getBCR(fixedImage).width;
                            value.height = getBCR(fixedImage).width / aspectDiff;

                          }

                          if(value.width > getBCR(fixedImage).width){

                            value.width = getBCR(fixedImage).width;
                            value.height = getBCR(fixedImage).width / aspectDiff;

                          }

                          if(value.height > getBCR(fixedImage).height){

                            value.height = getBCR(fixedImage).height;
                            value.width = getBCR(fixedImage).height * aspectDiff;

                          }

                          return value

                        }

                        function getImageValues(){
                          var value = {};
                          switch (imageType) {
                            case 'landscape':
                            value.imageWidth = getBCR(cropperParent).width;
                            value.imageHeight = getBCR(cropperParent).width / naturalAR;
                            break;
                            case 'portrait':
                            value.imageWidth = getBCR(cropperParent).height * naturalAR;
                            value.imageHeight = getBCR(cropperParent).height;
                            break;
                          }

                          return value;

                        }


                        function getImageXY(){

                          var value = {};

                          if(imageType === 'landscape'){
                            value.imageTop = (getBCR(cropperParent).height - getBCR(fixedImage).height)/2;
                            value.imageLeft = 0;
                          } else {
                            value.imageTop = 0;
                            if(window._lyteUiUtils.getRTL()){
                              value.imageLeft = "-"+(getBCR(cropperParent).width - getBCR(fixedImage).width)/2;
                            }else {
                              value.imageLeft = (getBCR(cropperParent).width - getBCR(fixedImage).width)/2;
                            }
                          }

                          return value;

                        }

                        function getCropperXY(){

                          var value = {};

                          if(aR.selection){

                            if(aR.selection.top){
                              value.cropperTop = cropperMaxXY().top;
                            } else {
                              value.cropperTop = getDefaultTopLeft().cropperTop;
                            }
                            if(aR.selection.left){
                              value.cropperLeft = cropperMaxXY().left;
                            } else {
                              value.cropperLeft = getDefaultTopLeft().cropperLeft;
                            }


                          } else {
                            value.cropperLeft = getDefaultTopLeft().cropperLeft;
                            value.cropperTop = getDefaultTopLeft().cropperTop;
                          }

                          return value;

                        }


                        function cropperMaxXY(){

                          var value = {};

                          if((parseFloat(aR.selection.top)+getBCR(cropper).height) > getBCR(opacityDiv).bottom){
                            value.top = getBCR(opacityDiv).height - getBCR(cropper).height;
                          } else {
                            value.top = parseFloat(aR.selection.top);
                          }
                          if((parseFloat(aR.selection.left)+getBCR(cropper).width) > getBCR(opacityDiv).right){
                            value.left = getBCR(opacityDiv).width - getBCR(cropper).width;
                          } else {
                            value.left = parseFloat(aR.selection.left);
                          }

                          return value;

                        }

                        function getDefaultTopLeft(){

                          var value = {};


                          if(imageType === 'portrait'){
                            value.cropperTop = (getBCR(opacityDiv).height - getBCR(cropper).height)/2;
                            value.cropperLeft = (getBCR(fixedImage).width - getBCR(cropper).width)/2;
                          } else {
                            value.cropperTop = (getBCR(opacityDiv).height - getBCR(cropper).height)/2;
                            value.cropperLeft = (getBCR(fixedImage).width - getBCR(cropper).width)/2;
                          }

                          return value;

                        }

                        function setCropperValues(){

                          var initialImageData = getImageValues();

                          fixedImage.style.height = initialImageData.imageHeight + "px";
                          fixedImage.style.width = initialImageData.imageWidth + "px";

                          divImageImg.style.height = initialImageData.imageHeight + "px";
                          divImageImg.style.width = initialImageData.imageWidth + "px";

                          cropArea.style.height = getBCR(fixedImage).height + "px";
                          cropArea.style.width = getBCR(fixedImage).width + "px";

                          var initialImageXY = getImageXY()

                          cropArea.style.left = initialImageXY.imageLeft + "px";
                          cropArea.style.top = initialImageXY.imageTop + "px";

                          var initialCropperData = setInitialValues();

                          cropper.style.height = initialCropperData.cropperHeight + "px";
                          cropper.style.width = initialCropperData.cropperWidth + "px";

                          var initialCropperXY = getCropperXY();

                          cropper.style.top = initialCropperXY.cropperTop + "px";
                          cropper.style.left = initialCropperXY.cropperLeft + "px";

                          divImageImg.style.left = - initialCropperXY.cropperLeft + "px";
                          divImageImg.style.top = - initialCropperXY.cropperTop + "px";

                          box.style.overflow = "unset";


                          var angle;
                          if(initialRotateAngle===90 || initialRotateAngle === 270){
                            var cropperDim = getBCR(cropper);
                            var cropAreaDim = getBCR(cropArea);
                            var imageDim = getBCR(fixedImage);
                            angle = initialRotateAngle;
                            var prevAng = initialRotateAngle - 90;
                            if(angle){
                              prevAng = initialRotateAngle - 90;
                              angle = initialRotateAngle;
                              if(angle >= 360){
                                angle = 0;
                              }
                              fixedImage.style.transform = "rotate("+angle+"deg) rotateY("+exifRotateY+"deg)";
                              divImageImg.style.transform = "rotate("+angle+"deg) rotateY("+exifRotateY+"deg)";
                            } else {
                              var angle = 90;
                              fixedImage.style.transform = "rotate("+angle+"deg) rotateY("+exifRotateY+"deg)";
                              divImageImg.style.transform = "rotate("+angle+"deg) rotateY("+exifRotateY+"deg)";
                            }
                            aspectDiff = 1/aspectDiff;
                            if(imageType === "landscape"){
                              imageType = "portrait";
                            } else {
                              imageType = "landscape";
                            }
                            setMinAndMaxDim();
                            positionCropper(cropperDim , cropAreaDim , imageDim , angle , prevAng);
                            // setMinAndMaxDim();
                          }
                          if((initialRotateAngle===180)||(initialRotateAngle === 0)){
                            angle = initialRotateAngle;
                            if(angle===0){
                              prevAng = initialRotateAngle - 90;
                              angle = initialRotateAngle;
                              if(angle >= 360){
                                angle = 0;
                              }
                              fixedImage.style.transform = "rotate("+angle+"deg) rotateY("+exifRotateY+"deg)";
                              divImageImg.style.transform = "rotate("+angle+"deg) rotateY("+exifRotateY+"deg)";
                            } else {
                              // var angle = 90;
                              fixedImage.style.transform = "rotate("+angle+"deg) rotateY("+exifRotateY+"deg)";
                              divImageImg.style.transform = "rotate("+angle+"deg) rotateY("+exifRotateY+"deg)";
                            }
                          }

                          setCropperData();

                          cropper.addEventListener("mousedown" , cropImage);

                        }

                        if((window.getComputedStyle(imageTag).imageOrientation !== 'from-image')&&(useExif)){

                          getImageExif();

                        } else {
                          beforeRender();
                          loadCropper();
                          constructor();
                          afterRender();
                        }


                        function cropImage(event){

                          cropStart();

                          cropVerGrid1.style.opacity = cropVerGrid2.style.opacity = cropHorGrid1.style.opacity = cropHorGrid2.style.opacity = 1;

                          opacityDiv.style.opacity = "0.6";

                          event.preventDefault();

                          var todo;
                          if((event.target.className === "lyteCropDivImageImg")||(event.target.className === "lyteCropDivImage")){
                            todo = "parent";
                          } else {
                            todo = "child"
                          }


                          var topEdge           =  $L('.lyteCropTopEdge')[0],
                              rightEdge         =  $L('.lyteCropRightEdge')[0],
                              bottomEdge        =  $L('.lyteCropBottomEdge')[0],
                              leftEdge          =  $L('.lyteCropLeftEdge')[0],
                              topRightCorner    =  $L('.lyteCropTopRightCorner')[0],
                              bottomRightCorner =  $L('.lyteCropBottomRightCorner')[0],
                              bottomLeftCorner  =  $L('.lyteCropBottomLeftCorner')[0],
                              topLeftCorner     =  $L('.lyteCropTopLeftCorner')[0];


                          switch(todo){

                            case "parent" :

                              if((event.target.className === 'lyteCropDivImage')||(event.target.className === 'lyteCropDivImageImg')){

                                var cropperMoveData = getBCR(cropper),
                                    opacityDivMoveData = getBCR(opacityDiv),
                                    cropAreaMoveData = getBCR(cropArea),
                                    boxMoveData = getBCR(box),
                                    fixedImageMoveData = getBCR(fixedImage),
                                    previousClientX = event.clientX,
                                    previousClientY = event.clientY,
                                    finalLeft = opacityDivMoveData.left - cropAreaMoveData.left,
                                    finalRight = opacityDivMoveData.right - cropperMoveData.width - boxMoveData.left,
                                    finalTop = opacityDivMoveData.top - cropAreaMoveData.top,
                                    finalBottom = ((cropAreaMoveData.bottom - (cropAreaMoveData.bottom - opacityDivMoveData.bottom) - cropperMoveData.height)-(window.innerHeight - cropAreaMoveData.bottom));


                                function removeCropMoveEvent(){

                                  opacityDiv.style.opacity = "";
                                  cropVerGrid1.style.opacity = cropVerGrid2.style.opacity = cropHorGrid1.style.opacity = cropHorGrid2.style.opacity = 0;
                                  document.removeEventListener("mousemove" , moveCropper);
                                  document.removeEventListener("mouseup" , removeCropMoveEvent);
                                  document.removeEventListener("mousedown" , moveCropper);

                                  setCropperData();

                                  onSet();


                                }


                                function moveCropper(event){
                                  cropVerGrid1.style.opacity = cropVerGrid2.style.opacity = cropHorGrid1.style.opacity = cropHorGrid2.style.opacity = 1;

                                  event.preventDefault();

                                  var evX = event.clientX;
                                  var evY = event.clientY;

                                  if(((cropperMoveData.top+(evY-previousClientY) - cropAreaMoveData.top)+cropAreaMoveData.top)>opacityDivMoveData.top){
                                    cropper.style.top = (cropperMoveData.top+(evY-previousClientY) - cropAreaMoveData.top)+"px";
                                  } else {
                                    cropper.style.top = finalTop +"px";
                                  }
                                  if(((cropperMoveData.left+(evX-previousClientX) - cropAreaMoveData.left)+cropAreaMoveData.left)>opacityDivMoveData.left){
                                    cropper.style.left = ((cropperMoveData.left+(evX - previousClientX))-cropAreaMoveData.left) + "px";
                                  } else {
                                    cropper.style.left = finalLeft + "px";
                                  }
                                  if(!(((cropperMoveData.right+(evX-previousClientX) - cropAreaMoveData.right)+cropAreaMoveData.right)<opacityDivMoveData.right)){
                                    cropper.style.left = finalRight +"px";
                                  }
                                  if(!(((cropperMoveData.bottom+(evY-previousClientY) - cropAreaMoveData.bottom)+cropAreaMoveData.bottom)<opacityDivMoveData.bottom)){
                                    cropper.style.top = opacityDivMoveData.bottom - cropperMoveData.height - cropAreaMoveData.top + "px";
                                  }

                                  var fixedImageTransform = fixedImage.style.transform;
                                  fixedImage.style.transform = 'rotate(0deg)';
                                  divImageImg.style.left = (getBCR(fixedImage).left - getBCR(cropper).left)+"px";
                                  divImageImg.style.top = (getBCR(fixedImage).top - getBCR(cropper).top)+"px";
                                  fixedImage.style.transform = fixedImageTransform;

                                  setCropperData();

                                }


                                document.addEventListener("mousemove" , moveCropper);
                                document.addEventListener("mouseup" , removeCropMoveEvent);

                              }

                            break;


                            case "child" :

                            {
                              var cropperData = getBCR(cropper),
                                  cropperLeft = cropperData.left,
                                  cropperTop = cropperData.top,
                                  cropperWidth = cropperData.width,
                                  cropperHeight = cropperData.height,
                                  cropperRight = cropperData.right,
                                  cropperBottom = cropperData.bottom,
                                  opacityDivData = getBCR(opacityDiv),
                                  opacityDivTop = opacityDivData.top,
                                  opacityDivLeft = opacityDivData.left,
                                  opacityDivWidth = opacityDivData.width,
                                  opacityDivHeight = opacityDivData.height,
                                  opacityDivBottom = opacityDivData.bottom,
                                  opacityDivRight = opacityDivData.right,
                                  cropAreaData = getBCR(cropArea),
                                  cropAreaTop = cropAreaData.top,
                                  cropAreaLeft = cropAreaData.left,
                                  cropAreaWidth = cropAreaData.width,
                                  cropAreaHeight = cropAreaData.height,
                                  cropAreaRight = cropAreaData.right,
                                  cropAreaBottom = cropAreaData.bottom,
                                  boxData = getBCR(box),
                                  boxHeight = boxData.height,
                                  boxWidth = boxData.width,
                                  boxLeft = boxData.left,
                                  boxTop = boxData.top,
                                  fixedImageData = getBCR(fixedImage),
                                  fixedImageLeft = fixedImageData.left,
                                  fixedImageTop = fixedImageData.top,
                                  fixedImageWidth = fixedImageData.width,
                                  fixedImageheight = fixedImageData.height,
                                  previousClientX = event.clientX,
                                  previousClientY = event.clientY,
                                  midHeight       = (cropperData.top + (cropperData.height / 2)) - cropAreaData.top,
                                  midWidth        = (cropperData.left + (cropperData.width / 2)) - cropAreaData.left,
                                  finalLeft       = opacityDivData.left - cropAreaData.left,
                                  finalTop        = opacityDivData.top - cropAreaData.top,
                                  finalRight      = opacityDivData.right - cropperData.width - boxData.left,
                                  tempWidth ,
                                  tempHeight,
                                  todoC;
                              if (event.target.className === "") {
                                todoC = event.target.parentElement.className;
                              } else {
                                todoC = event.target.className;
                              }


                              function removeResizeEvent(){
                                opacityDiv.style.opacity = "";
                                cropVerGrid1.style.opacity = cropVerGrid2.style.opacity = cropHorGrid1.style.opacity = cropHorGrid2.style.opacity = 0;
                                document.removeEventListener("mousemove" , resizeCropper);
                                document.removeEventListener("mouseup" , removeResizeEvent);
                                setCropperData();

                                cropEnd();

                              }


                              function resizeCropper(event){

                                setCropperData();

                                var dragCrop = cropDrag();

                                if(dragCrop === false){
                                  return
                                }

                                var cropperNewTop , cropperNewLeft , cropperNewWidth , cropperNewHeight , cropperNewRight , cropperNewBottom,evX = event.clientX,evY = event.clientY,presentClientX = event.clientX,presentClientY = event.clientY,cropperDummyData = getBCR(cropper);

                                function upDCropperDD(){
                                  cropperDummyData = getBCR(cropper);
                                }

                                switch(todoC){

                                  case "lyteCropLeftEdge":


                                  upDCropperDD();

                                  cropperNewTop = 0; cropperNewLeft = 0; cropperNewWidth = 0; cropperNewHeight= 0;

                                  if (((cropperWidth - (evX - previousClientX))>=leastWidth)&&((cropperWidth - (evX - previousClientX))<=maxWidth)) {
                                    if(evX > opacityDivLeft){
                                      cropperNewWidth   = cropperWidth - (presentClientX - previousClientX) + "px";
                                      cropperNewHeight  = (cropperWidth - (presentClientX - previousClientX))/aspectDiff + "px";
                                      cropperNewTop     = ((cropperTop - cropAreaTop) + ((presentClientX - previousClientX)/aspectDiff)/2) + "px";
                                      cropperNewLeft    = ((cropperLeft - cropAreaLeft) + (evX - previousClientX))+ "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop,'left' : cropperNewLeft})
                                    }
                                    upDCropperDD();
                                    if(evX-6 <= opacityDivLeft){
                                      if((!(cropperDummyData.height >= opacityDivHeight))||(!(cropperDummyData.width >= opacityDivWidth))&&(cropperDummyData.top < opacityDivTop)){
                                        cropperNewTop = (opacityDivBottom - (((opacityDivWidth - (opacityDivRight - cropperRight))/aspectDiff) + (opacityDivBottom - (midHeight + ((opacityDivWidth - (opacityDivRight - cropperRight))/aspectDiff)/2)))) + "px";
                                        cropperNewLeft = opacityDivLeft - cropAreaLeft + "px";
                                        $L(cropper).css({'top' : cropperNewTop,'left' : cropperNewLeft})
                                      }
                                      cropperNewLeft = opacityDivLeft - cropAreaLeft + "px";
                                      cropperNewWidth = cropperRight - opacityDivLeft + "px";
                                      cropperNewHeight = (opacityDivWidth - (opacityDivRight - cropperRight))/aspectDiff + "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight , 'left' : cropperNewLeft})
                                    }
                                    upDCropperDD();
                                    if(cropperDummyData.bottom >= opacityDivBottom){
                                      cropperNewTop = opacityDivBottom - cropperDummyData.height - cropAreaTop + "px";
                                      $L(cropper).css({'top' : cropperNewTop})
                                    }
                                    upDCropperDD();
                                    if(cropperDummyData.top <= opacityDivTop){
                                      cropperNewTop = opacityDivTop - cropAreaTop + "px";
                                      $L(cropper).css({'top' : cropperNewTop})
                                    }
                                    upDCropperDD();
                                    if((cropperDummyData.bottom >= opacityDivBottom)&&(cropperDummyData.top <= opacityDivTop)){
                                      cropperNewLeft = cropperRight - ((opacityDivBottom - opacityDivTop)*aspectDiff) - cropAreaLeft + "px";
                                      cropperNewWidth = (opacityDivBottom - opacityDivTop)*aspectDiff + "px";
                                      cropperNewHeight = opacityDivBottom - opacityDivTop + "px";
                                      cropperNewTop = opacityDivTop - cropAreaTop + "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop,'left' : cropperNewLeft})
                                    }

                                  }else if(((cropperWidth - (evX - previousClientX))<=leastWidth)){
                                    if(!(aspectRatio === "n:n")){
                                      cropperNewLeft    = (cropperRight - leastWidth) - cropAreaLeft + "px";
                                      cropperNewTop     = (midHeight - (leastHeight/2)) + "px";
                                      cropperNewWidth   = leastWidth +"px";
                                      cropperNewHeight  = leastHeight + "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop,'left' : cropperNewLeft})
                                    } else {
                                      cropperNewLeft    = (cropperRight - leastWidth) - cropAreaLeft + "px";
                                      cropperNewWidth   = leastWidth +"px";
                                      $L(cropper).css({'width' : cropperNewWidth,'left' : cropperNewLeft})
                                    }
                                  }else if(((cropperWidth - (evX+6 - previousClientX))>=maxWidth)){
                                    if(!(aspectRatio === "n:n")){
                                      var checkHeight = (cropperWidth - (presentClientX - previousClientX))/aspectDiff;
                                      var checkWidth = cropperWidth - (presentClientX - previousClientX);
                                      var checkLeft = ((cropperLeft - cropAreaLeft) + (evX - previousClientX));
                                      if(((checkWidth >= maxWidth)||(checkHeight >= maxHeight))&&((evX+6 <= opacityDivLeft)&&((cropperRight - opacityDivLeft)>=maxWidth))){
                                        cropperNewLeft    = (cropperRight - maxWidth) - cropAreaLeft + "px";
                                        upDCropperDD();
                                        // if(imageType === "landscape"){
                                          cropperNewTop     = (midHeight - (maxHeight/2));
                                          if(cropperNewTop < 0){
                                            cropperNewTop = 0 ;
                                          }
                                          if(cropperNewTop > (opacityDivBottom - maxHeight)-opacityDivTop){
                                            cropperNewTop = (opacityDivBottom - maxHeight)-opacityDivTop ;
                                          }
                                        // } else {
                                        //   cropperNewLeft     = 0 + "px";
                                        // }
                                        cropperNewWidth   = maxWidth +"px";
                                        cropperNewHeight  = maxHeight + "px";
                                        $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop,'left' : cropperNewLeft})
                                      }
                                    } else {

                                      if(maxWidth!=fixedImageWidth){
                                        cropperNewLeft =  cropperRight - maxWidth - opacityDivLeft;
                                        cropperNewWidth   = maxWidth +"px";
                                      } else {
                                        cropperNewLeft = 0;
                                        cropperNewWidth   = cropperRight - opacityDivLeft +"px";
                                      }
                                      $L(cropper).css({'width' : cropperNewWidth,'left' : cropperNewLeft})
                                    }
                                  }
                                  break;

                                  case "lyteCropTopEdge":

                                  upDCropperDD();

                                  cropperNewTop = 0; cropperNewLeft = 0; cropperNewWidth = 0; cropperNewHeight= 0;

                                  if (((cropperHeight - (evY - previousClientY))>=leastHeight)&&((cropperHeight - (evY - previousClientY))<=maxHeight)) {
                                    if(evY > opacityDivTop+6){
                                      cropperNewWidth = (cropperHeight - (evY - previousClientY))*aspectDiff + "px";
                                      cropperNewHeight  = cropperHeight - (evY - previousClientY)+ "px";
                                      cropperNewLeft    = ((cropperLeft - cropAreaLeft) + ((evY - previousClientY)*aspectDiff)/2) + "px";
                                      cropperNewTop     = ((cropperTop - cropAreaTop) + (evY - previousClientY))+ "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop,'left' : cropperNewLeft})
                                    }
                                    upDCropperDD();
                                    if(evY-6 <= opacityDivTop){
                                      if((!(cropperDummyData.height >= opacityDivHeight))||(!(cropperDummyData.width >= opacityDivWidth))&&(cropperDummyData.left < opacityDivLeft)){
                                        cropperNewLeft = (opacityDivRight - (((cropperBottom - opacityDivTop)*aspectDiff) + (opacityDivRight-(midWidth+(((cropperBottom - opacityDivTop)*aspectDiff)/2))))) + "px";
                                        cropperNewTop = opacityDivTop - cropAreaTop + "px";
                                        $L(cropper).css({'top' : cropperNewTop,'left' : cropperNewLeft})
                                      }
                                      cropperNewWidth = (cropperBottom - opacityDivTop)*aspectDiff + "px";
                                      cropperNewHeight = cropperBottom - opacityDivTop + "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight})
                                    }
                                    upDCropperDD();
                                    if(cropperDummyData.left <= opacityDivLeft){
                                      cropperNewLeft = opacityDivLeft - cropAreaLeft + "px";
                                      $L(cropper).css({'left' : cropperNewLeft})
                                    }
                                    upDCropperDD();
                                    if(cropperDummyData.right >= opacityDivRight){
                                      cropperNewLeft = opacityDivRight - cropperDummyData.width - cropAreaLeft+ "px";
                                      $L(cropper).css({'left' : cropperNewLeft})
                                    }
                                    upDCropperDD();
                                    if((cropperDummyData.right >= opacityDivRight)&&(cropperDummyData.left <= opacityDivLeft)){
                                      cropperNewWidth = opacityDivRight - opacityDivLeft + "px";
                                      cropperNewHeight = (opacityDivRight - opacityDivLeft)/aspectDiff + "px";
                                      cropperNewTop = (cropperBottom - ((opacityDivRight - opacityDivLeft)/aspectDiff)) - cropAreaTop + "px";
                                      cropperNewLeft = opacityDivLeft - cropAreaLeft + "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop,'left' : cropperNewLeft})
                                    }
                                  }else if((cropperHeight - (evY - previousClientY))<=leastHeight) {
                                    if(!(aspectRatio === "n:n")){
                                      cropperNewTop     = (cropperBottom - leastHeight) - cropAreaTop + "px";
                                      cropperNewLeft    = (midWidth - (leastWidth/2)) + "px";
                                      cropperNewWidth   = leastWidth +"px";
                                      cropperNewHeight  = leastHeight + "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop,'left' : cropperNewLeft})
                                    } else {
                                      cropperNewTop     = (cropperBottom - leastHeight) - cropAreaTop + "px";
                                      cropperNewHeight  = leastHeight + "px";
                                      $L(cropper).css({'height' : cropperNewHeight,'top' : cropperNewTop})
                                    }
                                  }else if(((cropperHeight - (evY - previousClientY))>=maxHeight)){
                                    if(!(aspectRatio === "n:n")){
                                      var checkHeight = cropperHeight - (evY - previousClientY);
                                      var checkWidth = (cropperHeight - (evY - previousClientY))*aspectDiff;
                                      var checkTop = ((cropperTop - cropAreaTop) + (evY - previousClientY));
                                      if(((checkWidth >= maxWidth)||(checkHeight >= maxHeight))&&((evY-6 < opacityDivTop)&&((cropperBottom - opacityDivTop)>=maxHeight))){
                                        cropperNewTop    = (cropperBottom - maxHeight) - cropAreaTop + "px";
                                        upDCropperDD();
                                        // if(imageType === "landscape"){
                                          cropperNewLeft     = (midWidth - (maxWidth/2));
                                          if(cropperNewLeft < 0){
                                            cropperNewLeft = 0 ;
                                          }
                                          if(cropperNewLeft > (opacityDivRight - maxWidth)-opacityDivLeft){
                                            cropperNewLeft = (opacityDivRight - maxWidth)-opacityDivLeft ;
                                          }
                                        // } else {
                                        //   cropperNewLeft     = 0 + "px";
                                        // }
                                        cropperNewWidth   = maxWidth +"px";
                                        cropperNewHeight  = maxHeight + "px";
                                        $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop,'left' : cropperNewLeft})
                                      }
                                    } else {

                                      if(maxHeight!=fixedImageheight){
                                        cropperNewTop =  cropperBottom - maxHeight - opacityDivTop;
                                        cropperNewHeight   = maxHeight +"px";
                                      } else {
                                        cropperNewTop = 0;
                                        cropperNewHeight   = cropperBottom - opacityDivTop +"px";
                                      }
                                      $L(cropper).css({'height' : cropperNewHeight,'top' : cropperNewTop})
                                    }
                                  }
                                  break;


                                  case "lyteCropRightEdge":
                                  upDCropperDD();

                                  cropperNewTop = 0; cropperNewRight = 0; cropperNewWidth = 0; cropperNewHeight= 0 , cropperNewLeft = 0;

                                  if(((cropperWidth + (presentClientX - previousClientX))>=leastWidth)&&((cropperWidth + (presentClientX - previousClientX))<=maxWidth)){
                                    if(presentClientX < opacityDivRight){
                                      cropperNewWidth   = cropperWidth + (presentClientX - previousClientX) + "px";
                                      cropperNewHeight  = (cropperWidth + (presentClientX - previousClientX))/aspectDiff + "px";
                                      cropperNewTop     = ((cropperTop - cropAreaTop) - ((presentClientX - previousClientX)/aspectDiff)/2) + "px";
                                      cropperNewRight   = ((cropperRight - cropAreaRight) - (presentClientX - previousClientX))+ "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop,'right' : cropperNewRight})
                                    }
                                    if(presentClientX >= opacityDivRight){
                                      cropperNewTop = midHeight - (((opacityDivRight - cropperLeft)/aspectDiff) / 2) + "px";
                                      cropperNewWidth = opacityDivRight - cropperLeft + "px";
                                      cropperNewHeight = (opacityDivRight - cropperLeft)/aspectDiff + "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop})
                                    }
                                    upDCropperDD();
                                    if(cropperDummyData.bottom >= opacityDivBottom){
                                      cropperNewTop = opacityDivBottom - cropperDummyData.height - cropAreaTop + "px";
                                      $L(cropper).css({'top' : cropperNewTop})
                                    }
                                    upDCropperDD();
                                    if(cropperDummyData.top <= opacityDivTop){
                                      cropperNewTop = opacityDivTop - cropAreaTop + "px";
                                      $L(cropper).css({'top' : cropperNewTop})
                                    }
                                    upDCropperDD();
                                    if((cropperDummyData.bottom >= opacityDivBottom)&&(cropperDummyData.top <= opacityDivTop)){
                                      cropperNewLeft = cropperLeft - cropAreaLeft + "px";
                                      cropperNewWidth = (opacityDivBottom - opacityDivTop)*aspectDiff + "px";
                                      cropperNewHeight = (opacityDivBottom - opacityDivTop) + "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'left' : cropperNewLeft})
                                    }
                                  }else if((cropperWidth + (presentClientX - previousClientX))<=leastWidth){
                                    if(!(aspectRatio === "n:n")){
                                      cropperNewTop     = (midHeight - (leastHeight/2)) + "px";
                                      cropperNewWidth   = leastWidth + "px";
                                      cropperNewHeight  = leastHeight + "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop})
                                    } else {
                                      cropperNewWidth   = leastWidth + "px";
                                      $L(cropper).css({'width' : cropperNewWidth})
                                    }
                                  }else if(((cropperWidth + (evX - previousClientX))>=maxWidth)){
                                    if(!(aspectRatio === "n:n")){
                                      var checkHeight = (cropperWidth + (presentClientX - previousClientX))/aspectDiff;
                                      var checkWidth = cropperWidth + (presentClientX - previousClientX);
                                      if(((checkHeight >= maxHeight)||(checkWidth >= maxWidth))&&(cropperLeft <= (opacityDivRight - maxWidth))){
                                        // if(imageType === "portrait"){
                                          cropperNewTop     = (midHeight - (maxHeight/2));
                                          if(cropperNewTop < 0){
                                            cropperNewTop = 0 ;
                                          }
                                          if(cropperNewTop > (opacityDivBottom - maxHeight)-opacityDivTop){
                                            cropperNewTop = (opacityDivBottom - maxHeight)-opacityDivTop ;
                                          }
                                        // } else {
                                        //   cropperNewTop     = 0 + "px";
                                        // }
                                        cropperNewWidth   = maxWidth +"px";
                                        cropperNewHeight  = maxHeight + "px";
                                        $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop})
                                      }
                                    } else {
                                      if(maxWidth != fixedImageWidth){
                                        cropperNewWidth   = maxWidth +"px";
                                      } else {
                                        cropperNewWidth   = opacityDivRight - cropperLeft +"px";
                                      }
                                      $L(cropper).css({'width' : cropperNewWidth})
                                    }
                                  }
                                  break;

                                  case "lyteCropBottomEdge":
                                  upDCropperDD();

                                  cropperNewTop = 0; cropperNewRight = 0; cropperNewWidth = 0; cropperNewHeight= 0 , cropperNewLeft = 0;
                                  if(((cropperHeight + (evY - previousClientY))>=leastHeight)&&((cropperHeight + (evY - previousClientY))<=maxHeight)){
                                    if(evY < opacityDivBottom){
                                      cropperNewWidth   = (cropperHeight + (presentClientY - previousClientY))*aspectDiff + "px";
                                      cropperNewHeight  = cropperHeight + (evY - previousClientY)+ "px";
                                      cropperNewLeft    = ((cropperLeft - cropAreaLeft) - ((presentClientY - previousClientY)*aspectDiff)/2) + "px";
                                      cropperNewBottom  = ((cropperBottom - cropAreaBottom) - (presentClientY - previousClientY))+ "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'left' : cropperNewLeft,'bottom' : cropperNewBottom})
                                    }
                                    if(evY >= opacityDivBottom){
                                      cropperNewLeft = midWidth - (((opacityDivBottom - cropperTop)*aspectDiff) / 2) + "px";
                                      cropperNewWidth = (opacityDivBottom - cropperTop)*aspectDiff + "px";
                                      cropperNewHeight = opacityDivBottom - cropperTop + "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'left' : cropperNewLeft})
                                    }
                                    upDCropperDD();
                                    if(cropperDummyData.left <= opacityDivLeft){
                                      cropperNewLeft = opacityDivLeft - cropAreaLeft + "px";
                                      $L(cropper).css({'left' : cropperNewLeft})
                                    }
                                    upDCropperDD();
                                    if(cropperDummyData.right >= opacityDivRight){
                                      cropperNewLeft = opacityDivRight - cropperDummyData.width - cropAreaLeft+ "px";
                                      $L(cropper).css({'left' : cropperNewLeft})
                                    }
                                    upDCropperDD();
                                    if((cropperDummyData.right >= opacityDivRight)&&(cropperDummyData.left <= opacityDivLeft)){
                                      cropperNewLeft = opacityDivLeft - cropAreaLeft + "px";
                                      cropperNewWidth = opacityDivRight - opacityDivLeft + "px";
                                      cropperNewHeight = (opacityDivRight - opacityDivLeft)/aspectDiff + "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'left' : cropperNewLeft})
                                    }
                                  }else if((cropperHeight + (evY - previousClientY))<=leastHeight) {
                                    if(!(aspectRatio === "n:n")){
                                      cropperNewLeft    = (midWidth - (leastWidth/2)) + "px";
                                      cropperNewWidth   = leastWidth + "px";
                                      cropperNewHeight  = leastHeight + "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'left' : cropperNewLeft})
                                    } else {
                                      cropperNewHeight  = leastHeight + "px";
                                      $L(cropper).css({'height' : cropperNewHeight})
                                    }
                                  }else if(((cropperHeight + (evY - previousClientY))>=maxHeight)){
                                    if(!(aspectRatio === "n:n")){
                                      var checkHeight = cropperHeight + (evY - previousClientY);
                                      var checkWidth = (cropperHeight + (presentClientY - previousClientY))*aspectDiff;
                                      if(((checkWidth >= maxWidth)||(checkHeight >= maxHeight))&&(cropperTop <= (opacityDivBottom - maxHeight))){
                                        // if(imageType === "landscape"){
                                          cropperNewLeft = (midWidth - (maxWidth/2));
                                          if(cropperNewLeft < 0){
                                            cropperNewLeft = 0 ;
                                          }
                                          if(cropperNewLeft > (opacityDivRight - maxWidth)-opacityDivLeft){
                                            cropperNewLeft = (opacityDivRight - maxWidth)-opacityDivLeft ;
                                          }
                                        // } else {
                                        //   cropperNewLeft  = 0 + "px";
                                        // }
                                        cropperNewWidth   = maxWidth +"px";
                                        cropperNewHeight  = maxHeight + "px";
                                        $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'left' : cropperNewLeft})
                                      }
                                    } else {
                                      if(maxHeight != fixedImageheight){
                                        cropperNewHeight   = maxHeight +"px";
                                      } else {
                                        cropperNewHeight   = opacityDivBottom - cropperTop +"px";
                                      }
                                      $L(cropper).css({'height' : cropperNewHeight})
                                    }
                                  }
                                  break;

                                  case "lyteCropTopRightCorner":
                                  upDCropperDD();

                                  cropperNewTop = 0; cropperNewRight = 0; cropperNewWidth = 0; cropperNewHeight= 0 , cropperNewLeft = 0;
                                  if(aspectRatio === "n:n"){
                                    if(((cropperWidth + (presentClientX - previousClientX))>=leastWidth) && ((cropperWidth + (presentClientX - previousClientX))<=maxWidth)){
                                      if(presentClientX < opacityDivRight){
                                        cropperNewWidth   = cropperWidth + (presentClientX - previousClientX) + "px";
                                        $L(cropper).css({'width' : cropperNewWidth})
                                        $L(cropper).css({'width' : cropperNewWidth})
                                      }
                                    } else if((cropperWidth + (presentClientX - previousClientX))<leastWidth){
                                      if(presentClientX <= cropperLeft){
                                          cropperNewWidth = leastWidth + "px";
                                        $L(cropper).css({'width' : cropperNewWidth})
                                      }
                                    } else if((cropperWidth + (presentClientX - previousClientX))>maxWidth) {
                                      if(presentClientX >= opacityDivRight){
                                        if(maxWidth != fixedImageWidth){
                                          cropperNewWidth = maxWidth + "px";
                                        } else {
                                          cropperNewWidth = opacityDivRight - cropperLeft + "px";
                                        }
                                        $L(cropper).css({'width' : cropperNewWidth})
                                      }
                                    }
                                    if(((cropperHeight - (presentClientY - previousClientY))>=leastHeight) && ((cropperHeight - (presentClientY - previousClientY))<=maxHeight)){
                                      if(presentClientY > opacityDivTop){
                                        cropperNewTop = ((cropperTop - cropAreaTop) + (evY - previousClientY))+ "px";
                                        cropperNewHeight   = cropperHeight - (presentClientY - previousClientY) + "px";
                                        $L(cropper).css({'height' : cropperNewHeight , 'top' : cropperNewTop})
                                      }
                                    } else if((cropperHeight - (presentClientY - previousClientY))<leastHeight){
                                      if(presentClientY > cropperBottom){
                                          cropperNewHeight = leastHeight + "px";
                                          cropperNewTop = cropperBottom - leastHeight - opacityDivTop + "px";
                                        $L(cropper).css({'height' : cropperNewHeight , 'top' : cropperNewTop})
                                      }
                                    } else if((cropperHeight - (presentClientY - previousClientY))>maxHeight) {
                                      if(presentClientY <= opacityDivTop){
                                        if(maxHeight != fixedImageheight){
                                          cropperNewTop = cropperBottom - maxHeight - opacityDivTop + "px";
                                          cropperNewHeight   = maxHeight + "px";
                                        } else {
                                          cropperNewTop = (opacityDivTop - fixedImageTop) + "px";
                                          cropperNewHeight   = (cropperBottom - opacityDivTop) + "px";
                                        }
                                        $L(cropper).css({'height' : cropperNewHeight , 'top' : cropperNewTop})
                                      }
                                    }
                                  } else {
                                      if (((cropperHeight - (evY - previousClientY))>=leastHeight)&&((cropperHeight - (evY - previousClientY))<=maxHeight)) {
                                        if(evY >= opacityDivTop+5){
                                          cropperNewWidth   = (cropperHeight - (evY - previousClientY))*aspectDiff + "px";
                                          cropperNewHeight  = cropperHeight - (evY - previousClientY)+ "px";
                                          cropperNewTop     = ((cropperTop - cropAreaTop) + (evY - previousClientY))+ "px";
                                          cropperNewRight   = ((cropperRight - cropAreaRight) - (evX - previousClientX))+ "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop,'right' : cropperNewRight})
                                        }
                                        upDCropperDD();
                                        if(evY < (opacityDivTop+5)){
                                          if((!(cropperDummyData.height >= opacityDivHeight))||(!(cropperDummyData.width >= opacityDivWidth))&&(cropperDummyData.left < opacityDivLeft)){
                                            cropperNewTop = opacityDivTop - cropAreaTop  + "px";
                                          }
                                          cropperNewWidth = (cropperBottom - opacityDivTop)*aspectDiff + "px";
                                          cropperNewHeight = cropperBottom - opacityDivTop + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop})
                                        }
                                        upDCropperDD();
                                       if(cropperDummyData.right >= opacityDivRight){
                                         cropperNewTop = (cropperBottom - ((opacityDivRight - cropperLeft)/aspectDiff)) - cropAreaTop + "px";
                                         cropperNewWidth = opacityDivRight - cropperLeft + "px";
                                         cropperNewHeight = (opacityDivRight - cropperLeft)/aspectDiff + "px";
                                         $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop})
                                       }
                                     } else if((cropperHeight - (evY - previousClientY))<=leastHeight) {
                                          cropperNewTop     = (cropperBottom - leastHeight) - cropAreaTop + "px";
                                          cropperNewWidth   = leastWidth + "px";
                                          cropperNewHeight  = leastHeight + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop})
                                      }
                                      else if((cropperHeight - (evY - previousClientY))>=maxHeight) {
                                        var checkHeight = cropperHeight - (evY - previousClientY);
                                        var checkWidth = (cropperHeight - (evY - previousClientY))*aspectDiff;
                                        var checkTop = ((cropperTop - cropAreaTop) + (evY - previousClientY));
                                        if(((checkWidth >= maxWidth)||(checkHeight >= maxHeight))&&((evY-6 < opacityDivTop)&&((cropperBottom - opacityDivTop)>=maxHeight))&&(cropperLeft <= (opacityDivRight - maxWidth))){
                                          cropperNewTop    = (cropperBottom - maxHeight) - cropAreaTop + "px";
                                          // if(imageType === "landscape"){
                                            cropperNewLeft     = (midWidth - (maxWidth/2));
                                            if(cropperNewLeft < 0){
                                              cropperNewLeft = 0 ;
                                            }
                                            if(cropperNewLeft > (opacityDivRight - maxWidth)-opacityDivLeft){
                                              cropperNewLeft = (opacityDivRight - maxWidth)-opacityDivLeft ;
                                            }
                                          // } else {
                                          //   cropperNewLeft     = 0 + "px";
                                          // }
                                          cropperNewWidth   = maxWidth +"px";
                                          cropperNewHeight  = maxHeight + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop})
                                        }
                                      }
                                  }
                                  break;

                                  case "lyteCropTopLeftCorner":
                                  upDCropperDD();

                                  cropperNewTop = 0; cropperNewRight = 0; cropperNewWidth = 0; cropperNewHeight= 0 , cropperNewLeft = 0;
                                  if(aspectRatio === "n:n"){
                                    upDCropperDD();
                                    if (((cropperWidth - (evX - previousClientX))>=leastWidth)&&((cropperWidth - (evX - previousClientX))<=maxWidth)) {
                                      if(evX > opacityDivLeft){
                                        cropperNewWidth   = cropperWidth - (presentClientX - previousClientX) + "px";
                                        cropperNewLeft    = ((cropperLeft - cropAreaLeft) + (evX - previousClientX))+ "px";
                                        $L(cropper).css({'width' : cropperNewWidth,'left' : cropperNewLeft})
                                      }
                                    }else if((cropperWidth - (evX - previousClientX))<leastWidth){
                                      if(presentClientX > cropperRight){
                                          cropperNewWidth = leastWidth + "px";
                                          cropperNewLeft = cropperRight - leastWidth - opacityDivLeft + "px";
                                        $L(cropper).css({'width' : cropperNewWidth , 'left' : cropperNewLeft})
                                      }
                                    }else if((cropperWidth - (evX - previousClientX))>maxWidth){
                                      if(evX <= opacityDivLeft){
                                        if(maxWidth != fixedImageWidth){
                                          cropperNewWidth   = maxWidth + "px";
                                          cropperNewLeft    = cropperRight - maxWidth - opacityDivLeft + "px";
                                        } else {
                                          cropperNewWidth   = (cropperRight - opacityDivLeft) + "px";
                                          cropperNewLeft    = (opacityDivLeft - fixedImageLeft) + "px";
                                        }
                                        $L(cropper).css({'width' : cropperNewWidth,'left' : cropperNewLeft})
                                      }
                                    }
                                    if(((cropperHeight - (presentClientY - previousClientY))>=leastHeight) && ((cropperHeight - (presentClientY - previousClientY))<=maxHeight)){
                                      if(presentClientY > opacityDivTop){
                                        cropperNewTop = ((cropperTop - cropAreaTop) + (evY - previousClientY))+ "px";
                                        cropperNewHeight   = cropperHeight - (presentClientY - previousClientY) + "px";
                                        $L(cropper).css({'height' : cropperNewHeight , 'top' : cropperNewTop})
                                      }
                                    }else if((cropperHeight - (presentClientY - previousClientY))<leastHeight){
                                      if(presentClientY > cropperBottom){
                                          cropperNewHeight = leastHeight + "px";
                                          cropperNewTop = cropperBottom - leastHeight - opacityDivTop + "px";
                                        $L(cropper).css({'height' : cropperNewHeight , 'top' : cropperNewTop})
                                      }
                                    } else if((cropperHeight - (presentClientY - previousClientY))>maxHeight){
                                      if(presentClientY <= opacityDivTop){
                                        if(maxHeight != fixedImageheight){
                                          cropperNewTop = cropperBottom - maxHeight - opacityDivTop + "px";
                                          cropperNewHeight   = maxHeight + "px";
                                        } else {
                                          cropperNewTop = (opacityDivTop - fixedImageTop) + "px";
                                          cropperNewHeight   = (cropperBottom - opacityDivTop) + "px";
                                        }
                                        $L(cropper).css({'height' : cropperNewHeight , 'top' : cropperNewTop})
                                      }
                                    }
                                  } else {
                                      if(((cropperHeight - (evY - previousClientY))>=leastHeight)&&((cropperHeight - (evY - previousClientY))<=maxHeight)){
                                        if(evY >= opacityDivTop+5){
                                          cropperNewWidth = (cropperHeight - (evY - previousClientY))*aspectDiff + "px";
                                          cropperNewHeight  = cropperHeight - (evY - previousClientY)+ "px";
                                          cropperNewTop     = ((cropperTop - cropAreaTop) + (evY - previousClientY))+ "px";
                                          cropperNewLeft    = ((cropperLeft - cropAreaLeft) + ((evY - previousClientY)*aspectDiff)) + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'left' : cropperNewLeft,'top':cropperNewTop})
                                        }
                                        upDCropperDD();
                                        if(evY-6 <= opacityDivTop){
                                          if((!(cropperDummyData.height > opacityDivHeight))||(!(cropperDummyData.width > opacityDivWidth))&&(cropperDummyData.left < opacityDivLeft)){
                                            cropperNewLeft = (opacityDivRight - (((cropperBottom - opacityDivTop)*aspectDiff) + (opacityDivRight - cropperRight))) - cropAreaLeft + "px";
                                            cropperNewTop = opacityDivTop - cropAreaTop + "px";
                                          }
                                          cropperNewWidth = (cropperBottom - opacityDivTop)*aspectDiff + "px";
                                          cropperNewHeight = cropperBottom - opacityDivTop + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'left' : cropperNewLeft,'top':cropperNewTop})
                                        }
                                        upDCropperDD();
                                        if(cropperDummyData.left <= opacityDivLeft){
                                          cropperNewTop = (cropperBottom - ((cropperRight - opacityDivLeft)/aspectDiff)) - cropAreaTop + "px";
                                          cropperNewLeft = opacityDivLeft - cropAreaLeft + "px";
                                          cropperNewWidth = cropperRight - opacityDivLeft + "px";
                                          cropperNewHeight = (cropperRight - opacityDivLeft)/aspectDiff + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'left' : cropperNewLeft,'top':cropperNewTop})
                                        }
                                      }else if((cropperHeight - (evY - previousClientY))<=leastHeight){
                                        if(!(aspectRatio === "n:n")){
                                          cropperNewTop     = (cropperBottom - leastHeight) - cropAreaTop + "px";
                                          cropperNewLeft    = (cropperRight - leastWidth) - cropAreaLeft + "px";
                                          cropperNewWidth   = leastWidth + "px";
                                          cropperNewHeight  = leastHeight + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'left' : cropperNewLeft,'top':cropperNewTop})
                                        }
                                      }else if((cropperHeight - (evY - previousClientY))>=maxHeight) {
                                        var checkHeight = cropperHeight - (evY - previousClientY);
                                        var checkWidth = (cropperHeight - (evY - previousClientY))*aspectDiff;
                                        var checkTop = ((cropperTop - cropAreaTop) + (evY - previousClientY));
                                        if(((checkWidth >= maxWidth)||(checkHeight >= maxHeight))&&((evY-6 < opacityDivTop)&&((cropperBottom - opacityDivTop)>=maxHeight))&&(cropperRight - opacityDivLeft >= maxWidth)){
                                          cropperNewTop    = (cropperBottom - maxHeight) - cropAreaTop + "px";
                                          // if(imageType === "landscape"){
                                            cropperNewLeft     = (midWidth - (maxWidth/2));
                                            if(cropperNewLeft < 0){
                                              cropperNewLeft = 0 ;
                                            }
                                            if(cropperNewLeft > (opacityDivRight - maxWidth)-opacityDivLeft){
                                              cropperNewLeft = (opacityDivRight - maxWidth)-opacityDivLeft ;
                                            }
                                          // } else {
                                          //   cropperNewLeft     = 0 + "px";
                                          // }
                                          cropperNewWidth   = maxWidth +"px";
                                          cropperNewHeight  = maxHeight + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'top' : cropperNewTop,'left' : cropperNewLeft})
                                        }
                                      }
                                    }
                                break;
                                case "lyteCropBottomRightCorner":
                                upDCropperDD();

                                cropperNewTop = 0; cropperNewRight = 0; cropperNewWidth = 0; cropperNewHeight= 0 , cropperNewLeft = 0;
                                if(aspectRatio === "n:n"){
                                  upDCropperDD();
                                  if(((cropperHeight + (evY - previousClientY))>=leastHeight)&&((cropperHeight + (evY - previousClientY))<=maxHeight)){
                                    if(evY < opacityDivBottom){
                                      cropperNewHeight  = cropperHeight + (evY - previousClientY)+ "px";
                                      $L(cropper).css({'height' : cropperNewHeight})
                                    }
                                  }else if((cropperHeight + (evY - previousClientY))<leastHeight){
                                    if(presentClientY < cropperTop){
                                        cropperNewHeight = leastHeight + "px";
                                      $L(cropper).css({'height' : cropperNewHeight})
                                    }
                                  } else if((cropperHeight + (evY - previousClientY))>maxHeight) {
                                    if(evY >= opacityDivBottom){
                                      if(maxHeight != fixedImageheight){
                                        cropperNewHeight = maxHeight + "px";
                                      } else {
                                        cropperNewHeight = opacityDivBottom - cropperTop + "px";
                                      }
                                      $L(cropper).css({'height' : cropperNewHeight})
                                    }
                                  }
                                  if(((cropperWidth + (evX - previousClientX))>=leastWidth)&&((cropperWidth + (evX - previousClientX))<=maxWidth)){
                                    if(evX < opacityDivRight){
                                      cropperNewWidth  = cropperWidth + (evX - previousClientX) + "px";
                                      $L(cropper).css({'width' : cropperNewWidth})
                                    }
                                  }else if((cropperWidth + (evX - previousClientX))<leastWidth){
                                    if(presentClientX <= cropperLeft){
                                        cropperNewWidth = leastWidth + "px";
                                      $L(cropper).css({'width' : cropperNewWidth})
                                    }
                                  } else if((cropperWidth + (evX - previousClientX))>maxWidth){
                                    if(evX >= opacityDivRight){
                                      if(maxWidth != fixedImageWidth){
                                        cropperNewWidth = maxWidth + "px";
                                      } else {
                                        cropperNewWidth = opacityDivRight - cropperLeft + "px";
                                      }
                                      $L(cropper).css({'width' : cropperNewWidth})
                                    }
                                  }
                                } else {
                                    if(((cropperWidth + (presentClientX - previousClientX))>=leastWidth)&&((cropperWidth + (presentClientX - previousClientX))<=maxWidth)){
                                        if(presentClientX < opacityDivRight){
                                          cropperNewWidth   = cropperWidth + (presentClientX - previousClientX) + "px";
                                          cropperNewHeight  = (cropperWidth + (presentClientX - previousClientX))/aspectDiff + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight})
                                        }
                                        upDCropperDD();
                                        if((cropperDummyData.right >= opacityDivRight-5)&&(presentClientX >= opacityDivRight-5)){
                                          cropperNewWidth = opacityDivRight - cropperLeft + "px";
                                          cropperNewHeight = (opacityDivRight - cropperLeft)/aspectDiff + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight})
                                        }
                                        upDCropperDD();
                                        if(cropperDummyData.bottom >= opacityDivBottom){
                                          cropperNewHeight = opacityDivBottom - cropperTop + "px";
                                          cropperNewWidth = (opacityDivBottom - cropperTop)*aspectDiff + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight})
                                        }
                                      }else if((cropperWidth + (presentClientX - previousClientX))<=leastWidth){
                                          cropperNewWidth   = leastWidth + "px";
                                          cropperNewHeight  = leastHeight + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight})
                                      }else if((cropperWidth + (presentClientX - previousClientX))>=maxWidth){
                                        var checkHeight = (cropperWidth + (presentClientX - previousClientX))/aspectDiff;
                                        var checkWidth = cropperWidth + (presentClientX - previousClientX);
                                        if(((checkHeight >= maxHeight)||(checkWidth >= maxWidth))&&(opacityDivBottom - cropperTop >= maxHeight)&&(opacityDivRight - cropperLeft >= maxWidth)){
                                          // // cropperNewLeft    = (cropperRight - maxWidth) - cropAreaLeft + "px";
                                          // if(imageType === "portrait"){
                                          //   // cropperNewTop     = (midHeight - (maxHeight/2));
                                          //   if(cropperNewTop < 0){
                                          //     // cropperNewTop = 0 ;
                                          //   }
                                          //   if(cropperNewTop > (opacityDivBottom - maxHeight)-opacityDivTop){
                                          //     // cropperNewTop = (opacityDivBottom - maxHeight)-opacityDivTop ;
                                          //   }
                                          // } else {
                                          //   //cropperNewTop     = 0 + "px";
                                          // }
                                          cropperNewWidth   = maxWidth +"px";
                                          cropperNewHeight  = maxHeight + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight})
                                        }
                                      }
                                  }
                                break;
                                case "lyteCropBottomLeftCorner":
                                upDCropperDD();

                                cropperNewTop = 0; cropperNewRight = 0; cropperNewWidth = 0; cropperNewHeight= 0 , cropperNewLeft = 0;
                                if(aspectRatio === "n:n"){
                                  upDCropperDD();
                                  if (((cropperWidth - (evX - previousClientX))>=leastWidth)&&((cropperWidth - (evX - previousClientX))<=maxWidth)) {
                                    if(evX > opacityDivLeft){
                                      cropperNewWidth   = cropperWidth - (presentClientX - previousClientX) + "px";
                                      cropperNewLeft    = ((cropperLeft - cropAreaLeft) + (evX - previousClientX))+ "px";
                                      $L(cropper).css({'width' : cropperNewWidth,'left' : cropperNewLeft})
                                    }
                                  }else if((cropperWidth - (evX - previousClientX))<leastWidth){
                                    if(presentClientX > cropperRight){
                                        cropperNewWidth = leastWidth + "px";
                                        cropperNewLeft = cropperRight - leastWidth - opacityDivLeft + "px";
                                      $L(cropper).css({'width' : cropperNewWidth , 'left' : cropperNewLeft})
                                    }
                                  } else if((cropperWidth - (evX - previousClientX))>maxWidth){
                                    if(evX <= opacityDivLeft){
                                      if(maxWidth != fixedImageWidth){
                                        cropperNewWidth   = maxWidth + "px";
                                        cropperNewLeft    = cropperRight - maxWidth - opacityDivLeft + "px";
                                      } else {
                                        cropperNewWidth   = (cropperRight - opacityDivLeft) + "px";
                                        cropperNewLeft    = (opacityDivLeft - fixedImageLeft) + "px";
                                      }
                                      $L(cropper).css({'width' : cropperNewWidth,'left' : cropperNewLeft})
                                    }
                                  }
                                  if(((cropperHeight + (evY - previousClientY))>=leastHeight)&&((cropperHeight + (evY - previousClientY))<=maxHeight)){
                                    if(evY < opacityDivBottom){
                                      cropperNewHeight  = cropperHeight + (evY - previousClientY)+ "px";
                                      $L(cropper).css({'height' : cropperNewHeight})
                                    }
                                  }else if((cropperHeight + (evY - previousClientY))<leastHeight){
                                    if(presentClientY < cropperTop){
                                        cropperNewHeight = leastHeight + "px";
                                      $L(cropper).css({'height' : cropperNewHeight})
                                    }
                                  } else if((cropperHeight + (evY - previousClientY))>maxHeight){
                                    if(evY >= opacityDivBottom){
                                      if(maxHeight != fixedImageheight){
                                        cropperNewHeight = maxHeight + "px";
                                      } else {
                                        cropperNewHeight = opacityDivBottom - cropperTop + "px";
                                      }
                                      $L(cropper).css({'height' : cropperNewHeight})
                                    }
                                  }
                                } else {
                                      if(((cropperWidth - (evX - previousClientX))>=leastWidth)&&((cropperWidth - (evX - previousClientX))<=maxWidth)){
                                      if(evX > opacityDivLeft){
                                        cropperNewWidth   = cropperWidth - (presentClientX - previousClientX) + "px";
                                        cropperNewHeight  = (cropperWidth - (presentClientX - previousClientX))/aspectDiff + "px";
                                        cropperNewLeft    = ((cropperLeft - cropAreaLeft) + (evX - previousClientX))+ "px";
                                        $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight , 'left' : cropperNewLeft})
                                      }
                                      upDCropperDD();
                                      if(evX-6 <= opacityDivLeft+2){
                                        if((!(cropperDummyData.height >= opacityDivHeight))||(!(cropperDummyData.width >= opacityDivWidth))&&(cropperDummyData.left < opacityDivLeft)){
                                          cropperNewLeft = opacityDivLeft - cropAreaLeft  + "px";
                                        }
                                        cropperNewWidth = (cropperRight - opacityDivLeft) + "px";
                                        cropperNewHeight = (cropperRight - opacityDivLeft)/aspectDiff + "px";
                                        $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight , 'left' : cropperNewLeft})
                                      }
                                      upDCropperDD();
                                      if(cropperDummyData.bottom >= opacityDivBottom){
                                        cropperNewHeight = (opacityDivBottom - cropperTop) + "px";
                                        cropperNewWidth = (opacityDivBottom - cropperTop)*aspectDiff + "px";
                                        cropperNewLeft = opacityDivRight - (((opacityDivBottom - cropperTop)*aspectDiff) + (opacityDivRight - cropperRight)) - cropAreaLeft + "px";
                                        $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight , 'left' : cropperNewLeft})
                                      }
                                    }else if((cropperWidth - (evX - previousClientX))<=leastWidth){
                                      if(!(aspectRatio === "n:n")){
                                        cropperNewLeft    = (cropperRight - leastWidth) - cropAreaLeft + "px";
                                        cropperNewWidth   = leastWidth + "px";
                                        cropperNewHeight  = leastHeight + "px";
                                        $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight , 'left' : cropperNewLeft})
                                      }
                                    }
                                    else if((cropperWidth - (evX - previousClientX))>=maxWidth){
                                      if(!(aspectRatio === "n:n")){
                                        var checkHeight = (cropperWidth - (presentClientX - previousClientX))/aspectDiff;
                                        var checkWidth = cropperWidth - (presentClientX - previousClientX);
                                        var checkLeft = ((cropperLeft - cropAreaLeft) + (evX - previousClientX));
                                        if(((checkHeight >= maxHeight)||(checkWidth >= maxWidth))&&((evX-6 < opacityDivLeft)&&((cropperRight - opacityDivLeft)>=maxWidth))&&(opacityDivBottom - cropperTop >= maxHeight)){
                                          cropperNewLeft    = (cropperRight - maxWidth) - cropAreaLeft + "px";
                                          // if(imageType === "portrait"){
                                          //   // cropperNewTop     = (midHeight - (maxHeight/2));
                                          //   if(cropperNewTop < 0){
                                          //     // cropperNewTop = 0 ;
                                          //   }
                                          //   if(cropperNewTop > (opacityDivBottom - maxHeight)-opacityDivTop){
                                          //     // cropperNewTop = (opacityDivBottom - maxHeight)-opacityDivTop ;
                                          //   }
                                          // } else {
                                          //   //cropperNewTop     = 0 + "px";
                                          // }
                                          cropperNewWidth   = maxWidth +"px";
                                          cropperNewHeight  = maxHeight + "px";
                                          $L(cropper).css({'width' : cropperNewWidth,'height' : cropperNewHeight,'left' : cropperNewLeft})
                                        }
                                      }
                                    }
                                  }
                                break;
                                }
                                var fixedImageTransform = fixedImage.style.transform;
                                fixedImage.style.transform = 'rotate(0deg)';
                                divImageImg.style.left = (getBCR(fixedImage).left - getBCR(cropper).left)+"px";
                                divImageImg.style.top = (getBCR(fixedImage).top - getBCR(cropper).top)+"px";
                                fixedImage.style.transform = fixedImageTransform;
                                setCropperData();
                              }
                              document.addEventListener("mousemove" , resizeCropper);
                              document.addEventListener("mouseup" , removeResizeEvent);
                            }

                            break;
                          }
                        }


                        function positionCropper(cropperDim , cropAreaDim , imageDim , ang1 , prevAng){

                              var ang = fixedImage.style.transform.match(/-?\d+/g)[0];

                              var angCheck = parseInt(ang);
                              var angCheck1 = angCheck;
                              angCheck = Math.abs(angCheck);

                              if((angCheck === 90) || (angCheck === 270)){

                              if(imageData.height<imageData.width){
                                fixedImage.style.width = divImageImg.style.width = getBCR(cropperDiv).height + "px";
                                fixedImage.style.height = divImageImg.style.height ="auto";
                                cropArea.style.height = getBCR(cropperDiv).height + "px";
                                cropArea.style.top = "0px";
                                cropArea.style.width = getBCR(fixedImage).width + "px";
                                var absLeft = Math.abs(getBCR(cropArea).left - getBCR(fixedImage).left);
                                if(window._lyteUiUtils.getRTL()){
                                  cropArea.style.left = "-"+((getBCR(cropperDiv).width - getBCR(cropArea).width)/2) + "px";
                                  fixedImage.style.left = -absLeft + "px";
                                } else{
                                  cropArea.style.left = ((getBCR(cropperDiv).width - getBCR(cropArea).width)/2) + "px";
                                  fixedImage.style.left = -absLeft + "px";
                                }
                              } else if(imageData.height>imageData.width){
                                fixedImage.style.width = divImageImg.style.width = "auto"
                                fixedImage.style.height = divImageImg.style.height = getBCR(cropperDiv).width + "px";
                                cropArea.style.width = getBCR(cropperDiv).width + "px";
                                cropArea.style.left = "0px";
                                cropArea.style.height = getBCR(fixedImage).height + "px";
                                cropArea.style.top = ((getBCR(cropperDiv).height - getBCR(cropArea).height)/2) + "px";
                                var x = Math.abs(getBCR(cropArea).left - getBCR(fixedImage).left);
                                if(window._lyteUiUtils){
                                  fixedImage.style.left = x + "px";
                                }else{
                                  fixedImage.style.left = x + "px";
                                }
                              }

                              fixedImage.style.top = (getBCR(cropArea).top - getBCR(fixedImage).top) + "px";

                              setMinAndMaxDim();

                              if(aspectRatio !== 'n:n'){
                                leastHeight = 15*(getBCR(cropArea).height/cropAreaDim.width);
                                leastWidth = leastHeight*aspectDiff;
                              } else {
                                leastHeight = 15*(getBCR(cropArea).height/cropAreaDim.width);
                                leastWidth = leastHeight;
                              }

                              var cropperWidth = (cropperDim.height*getBCR(cropArea).width) / cropAreaDim.height;
                              var cropperHeight = (cropperDim.width*getBCR(cropArea).height) / cropAreaDim.width;
                              var newCropperWidth = cropperWidth;
                              var newCropperHeight = cropperHeight;
                              if((leastWidth > cropperWidth)&&(aspectRatio != "n:n")) {
                                newCropperWidth = leastWidth;
                                newCropperHeight = newCropperWidth/aspectDiff;
                              }
                              if((leastHeight > cropperHeight)&&(aspectRatio != "n:n")) {
                                newCropperHeight = leastHeight;
                                newCropperWidth = newCropperHeight*aspectDiff;
                              }
                              cropper.style.width = newCropperWidth + "px";
                              cropper.style.height = newCropperHeight + "px";


                              if((angCheck1 === -90)||(angCheck1 === -270)){
                                cropper.style.left = (((cropperDim.top - cropAreaDim.top) * getBCR(cropArea).width)/cropAreaDim.height) + "px";
                                cropper.style.top = ((getBCR(cropArea).height) - ((((cropperDim.left - cropAreaDim.left) * getBCR(cropArea).height)/cropAreaDim.width) + getBCR(cropper).height) ) + "px";
                              }
                              if((angCheck1 === 90) || (angCheck1 === 270)){
                                cropper.style.top = (((cropperDim.left - cropAreaDim.left) * getBCR(cropArea).height)/cropAreaDim.width) + "px";
                                cropper.style.left = (getBCR(cropArea).width - ( getBCR(cropper).width + (((cropperDim.top - cropAreaDim.top)* getBCR(cropArea).width)/cropAreaDim.height))) + "px";
                              }



                            } else {

                              if(imageData.height<imageData.width){
                                fixedImage.style.width = divImageImg.style.width = getBCR(cropperDiv).width + "px";
                                fixedImage.style.height = divImageImg.style.height = "auto";
                                cropArea.style.width = getBCR(cropperDiv).width + "px";
                                cropArea.style.left = "0px";
                                cropArea.style.right = "";
                                cropArea.style.height = getBCR(fixedImage).height + "px";
                                cropArea.style.top = (getBCR(cropperDiv).height - getBCR(cropArea).height)/2 + "px";
                                fixedImage.style.left = (getBCR(cropArea).width - getBCR(fixedImage).width)/2 + "px";
                              } else {
                                fixedImage.style.width = divImageImg.style.width = "auto";
                                fixedImage.style.height = divImageImg.style.height = getBCR(cropperDiv).height + "px";
                                cropArea.style.height = getBCR(cropperDiv).height + "px";
                                cropArea.style.top = "0px";
                                cropArea.style.width = getBCR(fixedImage).width + "px";
                                if(window._lyteUiUtils.getRTL()){
                                  cropArea.style.left = "-"+(getBCR(cropperDiv).width - getBCR(cropArea).width)/2 + "px";
                                }else{
                                  cropArea.style.left = (getBCR(cropperDiv).width - getBCR(cropArea).width)/2 + "px";
                                }
                                fixedImage.style.left = (getBCR(cropArea).width - getBCR(fixedImage).width)/2 + "px";
                              }



                              fixedImage.style.top = (getBCR(box).height - getBCR(fixedImage).height)/2 + "px";

                              setMinAndMaxDim();

                              var cropperWidth = (cropperDim.height*getBCR(cropArea).width) / cropAreaDim.height;
                              var cropperHeight = (cropperDim.width*getBCR(cropArea).height) / cropAreaDim.width;
                              var newCropperWidth = cropperWidth;
                              var newCropperHeight = cropperHeight;
                              if((leastHeight > cropperHeight)&&(aspectRatio != "n:n")) {
                                newCropperHeight = leastHeight;
                                newCropperWidth = newCropperHeight * aspectDiff;
                              }
                              cropper.style.width = newCropperWidth + "px";
                              cropper.style.height = newCropperHeight + "px";

                              if((angCheck1 === -180)){
                                cropper.style.top = ((getBCR(cropArea).height) - ((((cropperDim.left - cropAreaDim.left) * getBCR(cropArea).height)/cropAreaDim.width) + getBCR(cropper).height) ) + "px";
                                cropper.style.left = (((cropperDim.top - cropAreaDim.top) * getBCR(cropArea).width)/cropAreaDim.height) + "px";
                              }
                              if((angCheck1 === 0)||(angCheck1 === 180)){
                                cropper.style.top = (((cropperDim.left - cropAreaDim.left) * getBCR(cropArea).height)/cropAreaDim.width) + "px";
                                cropper.style.left = (getBCR(cropArea).width - ( getBCR(cropper).width + (((cropperDim.top - cropAreaDim.top)* getBCR(cropArea).width)/cropAreaDim.height))) + "px";
                              }
                            }

                            var fixedImageTransform = fixedImage.style.transform;
                            fixedImage.style.transform = 'rotate(0deg)';
                            divImageImg.style.left = (getBCR(fixedImage).left - getBCR(cropper).left)+"px";
                            divImageImg.style.top = (getBCR(fixedImage).top - getBCR(cropper).top)+"px";
                            fixedImage.style.transform = fixedImageTransform;

                            }




                        function setCropperData(){

                          var cropperData = getBCR(cropper);

                          cropData.cropperDimensions = {
                            'top' : cropper.offsetTop,
                            'left' : cropper.offsetLeft,
                            'width' : cropperData.width,
                            'height' : cropperData.height
                          }
                          cropData.imageDimension = imageData;



                          function getImageResolution(){

                            var resoluWidth , resoluHeight;

                            var image = $L('.lyteCropDivImageImg')[0];

                            var widthScaleFactor = image.naturalWidth / image.getBoundingClientRect().width;
                            var heightScaleFactor = image.naturalHeight / image.getBoundingClientRect().height;
                            if((cropData.angle === 90) || (cropData.angle === 270)){
                              widthScaleFactor = image.naturalHeight / image.getBoundingClientRect().width;
                              heightScaleFactor = image.naturalWidth / image.getBoundingClientRect().height;
                            }




                            resoluWidth = cropper.getBoundingClientRect().width * widthScaleFactor;
                            resoluHeight = cropper.getBoundingClientRect().height * heightScaleFactor;

                            return { "width" : resoluWidth , "height" : resoluHeight }

                          }

                          cropData.resolution = getImageResolution();

                          cropData.rotate = function(){
                                var cropperDim = getBCR(cropper);
                                var cropAreaDim = getBCR(cropArea);
                                var imageDim = getBCR(fixedImage);
                                var angle;
                                var o = fixedImage.style.transform;
                                var prevAng;
                                if(o){
                                  angle = o.match(/-?\d+/g);
                                  prevAng = angle[0];
                                  angle = parseInt(angle[0]) + 90;
                                  if(angle >= 360){
                                    angle = 0;
                                  }
                                  fixedImage.style.transform = "rotate("+angle+"deg) rotateY("+exifRotateY+"deg)";
                                  divImageImg.style.transform = "rotate("+angle+"deg) rotateY("+exifRotateY+"deg)";
                                } else {
                                  var angle = 90;
                                  fixedImage.style.transform = "rotate("+angle+"deg) rotateY("+exifRotateY+"deg)";
                                  divImageImg.style.transform = "rotate("+angle+"deg) rotateY("+exifRotateY+"deg)";
                                }
                                initialRotateAngle = angle;
                                // if(cropData.angle === undefined){
                                  // cropData.angle = angle;
                                // } else {
                                cropData.angle = angle;
                                // }
                                aspectDiff = 1/aspectDiff;
                                if(imageType === "landscape"){
                                  imageType = "portrait";
                                } else {
                                  imageType = "landscape";
                                }
                                positionCropper(cropperDim , cropAreaDim , imageDim , angle , prevAng);
                                setCropperData();
                              };


                              cropData.getCroppedImage = function(){
                                var image = $L('.lyteCropDivImageImg')[0];
                                var cropperData = getBCR(cropper);
                                var cropperAreaData = getBCR(cropArea);
                                var divImageData = getBCR(divImageImg);

                                var scaleFactor = image.naturalWidth / cropperData.width;

                                function scaleIt(img , scaleFactor){

                                  var c1 = document.createElement('CANVAS');
                                  var ctx = c1.getContext('2d');
                                  c1.style.background = "#eee";


                                  var o = fixedImage.style.transform;
                                  var angle = 0;
                                  if(o){
                                    angle = o.match(/-?\d+/g);
                                    angle = parseInt(angle[0]);
                                  }
                                  if((Math.abs(angle) !== 90)&&(Math.abs(angle) !== 270)){
                                    divImageImg.style.transform = 'rotate(0deg) rotateY(' +exifRotateY+'deg)';
                                  }
                                  var cw;
                                  var ch;
                                  var cx = cropperAreaData.left - cropperData.left;
                                  var cy = cropperAreaData.top - cropperData.top;

                                  if((Math.abs(angle) !== 90)&&(Math.abs(angle) !== 270)){
                                    c1.width = Math.round(cropperData.width * (img.naturalWidth / divImageData.width));
                                    c1.height = Math.round(cropperData.height * (img.naturalHeight / divImageData.height));
                                    cw = img.naturalWidth;
                                    ch = img.naturalHeight;
                                  } else {
                                    c1.height = Math.round(cropperData.height * (img.naturalWidth / divImageData.height));
                                    c1.width = Math.round(cropperData.width * (img.naturalHeight / divImageData.width));
                                    ch = img.naturalWidth;
                                    cw = img.naturalHeight;
                                  }
                                  cx = cx * (cw / divImageData.width)
                                  cy = cy * (ch / divImageData.height)
                                  divImageImg.style.transform = o;



                                  if((angle !== 0)||(exifRotateY===180)){

                                    ctx.save();
                                    if((Math.abs(angle)%90 === 0)&&(!((Math.abs(angle) === 180)||(Math.abs(angle) === 360)))){
                                      var cW = img.naturalWidth;
                                      var cH = img.naturalHeight;
                                    }
                                    var halfWidth = cw / 2;
                                    var halfHeight = ch / 2;

                                    if(((Math.abs(angle)%90 === 0)&&(angle!=0))&&(!((Math.abs(angle) === 180)||(Math.abs(angle) === 360)))){

                                      ctx.translate( cx+halfWidth , cy+halfHeight);
                                      ctx.rotate(angle * (Math.PI/180));
                                      if(exifRotateY === 180){
                                        ctx.scale(-1, 1);
                                      }
                                      ctx.drawImage(image, -halfHeight, -halfWidth, ch, cw);
                                    } else {
                                      ctx.translate( cx+cw/2 , cy+ch/2);
                                      ctx.rotate(angle * (Math.PI/180));
                                      if(exifRotateY === 180){
                                        ctx.scale(-1, 1);
                                      }
                                      ctx.drawImage(image,-cw/2,-ch/2,cw,ch);
                                    }
                                    ctx.restore();
                                  } else {
                                    ctx.drawImage(img , cx , cy , cw , ch);
                                  }

                                  function convertCanvasToImage(cc) {
                                    var image = new window.Image();
                                    image.src = cc.toDataURL("image/jpeg");
                                    return image;
                                  }

                                  // return convertCanvasToImage(c1);
                                  return c1;

                                }

                                return scaleIt(image , scaleFactor);


                              }

                              cropData.changeByHeight = function(val){

                                var retObj = {}

                                var cropperData = getBCR(cropper);
                                var opacityDivData = getBCR(opacityDiv)

                                var newHeight = parseFloat(val);

                                if(!(newHeight + getBCR(cropper).top <= getBCR(opacityDiv).bottom)){
                                  newHeight = getBCR(opacityDiv).bottom - getBCR(cropper).top;
                                }

                                var newTop;

                                var leftMid = getBCR(cropper).left + getBCR(cropper).width/2 - getBCR(opacityDiv).left;


                                if(newHeight>=maxHeight){
                                  newHeight = maxHeight;
                                }
                                if(newHeight<=leastHeight){
                                  newHeight = leastHeight;
                                }

                                var newWidth = newHeight*aspectDiff;

                                if(cropperData.top + newHeight >= opacityDivData.bottom ){
                                  newTop = opacityDivData.bottom - newHeight - opacityDivData.top;
                                  $L(cropper).css({'top' : newTop})
                                }

                                var cropperNewLeft = leftMid - newWidth/2;

                                if(cropperNewLeft >= 0){
                                  $L(cropper).css({'left' : cropperNewLeft})
                                }
                                if(cropperNewLeft+newWidth >= getBCR(opacityDiv).right - getBCR(opacityDiv).left){
                                  cropperNewLeft = getBCR(opacityDiv).right - newWidth - getBCR(opacityDiv).left;
                                  $L(cropper).css({'left' : cropperNewLeft})
                                }

                                if(aspectRatio !== 'n:n'){
                                  $L(cropper).css({'width' : newWidth,'height' : newHeight})
                                } else {
                                  newWidth = getBCR(cropper).width;
                                  $L(cropper).css({'height' : newHeight})
                                }

                                if(val === 'NaN'){
                                    newWidth = leastWidth;
                                    newHeight = leastHeight;
                                }

                                retObj = {'cropperWidth' : newWidth , 'cropperHeight' : newHeight};

                                var fixedImageTransform = fixedImage.style.transform;
                                fixedImage.style.transform = 'rotate(0deg)';
                                divImageImg.style.left = (getBCR(fixedImage).left - getBCR(cropper).left)+"px";
                                divImageImg.style.top = (getBCR(fixedImage).top - getBCR(cropper).top)+"px";
                                fixedImage.style.transform = fixedImageTransform;

                                setCropperData();

                                return retObj;

                              }


                              cropData.changeByWidth = function(val){

                                var retObj = {};

                                var newWidth = parseFloat(val);

                                if(!(newWidth + getBCR(cropper).left <= getBCR(opacityDiv).right)){
                                  newWidth = getBCR(opacityDiv).right - getBCR(cropper).left;
                                }

                                var newLeft;
                                var cropperData = getBCR(cropper);
                                var opacityDivData = getBCR(opacityDiv);

                                var topMid = getBCR(cropper).top + getBCR(cropper).height/2 - getBCR(opacityDiv).top;

                                if(newWidth>=maxWidth){
                                  newWidth = maxWidth;
                                }
                                if(newWidth<=leastWidth){
                                  newWidth = leastWidth;
                                }

                                var newHeight = newWidth/aspectDiff;

                                if(cropperData.left + newWidth >= opacityDivData.right ){
                                  newLeft = opacityDivData.right - newWidth - opacityDivData.left;
                                  $L(cropper).css({'left' : newLeft})
                                }

                                var cropperNewTop = topMid - newHeight/2;

                                if(cropperNewTop >= 0){
                                  $L(cropper).css({'top' : cropperNewTop})
                                }

                                if(cropperNewTop+newHeight >= getBCR(opacityDiv).bottom - getBCR(opacityDiv).top){
                                  cropperNewTop = getBCR(opacityDiv).bottom - newHeight - getBCR(opacityDiv).top;
                                  $L(cropper).css({'top' : cropperNewTop})
                                }


                                if(aspectRatio !== 'n:n'){
                                  $L(cropper).css({'width' : newWidth,'height' : newHeight})
                                } else {
                                  newHeight = getBCR(cropper).height;
                                  $L(cropper).css({'width' : newWidth})
                                }

                                if(val === 'NaN'){
                                    newWidth = leastWidth;
                                    newHeight = leastHeight;
                                }

                                retObj = {'cropperWidth' : newWidth , 'cropperHeight' : newHeight};

                                var fixedImageTransform = fixedImage.style.transform;
                                fixedImage.style.transform = 'rotate(0deg)';
                                divImageImg.style.left = (getBCR(fixedImage).left - getBCR(cropper).left)+"px";
                                divImageImg.style.top = (getBCR(fixedImage).top - getBCR(cropper).top)+"px";
                                fixedImage.style.transform = fixedImageTransform;

                                setCropperData();

                                return retObj;

                              }

                              cropData.deleteCropper = function(){

                                cropperDiv.removeChild(cropArea)
                                imageTag.style.display = 'block'

                              }

                              cropData.swapAspectRatio = function(){

                                aspectDiff = 1/aspectDiff

                                setMinAndMaxDim();

                                var cropperOldHeight = getBCR(cropper).height;
                                var cropperOldWidth = getBCR(cropper).width;
                                var cropperNewTop ;
                                var cropperNewLeft;
                                var topMid = getBCR(cropper).height/2 + getBCR(cropper).top;
                                var leftMid = getBCR(cropper).width/2 + getBCR(cropper).left;

                                var cropperNewWidth;
                                var cropperNewHeight;



                                if(getBCR(cropper).top + cropperOldWidth > getBCR(opacityDiv).bottom){
                                  cropperNewTop = getBCR(opacityDiv).bottom - cropperOldWidth - getBCR(opacityDiv).top;
                                  $L(cropper).css({'top' : cropperNewTop})
                                } else {
                                  cropperNewTop = topMid - (getBCR(cropper).width/2) - getBCR(opacityDiv).top;
                                  if(cropperNewTop <= 0){
                                    cropperNewTop = 0;
                                  }
                                  $L(cropper).css({'top' : cropperNewTop})
                                }
                                if(getBCR(cropper).left + cropperOldHeight > getBCR(opacityDiv).right){
                                  cropperNewLeft = getBCR(opacityDiv).right - cropperOldHeight - getBCR(opacityDiv).left;
                                  $L(cropper).css({'left' : cropperNewLeft})
                                } else {
                                  cropperNewLeft = leftMid - (getBCR(cropper).height/2) - getBCR(opacityDiv).left;
                                  if(cropperNewLeft <= 0 ){
                                    cropperNewLeft = 0;
                                  }
                                  $L(cropper).css({'left' : cropperNewLeft})
                                }

                                $L(cropper).css({'width' : cropperOldHeight,'height' : cropperOldWidth})

                                if(cropperOldWidth >= getBCR(fixedImage).height){
                                  cropperNewWidth = getBCR(fixedImage).height * aspectDiff;
                                  cropperNewHeight = getBCR(fixedImage).height ;
                                  cropperNewLeft = (getBCR(fixedImage).width - cropperNewWidth)/2;
                                  $L(cropper).css({'height' : cropperNewHeight , 'width' : cropperNewWidth , 'top' : 0 , 'left' : cropperNewLeft});
                                }
                                if(cropperOldHeight >= getBCR(fixedImage).width){
                                  cropperNewWidth = getBCR(fixedImage).width;
                                  cropperNewHeight = getBCR(fixedImage).width / aspectDiff;
                                  cropperNewTop = (getBCR(fixedImage).height - cropperNewHeight)/2;
                                  $L(cropper).css({'height' : cropperNewHeight , 'width' : cropperNewWidth , 'left' : 0 , 'top' : cropperNewTop});
                                }


                                var fixedImageTransform = fixedImage.style.transform ;
                                fixedImage.style.transform = 'rotate(0deg)';
                                divImageImg.style.left = (getBCR(fixedImage).left - getBCR(cropper).left)+"px";
                                divImageImg.style.top = (getBCR(fixedImage).top - getBCR(cropper).top)+"px";
                                fixedImage.style.transform = fixedImageTransform+ 'rotateY('+exifRotateY+')';

                                setCropperData();

                              }

                              cropData.angle = initialRotateAngle;
                              cropData.exifAngle = exifRotateY;

                          $L(imageTag).data('cropper' , cropData);
                        }
        } else if(aRD.type === 'DP'){


            var mainImage = this[0];
            var mainImageDimension = mainImage.getBoundingClientRect()
            mainImage.style.display = 'none';
            var imageParent = mainImage.parentElement;
            var imageParentDimension = imageParent.getBoundingClientRect()
            var imageType;
            var inImageDimension;
            var cropData = {}
            var initialImageValue;

            if(!aRD){
              aRD = {}
            }

            if(!aRD.cropperSize){
              aRD.cropperSize = 300
            }

            var mainArea,backImage,frontImage,visualArea,freezeDiv


            if(mainImageDimension.height < mainImageDimension.width){
              imageType = "landscape";
            } else {
              imageType = "portrait";
            }

            var generateDiv = function(){

              mainArea = document.createElement('DIV');
              freezeDiv = document.createElement('DIV');
              backImage = document.createElement('IMG');
              visualArea = document.createElement('DIV');
              frontImage = document.createElement('IMG');


              backImage.src = frontImage.src = mainImage.src

              mainArea.setAttribute('class' , 'lytePSParent')
              freezeDiv.setAttribute('class' , 'lytePSFreezeLayer')
              backImage.setAttribute('class' , 'lytePSBackImage')
              visualArea.setAttribute('class' , 'lytePSvisualArea')
              frontImage.setAttribute('class' , 'lytePSFrontImage')

              if(imageType === "landscape"){
                backImage.style.height = aRD.cropperSize + "px";
                frontImage.style.height = aRD.cropperSize + "px";
              } else {
                backImage.style.width = aRD.cropperSize + "px";
                frontImage.style.width = aRD.cropperSize + "px";
              }


              appendFunction()
              setDimensions()

            }

            var appendFunction = function(){

              mainArea.appendChild(backImage)
              mainArea.appendChild(freezeDiv)
              visualArea.appendChild(frontImage)
              mainArea.appendChild(visualArea)
              imageParent.appendChild(mainArea)

              inImageDimension = backImage.getBoundingClientRect()

            }

            var setDimensions = function(){

              visualArea.style.width = visualArea.style.height = aRD.cropperSize + "px"

              visualArea.style.top = (imageParentDimension.height/2 - aRD.cropperSize/2) + "px";
              visualArea.style.left = (imageParentDimension.width/2 - aRD.cropperSize/2) + "px";
              if(imageType === "landscape"){
                backImage.style.top = (imageParentDimension.height/2 - aRD.cropperSize/2)+ "px";
                backImage.style.left = (imageParentDimension.width - inImageDimension.width)/2 + "px";
              } else {
                backImage.style.top = (imageParentDimension.height - inImageDimension.height)/2 + "px";
                backImage.style.left = (imageParentDimension.width/2 - aRD.cropperSize/2) + "px";
              }
              frontImage.style.left = (backImage.getBoundingClientRect().left - visualArea.getBoundingClientRect().left) + "px"
              frontImage.style.top = (backImage.getBoundingClientRect().top - visualArea.getBoundingClientRect().top) + "px"


              initialImageValue = backImage.getBoundingClientRect()


              imageParent.addEventListener('mousedown' , psMouseDown)


            }

            var bst , bsl
            var preY , preX

            var psMouseDown = function(eve){
              if($L(eve.target).hasClass('lytePSvisualArea')){

                imageParent.addEventListener('mousemove' , psMoveImage)
                imageParent.addEventListener('mouseup' , remPsFun)

                bst = backImage.getBoundingClientRect().top - imageParent.getBoundingClientRect().top
                bsl = backImage.getBoundingClientRect().left - imageParent.getBoundingClientRect().left
                preY = eve.clientY
                preX = eve.clientX

              }
            }

            var psMoveImage = function(eve){

              var mFT = ((-1*(imageParentDimension.height/2 - aRD.cropperSize/2)) + (bst - (preY - eve.clientY)))
              var mBT = (bst - (preY - eve.clientY))
              var mFL = (((bsl - (preX - eve.clientX)))-(imageParentDimension.width/2 - aRD.cropperSize/2))
              var mBL = (bsl - (preX - eve.clientX))

              if(mBL <= (visualArea.getBoundingClientRect().left - imageParent.getBoundingClientRect().left)){
                backImage.style.left = (bsl - (preX - eve.clientX)) + "px"
                frontImage.style.left = (((bsl - (preX - eve.clientX)))-(imageParentDimension.width/2 - aRD.cropperSize/2)) + "px"
              } else {
                backImage.style.left = (visualArea.getBoundingClientRect().left - imageParent.getBoundingClientRect().left) + "px"
                frontImage.style.left = ((visualArea.getBoundingClientRect().left - imageParent.getBoundingClientRect().left) - (imageParentDimension.width/2 - aRD.cropperSize/2)) + "px";
              }


              if(
                (mBL + backImage.getBoundingClientRect().width) < ((visualArea.getBoundingClientRect().left - imageParent.getBoundingClientRect().left) + visualArea.getBoundingClientRect().width )
              ){

                backImage.style.left = -1*((backImage.getBoundingClientRect().width - visualArea.getBoundingClientRect().width) - (visualArea.getBoundingClientRect().left - imageParent.getBoundingClientRect().left)) + "px"
                frontImage.style.left = (-1*((backImage.getBoundingClientRect().width - visualArea.getBoundingClientRect().width) - (visualArea.getBoundingClientRect().left - imageParent.getBoundingClientRect().left)) - (imageParentDimension.width/2 - aRD.cropperSize/2)) + "px";

              }



              if(mBT <= (visualArea.getBoundingClientRect().top - imageParent.getBoundingClientRect().top)){
                backImage.style.top = (bst - (preY - eve.clientY)) + "px"
                frontImage.style.top = ((-1*(imageParentDimension.height/2 - aRD.cropperSize/2)) + (bst - (preY - eve.clientY))) + "px"
              } else {
                backImage.style.top = (visualArea.getBoundingClientRect().top - imageParent.getBoundingClientRect().top) + "px"
                frontImage.style.top = ((-1*(imageParentDimension.height/2 - aRD.cropperSize/2)) + (visualArea.getBoundingClientRect().top - imageParent.getBoundingClientRect().top)) + "px"
              }

              if(
                (mBT + backImage.getBoundingClientRect().height) < ((visualArea.getBoundingClientRect().top - imageParent.getBoundingClientRect().top) + visualArea.getBoundingClientRect().height )
              ){

                backImage.style.top = -1*((backImage.getBoundingClientRect().height - visualArea.getBoundingClientRect().height) - (visualArea.getBoundingClientRect().top - imageParent.getBoundingClientRect().top)) + "px"
                frontImage.style.top = (-1*((backImage.getBoundingClientRect().height - visualArea.getBoundingClientRect().height) - (visualArea.getBoundingClientRect().top - imageParent.getBoundingClientRect().top)) - (imageParentDimension.height/2 - aRD.cropperSize/2)) + "px";

              }


            }

            var remPsFun = function(eve){

              imageParent.removeEventListener('mousemove' , psMoveImage)
              imageParent.removeEventListener('mouseup' , remPsFun)

            }

            generateDiv();

            cropData.zoomImage = function(percent) {
              var scaleValue = (percent / 100) + 1;
              var iamgeParentDimension = imageParent.getBoundingClientRect();

              var backImageCurrentTop = parseFloat(backImage.style.top);
              var backImageCurrentLeft = parseFloat(backImage.style.left);
              var backImageCurrentDimension = backImage.getBoundingClientRect();
              var backImageCurrentHeight = backImageCurrentDimension.height;
              var backImageCurrentWidth = backImageCurrentDimension.width;
              var backImageCurrentRight = backImageCurrentLeft + backImageCurrentWidth;
              var backImageCurrentBottom = backImageCurrentTop + backImageCurrentHeight;

              var cropperDimension = visualArea.getBoundingClientRect();
              var cropperTop = cropperDimension.top - iamgeParentDimension.top;
              var cropperLeft = cropperDimension.left - iamgeParentDimension.left;
              var cropperRight = cropperLeft + cropperDimension.width;
              var cropperBottom = cropperTop + cropperDimension.height;

              var LeftGapBetweenImageAndCropper = cropperLeft - backImageCurrentLeft;
              var rightGapBetweenImageAndCropper = backImageCurrentRight - cropperRight;
              var topGapBetweenImageAndCropper = cropperTop - backImageCurrentTop;
              var BottomGapBetweenImageAndCropper = backImageCurrentBottom - cropperBottom;

              var imageHeightNew = initialImageValue.height*scaleValue;
              var imageWidthNew = initialImageValue.width*scaleValue;

              var oldTotalHorizontalGap = backImageCurrentWidth - cropperDimension.width;
              var oldTotalVerticalGap = backImageCurrentHeight - cropperDimension.height;
              var newTotalHorizontalGap = imageWidthNew - cropperDimension.width;
              var newTotalVerticalGap = imageHeightNew - cropperDimension.height;

              var imageHeightDiff = imageHeightNew - backImageCurrentHeight;
              var imageWidthDiff = imageWidthNew - backImageCurrentWidth;

              var newLeftGapBetweenImageAndCropper = (LeftGapBetweenImageAndCropper/ oldTotalHorizontalGap) * newTotalHorizontalGap;
              var newTopGapBetweenImageAndCropper = (topGapBetweenImageAndCropper / oldTotalVerticalGap) * newTotalVerticalGap;

              var backImageTopNew, backImageLeftNew;
              if((LeftGapBetweenImageAndCropper == rightGapBetweenImageAndCropper) && (topGapBetweenImageAndCropper == BottomGapBetweenImageAndCropper)) {
                  backImageLeftNew = backImageCurrentLeft - (imageWidthDiff / 2);
                  backImageTopNew = backImageCurrentTop - (imageHeightDiff / 2);
              }
              else if(LeftGapBetweenImageAndCropper == rightGapBetweenImageAndCropper) {
                  backImageTopNew = cropperTop - newTopGapBetweenImageAndCropper;
                  backImageLeftNew = backImageCurrentLeft - (imageWidthDiff / 2);
              }
              else if(topGapBetweenImageAndCropper == BottomGapBetweenImageAndCropper) {
                  backImageTopNew = backImageCurrentTop - (imageHeightDiff / 2);
                  backImageLeftNew = cropperLeft - newLeftGapBetweenImageAndCropper;
              }
              else {
                  backImageTopNew = cropperTop - newTopGapBetweenImageAndCropper;
                  backImageLeftNew = cropperLeft - newLeftGapBetweenImageAndCropper;
              }

              if(imageType === "landscape"){
                  backImage.style.height = imageHeightNew + "px";
                  frontImage.style.height = imageHeightNew + "px";
              } else {
                  backImage.style.width = imageWidthNew + "px";
                  frontImage.style.width = imageWidthNew + "px";
              }

              backImage.style.top = backImageTopNew + "px";
              frontImage.style.top = (backImageTopNew - cropperTop) + "px";
              backImage.style.left = backImageLeftNew + "px";
              frontImage.style.left = (backImageLeftNew - cropperLeft) + "px"
          }
          cropData.getCroppedImage = function(){
            var image = frontImage;
            var cropperData = visualArea.getBoundingClientRect();
            var mainAreaData = mainArea.getBoundingClientRect();
            var divImageData = frontImage.getBoundingClientRect();

            var scaleFactor = image.naturalWidth / cropperData.width;

            function scaleIt(img , scaleFactor){

              var c1 = document.createElement('CANVAS');
              var ctx = c1.getContext('2d');
              c1.style.background = "#eee";


              var o = backImage.style.transform;
              var angle = 0;
              if(o){
                angle = o.match(/-?\d+/g);
                angle = parseInt(angle[0]);
              }
              var cw;
              var ch;
              var cx = divImageData.left - cropperData.left;
              var cy = divImageData.top - cropperData.top;

              if((Math.abs(angle) !== 90)&&(Math.abs(angle) !== 270)){
                c1.width = Math.round(cropperData.width * (image.naturalWidth / divImageData.width));
                c1.height = Math.round(cropperData.height * (image.naturalHeight / divImageData.height));
                cw = image.naturalWidth;
                ch = image.naturalHeight;
              } else {
                c1.height = Math.round(cropperData.height * (image.naturalWidth / divImageData.height));
                c1.width = Math.round(cropperData.width * (image.naturalHeight / divImageData.width));
                ch = image.naturalWidth;
                cw = image.naturalHeight;
              }
              cx = cx * (cw / divImageData.width)
              cy = cy * (ch / divImageData.height)
              frontImage.style.transform = o;

              ctx.drawImage(image , cx , cy , cw , ch);

              // return convertCanvasToImage(c1);
              return c1;

            }

            return scaleIt(image , scaleFactor);


          }

            $L(mainImage).data('lyteCrop' , cropData);
        }
      }

    }
  }
} );
( function( factory ) {
    if( typeof define === "function" && define.amd ) {
        define( [ "@zoho/lyte-dom" ], factory );
    }
    else {
        factory( $L );
    }
} )(function( $L ) {
	if($L){
		$L.prototype.manageDraggable = {
            init : false,
            draggedEle : null,
            isRestricted : function(restrict,element){
                restrict = restrict instanceof Array ? restrict : restrict.split(",");
                for(var i = 0; i<restrict.length; i++){
                    var elements = document.querySelectorAll(restrict[i]);
                    for(var j = 0; j < elements.length; j++){
                        if(element.isEqualNode(elements[j])){
                            return true;
                        }
                    }
                }
                return false;
            },
            destroy : function(element){
                var draggableParent;
                if(!element._draggableData && (this.hasClassOrAttr(true,element,'draggable-element') || (this.hasClassOrAttr(false,element,'draggable-element'))) ){
                    var handleElems = element.querySelector('[draggable-handle-element]');
                    draggableParent = element;
                    element = handleElems ? handleElems : element.querySelector('.draggable-handle-element');
                }
                if(!element._draggableData || !(this.hasClassOrAttr(element._draggableData.attribute,element,'draggable-element')) && !(this.hasClassOrAttr(element._draggableData.attribute,element,'draggable-handle-element'))){
                    console.info("ALERT! - U have already destroyed its draggable behaviour.");
                    return;
                }
                var attribute = element._draggableData.attribute;
                if(this.hasClassOrAttr(attribute,element,'draggable-handle-element')){
                    this.removeClassOrAttr(attribute,element,'draggable-handle-element');
                    element.removeEventListener('mousedown',element._draggableData.__mousedown);
                    if(element._draggableData.aria){
                        element.removeEventListener('keydown',element._draggableData.__keyDownEvent);
                    }
                    element.removeEventListener('touchstart',element._draggableData.__mousedown, true);
                    element._draggableData = null;
                }
                else{
                    var handleElems = element.querySelectorAll('[draggable-handle-element]');
                    handleElems= handleElems.length ? handleElems : element.querySelectorAll('.draggable-handle-element');
                    for(var i = 0; i<handleElems.length; i++){
                        this.removeClassOrAttr(attribute,handleElems[i],'draggable-handle-element');
                        handleElems[i].removeEventListener('mousedown',handleElems[i]._draggableData.__mousedown);
                        if(handleElems[i]._draggableData.aria){
                            handleElems[i].removeEventListener('keydown',element._draggableData.__keyDownEvent);
                        }
                        handleElems[i].removeEventListener('touchstart',handleElems[i]._draggableData.__mousedown, true);
                        handleElems[i]._draggableData = null;
                    }
                }
                if(draggableParent){
                    this.removeClassOrAttr(attribute,draggableParent,'draggable-element');
                    draggableParent._mousedown = undefined;
                }else{
                    this.removeClassOrAttr(attribute,element,'draggable-element');
                }
                this.removeClassOrAttr(attribute,element,'draggable-helper-element');
                element._mousedown = undefined;
            },
            removeClassOrAttr :function(attribute,elem,name){
                if(attribute){
                    $L(elem).removeAttr(name)
                }else{
                    $L(elem).removeClass(name);
                }

            },
            hasClassOrAttr : function(attribute,elem,name){
                if(attribute){
                    return $L(elem).attr(name) !== undefined;
                }else{
                    return $L(elem).hasClass(name);
                }

            },
            addClassOrAttr : function(attribute,elem,name){
                if(attribute){
                    $L(elem).attr(name,'');
                }else{
                    $L(elem).addClass(name);
                }

            }

        };
        $L.prototype.draggable = function(object) {
            var manageDraggable = $L.prototype.manageDraggable;
            var managerDD = $L.prototype.managerDD;
            if(!manageDraggable.init){
                if (!window.Element.prototype.matches) {
                    window.Element.prototype.matches =
                        Element.prototype.matchesSelector ||
                        Element.prototype.mozMatchesSelector ||
                        Element.prototype.msMatchesSelector ||
                        Element.prototype.oMatchesSelector ||
                        Element.prototype.webkitMatchesSelector ||
                        function(s) {
                            var matches = (this.document || this.ownerDocument).querySelectorAll(s),
                                i = matches.length - 1;
                            while (i >= 0 && matches.item(i) !== this){
                                --i;
                                //gets the index of the matched item
                            }
                            return i > -1;
                        };
                }
                manageDraggable.init = true;
            }

            if(typeof object === "string" && object === "destroy"){
                if(this.length > 1){
                    var elemArray = this;
                    for(var i = 0; i<elemArray.length; i++){
                        manageDraggable.destroy(elemArray[i]);
                    }
                }
                else{
                    manageDraggable.destroy(this[0]);
                }
                return;
            }

            var data = object ? object : {};

            if(this.length > 1){
                var elemArray = this;
                for(var i = 0; i<elemArray.length; i++){
                    $L(elemArray[i]).draggable(Object.assign({},data));
                }
                return;
            }
            //Parent Element
            if(data.restrict && manageDraggable.isRestricted(data.restrict,this[0])){
                return;
            }
            data._element = this[0];
            manageDraggable.addClassOrAttr(data.attribute,data._element,'draggable-element');

            var _handleElement;
            var _initClientX;
            var _initClientY;
            var _initialPos = {};
            var _offset = [0,0];
            var _marginTop = 0;
            var _marginLeft = 0;
            var _placeholder;
            var _sortableElemClass;
            var _positionedPlceholder = false;
            var _requestId1;
            var _animationFrameFired1;
            var _elemBelow;
            var droppablePlace;
            var returnVal;
            var prevDimension = null;
            var _maxScrollHeight;
            var _maxScrollWidth;
            var _scrollTop;
            var _scrollLeft;
            var _requestId2;
            var _animationFrameFired2;
            var _borderVal = {
                left : parseFloat(getComputedStyle($L(this)[0]).borderLeft.split(' ')[0]),
                right : parseFloat(getComputedStyle($L(this)[0]).borderRight.split(' ')[0]),
                top : parseFloat(getComputedStyle($L(this)[0]).borderTop.split(' ')[0]),
                bottom : parseFloat(getComputedStyle($L(this)[0]).borderBottom.split(' ')[0])
            }

            //Data initialization
            data.cancel = data.cancel === undefined ? [] : data.cancel instanceof Array ? data.cancel : data.cancel.split(",");
            data.placeholder = data.placeholder ? data.placeholder : "lyteDraggablePlaceholder";
            data.containment = (data.containment === undefined) ? document : $L(data.containment)[0];
            data.orientation = (data.orientation === undefined) ? "default" : data.orientation;
            data.handle = (data.handle === undefined) ? this[0] : data.handle;
            data.restrict = data.restrict === undefined ? [] : data.restrict instanceof Array ? data.restrict : data.restrict.split(",");
            data.helper = data.helper ? data.helper : "original";
            data.connectToSortable = $L(data.connectToSortable).length ? data.connectToSortable : null;
            data.cursorAt = data.cursorAt;
            data.disabled = data.disabled ? data.disabled : "lyteDraggableDisabledPlaceholder";
            data.appendTo = data.appendTo && data.appendTo != "parent" ? $L(data.appendTo)[0] : "parent";
            data.bubbles = data.bubbles === undefined ? true : data.bubbles;
            data.mouseUpBubbles = data.mouseUpBubbles ? data.mouseUpBubbles : false;
            data.scrollDivX = data.scrollDivX ? (typeof data.scrollDivX == "string" ? document.querySelector(data.scrollDivX) : data.scrollDivX) : undefined;
            data.scrollDivY = data.scrollDivY ? (typeof data.scrollDivY == "string" ? document.querySelector(data.scrollDivY) : data.scrollDivY) : undefined;
            data.scrollSpeed = data.scrollSpeed ? parseInt(data.scrollSpeed) : 10;
            data.threshold = data.threshold ? parseInt(data.threshold) : 0;
            data.hasContainment = data.hasContainment ? data.hasContainment : false;
            data.minVisible = data.minVisible ? data.minVisible : 0;
            data.restrictLeftTopOnly = data.restrictLeftTopOnly ? data.restrictLeftTopOnly : false;
            data.attribute = data.attribute ? data.attribute : false;
            data.dblTouchEvent = data.dblTouchEvent ? data.dblTouchEvent : false;
            data.bindDroppable = data.bindDroppable ? data.bindDroppable : false;
            data.aria = data.aria ? data.aria : false;

            if(data.scrollSpeed < 1){
                data.scrollSpeed = 1;
            }
            
            function checkfordraggable(targetElem){
                var cancel = data.cancel || [];
                for(var index = 0; index < cancel.length ; index++){
                    var elem = targetElem;
                    while(elem.parentElement){
                        if(elem.matches(data.cancel[index])){
                            return true;
                        }
                        if(manageDraggable.hasClassOrAttr(data.attribute,elem,'draggable-handle-element')){
                            break;
                        }
                        elem = elem.parentElement;
                    }
                }
                return false;
            }
            function mouseDownEvent(event){
                
                // event.preventDefault();
                // calling mousedown from draggable;
                //Disable right click on the sortable elements to avoid unwanted behaviour
                if(event.which == 3){
                    return;
                }
                _initClientX = event.clientX
                _initClientY = event.clientY
                if(checkfordraggable(event.target)){
                    return;
                }
                var _handleElement =  event.target.closest('[draggable-handle-element]') ;
                _handleElement = _handleElement ? _handleElement : event.target.closest('.draggable-handle-element');
                manageDraggable.draggedEle = _handleElement;
                if(_handleElement){
                    if(!_handleElement._draggableData.bubbles){
                        event.stopPropagation();
                    }
                    var data = _handleElement._draggableData;
                    var elem = data._element;
                    var elemOffset = elem.getBoundingClientRect();
                    var cs = window.getComputedStyle(elem);
                    var width = elemOffset.width;
                    var height = elemOffset.height;
                    data._offParent = elem.offsetParent || $L('body')[0];
                    data._parent = elem.parentElement;
                    data._zIndex = window.getComputedStyle(elem);
                    var returnVal = true;

                    //Callback fired
                    if(data.onStart){
                        returnVal = onStart(data, event);
                    }
                    if(returnVal){
                        if(returnVal.then){
                            returnVal.then(function(start){
                                if(start){
                                    initializeDragEvents(elem,data,_handleElement,event);
                                }
                            });
                        }else{
                            initializeDragEvents(elem,data,_handleElement,event)
                        }
                    }
                }
                else{
                    _handleElement = null;
                }
            }

            function initializeDragEvents (elem,data,_handleElement,event){
                var data = _handleElement._draggableData;
                var elem = data._element;
                var elemOffset = elem.getBoundingClientRect();
                var cs = window.getComputedStyle(elem);
                var width = elemOffset.width;
                var height = elemOffset.height;
                _initialPos = {
                        x : elem.offsetLeft,
                        y : elem.offsetTop,
                        pos : $L(elem).css('position')
                    };
                    if(data.cursorAt){
                        _offset = [
                            data.cursorAt.left,
                            data.cursorAt.top
                        ];
                    }
                    else{
                        if(event.type == "mousedown"){
                            _offset = [
                                event.clientX - elemOffset.left,
                                event.clientY - elemOffset.top
                            ];
                        }
                        else if(event.type == "touchstart"){
                            _offset = [
                                event.touches[0].clientX - elemOffset.left,
                                event.touches[0].clientY - elemOffset.top
                            ];
                        }
                    }
                    // if(event.type == "mousedown"){
                    //  _offset = [
                    //      event.clientX - elemOffset.left,
                    //      event.clientY - elemOffset.top
                    //  ];
                    // }
                    if(event.type == "touchstart"){
                        // _offset = [
                        //  event.touches[0].clientX - elemOffset.left,
                        //  event.touches[0].clientY - elemOffset.top
                        // ];

                        //Binding touch events
                        
                        document.addEventListener('touchmove',mouseMoveEvent, true);
                        document.addEventListener('touchend',mouseUpEvent, true);
                        data._element.classList.add('stopDefaultMove');
                    }

                    if(cs.marginTop){
                        _marginTop = cs.marginTop;
                    }
                    if(cs.marginLeft){
                        _marginLeft = cs.marginLeft;
                    }
                    // var parent = elem.offsetParent;


                    if(data.scrollDivY && ( window.getComputedStyle(data.scrollDivY).position == "relative" ||  window.getComputedStyle(data.scrollDivY).position == 'absolute') && data.scrollDivY.contains(elem)){
                        data._isRelativeY = true;
                    }
                    else{
                        data._isRelativeY = false;
                    }

                    if(data.scrollDivX && ( window.getComputedStyle(data.scrollDivX).position == "relative" ||  window.getComputedStyle(data.scrollDivX).position == 'absolute') && data.scrollDivX.contains(elem)){
                        data._isRelativeX = true;
                    }
                    else{
                        data._isRelativeX = false;
                    }

                    data._isDown = true;
                    data._initialPos = _initialPos;
                    data._offset = _offset;
                    data._Elemoffset = {top : _offset[0],left : _offset[1]};
                    data._marginLeft = _marginLeft;
                    data._marginTop = _marginTop;
                    manageDraggable.addClassOrAttr(data.attribute,_handleElement,'selected-element','');
                    // $L(_handleElement).addClass('selected-element');

                    //Set the current element for manager to manage draggables and droppables
                    if(typeof managerDD !== "undefined"){
                        managerDD._current = _handleElement;
                    }
                    if(event.type == "mousedown"){
                        document.addEventListener('mousemove',mouseMoveEvent);
                        document.addEventListener('mouseup',mouseUpEvent);
                        if(getOS() === "Windows"){  //Added check to restrict initial triggering of mousemove in windows as soon as the event is added
                            manageDraggable.mouseMoveTriggered = true;
                        }
                    }
            }
            var mouseMoveEvent = function(event){

                if(_animationFrameFired1 && _requestId1){
                    cancelAnimationFrame(_requestId1);
                    _animationFrameFired1 = false;
                    _requestId1 = null;
                }
                if(_animationFrameFired2 && _requestId2){
                    cancelAnimationFrame(_requestId2);
                    _animationFrameFired2 = false;
                    _requestId2 = null;
                }
                //calling mousemove from draggable;
                if(getOS() === "Windows" && manageDraggable.mouseMoveTriggered){	//Added check to restrict initial triggering of mousemove in windows as soon as the event is added
                    manageDraggable.mouseMoveTriggered = false;
                    return;
                }
                
                if(manageDraggable.draggedEle && manageDraggable.hasClassOrAttr(manageDraggable.draggedEle._draggableData.attribute,manageDraggable.draggedEle,'selected-element') && manageDraggable.draggedEle._draggableData && manageDraggable.draggedEle._draggableData._isDown){
                    _handleElement = manageDraggable.draggedEle;

                }
                else{
                    _handleElement = null;
                    return;
                }
                // var target = event.target;
                // while(target && target != document){
                // 	if($L(target).hasClass("selected-element")){
                // 		_handleElement = target;
                // 		break;
                // 	}
                // 	target = target.parentElement;
                // }
                if(_handleElement){
                    var data = _handleElement._draggableData;
                    if((!data._isMoved) ){
                        if(data.orientation === "vertical" && ((Math.abs(_initClientY - event.clientY)) < data.threshold)){
                            return;
                        }else if(data.orientation === 'horizontal' && ((Math.abs(_initClientX - event.clientX)) < data.threshold) ){
                            return;
                        }else if((((Math.abs(_initClientX - event.clientX)) < data.threshold) && ((Math.abs(_initClientY - event.clientY)) < data.threshold))){
                            return;
                        }	
                    }
                    if(data && data._isDown){
                        event.preventDefault();
                        if(typeof document.body.style.MozUserSelect!="undefined"){
                            document.body.style.MozUserSelect = "none";
                        }
                        var elem = data._element;
                        _offset = data._offset;
                        _marginLeft = data._marginLeft;
                        _marginTop = data._marginTop;
                        var orientation = data.orientation;
                        var parent = data._offParent;
                        var elemOffset = elem.getBoundingClientRect();
                        var parentOffset = parent.getBoundingClientRect();
                        var scrollLeftValue = 0;
                        if(data.scrollDivY && data._isRelativeY){
                            _scrollTop = data.scrollDivY.scrollTop;
                        }
                        else{
                            _scrollTop = 0;
                        }
                        if(data.scrollDivX && data._isRelativeX){
                            _scrollLeft = data.scrollDivX.scrollLeft;
                            if(window._lyteUiUtils.getRTL() && !window._lyteUiUtils.isNegativeScroll() && detectBrowser() == "chrome" && data._isRelativeX){
                                _scrollLeft -= (data._maxScrollWidth ? data._maxScrollWidth : (data.scrollDivX.scrollWidth - data.scrollDivX.offsetWidth));
                            }
                        }
                        else{
                            _scrollLeft = 0;
                        }
                        if(data._isRelative){
                            scrollLeftValue = _scrollLeft;
                        }
                        if(data.dragstartreturn !== false){
                            var returnVal = true;	
                        }else{
                            var returnVal = false;
                        }
                        
                        data._element.addScrollDivXY =  function(scrollDivX,scrollDivY){
                            var scrollDivX = scrollDivX ? (typeof scrollDivX == "string" ? document.querySelector(scrollDivX) : scrollDivX) : undefined;
                            var scrollDivY = scrollDivY ? (typeof scrollDivY == "string" ? document.querySelector(scrollDivY) : scrollDivY) : undefined;
                            if( scrollDivY && scrollDivY !== data.scrollDivY){
                                data.scrollDivY = scrollDivY;
                                _maxScrollHeight = data.scrollDivY.scrollHeight - data.scrollDivY.offsetHeight;
                                data._maxScrollHeight = _maxScrollHeight;
                                data._element._draggableData._maxScrollHeight = _maxScrollHeight;
                                data._element._draggableData.scrollDivY = data.scrollDivY;
                                if(_requestId1){
                                    cancelAnimationFrame(_requestId1);
                                    _animationFrameFired1 = false;
                                    _requestId1 = null;
                                }
                            }
                            if(scrollDivX && scrollDivX !== data.scrollDivX){
                                data.scrollDivX = scrollDivX; 
                                _maxScrollWidth = data.scrollDivX.scrollWidth - data.scrollDivX.offsetWidth;
                                data._maxScrollWidth = _maxScrollWidth;
                                data._element._draggableData._maxScrollWidth = _maxScrollWidth;
                                data._element._draggableData.scrollDivX = data.scrollDivX;
                                if(_requestId2){
                                    cancelAnimationFrame(_requestId2);
                                    _animationFrameFired2 = false;
                                    _requestId2 = null;
                                }
                            }	
                        }

                        if(!data._isMoved){
                            
                            //data.dragstartreturn = true;
                            // data.returnVal = true;
                            // var cs = window.getComputedStyle(elem);
                            // var borderDimensionY = ((cs.borderTop ? parseFloat(cs.borderTop) : 0) +
                            //                          (cs.borderBottom ? parseFloat(cs.borderBottom) : 0));
                            // var borderDimensionX = ((cs.borderLeft ? parseFloat(cs.borderLeft) : 0) +
                            //                          (cs.borderRight ? parseFloat(cs.borderRight) : 0));
                            if(typeof data.helper == "string"){
                                if(data.helper == "clone"){
                                    var helper = elem.cloneNode(true);
                                    window._lyteUiUtils.insertAfter(elem,helper);
                                    // $L(elem).removeClass('selected-element');
                                    manageDraggable.removeClassOrAttr(data.attribute,elem,'selected-element');
                                    if(!(manageDraggable.hasClassOrAttr(data.attribute,helper,'draggable-handle-element'))){
                                        manageDraggable.addClassOrAttr(data.attribute,helper,'draggable-handle-element','');
                                    }
                                    helper._draggableData = Object.assign({},data);
                                    helper.addScrollDivXY = data._element.addScrollDivXY;
                                    data = helper._draggableData;
                                    data._element = data.handle = helper;
                                    _handleElement = helper;
                                    elem = helper;
                                    manageDraggable.draggedEle = _handleElement = helper;
                                    elem.addEventListener("mousedown",mouseDownEvent);
                                    if(data.connectToSortable){
                                        data._prevTop = event.clientY;
                                    }
                                    elem._draggableData.helperElem = elem;
                                }
                            }
                            else{
                                var helper = data.helper(elem);
                                if(helper){
                                    helper._callee = elem;
                                    if(data.appendTo == "parent"){
                                        window._lyteUiUtils.appendChild(data._parent,helper);
                                        // data._parent.appendChild(helper);
                                    }
                                    else{
                                        window._lyteUiUtils.appendChild($L(data.appendTo)[0],helper);
                                        // data.appendTo.appendChild(helper);
                                    }
                                    // $L(elem).removeClass('selected-element');
                                    manageDraggable.removeClassOrAttr(data.attribute,elem,'selected-element');
                                    if(!(manageDraggable.hasClassOrAttr(data.attribute,helper,'draggable-handle-element'))){
                                        manageDraggable.addClassOrAttr(data.attribute,helper,'draggable-handle-element','');
                                    }
                                    if(!(manageDraggable.hasClassOrAttr(data.attribute,helper,'selected-element'))){
                                        manageDraggable.addClassOrAttr(data.attribute,helper,'selected-element','');
                                    }
                                    manageDraggable.addClassOrAttr(data.attribute,helper,'draggable-helper-element','');
                                    helper._draggableData = Object.assign({},data);
                                    helper.addScrollDivXY = data._element.addScrollDivXY;
                                    data = helper._draggableData;
                                    data._origin = data._element;
                                    data._element = data.handle = helper;
                                    manageDraggable.draggedEle = _handleElement = helper;									
                                    elem = helper;
                                    if(data.scrollDivY && !data.scrollDivY.contains(elem)){
                                        data._isRelativeY = false;
                                    }
                                    if(data.scrollDivX && !data.scrollDivX.contains(elem)){
                                        data._isRelativeX = false;
                                    }
                                    elem.addEventListener("mousedown",mouseDownEvent);
                                    if(data.connectToSortable){
                                        data._prevTop = event.clientY;
                                    }
                                    parent = data._offParent = elem.offsetParent;
                                    parentOffset = parent.getBoundingClientRect();
                                    elem._draggableData.helperElem = elem;
                                }
                            }
                            if(typeof managerDD != "undefined"){
                                managerDD._current = _handleElement;
                            }

                            data = elem._draggableData || _handleElement._draggableData;

                            //Create placeholder and append it to the DOM
                            if(data.connectToSortable){
                                _placeholder = elem.cloneNode(true);
                                _placeholder._callee = elem;
                                // $L(_placeholder).removeClass('selected-element');
                                manageDraggable.removeClassOrAttr(data.attribute,_placeholder,'selected-element');
                                _placeholder.innerHTML = "";
                                $L(_placeholder).attr('id','lyteDraggableDummy');
                                $L(_placeholder).addClass(data.placeholder);
                                _placeholder.style.boxSizing = "border-box";
                                // if(cs.boxSizing == "border-box"){
                                    _placeholder.style.width = elemOffset.width + "px";
                                    _placeholder.style.height = elemOffset.height + "px";
                                // }
                                // else{
                                // 	_placeholder.style.width = calculateWidth(elem)/*(elemOffset.width - borderDimensionX)*/ + "px";
                                // 	_placeholder.style.height = calculateHeight(elem)/*(elemOffset.height - borderDimensionY)*/ + "px";
                                // }
                                _placeholder.style.padding = "0px";
                                elem.classList.add('lyteSortableDisablePE');
                            }
                            if(data.onDragStart){
                                data.dragstartreturn = onDragStart(data,_handleElement,_placeholder,event);
                                
                                if(!data.dragstartreturn){
                                    data._isMoved = true;
                                    returnVal = false;
                                    return;
                                }
                            }else{
                                data.dragstartreturn = true;
                            }
                            elem.style.width = calculateWidth(elem) +'px';
                            elem.style.height = calculateHeight(elem)  +'px';
                            elem.style.top = elemOffset.top - parentOffset.top /*- parseInt(cellSpacing)*/ - parseInt(_marginTop) + _scrollTop + 'px';
                            elem.style.left = elemOffset.left - parentOffset.left - parseInt(_marginLeft) + _scrollLeft + 'px';
                            elem.style.zIndex = 200000;
                            
                            elem.style.position = "absolute";
                            
                            if(data.scrollDivY){
                                if(isWindowScroll(data.scrollDivY)){
                                    _maxScrollHeight = data.scrollDivY.scrollHeight - data.scrollDivY.clientHeight;
                                }else{
                                    _maxScrollHeight = data.scrollDivY.scrollHeight - data.scrollDivY.offsetHeight;
                                }
                            }
                            if(data.scrollDivX){
                                _maxScrollWidth = data.scrollDivX.scrollWidth - data.scrollDivX.offsetWidth;
                                data._maxScrollWidth = _maxScrollWidth;
                            }
                            if(data.cursorAt && window._lyteUiUtils.getRTL()){
                                var offset = data.cursorAt,
                                    newOffset = {};
                                for(key in offset){
                                    if(key == "left"){
                                        newOffset.left = data._element.offsetWidth - offset[key];
                                    }
                                    else{
                                        newOffset[key] = offset[key];
                                    }
                                }
                                data._preCursorAt = Object.assign({},data.cursorAt);
                                data.cursorAt = newOffset;
                                _offset = data._offset = [
                                                            data.cursorAt.left,
                                                            data.cursorAt.top
                                                        ];
                            }
                        }
                        else{
                            if(data._placeholder){
                                _placeholder = data._placeholder;
                            }
                            if(data._positionedPlceholder){
                                _positionedPlceholder = data._positionedPlceholder;
                            }
                        }

                        if(event.type == "mousemove" ||(data.aria && event.type == 'keydown')){
                            data._mousePosition = {
                                x : event.clientX,
                                y : event.clientY
                            };
                        }
                        else if(event.type == "touchmove"){
                            data.touchTarget = event.touches;
                            data._mousePosition = {
                                x : event.touches[0].clientX,
                                y : event.touches[0].clientY
                            };
                        }

                        //Callback fired
                        var leftVal = data._mousePosition.x - data._offset[0] - parentOffset.left - parseInt(_marginLeft) + _scrollLeft;
                        var TopVal = data._mousePosition.y - data._offset[1] - parentOffset.top - parseInt(_marginTop) + _scrollTop;
                        data._Elemoffset = { top : TopVal, left : leftVal};
                        if(data.dragstartreturn && data.onDrag){
                            returnVal = onDrag(data,_handleElement,event);
                        }

                        
                        if(returnVal){
                            elemOffset = elem.getBoundingClientRect();
                            if(orientation === "vertical"){
                                elem.style.top = data._mousePosition.y - _offset[1] - parentOffset.top - parseInt(_marginTop) + _scrollTop + 'px';
                                if(data.scrollDivY){
                                    var scrollDivOffset = data.scrollDivY.getBoundingClientRect();
                                    if((elemOffset.left <= scrollDivOffset.right) && (elemOffset.right >= scrollDivOffset.left)){
                                        _requestId1 = requestAnimationFrame(callForScrollY.bind(this,data,data.scrollDivY,scrollDivOffset,_maxScrollHeight,data._isRelativeY,data._mousePosition,_offset,parentOffset,event));
                                        _animationFrameFired1 = true;
                                    }
                                }
                            }
                            else if(orientation === "horizontal"){
                                elem.style.left = data._mousePosition.x - _offset[0] - parentOffset.left - parseInt(_marginLeft) + _scrollLeft + 'px';
                                if(data.scrollDivX){
                                    var scrollDivOffset = data.scrollDivX.getBoundingClientRect();
                                    if(elemOffset.left <= scrollDivOffset.right || elemOffset.right >= scrollDivOffset.left){
                                        _requestId2 = requestAnimationFrame(callForScrollX.bind(this,data,scrollDivOffset,data._maxScrollWidth,data._mousePosition,_offset,parentOffset,data._isRelativeX,event));
                                        _animationFrameFired2 = true;
                                    }
                                }
                            }
                            else if(orientation === "default"){
                                elem.style.left = data._mousePosition.x - _offset[0] - parentOffset.left - parseInt(_marginLeft) + _scrollLeft + 'px';
                                elem.style.top = data._mousePosition.y - _offset[1] - parentOffset.top - parseInt(_marginTop)  + 'px';
                                elemOffset = elem.getBoundingClientRect();
                                if(data.scrollDivY){
                                    var scrollDivOffset = data.scrollDivY.getBoundingClientRect();
                                    if((elemOffset.left <= scrollDivOffset.right) && (elemOffset.right >= scrollDivOffset.left)){
                                        _requestId1 = requestAnimationFrame(callForScrollY.bind(this,data,data.scrollDivY,scrollDivOffset,_maxScrollHeight,data._isRelativeY,data._mousePosition,_offset,parentOffset,event));
                                        _animationFrameFired1 = true;
                                    }
                                }
                                //Animation Frame fired for horizontal scrolling
                                if(data.scrollDivX){
                                    var scrollDivOffset = data.scrollDivX.getBoundingClientRect();
                                    if(elemOffset.left <= scrollDivOffset.right || elemOffset.right >= scrollDivOffset.left){
                                        _requestId2 = requestAnimationFrame(callForScrollX.bind(this,data,scrollDivOffset,data._maxScrollWidth,data._mousePosition,_offset,parentOffset,data._isRelativeX,event));
                                        _animationFrameFired2 = true;
                                    }
                                }
                                if(data.connectToSortable){
                                    var sortableData = $L(data.connectToSortable).length ? $L(data.connectToSortable)[0]._sortableParentData : null;
                                    _sortableElemClass = sortableData.sortableElemClass;

                                    //Find the below element over which the sortable element is being dragged
                                    _elemBelow = document.elementFromPoint(data._mousePosition.x,data._mousePosition.y);

                                    //check isOver sortable list
                                    $L.prototype.manageSortable.isOver(event,data,true);

                                    if(!_elemBelow){
                                        return;
                                    }

                                    //Find the closest sortable element to sort with
                                    droppablePlace = _elemBelow.closest('.'+_sortableElemClass);

                                    if(droppablePlace && droppablePlace.parentElement._sortableParentData.droppable /* && checkDroppable(droppablePlace,_sortableElem.parentElement,_sortableElem,data.connectedWith,data.containmentDimensions,_mousePosition)*/){

                                        if($L(_elemBelow).hasClass('sortable-parent') && checkParentDroppable(_elemBelow,data) && checkForIntersect(_elemBelow,data._mousePosition) && checkForBetween(_elemBelow,data._mousePosition,elem/*,isRelativeY,scrollDiv*/)){
                                            window._lyteUiUtils.appendChild(_elemBelow,_placeholder);
                                            _placeholder.style.display = "";
                                            _positionedPlceholder = true;
                                        }
                                        else{
                                            if(elem.getBoundingClientRect().top <= droppablePlace.getBoundingClientRect().top){
                                                window._lyteUiUtils.insertBefore(droppablePlace,_placeholder);
                                                _placeholder.style.display = "";
                                                _positionedPlceholder = true;
                                            }
                                            else if(elem.getBoundingClientRect().bottom > droppablePlace.getBoundingClientRect().bottom){
                                                window._lyteUiUtils.insertAfter(droppablePlace,_placeholder);
                                                _placeholder.style.display = "";
                                                _positionedPlceholder = true;
                                            }
                                        }
                                    }
                                    else if(_elemBelow && $L(_elemBelow).hasClass('sortable-parent') && checkParentDroppable(_elemBelow,data) && checkForIntersect(_elemBelow,data._mousePosition) && checkForBetween(_elemBelow,data._mousePosition,elem/*,isRelativeY,scrollDiv*/)){
                                        window._lyteUiUtils.appendChild(_elemBelow,_placeholder);
                                        _placeholder.style.display = "";
                                        _positionedPlceholder = true;
                                    }
                                    else{
                                        if(!checkPlaceholderBelow(_elemBelow) && !($L(_elemBelow).hasClass('sortable-parent') && checkParentDroppable(_elemBelow,data))){
                                            // placeholder set to false
                                            if(document.getElementById('lyteDraggableDummy')){
                                                document.getElementById('lyteDraggableDummy').style.display = "none";
                                            }
                                            _positionedPlceholder = false;
                                        }
                                    }

                                    if(_positionedPlceholder){
                                        if(!data.onPlaceholder || checkValidDroppable(data,_placeholder)){
                                            if($L(_placeholder).hasClass(data.disabled)){
                                                $L(_placeholder).removeClass(data.disabled);
                                            }
                                            $L(_placeholder).addClass(data.placeholder);
                                        }
                                        else{
                                            if($L(_placeholder).hasClass(data.placeholder)){
                                                $L(_placeholder).removeClass(data.placeholder);
                                            }
                                            $L(_placeholder).addClass(data.disabled);
                                        }
                                    }
                                    data._placeholder = _placeholder;
                                    data._positionedPlceholder = _positionedPlceholder;
                                }
                            }
                            if(data.hasContainment && returnVal){
                                var parent = $L(data.containment)[0];
                                var offParent = data._offParent;
                                var _scrollTop = 0;
                                if(isWindowScroll(parent)){
                                    var top = 0;
                                    var height = window.innerHeight;
                                    var width = window.innerWidth;
                                    _scrollTop = document.documentElement.scrollTop; 
                                }else{
                                    var parentRect = parent.getBoundingClientRect()
                                    var top = parentRect.top;
                                    var height = parentRect.height;
                                    var width = parentRect.width;
                                    var left =  parentRect.left;
                                }
                                var ElemRect  = elem.getBoundingClientRect()
                                var minheight = Math.min(data.minVisible,ElemRect.height);
                                var minWidth = Math.min(data.minVisible,ElemRect.width);
                                var cs = getComputedStyle(offParent);
                                var offsetTop = 0,offsetLeft = 0;  
                                if(cs.position === 'relative' || cs.position === 'absolute'){
                                    offsetLeft = offParent.getBoundingClientRect().left;
                                    offsetTop = offParent.getBoundingClientRect().top;
                                }
                                if(elem.getBoundingClientRect().top <= top){
                                    elem.style.top = top - offsetTop  + _borderVal.top + _scrollTop + 'px';
                                }
                                if(elem.getBoundingClientRect().bottom >= (top + height) && !data.restrictLeftTopOnly){
                                    elem.style.top = (top + height) - offsetTop - ElemRect.height + _borderVal.bottom + _scrollTop + 'px';
                                }
                                if((elem.getBoundingClientRect().top + minheight)  >= (top + height) && data.restrictLeftTopOnly){
                                    elem.style.top = (top + height - minheight) - offsetTop + _borderVal.bottom + _scrollTop + 'px';
                                }
                                if(elem.getBoundingClientRect().left <= left){															
                                    elem.style.left = left + _borderVal.left - offsetLeft + 'px';
                                }
                                if(elem.getBoundingClientRect().right >= (left + width) && !data.restrictLeftTopOnly){
                                    elem.style.left = (left - offsetLeft + width) - ElemRect.width + _borderVal.right + _scrollLeft  + 'px';
                                }
                                if((elem.getBoundingClientRect().left + minWidth)  >= (left + width) && data.restrictLeftTopOnly){
                                    elem.style.left = (left  + width - minheight) - offsetLeft + _borderVal.left + 'px';
                                }
                            }
                        }
                        
                        //Check for any droppable element and if present execute its drag function
                        if(typeof managerDD !== "undefined"){
                            managerDD._drag(event);
                        }
                        data._isMoved = true;
                    }
                }
            }
            

            var mouseUpEvent = function(event){
                if(_animationFrameFired1 && _requestId1){
                    cancelAnimationFrame(_requestId1);
                    _animationFrameFired1 = false;
                    _requestId1 = null;
                }
                if(_animationFrameFired2 && _requestId2){
                    cancelAnimationFrame(_requestId2);
                    _animationFrameFired2 = false;
                    _requestId2 = null;
                }
                
                // console.log(event.type, event.target);
                // console.log("calling mouseup from draggable");
                // event.preventDefault();
                // _handleElement = event.target.closest('.selected-element') ? event.target.closest('.selected-element') : document.querySelector('.selected-element');
                // var target = event.target;
                // _handleElement = null;
                // while(target && target != document){
                // 	if($L(target).hasClass("selected-element")){
                // 		_handleElement = target;
                // 		break;
                // 	}
                // 	target = target.parentElement;
                // }
                //Unbind mouseup and mousemove
                if(event.type == "mouseup"){
                    document.removeEventListener('mousemove',mouseMoveEvent);
                    document.removeEventListener('mouseup',mouseUpEvent);
                }
                //Unbinding touch events
                if(event.type == "touchend"){
                    document.removeEventListener('touchmove',mouseMoveEvent, true);
                    document.removeEventListener('touchend',mouseUpEvent, true);
                }

                if(manageDraggable.draggedEle && manageDraggable.hasClassOrAttr(manageDraggable.draggedEle._draggableData.attribute,manageDraggable.draggedEle,'selected-element') && manageDraggable.draggedEle._draggableData && manageDraggable.draggedEle._draggableData._isDown){
                    _handleElement = manageDraggable.draggedEle;
                }
                else{
                    _handleElement = null;
                    return;
                }
                
                if(_handleElement){
                    if(_handleElement._draggableData.mouseUpBubbles){
                        event.stopPropagation();
                    }
                    var data = _handleElement._draggableData;
                    // if(event.type == "touchend"){
                    // 	if(data._element.classList.contains('stopDefaultMove')){
                    // 		data._element.classList.remove('stopDefaultMove');
                    // 	}
                    // }
                    if(data.cursorAt && window._lyteUiUtils.getRTL()){
                        data.cursorAt = Object.assign({},data._preCursorAt);
                        data._preCursorAt = undefined;

                    }
                    if(data.connectToSortable){ 
                        if( $L.prototype.manageSortable.prevSortable ){
                            $L.prototype.manageSortable.prevSortable = false;
                        }
                        _handleElement.classList.remove('lyteSortableDisablePE');
                    }
                    _placeholder = data._placeholder;

                    if(data && data._isDown){
                        data._isDown = false;
                        var elem = data._element;
                        if(data._isMoved){
                            var placed = false;
                            data._isMoved = false;
                            _initialPos = data._initialPos;
                            _marginTop = parseInt(data._marginTop);
                            _marginLeft = parseInt(data._marginLeft);

                            var returnVal = true;
                            if(data.onBeforeStop){
                                returnVal = onBeforeStop(data,event);
                            }
                            if(!returnVal){
                                
                                if(data.helperElem){
                                    elem.remove();
                                    if(document.getElementById('lyteDraggableDummy')){
                                        _placeholder.remove();
                                    }
                                    manageDraggable.draggedEle = null;
                                    return;
                                }
                                if(_initialPos.pos === "absolute"){
                                    elem.style.left = _initialPos.x + "px";
                                    elem.style.top = _initialPos.y + "px";
                                }
                                else{
                                    elem.style.left = "";
                                    elem.style.top = "";
                                    elem.style.position = "";
                                }
                                data._positionedPlceholder = false;
                            }
                            else{
                                if(data.connectToSortable && data._positionedPlceholder){
                                    var sibling = (findPreviousElem(_placeholder) ? findPreviousElem(_placeholder) : findNextElem(_placeholder));
                                    var elementData = sibling ? sibling._sortableChildData : _placeholder.parentElement._sortableParentData;
                                    // $L(_placeholder).replace(_div);
                                    window._lyteUiUtils.replaceWith(_placeholder, elem);

                                    _placeholder = null;
                                    elem._sortableChildData = elementData;
                                    elem.removeEventListener('mousedown',mouseDownEvent);
                                    removeStyle(elem);
                                    placed = true;
                                }
                            }
                            //Check for any droppable element & if present execute its drop function
                            if(typeof managerDD !== "undefined"){

                                managerDD._drop(event);
                                managerDD._current = null;
                                if(data.currDroppable && data.currDroppable._droppableData){
                                    data.currDroppable._droppableData.entered = false
                                    data.currDroppable = null;
                                }
                            }

                            //Callback fired
                            if(data.onStop){
                                returnVal = onStop(data, event);
                            }

                            if(!returnVal){

                                if(data.helperElem && !placed){
                                    elem.remove();
                                    if(document.getElementById('lyteDraggableDummy')){
                                        _placeholder.remove();
                                    }
                                    manageDraggable.draggedEle = null;
                                    return;
                                }
                                if(_initialPos.pos === "absolute"){
                                    elem.style.left = _initialPos.x + "px";
                                    elem.style.top = _initialPos.y + "px";
                                }
                                else{
                                    elem.style.left = "";
                                    elem.style.top = "";
                                    elem.style.position = "";
                                }
                            }

                        }
                        elem.style.zIndex = data._zIndex;
                        manageDraggable.removeClassOrAttr(data.attribute,_handleElement,'selected-element');
                        // $L(_handleElement).removeClass('selected-element');

                    }
                    data.touchTarget = null;
                    _handleElement = null;
                    if(document.getElementById('lyteDraggableDummy')){
                        document.getElementById('lyteDraggableDummy').remove();
                        if(_placeholder){
                            _placeholder = null;
                        }
                    }
                }
                var elements = data.attribute ? event.target.ownerDocument.querySelectorAll("[selected-element]") : event.target.ownerDocument.querySelectorAll(".selected-element");
                var draggableDummy = event.target.ownerDocument.querySelectorAll(".lyteDraggableDummy");
                for(var i = 0; i < elements.length; i++){
                    var elem = elements[i],
                        data = elem._draggableData;
                    if(data.cursorAt && data._preCursorAt && window._lyteUiUtils.getRTL()){
                        data.cursorAt = Object.assign({},data._preCursorAt);
                        data._preCursorAt = undefined;
                    }
                    if(data._placeholder){
                        data._placeholder = null;
                        data._positionedPlceholder = false;
                    }
                    data._isDown = false;
                    data._isMoved = false;
                    manageDraggable.removeClassOrAttr(data.attribute,elem,'selected-element');
                    // $L(elem).removeClass('selected-element');
                    // $L(elem).removeClass('stopDefaultMove');
                }
                for(var i = 0; i < draggableDummy; i++){
                    draggableDummy[i].remove();
                }

                manageDraggable.draggedEle = null;
            }

            /*---------------Callbacks Start--------------*/
            var onReady = function(data){
                data.onReady(data._element);
            }

            var onStart = function(data, event){
                returnVal = data.onStart(data._element, event);
                return (returnVal == undefined) ? true : returnVal;
            }

            var onDragStart = function(data,_handleElement,_placeholder,event){
                returnVal = data.onDragStart(data._element,_handleElement,_placeholder,event,data._origin);
                return (returnVal == undefined) ? true : returnVal;
            }

            var onDrag = function(data, _handleElement,event){
                returnVal = data.onDrag(data._element,_handleElement,event,data._origin,data._Elemoffset);
                return (returnVal == undefined) ? true : returnVal;
            }

            var onBeforeStop = function(data,event){
                returnVal = data.onBeforeStop(data._element,data._placeholder,data._positionedPlceholder ? data._placeholder.parentElement : null,event,getIndex(data, "onBeforeStop"),data._origin);
                return (returnVal == undefined) ? true : returnVal;
            }

            var checkValidDroppable = function(data,placeholder){
                var returnVal = data.onPlaceholder(data._element,placeholder, data._element.parentElement, placeholder ? placeholder.parentElement : null);
                return (returnVal == undefined) ? true : returnVal;
            }

            var onStop = function(data,event){
                var prevStyle = window.getComputedStyle(data._element).pointerEvents;
                data._element.style.pointerEvents = "none";
                if(event.type == "mouseup"){
                    _elemBelow = document.elementFromPoint(event.clientX, event.clientY);
                }
                else if(event.type == "touchend"){
                    _elemBelow = document.elementFromPoint(data.touchTarget[0].clientX,data.touchTarget[0].clientY);
                }
                data._element.style.pointerEvents = prevStyle;
                returnVal = data.onStop(data._element, data._positionedPlceholder ? data._element.parentElement : null, _elemBelow,event,getIndex(data, "onStop"),data._origin);
                return (returnVal === undefined) ? true : returnVal;
            }
            var keyDownEvent = function(event){
                var targetElem = event.target;
                var handle = targetElem._draggableData.handle;
                if(event.keyCode == 32){
                    if(handle.classList.contains('selected-element')){
                        event.clientY = handle.getBoundingClientRect().top;
                        event.clientX = handle.getBoundingClientRect().left;
                        mouseUpEvent(event)
                    }else{
                        event.clientY = handle.getBoundingClientRect().top;
                        event.clientX = handle.getBoundingClientRect().left;
                        mouseDownEvent(event);
                    }
                    event.preventDefault();
                    return;
                }
                if(handle.classList.contains('selected-element')){
                    if(event.keyCode == 39){
                        event.clientX = handle.getBoundingClientRect().left + 50;
                        mouseMoveEvent(event);
                    }else if(event.keyCode == 37){
                        event.clientX = handle.getBoundingClientRect().left - 50;
                        event.clientX = event.clientX > 0 ? event.clientX : 0;
                        mouseMoveEvent(event);
                    }else if(event.keyCode == 38){
                        event.clientY = handle.getBoundingClientRect().top - 50;
                        event.clientY = event.clientY > 0 ? event.clientY : 0;
                        mouseMoveEvent(event);
                    }else if(event.keyCode == 40){
                        event.clientY = handle.getBoundingClientRect().top + 50;
                        mouseMoveEvent(event);
                    }
                    event.preventDefault();
                }
            }
            /*---------------Callbacks End--------------*/


            //Bind events
            if(data.dblTouchEvent){
                var prevClick = 0;
                
                data.__mousedown = function(event) {
                    if(event.type == 'mousedown'){
                            mouseDownEvent(event);
                    }else{
                        var date = new Date();
                    var time = date.getTime();
                    var touches = event.touches;
                    var curtouchY = event.touches[0].clientY;
                    const time_between_taps = 200; 

                    if(touches.length == 1){
                            if(checkfordraggable(data,event.target)){
                                $L(	event.target  ).one('touchend',function(event){
                                        event.preventDefault();	  		
                                })
                                }
                        if (time - prevClick < time_between_taps &&  touches.length == 1 ) {
                                prevClick = 0;
                                event.preventDefault();
                                mouseDownEvent(event);
                            
                        }
                        }
                    prevClick = time;
                    }
                }
            }else{
                data.__mousedown = mouseDownEvent;
            }
            //data.__mousedown = mouseDownEvent;

            data.__mousemove = mouseMoveEvent;
            data.__mouseup = mouseUpEvent;
            data.__keyDownEvent = keyDownEvent;
            if(!data._element._mousedown){
                if(typeof data.handle !== "string" && data.handle.length){
                    data.handle.forEach(function(item){
                        var ele = $L(item, data._element)[0];
                        ele._draggableData = data;
                        manageDraggable.addClassOrAttr(data.attribute,ele,'draggable-handle-element','');
                        ele.addEventListener('mousedown',data.__mousedown);
                        ele.addEventListener('touchstart',data.__mousedown);
                        if(data.aria){
                            ele.addEventListener('keydown',data.__keyDownEvent);
                        }
                    });
                }
                else{
                    data.handle._draggableData = data;
                    manageDraggable.addClassOrAttr(data.attribute,data.handle,'draggable-handle-element','');
                    data.handle.addEventListener('mousedown',data.__mousedown);
                    data.handle.addEventListener('touchstart',data.__mousedown);
                    if(data.aria){
                        data.handle.addEventListener('keydown',data.__keyDownEvent);
                    }
                }
                data._element._mousedown = true;
            }



            //Callback fired
            if(data.onReady){
                onReady(data);
            }

            
            var isWindowScroll = function(scrollDiv){
                if(scrollDiv == document.documentElement){
                    return true;
                }

            }
            var checkParentDroppable = function(_elemBelow,data){
                if(_elemBelow.matches(data.connectToSortable) && _elemBelow._sortableParentData.droppable){
                    return true;
                }
                return false;
            }

            var calculateHeight = function(element) {
                var cs = getComputedStyle(element);
                if(cs.boxSizing == 'content-box'){
                    var paddingY = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);

                    var borderY = parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth);
                }else{
                    var paddingY = 0;
                    var borderY = 0;
                }

                

                // Element height minus padding and border
                var elementHeight = element.offsetHeight - paddingY - borderY;
                return elementHeight;
            };

            var calculateWidth = function(element) {
                var cs = getComputedStyle(element);
                if(cs.boxSizing == 'content-box'){
                    var paddingX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
                    var borderX = parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth);
                }else{
                    var paddingX = 0;
                    var borderX = 0;
                }
                // Element width minus padding and border
                var elementWidth = element.offsetWidth - paddingX - borderX;
                return elementWidth;
            };

            var callForScrollY = function(data,scrollDiv,parentOffset,_maxScrollHeight,isRelativeY,_mousePosition,_offset,parent,event){
                var divOffset = data._element.getBoundingClientRect();
                var height = scrollDiv  !== document.documentElement ? scrollDiv.offsetHeight : scrollDiv.clientHeight;
                if((document.compareDocumentPosition(data._element) & 1) ){
                    return;
                }
                var scrollCss  = window.getComputedStyle(data.scrollDivY);
                var isNegativeScroll;
                if(scrollCss.display == 'flex' && scrollCss.flexDirection == 'column-reverse'){
                    isNegativeScroll = true;
                }
                
                // var diff = data._placeholder.parentElement.offsetTop - scrollDiv.offsetTop + 5;
                var scrollTop = scrollDiv.scrollTop;
                // console.log("Scroll Y getting called",_maxScrollHeight,"    scrollTop",scrollTop);
                
                var isWindow = scrollDiv  === document.documentElement ? true : false;
                var scrollDivTop = (isWindow ? 0 : scrollDiv.getBoundingClientRect().top);
                if(!isNegativeScroll){
                    if((divOffset.top - parseInt(data._marginTop) <= scrollDivTop ) && (scrollTop > 0)){
                        if(isRelativeY){
                            data._element.style.top = _mousePosition.y - _offset[1] - parent.top - (_maxScrollHeight - scrollTop >= data.scrollSpeed ? data.scrollSpeed : _maxScrollHeight - scrollTop) + scrollTop + "px";
                        }
                        else if(isWindowScroll(scrollDiv)){
                            data._element.style.top = data._element.offsetTop - (_maxScrollHeight - scrollTop >= data.scrollSpeed ? data.scrollSpeed : _maxScrollHeight - scrollTop)   + 'px';
                        }
                        scrollDiv.scrollTop -= data.scrollSpeed;
                        if(data.onScroll){
                            data.onScroll(data._element,scrollDiv,_mousePosition);
                        }
                        if(data.bindDroppable){
                            managerDD._drag(event);
                        }
                    }
                    else if((divOffset.bottom >= (scrollDivTop + height - 3)) && (scrollTop < _maxScrollHeight)){
                        if(_maxScrollHeight - scrollTop > data.scrollSpeed){
                            if(isRelativeY){
                                data._element.style.top = _mousePosition.y - _offset[1] - parent.top + data.scrollSpeed + scrollTop + "px";
                            }
                            else if(isWindowScroll(scrollDiv)){
                                data._element.style.top = data._element.offsetTop + data.scrollSpeed + 'px';
                            }
                            scrollDiv.scrollTop += data.scrollSpeed;
                            if(data.onScroll){
                                data.onScroll(data._element,scrollDiv,_mousePosition);
                                
                            }
                            if(data.bindDroppable){
                                managerDD._drag(event);
                            }
                        }
                        else{
                            if(isRelativeY){
                                data._element.style.top = _mousePosition.y - _offset[1] - parent.top + _maxScrollHeight - scrollTop  + "px";
                            }else if(isWindowScroll(scrollDiv)){
                                data._element.style.top = data._element.offsetTop  + (_maxScrollHeight - scrollTop )     + 'px';
                            }
                            scrollDiv.scrollTop += (_maxScrollHeight - scrollTop);
                            if(data.onScroll){
                                data.onScroll(data._element,scrollDiv,_mousePosition); 
                            }
                            if(data.bindDroppable){
                                managerDD._drag(event);
                            }
                        }
                    }
                    else{
                        cancelAnimationFrame(_requestId1);
                        _animationFrameFired1 = false;
                        _requestId1 = null;
                        return;
                    }
                }else{
                    if((divOffset.top - parseInt(data._marginTop) <= scrollDivTop ) && (scrollTop > -(_maxScrollHeight))){
                        if(isRelativeY){
                            data._element.style.top = _mousePosition.y - _offset[1] - parent.top - (_maxScrollHeight - scrollTop >= data.scrollSpeed ? data.scrollSpeed : _maxScrollHeight - scrollTop) + scrollTop + "px";
                        }
                        else if(isWindowScroll(scrollDiv)){
                            data._element.style.top = data._element.offsetTop - (_maxScrollHeight - scrollTop >= data.scrollSpeed ? data.scrollSpeed : _maxScrollHeight - scrollTop)   + 'px';
                        }
                        scrollDiv.scrollTop -= data.scrollSpeed;
                        if(data.onScroll){
                            data.onScroll(data._element,scrollDiv,_mousePosition);
                        }
                        if(data.bindDroppable){
                            managerDD._drag(event);
                        }
                    }else if((divOffset.bottom >= (scrollDivTop + height - 3)) && (scrollTop < 0)){
                        if(_maxScrollHeight - scrollTop > data.scrollSpeed){
                            if(isRelativeY){
                                data._element.style.top = _mousePosition.y - _offset[1] - parent.top + data.scrollSpeed + scrollTop + "px";
                            }
                            else if(isWindowScroll(scrollDiv)){
                                data._element.style.top = data._element.offsetTop + data.scrollSpeed + 'px';
                            }
                            scrollDiv.scrollTop += data.scrollSpeed;
                            if(data.onScroll){
                                data.onScroll(data._element,scrollDiv,_mousePosition);
                            }
                            if(data.bindDroppable){
                                managerDD._drag(event);
                            }
                        }
                        else{
                            if(isRelativeY){
                                data._element.style.top = _mousePosition.y - _offset[1] - parent.top + _maxScrollHeight - scrollTop  + "px";
                            }else if(isWindowScroll(scrollDiv)){
                                data._element.style.top = data._element.offsetTop  + (_maxScrollHeight - scrollTop )     + 'px';
                            }
                            scrollDiv.scrollTop += (_maxScrollHeight - scrollTop);
                            if(data.onScroll){
                                data.onScroll(data._element,scrollDiv,_mousePosition);
                            }
                            if(data.bindDroppable){
                                managerDD._drag(event);
                            }
                        }
                    }else{
                        cancelAnimationFrame(_requestId1);
                        _animationFrameFired1 = false;
                        _requestId1 = null;
                        return;
                    }
                }
            
                _requestId1 = requestAnimationFrame(callForScrollY.bind(this,data,scrollDiv,parentOffset,_maxScrollHeight,isRelativeY,_mousePosition,_offset,parent,event));

            };

            var callForScrollX = function(data,parentOffset,_maxScrollWidth,_mousePosition,_offset,parent,isRelative,event){
                
                var divOffset = data._element.getBoundingClientRect();
                if((document.compareDocumentPosition(data._element) & 1) && data.scrollDivX ){
                    return;
                }
                _scrollLeft = data.scrollDivX.scrollLeft;
                var scrollCss  = window.getComputedStyle(data.scrollDivX);
                var isNegativeScroll = false;
                if(scrollCss.display == 'flex' && scrollCss.flexDirection == 'row-reverse'){
                    isNegativeScroll = true;
                }
            
                if( ( !isNegativeScroll && !window._lyteUiUtils.getRTL() )|| (!window._lyteUiUtils.isNegativeScroll() && window._lyteUiUtils.getRTL() && detectBrowser() == "chrome" && !isRelative) ){
                    if((divOffset.right >= parentOffset.right - 2) && (_scrollLeft < _maxScrollWidth)){
                        if((_maxScrollWidth - _scrollLeft) >= data.scrollSpeed){
                            data.scrollDivX.scrollLeft += data.scrollSpeed;
                            if(isRelative){
                                data._element.style.left = _mousePosition.x - _offset[0] - parent.left + data.scrollSpeed + _scrollLeft + "px";
                            }
                            if(data.bindDroppable){
                                managerDD._drag(event);
                            }
                            if(data.onScroll){
                                data.onScroll(data._element,data.scrollDivX,_mousePosition);
                            }
                        }
                        else{
                            data.scrollDivX.scrollLeft += (data.scrollSpeed - (_maxScrollWidth - _scrollLeft));
                            if(isRelative){
                                data._element.style.left = _mousePosition.x - _offset[0] - parent.left + (data.scrollSpeed - (_maxScrollWidth - _scrollLeft)) + _scrollLeft + "px";
                            }
                            if(data.bindDroppable){
                                managerDD._drag(event);
                            }
                            if(data.onScroll){
                                data.onScroll(data._element,data.scrollDivX,_mousePosition);
                            }
                        }
                    }
                    else if((divOffset.left <= parentOffset.left + 2) && (_scrollLeft > 0)){
                        if(isRelative){
                            data._element.style.left = _mousePosition.x - _offset[0] - parent.left - ((_maxScrollWidth - _scrollLeft) > data.scrollSpeed ? data.scrollSpeed : (data.scrollSpeed - (_maxScrollWidth - _scrollLeft))) + _scrollLeft + "px";
                        }
                        if(data.bindDroppable){
                            managerDD._drag(event);
                        }
                        if(data.onScroll){
                            data.onScroll(data._element,data.scrollDivX,_mousePosition);
                        }
                        data.scrollDivX.scrollLeft -= data.scrollSpeed;
                    }
                    else{
                        cancelAnimationFrame(_requestId2);
                        _animationFrameFired2 = false;
                        _requestId2 = null;
                        return;
                    }
                }
                else{
                    if( (!window._lyteUiUtils.isNegativeScroll() || !isNegativeScroll) && detectBrowser() == "chrome" && isRelative){
                        if((divOffset.right >= parentOffset.right) && (_scrollLeft < _maxScrollWidth)){
                            if((_maxScrollWidth - _scrollLeft) >= 5){
                                data.scrollDivX.scrollLeft += 5;
                                if(isRelative){
                                    data._element.style.left = _mousePosition.x - _offset[0] - parent.left + 5 + (_scrollLeft - _maxScrollWidth) + "px";
                                }
                                if(data.bindDroppable){
                                    managerDD._drag(event);
                                }
                                if(data.onScroll){
                                    data.onScroll(data._element,data.scrollDivX,_mousePosition);
                                }
                            }
                            else{
                                data.scrollDivX.scrollLeft += (5 - (_maxScrollWidth - _scrollLeft));
                                if(isRelative){
                                    data._element.style.left = _mousePosition.x - _offset[0] - parent.left + (5 - (_maxScrollWidth - _scrollLeft)) + _scrollLeft + "px";
                                }
                                if(data.bindDroppable){
                                    managerDD._drag(event);
                                }
                                if(data.onScroll){
                                    data.onScroll(data._element,data.scrollDivX,_mousePosition);
                                }
                            }
                        }
                        else if((divOffset.left <= parentOffset.left) && (_scrollLeft > 0)){
                            if(isRelative){
                                data._element.style.left = _mousePosition.x - _offset[0] - parent.left - ((_maxScrollWidth - _scrollLeft) + 5) + "px";
                            }
                            data.scrollDivX.scrollLeft -= 5;
                            if(data.bindDroppable){
                                managerDD._drag(event);
                            }
                            if(data.onScroll){
                                data.onScroll(data._element,data.scrollDivX,_mousePosition);
                            }
                        }
                        else{
                            cancelAnimationFrame(_requestId2);
                            _animationFrameFired2 = false;
                            _requestId2 = null;
                            return;
                        }
                    }
                    else if(((window._lyteUiUtils.isNegativeScroll() || isNegativeScroll) && detectBrowser() == "chrome") || detectBrowser() == "firefox" || detectBrowser() == "safari"){
                        if((divOffset.right >= parentOffset.right) && (_scrollLeft < 0)){
                            if((_maxScrollWidth + _scrollLeft) >= 5){
                                data.scrollDivX.scrollLeft += 5;
                                if(isRelative){
                                    data._element.style.left = _mousePosition.x - _offset[0] - parent.left + 5 + _scrollLeft + "px";
                                }
                            }
                            else{
                                data.scrollDivX.scrollLeft += (5 - (_maxScrollWidth + _scrollLeft));
                                if(isRelative){
                                    data._element.style.left = _mousePosition.x - _offset[0] - parent.left + (5 - (_maxScrollWidth + _scrollLeft)) + _scrollLeft + "px";
                                }
                            }
                            if(data.bindDroppable){
                                managerDD._drag(event);
                            }
                            if(data.onScroll){
                                data.onScroll(data._element,data.scrollDivX,_mousePosition);
                            }
                        }
                        else if((divOffset.left <= parentOffset.left) && (_scrollLeft > -(_maxScrollWidth))){
                            if(isRelative){
                                data._element.style.left = _mousePosition.x - _offset[0] - parent.left + (_scrollLeft - 5) + "px";
                            }
                            data.scrollDivX.scrollLeft -= 5;
                            if(data.bindDroppable){
                                managerDD._drag(event);
                            }
                            if(data.onScroll){
                                data.onScroll(data._element,data.scrollDivX,_mousePosition);
                            }
                        }
                        else{
                            cancelAnimationFrame(_requestId2);
                            _animationFrameFired2 = false;
                            _requestId2 = null;
                            return;
                        }
                    }
                    else if(detectBrowser() == "ie" || detectBrowser() == "edge"){
                        if((divOffset.right >= parentOffset.right) && (_scrollLeft > 0)){
                            if(_scrollLeft >= 5){
                                data.scrollDivX.scrollLeft -= 5;
                                // if(isRelative){
                                //  data._element.style.left = _mousePosition.x - _offset[0] - parent.left + 5 + _scrollLeft + "px";
                                // }
                            }
                            else{
                                data.scrollDivX.scrollLeft -= _scrollLeft;
                                // if(isRelative){
                                //  data._element.style.left = _mousePosition.x - _offset[0] - parent.left + (5 - (_maxScrollWidth + _scrollLeft)) + _scrollLeft + "px";
                                // }
                            }
                            if(data.onScroll){
                                data.onScroll(data._element,data.scrollDivX,_mousePosition);
                            }
                        }
                        else if((divOffset.left <= parentOffset.left) && (_scrollLeft < _maxScrollWidth)){
                            if(isRelative){
                                data._element.style.left = _mousePosition.x - _offset[0] - parent.left + (-_scrollLeft) - 5 + "px";
                            }
                            data.scrollDivX.scrollLeft += 5;
                            if(data.onScroll){
                                data.onScroll(data._element,data.scrollDivX,_mousePosition);
                            }
                        }
                        else{
                            cancelAnimationFrame(_requestId2);
                            _animationFrameFired2 = false;
                            _requestId2 = null;
                            return;
                        }
                    }

                }

                _requestId2 = requestAnimationFrame(callForScrollX.bind(this,data,parentOffset,_maxScrollWidth,_mousePosition,_offset,parent,isRelative,event));
            };
            var getRelativeParent = function(element){

                while(element.parentElement){
                    element = element.parentElement;
                    var cs = getComputedStyle(element);
                    if(cs.position == "relative"){
                        return element;
                    }
                }
                return null;
            };
            var detectBrowser = function(){
                //Check if browser is IE11
                if (navigator.userAgent.search("rv:11") >= 0) {
                    return "ie";
                }
                //Check if browser is Edge
                if (navigator.userAgent.search("Edge") >= 0) {
                    return "edge";
                }
                //Check if browser is Chrome || Opera
                else if (navigator.userAgent.search("Chrome") >= 0) {
                    return "chrome";
                }
                //Check if browser is Firefox
                else if (navigator.userAgent.search("Firefox") >= 0) {
                    return "firefox";
                }
                //Check if browser is Safari
                else if (navigator.userAgent.search("Safari") >= 0 && navigator.userAgent.search("Chrome") < 0) {
                    return "safari";
                }
            };

            var checkForIntersect = function(parentElem,mP){
                var cs = window.getComputedStyle(parentElem);
                var offset = parentElem.getBoundingClientRect();
                // console.log("cs",cs);
                // console.log("offset",offset);
                // console.log("_mousePosition",mP.x,mP.y);
                if(mP.x > (offset.left + parseFloat(cs.paddingLeft || 0)) && mP.x < (offset.right - parseFloat(cs.paddingRight || 0)) && mP.y > (offset.top + parseFloat(cs.paddingTop || 0)) && mP.y < (offset.bottom - parseFloat(cs.paddingBottom || 0))){
                    return true;
                }
                return false;
            };

            var checkForBetween = function(parentElem,mP,div){
                var childrens = parentElem.children;
                var templateTags = 0;
                var childElem = [];
                for(var i = 0;i<childrens.length;i++){
                    if(childrens[i].tagName != "TEMPLATE" && childrens[i].id != "dummy"){
                        childElem.push(childrens[i]);
                    }
                    else{
                        templateTags++;
                    }
                }
                if(templateTags == childrens.length){
                    return true;
                }
                else if(div.getBoundingClientRect().top > (childElem[childElem.length - 1].getBoundingClientRect().bottom/* + (isRelativeY ? scrollDiv.scrollTop : 0)*/)){
                    return true;
                }
                return false;
            };


            var findPreviousElem = function(elem){
                while(elem.previousElementSibling){
                    elem = elem.previousElementSibling;
                    if(elem.tagName != "TEMPLATE" && $L(elem).hasClass('sortable-element')){
                        return elem;
                    }
                }
                return null;
            };

            var findNextElem = function(elem){
                while(elem.nextElementSibling){
                    elem = elem.nextElementSibling;
                    if(elem.tagName != "TEMPLATE" && $L(elem).hasClass('sortable-element')){
                        return elem;
                    }
                }
                return null;
            };

            var removeStyle = function(elem){
                elem.style.left = "";
                elem.style.top = "";
                elem.style.zIndex = "";
                elem.style.position = "";
                $L(elem).addClass("sortable-element "+elem._sortableChildData.sortableElemClass);
                manageDraggable.removeClassOrAttr(data.attribute,elem,'draggable-element');
                manageDraggable.removeClassOrAttr(data.attribute,elem,'draggable-handle-element');
            };

            var checkPlaceholderBelow = function(elem){
                while(elem){
                    if(elem.id && elem.id === "lyteDraggableDummy"){
                        return true;
                    }
                    elem = elem.parentElement;
                }
                return false;
            };

            var isNotRestricted = function(data,targetElem){
                for(var i = 0; i<data.restrict.length ; i++){
                    if(targetElem.matches(data.restrict[i])){
                        return false;
                    }
                }
                return true;
            };

            var getIndex = function(data, fnName){
                if(data.connectToSortable && data._positionedPlceholder){
                    var elem,parent;
                    if(fnName === "onBeforeStop"){
                        elem = data._placeholder;
                        parent = data._placeholder.parentElement;
                    }
                    if(fnName === "onStop"){
                        elem = data._element;
                        parent = data._element.parentElement;
                    }
                    if(parent._sortableParentData.omitRestricted){
                    var siblings = Array.from(parent.children).filter( function(ele) { return ele.tagName != "TEMPLATE" } );
                        for(var y = 0; y<siblings.length; y++){
                            if(!isNotRestricted(data,siblings[y])){
                                siblings.splice(y,1);
                                --y;
                            }
                        }
                        return siblings.indexOf(elem);
                    }
                    else{
                        return Array.from(parent.children).filter( function(ele) { return ele.tagName != "TEMPLATE" } ).indexOf(elem);
                    }

                }
                return -1;
            };

            var getOS = function() {
                var userAgent = window.navigator.userAgent,
                    platform = window.navigator.platform,
                    macosPlatforms = ['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'],
                    windowsPlatforms = ['Win32', 'Win64', 'Windows', 'WinCE'],
                    iosPlatforms = ['iPhone', 'iPad', 'iPod'],
                    os = null;

                if (macosPlatforms.indexOf(platform) !== -1) {
                    os = 'Mac OS';
                } else if (iosPlatforms.indexOf(platform) !== -1) {
                    os = 'iOS';
                } else if (windowsPlatforms.indexOf(platform) !== -1) {
                    os = 'Windows';
                } else if (/Android/.test(userAgent)) {
                    os = 'Android';
                } else if (!os && /Linux/.test(platform)) {
                    os = 'Linux';
                }

                return os;
            };
            return this;

        }
	}

})

( function( factory ) {
    if( typeof define === "function" && define.amd ) {
        define( [ "@zoho/lyte-dom" ], factory );
    }
    else {
        factory( $L );
    }
} )(function( $L ) {

	if($L){	

		//This object synchronizes the draggable elements with the droppable elements
		//It contains the current object which is being dragged in the _current attribute
		//It also contains all the droppables available in the page inside the _droppables array attribute
		$L.prototype.managerDD = {
			init : false,
			_current : null,
			_droppables : [],
			_checkAcceptable : function(draggable,acceptables){
				if(typeof acceptables !== "string"){
					if(acceptables.length === 0){
						return true;
					}
					else{
						for(var i = 0 ; i < acceptables.length ;i++){
							if(draggable.matches(acceptables[i])){
								return true;
							}
						}
					}
				}
				return false;
			},

			_isNotRejected : function(draggable, rejectSelectors){
				if(typeof rejectSelectors !== "string"){
					if(rejectSelectors.length === 0){
						return true;
					}
					else{
						for(var i = 0 ; i < rejectSelectors.length ;i++){
							if(draggable.matches(rejectSelectors[i])){
								return false;
							}
						}
						return true;
					}
				}
				return false;
			},

			_isOverAxis : function( x, reference, size ) {
				return ( x >= reference ) && ( x < ( reference + size ) );
			},
			_checkIntersects : function(event,draggable,droppable,toleranceMode){
				var managerDD = $L.prototype.managerDD;
				var draggableOffset = draggable.getBoundingClientRect(),
					droppableOffset = droppable.getBoundingClientRect(),
					x1 = draggableOffset.left,
					y1 = draggableOffset.top,
					x2 = x1 + draggableOffset.width,
					y2 = y1 + draggableOffset.height,
					l = droppableOffset.left,
					t = droppableOffset.top,
					r = l + droppableOffset.width,
					b = t + droppableOffset.height;
				var clientX = event.clientX;
				var clientY = event.clientY;
				//If draggable and droppable elements are not from same window -
				//Calculate from their dimensions w.r.t top level window.
				if(draggable.ownerDocument.defaultView != droppable.ownerDocument.defaultView){
					//For draggable
					var currentWin = draggable.ownerDocument.defaultView || draggable.ownerDocument.parentWindow;
					while(currentWin && currentWin.frameElement){
						var frameElementOffset = currentWin.frameElement.getBoundingClientRect();
						x1 = x1 + frameElementOffset.left;
						x2 = x2 + frameElementOffset.left;
						y1 = y1 + frameElementOffset.top;
						y2 = y2 + frameElementOffset.top;
						currentWin = currentWin.parent;
					}
					//For event ClientX and ClientY
					var currentWin = event.target.ownerDocument.defaultView || event.target.ownerDocument.parentWindow;
					while(currentWin && currentWin.frameElement){
						var frameElementOffset = currentWin.frameElement.getBoundingClientRect();
						clientX = clientX + frameElementOffset.left;
						clientY = clientY + frameElementOffset.top;
						currentWin = currentWin.parent;
					}
					//For droppable
					currentWin = droppable.ownerDocument.defaultView || droppable.ownerDocument.parentWindow;
					while(currentWin && currentWin.frameElement){
						var frameElementOffset = currentWin.frameElement.getBoundingClientRect();
						l = l + frameElementOffset.left;
						r = r + frameElementOffset.left;
						t = t + frameElementOffset.top;
						b = b + frameElementOffset.top;
						currentWin = currentWin.parent;
					}
				}
				switch ( toleranceMode ) {
				case "fit":
					return ( l <= x1 && x2 <= r && t <= y1 && y2 <= b );
				case "intersect":
					return ( l < x1 + ( draggableOffset.width / 2 ) && // Right Half
						x2 - ( draggableOffset.width / 2 ) < r && // Left Half
						t < y1 + ( draggableOffset.height / 2 ) && // Bottom Half
						y2 - ( draggableOffset.height / 2 ) < b ); // Top Half
				case "pointer":
					if(event.type == "mousemove" || event.type == "mouseup"){
						return managerDD._isOverAxis( clientY, t, droppableOffset.height ) &&
						managerDD._isOverAxis( clientX, l, droppableOffset.width );
					}
					if(event.type == "touchmove" || event.type == "touchend"){
						return managerDD._isOverAxis( event.changedTouches[0].clientY, t, droppableOffset.height ) &&
						managerDD._isOverAxis( event.changedTouches[0].clientX, l, droppableOffset.width );
					}
				case "touch":
					return (
						( y1 >= t && y1 <= b ) || // Top edge touching
						( y2 >= t && y2 <= b ) || // Bottom edge touching
						( y1 < t && y2 > b ) // Surrounded vertically
					) && (
						( x1 >= l && x1 <= r ) || // Left edge touching
						( x2 >= l && x2 <= r ) || // Right edge touching
						( x1 < l && x2 > r ) // Surrounded horizontally
					);
				default:
					return false;
				}
			},
			_getOverflowParent : function(droppables){
				var parent = droppables.parentElement;
				var css = window.getComputedStyle(parent);
				var Parentoverflow = ['hidden','auto','scroll','clip'];
				while(!Parentoverflow.includes(css.overflow) && parent.tagName !== 'BODY'){
					parent = parent.parentElement;
				}
				return parent;
			},
			_checkIsVisible : function(droppables,draggable){
				var managerDD = $L.prototype.managerDD;
				var bounding = draggable.getBoundingClientRect();
				var draggableRect = {
					left  : bounding.left,
					top : bounding.top,
					right : bounding.right,
					bottom : bounding.bottom
				};
				var droppable_Parent = managerDD._getOverflowParent(droppables);
				bounding = droppable_Parent.getBoundingClientRect();;
				var DropParentRect =  {
					left  : bounding.left,
					top : bounding.top,
					right : bounding.right,
					bottom : bounding.bottom
				};
				if(draggable.ownerDocument.defaultView != droppable_Parent.ownerDocument.defaultView){
					//For draggable
					var currentWin = draggable.ownerDocument.defaultView || draggable.ownerDocument.parentWindow;
					while(currentWin && currentWin.frameElement){
						var frameElementOffset = currentWin.frameElement.getBoundingClientRect();
						draggableRect.left += frameElementOffset.left;
						draggableRect.right += frameElementOffset.left;
						draggableRect.top += frameElementOffset.top;
						draggableRect.bottom += frameElementOffset.top;
						currentWin = currentWin.parent;
					}
					currentWin = droppable_Parent.ownerDocument.defaultView || droppable_Parent.ownerDocument.parentWindow;
					while(currentWin && currentWin.frameElement){
						var frameElementOffset = currentWin.frameElement.getBoundingClientRect();
						DropParentRect.left += frameElementOffset.left;
						DropParentRect.right += frameElementOffset.left;
						DropParentRect.top +=  frameElementOffset.top;
						DropParentRect.bottom += frameElementOffset.top;
						currentWin = currentWin.parent;
					}
				}
				if(( draggableRect.left < DropParentRect.right  || 
						draggableRect.left < DropParentRect.right || 
						draggableRect.right < DropParentRect.right ) && 
						(
						draggableRect.bottom < DropParentRect.top || 
						draggableRect.top < DropParentRect.bottom ||
						draggableRect.bottom < DropParentRect.bottom
					) ){
					return true;
				}
				return false;
			},
			_drag : function(event){
				var managerDD = $L.prototype.managerDD;
				var droppables = this._droppables;
				var draggable = this._current;
				for(var i=0; i< droppables.length ; i++){
					
					var data = droppables[i]._droppableData;

					//Checks if the droppable is disabled or not
					//Also checks whether the draggable can be accepted by the droppable
					//And the draggable and droppable are not same element and doesnt have parent child relationship
					if(!data.disabled  && !(managerDD._isRelated(draggable, droppables[i])) && managerDD._checkAcceptable(draggable,data.accept) && managerDD._isNotRejected(draggable,data.reject)){

						//Checks if the draggable intersects the droppable
						if(managerDD._checkIntersects(event,draggable,droppables[i],data.tolerance) && managerDD._checkIsVisible(droppables[i],draggable)){
							if(!data.entered){
								var prevDroppable = draggable._draggableData.currDroppable;
								if(prevDroppable && prevDroppable != droppables[i]){
									var prevDroppableData = prevDroppable._droppableData;
									if(prevDroppableData.onLeave){
										prevDroppableData.onLeave(draggable._draggableData._element,prevDroppable);
									}
									if(prevDroppableData.hoverClass && $L(prevDroppable).hasClass(prevDroppableData.hoverClass)){
										$L(prevDroppable).removeClass(prevDroppableData.hoverClass);
									}
									if(prevDroppableData.activeClass && !$L(prevDroppable).hasClass(prevDroppableData.activeClass)){
										$L(prevDroppable).addClass(prevDroppableData.activeClass);
									}
									prevDroppableData.entered = false;
								}
								if(data.isScrollable){
									draggable._draggableData._element.addScrollDivXY(droppables[i],droppables[i]);
								}
								
								if(data.onEnter){
									data.onEnter(draggable._draggableData._element,droppables[i]);
								}
								data.entered = true;
								draggable._draggableData.currDroppable = droppables[i];
							}
							if(data.onDrag){
								if(event.type == "mousemove"){
									mousePosition = {
										x : event.clientX,
										y : event.clientY
									};
								}
								else if(event.type == "touchmove"){
									var mousePosition = {
										x : event.touches[0].clientX,
										y : event.touches[0].clientY
									};
								}
		
								data.onDrag(draggable._draggableData._element,droppables[i],event,mousePosition);
							}
							if(data.hoverClass && !$L(droppables[i]).hasClass(data.hoverClass)){
								this.removeHoverClass(droppables[i],data.hoverClass);
								if(data.activeClass && $L(droppables[i]).hasClass(data.activeClass)){
									$L(droppables[i]).removeClass(data.activeClass);
								}
								$L(droppables[i]).addClass(data.hoverClass);
								if(data.onHover){
									data.onHover(draggable._draggableData._element,droppables[i]);
								}
							}
							break;
						}
						else{
							if(data.entered){
								var prevDroppable = draggable._draggableData.currDroppable;
								if(!prevDroppable){
									data.entered = false;
									continue;
								}
								var prevDroppableData = prevDroppable._droppableData;
								if(prevDroppableData.onLeave){
									prevDroppableData.onLeave(draggable._draggableData._element,prevDroppable);
								}
								if(prevDroppableData.hoverClass && $L(prevDroppable).hasClass(prevDroppableData.hoverClass)){
									$L(prevDroppable).removeClass(prevDroppableData.hoverClass);
								}
								if(prevDroppableData.activeClass && !$L(prevDroppable).hasClass(prevDroppableData.activeClass)){
									$L(prevDroppable).addClass(prevDroppableData.activeClass);
								}
								prevDroppableData.entered = false;
								draggable._draggableData.currDroppable = null;
							}
						}
					}
				}
			},
			_drop : function(event){
				var managerDD = $L.prototype.managerDD;
				var droppables = this._droppables;
				var draggable = this._current;
				for(var i=0; i< droppables.length ; i++){

					if(!(managerDD._isRelated(draggable, droppables[i]))){
						var data = droppables[i]._droppableData;
						if(data.activeClass && $L(droppables[i]).hasClass(data.activeClass)){
							$L(droppables[i]).removeClass(data.activeClass);
						}
						if(data.hoverClass && $L(droppables[i]).hasClass(data.hoverClass)){
							$L(droppables[i]).removeClass(data.hoverClass);
						}
						if(!data.disabled && managerDD._checkAcceptable(draggable,data.accept)){
							if(managerDD._checkIntersects(event,draggable,droppables[i],data.tolerance)){
								if(data.onDrop){
									data.onDrop(draggable._draggableData._element,droppables[i]);
								}
								break;
							}
						}
					}
				}
			},
			_isRestricted : function(restrict,element){
				restrict = restrict instanceof Array ? restrict : restrict.split(",");
				for(var i = 0; i<restrict.length; i++){
					var elements = document.querySelectorAll(restrict[i]);
					for(var j = 0; j < elements.length; j++){
						if(element.isEqualNode(elements[i])){
							return true;
						}
					}
				}
				return false;
			},

			_isRelated : function(draggable, droppable){
				if(draggable.isEqualNode(droppable) || draggable.contains(droppable)){
					return true;
				}
				return false;
			},
			sort : function(){
				var droppables = this._droppables,
				lastItem = droppables[droppables.length - 1],
				lastItemOffset = lastItem.getBoundingClientRect();
				for(var i = 0; i < droppables.length - 1; i++){
					var elemOffset = droppables[i].getBoundingClientRect();
					if(lastItemOffset.height < elemOffset.height || lastItemOffset.width < elemOffset.width){
						droppables.splice(droppables.indexOf(lastItem),1);
						droppables.splice(i,0,lastItem);
						return;
					}
				}
			},

			destroy : function(element){
				var managerDD = $L.prototype.managerDD;
				var attribute = element._droppableData.attribute;
				if(this._current && this._current._draggableData && element  === this._current._draggableData.currDroppable){
					this._current._draggableData.currDroppable = undefined;
				}
				if(!(managerDD.hasClassOrAttr(attribute,element,'droppable-element'))){
					console.info("ALERT! - U have already destroyed its droppable behaviour.");
					return;
				}
				if(managerDD._droppables.indexOf(element) !== -1){
					managerDD._droppables.splice(managerDD._droppables.indexOf(element),1);
				}
				if(element._droppableData.registerFromParent || element._droppableData.registerToParent){
					var currentWin = window;
					managerDD.deleteDroppable(element, currentWin, "up");
					managerDD.deleteDroppable(element, currentWin, "down");
				}
				if (element._droppableData) {
					element._droppableData = null;
				}
				managerDD.removeClassOrAttr(attribute,element,'droppable-element');
			},

			sortDroppables : function(droppableEle){
				var managerDD = $L.prototype.managerDD;
				var data = droppableEle._droppableData;
				if(data.sortCallback) {
					data.sortCallback(this._droppables);
				}else{
					managerDD.sort();
				}
				
			},

			removeHoverClass : function(current,className){
				var droppables = this._droppables;
				for(var i = 0; i<droppables.length; i++){
					if(!(droppables[i].isEqualNode(current)) && droppables[i].classList.contains(className)){
						droppables[i].classList.remove(className);
					} 
				}
			},

			deleteDroppable : function(element,currentWin,direction){
				var managerDD = $L.prototype.managerDD;
				if(direction == "up"){
					while(currentWin.parent){
						currentWin = currentWin.parent;
						if(currentWin && currentWin.$L){
							var winManagerDD = currentWin.$L.prototype.managerDD;
							if(winManagerDD && winManagerDD._droppables.indexOf(element) !== -1){
								winManagerDD._droppables.splice(winManagerDD._droppables.indexOf(element),1);
							}
						}
						if(currentWin.parent == currentWin.top){
							break;
						}
					}
				}
				if(direction == "down"){
					var iframes = currentWin.document.documentElement.querySelectorAll('iframe');
					if(iframes){
						for(var i = 0; i<iframes.length ; i++){
							var win = iframes[i].contentWindow;
							if(win && win.$L){
								var winManagerDD = win.$L.prototype.managerDD;
								if(winManagerDD && winManagerDD._droppables.indexOf(element) !== -1){
									winManagerDD._droppables.splice(winManagerDD._droppables.indexOf(element),1);
									winManagerDD.deleteDroppable(element, win, "down");
								}
							}
						}
					}
				}
			},

			setProperty : function(element, properties){
				var managerDD = $L.prototype.managerDD;
				if(!element){
					console.error('Element whose droppable property will be updated is undefined');
					return;
				}
				if(!managerDD.hasClassOrAttr(element._droppableData.attribute,element,'droppable-element')){
					console.error('Element whose droppable property will be updated is not a droppable element');
					return;
				}
				if(managerDD.isEmpty(properties)){
					console.error('Droppable properties to be updated is not specified');
					return;
				}

				for(var prop in properties) {
					element._droppableData[prop] = properties[prop];
				}
			},

			isEmpty : function(properties){
				if(!properties){
					return true;
				}
				for(var prop in properties) {
					if(properties.hasOwnProperty(prop)) {
						return false;
					}
				}

				return JSON.stringify(properties) === JSON.stringify({});
			},
			addClassOrAttr : function( attribute, elem, name ){
				if(attribute){
					$L(elem).attr(name,'');
				}else{
					$L(elem).addClass(name);
				}
			},
			removeClassOrAttr : function( attribute, elem, name ){
				if(attribute){
					$L(elem).removeAttr(name);
				}else{
					$L(elem).removeClass(name);
				}
			},
			hasClassOrAttr: function( attribute, elem, name ){
				if(attribute){
					return $L(elem).attr(name) !== undefined;
				}else{
					return $L(elem).hasClass(name);
				}

			}
		};


		//It initializes the droppable funcionality and stores it in the managerDD._droppables array 
		$L.prototype.droppable = function(object, properties) {
			var managerDD = $L.prototype.managerDD;
			if(!managerDD.init){
				if (!window.Element.prototype.matches) {
					window.Element.prototype.matches = 
						Element.prototype.matchesSelector || 
						Element.prototype.mozMatchesSelector ||
						Element.prototype.msMatchesSelector || 
						Element.prototype.oMatchesSelector || 
						Element.prototype.webkitMatchesSelector ||
						function(s) {
							var matches = (this.document || this.ownerDocument).querySelectorAll(s),
								i = matches.length - 1;
							while (i >= 0 && matches.item(i) !== this){
								--i;
								//gets the index of the matched item
							}
							return i > -1;            
						};
				}
				managerDD.init = true;
			}

			if(!managerDD.init){
				if (!window.Element.prototype.matches) {
					window.Element.prototype.matches = 
						Element.prototype.matchesSelector || 
						Element.prototype.mozMatchesSelector ||
						Element.prototype.msMatchesSelector || 
						Element.prototype.oMatchesSelector || 
						Element.prototype.webkitMatchesSelector ||
						function(s) {
							var matches = (this.document || this.ownerDocument).querySelectorAll(s),
								i = matches.length - 1;
							while (i >= 0 && matches.item(i) !== this){
								--i;
								//gets the index of the matched item
							}
							return i > -1;            
						};
				}
				managerDD.init = true;
			}

			if(typeof object === "string"){
				if(object === "destroy"){
					if(this.length > 1){
						var elemArray = this;
						for(var i=0; i<elemArray.length; i++){
							managerDD.destroy(elemArray[i]);
						}
					}
					else{
						managerDD.destroy(this[0]);
					}
				}
				else if(object === "option"){
					if(this.length > 1){
						var elemArray = this;
						for(var i=0; i<elemArray.length; i++){
							managerDD.setProperty(elemArray[i], properties);
						}
					}
					else{
						managerDD.setProperty(this[0], properties);
					}
				}

				else if(object === "sort"){
					var currentDroppables = managerDD._droppables;
					if(currentDroppables.length > 0){
						managerDD._droppables = [];
						managerDD._droppables.push(currentDroppables[0]);
						for(var i = 1; i < currentDroppables.length; i++){
							managerDD._droppables.push(currentDroppables[i]);
							managerDD.sortDroppables(currentDroppables[i]);
						}
					}

					var element = this[0];
					if(element._droppableData && element._droppableData.registerToParent){
						var currentWin = window,
							winManagerDD;
						while(currentWin.parent){
							currentWin = currentWin.parent;
							if(currentWin && currentWin.$L){
								winManagerDD = currentWin.$L.prototype.managerDD;
								if(winManagerDD){
									currentDroppables = winManagerDD._droppables;
									if(currentDroppables.length > 0){
										winManagerDD._droppables = [];
										winManagerDD._droppables.push(currentDroppables[0]);
										for(var i = 1; i < currentDroppables.length; i++){
											winManagerDD._droppables.push(currentDroppables[i]);
											winManagerDD.sortDroppables(currentDroppables[i]);
										}
									}
								}
							}
							if(currentWin.parent == currentWin.top){
								break;
							}
						}
					}
					if(element._droppableData && element._droppableData.registerFromParent){
						var currentWin = window,
							parentWindow = window, pwinManagerDD, cwinManagerDD;
						while(parentWindow.parent){
							parentWindow = parentWindow.parent;
							if(parentWindow && parentWindow.$L){
								pwinManagerDD = parentWindow.$L.prototype.managerDD;
								if(pwinManagerDD){
									var droppables = pwinManagerDD._droppables;
									for(var i = 0; i<droppables.length ; i++){
										if(currentWin && currentWin.$L){
											cwinManagerDD = currentWin.$L.prototype.managerDD;
											currentDroppables = cwinManagerDD._droppables;
											if(currentDroppables.length > 0){
												cwinManagerDD._droppables = [];
												cwinManagerDD._droppables.push(currentDroppables[0]);
												for(var i = 1; i < currentDroppables.length; i++){
													cwinManagerDD._droppables.push(currentDroppables[i]);
													cwinManagerDD.sortDroppables(currentDroppables[i]);
												}
											}
										}
									}
								}
							}
							if(parentWindow.parent == parentWindow.top){
								break;
							}
						}
					}
				}
				
				return;
			}

			var data = object ? object : {};

			if(this.length > 1){
				var elemArray = this;
				for(var i = 0; i<elemArray.length; i++){
					$L(elemArray[i]).droppable(Object.assign({},data));
				}
				return;
			}

			if(data.restrict && managerDD._isRestricted(data.restrict, this[0])){
				return;
			}

			//Parent Element
			var droppableEle;
			data._element = droppableEle = this[0];

			
			data.entered = false;
			data.activeClass = data.activeClass ? data.activeClass : false; 
			data.accept = data.accept ? data.accept : [];
			data.disabled = (data.disabled === true) ? data.disabled : false;
			data.hoverClass = data.hoverClass ? data.hoverClass : false;
			data.isScrollable = data.isScrollable ? data.isScrollable : false;
			data.tolerance = (data.tolerance === "fit" || data.tolerance === "intersect" || data.tolerance === "pointer" || data.tolerance === "touch") ? data.tolerance : "intersect";
			data.registerToParent = data.registerToParent;
			data.attribute = data.attribute ? data.attribute : false;
			data.reject = data.reject ? data.reject : [],
			droppableEle._droppableData = data;
			managerDD.addClassOrAttr(data.attribute,data._element,'droppable-element');
			if(managerDD._droppables.indexOf(droppableEle) == -1){
				// managerDD._droppables.splice(managerDD._droppables.indexOf(droppableEle),1);
				managerDD._droppables.push(droppableEle);
				if(managerDD._droppables.length > 1 && data.sortDroppables){
					managerDD.sortDroppables(droppableEle);
				}
			}
			

			//Incase of nested iframes if user wants the droppables to be available to the parent window context
			if(data.registerToParent){
				var currentWin = window,
					winManagerDD;
				while(currentWin.parent){
					currentWin = currentWin.parent;
					if(currentWin && currentWin.$L){
						winManagerDD = currentWin.$L.prototype.managerDD;
						if(winManagerDD){
							winManagerDD._droppables.push(droppableEle);
							if(winManagerDD._droppables.length > 1 && droppableEle._droppableData.sortDroppables){
								winManagerDD.sortDroppables(droppableEle);
							}
						}
					}
					if(currentWin.parent == currentWin.top){
						break;
					}
				}
			}

			//Incase the user wants all the droppables from its parent
			if(data.registerFromParent){
				var currentWin = window,
					parentWindow = window, pwinManagerDD, cwinManagerDD;
				while(parentWindow.parent){
					parentWindow = parentWindow.parent;
					if(parentWindow && parentWindow.$L){
						pwinManagerDD = parentWindow.$L.prototype.managerDD;
						if(pwinManagerDD){
							var droppables = pwinManagerDD._droppables;
							for(var i = 0; i<droppables.length ; i++){
								if(currentWin && currentWin.$L){
									cwinManagerDD = currentWin.$L.prototype.managerDD;
									if(cwinManagerDD._droppables.indexOf(droppables[i]) == -1){
										cwinManagerDD._droppables.push(droppables[i]);
										if(cwinManagerDD._droppables.length > 1 && droppableEle._droppableData.sortDroppables){
											cwinManagerDD.sortDroppables(droppables[i]);
										}
									}
								}
							}
						}
					}
					if(parentWindow.parent == parentWindow.top){
						break;
					}
				}
			} 

			droppableEle = null;
			if(data.onReady){
				data.onReady(this[0]);
			}

			return this;
		}

	}
});


( function( factory ) {
    if( typeof define === "function" && define.amd ) {
        define( [ "@zoho/lyte-dom" ], factory );
    }
    else {
        factory( $L );
    }
} )( function( $L ){
	if( $L ){

		var ExifTags, TiffTags, GPSTags, IFD1Tags, StringValues, debug = false;
		
		$L.exif = function(arg, setDebug){
			var object = arg || {};
			if(setDebug){
				debug = true;
			}
			if(!object.target){
				console.error("Target not provided for the retrieving the data!!");
				return false;
			}
	        if (!targetHasData(object.target)) {
	        	
	            fetchTargetExifData(object.target, object.getData);
	        } else {
	            if (object.getData) {
	                object.getData.call(null,{target : object.target, exifdata : object.target.exifdata});
	            }
	        }
	        return true;
		}

		ExifTags = $L.exif.Tags = {

	        // version tags
	        0x9000 : "ExifVersion",             // EXIF version
	        0xA000 : "FlashpixVersion",         // Flashpix format version

	        // colorspace tags
	        0xA001 : "ColorSpace",              // Color space information tag

	        // image configuration
	        0xA002 : "PixelXDimension",         // Valid width of meaningful image
	        0xA003 : "PixelYDimension",         // Valid height of meaningful image
	        0x9101 : "ComponentsConfiguration", // Information about channels
	        0x9102 : "CompressedBitsPerPixel",  // Compressed bits per pixel

	        // user information
	        0x927C : "MakerNote",               // Any desired information written by the manufacturer
	        0x9286 : "UserComment",             // Comments by user

	        // related file
	        0xA004 : "RelatedSoundFile",        // Name of related sound file

	        // date and time
	        0x9003 : "DateTimeOriginal",        // Date and time when the original image was generated
	        0x9004 : "DateTimeDigitized",       // Date and time when the image was stored digitally
	        0x9290 : "SubsecTime",              // Fractions of seconds for DateTime
	        0x9291 : "SubsecTimeOriginal",      // Fractions of seconds for DateTimeOriginal
	        0x9292 : "SubsecTimeDigitized",     // Fractions of seconds for DateTimeDigitized

	        // picture-taking conditions
	        0x829A : "ExposureTime",            // Exposure time (in seconds)
	        0x829D : "FNumber",                 // F number
	        0x8822 : "ExposureProgram",         // Exposure program
	        0x8824 : "SpectralSensitivity",     // Spectral sensitivity
	        0x8827 : "ISOSpeedRatings",         // ISO speed rating
	        0x8828 : "OECF",                    // Optoelectric conversion factor
	        0x9201 : "ShutterSpeedValue",       // Shutter speed
	        0x9202 : "ApertureValue",           // Lens aperture
	        0x9203 : "BrightnessValue",         // Value of brightness
	        0x9204 : "ExposureBias",            // Exposure bias
	        0x9205 : "MaxApertureValue",        // Smallest F number of lens
	        0x9206 : "SubjectDistance",         // Distance to subject in meters
	        0x9207 : "MeteringMode",            // Metering mode
	        0x9208 : "LightSource",             // Kind of light source
	        0x9209 : "Flash",                   // Flash status
	        0x9214 : "SubjectArea",             // Location and area of main subject
	        0x920A : "FocalLength",             // Focal length of the lens in mm
	        0xA20B : "FlashEnergy",             // Strobe energy in BCPS
	        0xA20C : "SpatialFrequencyResponse",    //
	        0xA20E : "FocalPlaneXResolution",   // Number of pixels in width direction per FocalPlaneResolutionUnit
	        0xA20F : "FocalPlaneYResolution",   // Number of pixels in height direction per FocalPlaneResolutionUnit
	        0xA210 : "FocalPlaneResolutionUnit",    // Unit for measuring FocalPlaneXResolution and FocalPlaneYResolution
	        0xA214 : "SubjectLocation",         // Location of subject in image
	        0xA215 : "ExposureIndex",           // Exposure index selected on camera
	        0xA217 : "SensingMethod",           // Image sensor type
	        0xA300 : "FileSource",              // Image source (3 == DSC)
	        0xA301 : "SceneType",               // Scene type (1 == directly photographed)
	        0xA302 : "CFAPattern",              // Color filter array geometric pattern
	        0xA401 : "CustomRendered",          // Special processing
	        0xA402 : "ExposureMode",            // Exposure mode
	        0xA403 : "WhiteBalance",            // 1 = auto white balance, 2 = manual
	        0xA404 : "DigitalZoomRation",       // Digital zoom ratio
	        0xA405 : "FocalLengthIn35mmFilm",   // Equivalent foacl length assuming 35mm film camera (in mm)
	        0xA406 : "SceneCaptureType",        // Type of scene
	        0xA407 : "GainControl",             // Degree of overall image gain adjustment
	        0xA408 : "Contrast",                // Direction of contrast processing applied by camera
	        0xA409 : "Saturation",              // Direction of saturation processing applied by camera
	        0xA40A : "Sharpness",               // Direction of sharpness processing applied by camera
	        0xA40B : "DeviceSettingDescription",    //
	        0xA40C : "SubjectDistanceRange",    // Distance to subject

	        // other tags
	        0xA005 : "InteroperabilityIFDPointer",
	        0xA420 : "ImageUniqueID"            // Identifier assigned uniquely to each image
	    };

	    TiffTags = $L.exif.TiffTags = {
	        0x0100 : "ImageWidth",
	        0x0101 : "ImageHeight",
	        0x8769 : "ExifIFDPointer",
	        0x8825 : "GPSInfoIFDPointer",
	        0xA005 : "InteroperabilityIFDPointer",
	        0x0102 : "BitsPerSample",
	        0x0103 : "Compression",
	        0x0106 : "PhotometricInterpretation",
	        0x0112 : "Orientation",
	        0x0115 : "SamplesPerPixel",
	        0x011C : "PlanarConfiguration",
	        0x0212 : "YCbCrSubSampling",
	        0x0213 : "YCbCrPositioning",
	        0x011A : "XResolution",
	        0x011B : "YResolution",
	        0x0128 : "ResolutionUnit",
	        0x0111 : "StripOffsets",
	        0x0116 : "RowsPerStrip",
	        0x0117 : "StripByteCounts",
	        0x0201 : "JPEGInterchangeFormat",
	        0x0202 : "JPEGInterchangeFormatLength",
	        0x012D : "TransferFunction",
	        0x013E : "WhitePoint",
	        0x013F : "PrimaryChromaticities",
	        0x0211 : "YCbCrCoefficients",
	        0x0214 : "ReferenceBlackWhite",
	        0x0132 : "DateTime",
	        0x010E : "ImageDescription",
	        0x010F : "Make",
	        0x0110 : "Model",
	        0x0131 : "Software",
	        0x013B : "Artist",
	        0x8298 : "Copyright"
	    };

	    GPSTags = $L.exif.GPSTags = {
	        0x0000 : "GPSVersionID",
	        0x0001 : "GPSLatitudeRef",
	        0x0002 : "GPSLatitude",
	        0x0003 : "GPSLongitudeRef",
	        0x0004 : "GPSLongitude",
	        0x0005 : "GPSAltitudeRef",
	        0x0006 : "GPSAltitude",
	        0x0007 : "GPSTimeStamp",
	        0x0008 : "GPSSatellites",
	        0x0009 : "GPSStatus",
	        0x000A : "GPSMeasureMode",
	        0x000B : "GPSDOP",
	        0x000C : "GPSSpeedRef",
	        0x000D : "GPSSpeed",
	        0x000E : "GPSTrackRef",
	        0x000F : "GPSTrack",
	        0x0010 : "GPSImgDirectionRef",
	        0x0011 : "GPSImgDirection",
	        0x0012 : "GPSMapDatum",
	        0x0013 : "GPSDestLatitudeRef",
	        0x0014 : "GPSDestLatitude",
	        0x0015 : "GPSDestLongitudeRef",
	        0x0016 : "GPSDestLongitude",
	        0x0017 : "GPSDestBearingRef",
	        0x0018 : "GPSDestBearing",
	        0x0019 : "GPSDestDistanceRef",
	        0x001A : "GPSDestDistance",
	        0x001B : "GPSProcessingMethod",
	        0x001C : "GPSAreaInformation",
	        0x001D : "GPSDateStamp",
	        0x001E : "GPSDifferential"
	    };

	     // EXIF 2.3 Spec
	    IFD1Tags = $L.exif.IFD1Tags = {
	        0x0100: "ImageWidth",
	        0x0101: "ImageHeight",
	        0x0102: "BitsPerSample",
	        0x0103: "Compression",
	        0x0106: "PhotometricInterpretation",
	        0x0111: "StripOffsets",
	        0x0112: "Orientation",
	        0x0115: "SamplesPerPixel",
	        0x0116: "RowsPerStrip",
	        0x0117: "StripByteCounts",
	        0x011A: "XResolution",
	        0x011B: "YResolution",
	        0x011C: "PlanarConfiguration",
	        0x0128: "ResolutionUnit",
	        0x0201: "JpegIFOffset",    // When image format is JPEG, this value show offset to JPEG data stored.(aka "ThumbnailOffset" or "JPEGInterchangeFormat")
	        0x0202: "JpegIFByteCount", // When image format is JPEG, this value shows data size of JPEG image (aka "ThumbnailLength" or "JPEGInterchangeFormatLength")
	        0x0211: "YCbCrCoefficients",
	        0x0212: "YCbCrSubSampling",
	        0x0213: "YCbCrPositioning",
	        0x0214: "ReferenceBlackWhite"
	    };

	    StringValues = $L.exif.StringValues = {
	        ExposureProgram : {
	            0 : "Not defined",
	            1 : "Manual",
	            2 : "Normal program",
	            3 : "Aperture priority",
	            4 : "Shutter priority",
	            5 : "Creative program",
	            6 : "Action program",
	            7 : "Portrait mode",
	            8 : "Landscape mode"
	        },
	        MeteringMode : {
	            0 : "Unknown",
	            1 : "Average",
	            2 : "CenterWeightedAverage",
	            3 : "Spot",
	            4 : "MultiSpot",
	            5 : "Pattern",
	            6 : "Partial",
	            255 : "Other"
	        },
	        LightSource : {
	            0 : "Unknown",
	            1 : "Daylight",
	            2 : "Fluorescent",
	            3 : "Tungsten (incandescent light)",
	            4 : "Flash",
	            9 : "Fine weather",
	            10 : "Cloudy weather",
	            11 : "Shade",
	            12 : "Daylight fluorescent (D 5700 - 7100K)",
	            13 : "Day white fluorescent (N 4600 - 5400K)",
	            14 : "Cool white fluorescent (W 3900 - 4500K)",
	            15 : "White fluorescent (WW 3200 - 3700K)",
	            17 : "Standard light A",
	            18 : "Standard light B",
	            19 : "Standard light C",
	            20 : "D55",
	            21 : "D65",
	            22 : "D75",
	            23 : "D50",
	            24 : "ISO studio tungsten",
	            255 : "Other"
	        },
	        Flash : {
	            0x0000 : "Flash did not fire",
	            0x0001 : "Flash fired",
	            0x0005 : "Strobe return light not detected",
	            0x0007 : "Strobe return light detected",
	            0x0009 : "Flash fired, compulsory flash mode",
	            0x000D : "Flash fired, compulsory flash mode, return light not detected",
	            0x000F : "Flash fired, compulsory flash mode, return light detected",
	            0x0010 : "Flash did not fire, compulsory flash mode",
	            0x0018 : "Flash did not fire, auto mode",
	            0x0019 : "Flash fired, auto mode",
	            0x001D : "Flash fired, auto mode, return light not detected",
	            0x001F : "Flash fired, auto mode, return light detected",
	            0x0020 : "No flash function",
	            0x0041 : "Flash fired, red-eye reduction mode",
	            0x0045 : "Flash fired, red-eye reduction mode, return light not detected",
	            0x0047 : "Flash fired, red-eye reduction mode, return light detected",
	            0x0049 : "Flash fired, compulsory flash mode, red-eye reduction mode",
	            0x004D : "Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected",
	            0x004F : "Flash fired, compulsory flash mode, red-eye reduction mode, return light detected",
	            0x0059 : "Flash fired, auto mode, red-eye reduction mode",
	            0x005D : "Flash fired, auto mode, return light not detected, red-eye reduction mode",
	            0x005F : "Flash fired, auto mode, return light detected, red-eye reduction mode"
	        },
	        SensingMethod : {
	            1 : "Not defined",
	            2 : "One-chip color area sensor",
	            3 : "Two-chip color area sensor",
	            4 : "Three-chip color area sensor",
	            5 : "Color sequential area sensor",
	            7 : "Trilinear sensor",
	            8 : "Color sequential linear sensor"
	        },
	        SceneCaptureType : {
	            0 : "Standard",
	            1 : "Landscape",
	            2 : "Portrait",
	            3 : "Night scene"
	        },
	        SceneType : {
	            1 : "Directly photographed"
	        },
	        CustomRendered : {
	            0 : "Normal process",
	            1 : "Custom process"
	        },
	        WhiteBalance : {
	            0 : "Auto white balance",
	            1 : "Manual white balance"
	        },
	        GainControl : {
	            0 : "None",
	            1 : "Low gain up",
	            2 : "High gain up",
	            3 : "Low gain down",
	            4 : "High gain down"
	        },
	        Contrast : {
	            0 : "Normal",
	            1 : "Soft",
	            2 : "Hard"
	        },
	        Saturation : {
	            0 : "Normal",
	            1 : "Low saturation",
	            2 : "High saturation"
	        },
	        Sharpness : {
	            0 : "Normal",
	            1 : "Soft",
	            2 : "Hard"
	        },
	        SubjectDistanceRange : {
	            0 : "Unknown",
	            1 : "Macro",
	            2 : "Close view",
	            3 : "Distant view"
	        },
	        FileSource : {
	            3 : "DSC"
	        },

	        Components : {
	            0 : "",
	            1 : "Y",
	            2 : "Cb",
	            3 : "Cr",
	            4 : "R",
	            5 : "G",
	            6 : "B"
	        }
	    };

	    function targetHasData(target) {
	        return !!(typeof target === "object" && target.exifdata);
	    }

	    function base64ToArrayBuffer(base64, contentType) {
	        if(!contentType){
	    		var base_match = base64.match(/^data\:([\s\S]*?)\;base64,/mi)
	    		if(base_match && base_match[1]){
	    			contentType = base_match[1];
	    		}else{
	    			contentType = '';
	    		}
	    	}else{
	    		contentType = '';
	    	}
	        //contentType = contentType || base64.match(/^data\:([^\;]+)\;base64,/mi)[1] || ''; // e.g. 'data:image/jpeg;base64,...' => 'image/jpeg'
	        
			base64 = base64.replace(/^data\:([\s\S]*?)\;base64,/gmi, '');
	        var binary = window.atob(base64);
	        var len = binary.length;
	        var buffer = new window.ArrayBuffer(len);
	        var view = new window.Uint8Array(buffer);
	        for (var i = 0; i < len; i++) {
	            view[i] = binary.charCodeAt(i);
	        }
	        return buffer;
	    }

	    function objectURLToBlob(url, callback) {
	        var http = new window.XMLHttpRequest();
	        http.open("GET", url, true);
	        http.responseType = "blob";
	        http.onload = function(e) {
	            if (this.status == 200 || this.status === 0) {
	                callback(this.response);
	            }
	        };
	        http.send();
	    }

	    function fetchTargetExifData(target, callback) {

	        function readDataFromBinaryFile(binFile) {
	        	
	            var data = getExifData(binFile);

	            if(typeof target === "object"){
	            	target.exifdata = data || {};
	            }
	            var obj = {
			            	target : target,
			            	exifdata : data || {}
			            }
	            if (callback) {
	                callback.call(null,obj);
	            }
	        }
	        var src = typeof target === "string" ? target : target.src;
	        if (src) {
	            if (/^data\:/i.test(src)) { // Data URI
	                var arrayBuffer = base64ToArrayBuffer(src);
	                readDataFromBinaryFile(arrayBuffer);

	            } else if (/^blob\:/i.test(src)) { // Object URL
	                var fileReader = new window.FileReader();
	                fileReader.onload = function(e) {
	                    readDataFromBinaryFile(e.target.result);
	                };
	                objectURLToBlob(src, function (blob) {
	                    fileReader.readAsArrayBuffer(blob);
	                });
	            } else {
	                var http = new window.XMLHttpRequest();
	                http.onload = function() {
	                    if (this.status == 200 || this.status === 0) {

	                        readDataFromBinaryFile(http.response);

	                    } else {
	                        throw "Could not load image";
	                    }
	                    http = null;
	                };
	                http.open("GET", src, true);
	                http.responseType = "arraybuffer";
	                http.send(null);
	            }
	        } else if (window.self.FileReader && (target instanceof window.self.Blob || target instanceof window.self.File)) {
	            var fileReader = new window.FileReader();
	            fileReader.onload = function(e) {
	                debug && console.log("Got file of length " + e.target.result.byteLength);
	                readDataFromBinaryFile(e.target.result);
	            };

	            fileReader.readAsArrayBuffer(target);
	        }
	    }

	    function getExifData(file) {
	        var dataView = new window.DataView(file);

	        debug && console.log("Got file of length " + file.byteLength);
	        if ((getUint8Wrap(dataView , 0) != 0xFF) || (getUint8Wrap(dataView , 1) != 0xD8)) {
	            debug && console.log("Not a valid JPEG");
	            return false; // not a valid jpeg
	        }

	        var offset = 2,
	            length = file.byteLength,
	            marker;

	        while (offset < length) {
	            if (getUint8Wrap(dataView , offset) != 0xFF) {
	                debug && console.log("Not a valid marker at offset " + offset + ", found: " + getUint8Wrap(dataView, offset));
	                return false; // not a valid marker, something is wrong
	            }

	            
	            marker = getUint8Wrap(dataView , offset + 1)
	            debug && console.log(marker);

	            // we're only looking for 0xFFE1 for EXIF data
	            if (marker == 225) {
	                debug && console.log("Found 0xFFE1 marker");

	                return readExifData(dataView, offset + 4, getUint16Wrap(dataView , offset + 2) - 2);
	            } else {
	                //offset += 2 + dataView.getUint16(offset+2);
	            	offset += 2 + getUint16Wrap(dataView , offset+2)
	            }

	        }
	        

	    }

	    function readTags(file, tiffStart, dirStart, strings, bigEnd) {
	    	
	        var entries = getUint16Wrap(file, dirStart, !bigEnd),
	            tags = {},
	            entryOffset, tag,
	            i;

	        for (i=0;i<entries;i++) {
	            entryOffset = dirStart + i*12 + 2;
	            tag = strings[getUint16Wrap(file, entryOffset, !bigEnd)];
	            !tag && debug && console.log("Unknown tag: " + getUint16Wrap(file, entryOffset, !bigEnd));
	            tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);
	        }

	        return tags;
	    }


	    function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {
	    	
	        var type = getUint16Wrap(file, entryOffset+2, !bigEnd),
	            numValues = getUint32Wrap(file, entryOffset+4, !bigEnd),
	            valueOffset = getUint32Wrap(file, entryOffset+8, !bigEnd) + tiffStart,
	            offset,
	            vals, val, n,
	            numerator, denominator;

	        switch (type) {
	            case 1: // byte, 8-bit unsigned int
	            case 7: // undefined, 8-bit byte, value depending on field
	            	
	                if (numValues == 1) {
	                    return getUint8Wrap(file, entryOffset + 8, !bigEnd);
	                } else {
	                    offset = numValues > 4 ? valueOffset : (entryOffset + 8);
	                    vals = [];
	                    if((offset + numValues) < file.byteLength){
		                    for (n=0;n<numValues ;n++) {
		                        vals[n] = getUint8Wrap(file, offset + n);
		                    }
	                    }
	                    return vals;
	                }

	            case 2: // ascii, 8-bit byte
	            	
	                offset = numValues > 4 ? valueOffset : (entryOffset + 8);
	                return getStringFromDB(file, offset, numValues-1);

	            case 3: // short, 16 bit int
	            	
	                if (numValues == 1) {
	                    return getUint16Wrap(file, entryOffset + 8, !bigEnd);
	                } else {
	                    offset = numValues > 2 ? valueOffset : (entryOffset + 8);
	                    vals = [];
	                    if((offset + (2*numValues)) < file.byteLength){
	                    	for (n=0;n<numValues;n++) {
	                        	vals[n] = getUint16Wrap(file, offset + 2*n, !bigEnd);
	                    	}
	                    }
	                    
	                    return vals;
	                }

	            case 4: // long, 32 bit int
	            	
	                if (numValues == 1) {
	                    return getUint32Wrap(file, entryOffset + 8, !bigEnd);
	                } else {
	                    vals = [];
	                    if( (valueOffset + (4*numValues)) < file.byteLength ){
							for (n=0;n<numValues;n++) {
	                        	vals[n] = getUint32Wrap(file, valueOffset + 4*n, !bigEnd);
	                    	}
	                    }
	                    return vals;
	                }

	            case 5:    // rational = two long values, first is numerator, second is denominator
	            	
	                if (numValues == 1) {
	                    numerator = getUint32Wrap(file, valueOffset, !bigEnd);
	                    denominator = getUint32Wrap(file, valueOffset+4, !bigEnd);
	                    val = new Number(numerator / denominator);
	                    val.numerator = numerator;
	                    val.denominator = denominator;
	                    return val;
	                } else {
	                    vals = [];
	                    if(  ((valueOffset+  4) + 8*numValues) <  file.byteLength ){
		                    for (n=0;n<numValues ;n++) {
		                        numerator = getUint32Wrap(file, valueOffset + 8*n, !bigEnd);
		                        denominator = getUint32Wrap(file, valueOffset+4 + 8*n, !bigEnd);
		                        vals[n] = new Number(numerator / denominator);
		                        vals[n].numerator = numerator;
		                        vals[n].denominator = denominator;
		                    }
	                	}
	                    return vals;
	                }

	            case 9: // slong, 32 bit signed int
	            	
	                if (numValues == 1) {
	                    return getUint32Wrap(file, entryOffset + 8, !bigEnd);
	                } else {
	                    vals = [];
	                    if((valueOffset + 4*numValues) < file.byteLength){
		                    for (n=0;n<numValues;n++) {
		                        vals[n] = getUint32Wrap(file, valueOffset + 4*n, !bigEnd);
		                    }
	                    }
	                    return vals;
	                }

	            case 10: // signed rational, two slongs, first is numerator, second is denominator
	            	
	                if (numValues == 1) {
	                    return getUint32Wrap(file, valueOffset, !bigEnd) / file.getInt32(valueOffset+4, !bigEnd);
	                } else {
	                    vals = [];
	                    if((valueOffset + 8*numValues) < file.byteLength){
		                    for (n=0;n<numValues;n++) {
		                        vals[n] = getUint32Wrap(file, valueOffset + 8*n, !bigEnd) / file.getInt32(valueOffset+4 + 8*n, !bigEnd);
		                    }
	                    }
	                    return vals;
	                }
	        }
	    }

	    function getNextIFDOffset(dataView, dirStart, bigEnd){
	        //the first 2bytes means the number of directory entries contains in this IFD
	        var entries = getUint32Wrap(dataView, dirStart, !bigEnd);

	        // After last directory entry, there is a 4bytes of data,
	        // it means an offset to next IFD.
	        // If its value is '0x00000000', it means this is the last IFD and there is no linked IFD.

	        return getUint32Wrap(dataView, dirStart + 2 + entries * 12, !bigEnd); // each entry is 12 bytes long
	    }

	    function readThumbnailImage(dataView, tiffStart, firstIFDOffset, bigEnd){
	        // get the IFD1 offset
	        var IFD1OffsetPointer = getNextIFDOffset(dataView, tiffStart+firstIFDOffset, bigEnd);

	        if (!IFD1OffsetPointer) {
	            debug && console.log('IFD1Offset is empty, image thumb not found');
	            return {};
	        }
	        else if (IFD1OffsetPointer > dataView.byteLength) { // this should not happen
	            debug && console.log('IFD1Offset is outside the bounds of the DataView');
	            return {};
	        }
	        debug && console.log('thumbnail IFD offset (IFD1) is: %s', IFD1OffsetPointer);
	        
	        var thumbTags = readTags(dataView, tiffStart, tiffStart + IFD1OffsetPointer, IFD1Tags, bigEnd),
	        compressionProp = 'Compression', pIProp = 'PhotometricInterpretation';

	        // EXIF 2.3 specification for JPEG format thumbnail

	        // If the value of Compression(0x0103) Tag in IFD1 is '6', thumbnail image format is JPEG.

	        if (thumbTags[compressionProp]) {
	            debug && console.log('Thumbnail image found!');

	            switch (thumbTags[compressionProp]) {
	                case 6:
	                    debug && console.log('Thumbnail image format is JPEG');
	                    if (thumbTags.JpegIFOffset && thumbTags.JpegIFByteCount) {
	                    // extract the thumbnail
	                        var tOffset = tiffStart + thumbTags.JpegIFOffset;
	                        var tLength = thumbTags.JpegIFByteCount, blobProp = 'blob';
	                        thumbTags[blobProp] = new window.Blob([new window.Uint8Array(dataView.buffer, tOffset, tLength)], {
	                            type: 'image/jpeg'
	                        });
	                    }
	                break;

	            case 1:
	                console.log("Thumbnail image format is TIFF, which is not implemented.");
	                break;
	            default:
	                console.log("Unknown thumbnail image format '%s'", thumbTags[compressionProp]);
	            }
	        }
	        else if (thumbTags[pIProp] == 2) {
	            console.log("Thumbnail image format is RGB, which is not implemented.");
	        }
	        return thumbTags;
	    }

	    function getStringFromDB(buffer, start, length) {
	        var outstr = "";
	        if((start+length) < buffer.byteLength){
		        for (var n = start; n < start+length; n++) {
		            outstr += String.fromCharCode(getUint8Wrap(buffer, n));
		        }
	        }
	        return outstr;
	    }

	    function readExifData(file, start) {
	    	
	        if (getStringFromDB(file, start, 4) != "Exif") {
	            debug && console.log("Not valid EXIF data! " + getStringFromDB(file, start, 4));
	            return false;
	        }

	        var bigEnd,
	            tags, tag,
	            exifData, gpsData, thumbnailProp = 'thumbnail'
	            window.tiffOffset = start + 6;

	        // test for TIFF validity and endianness
	        if (getUint16Wrap(file, tiffOffset) == 0x4949) {
	            bigEnd = false;
	        } else if (getUint16Wrap(file, tiffOffset) == 0x4D4D) {
	            bigEnd = true;
	        } else {
	            debug && console.log("Not valid TIFF data! (no 0x4949 or 0x4D4D)");
	            return false;
	        }

	        if (getUint16Wrap(file, tiffOffset+2, !bigEnd) != 0x002A) {
	            debug && console.log("Not valid TIFF data! (no 0x002A)");
	            return false;
	        }

	        var firstIFDOffset = getUint32Wrap(file, tiffOffset+4, !bigEnd);

	        if (firstIFDOffset < 0x00000008) {
	            debug && console.log("Not valid TIFF data! (First offset less than 8)", getUint32Wrap(file, tiffOffset+4, !bigEnd));
	            return false;
	        }
	        
	        tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, TiffTags, bigEnd);

	        if (tags.ExifIFDPointer) {
	            exifData = readTags(file, tiffOffset, tiffOffset + tags.ExifIFDPointer, ExifTags, bigEnd);
	            for (tag in exifData) {
	                switch (tag) {
	                    case "LightSource" :
	                    case "Flash" :
	                    case "MeteringMode" :
	                    case "ExposureProgram" :
	                    case "SensingMethod" :
	                    case "SceneCaptureType" :
	                    case "SceneType" :
	                    case "CustomRendered" :
	                    case "WhiteBalance" :
	                    case "GainControl" :
	                    case "Contrast" :
	                    case "Saturation" :
	                    case "Sharpness" :
	                    case "SubjectDistanceRange" :
	                    case "FileSource" :
	                        exifData[tag] = StringValues[tag][exifData[tag]];
	                        break;

	                    case "ExifVersion" :
	                    case "FlashpixVersion" :
	                        exifData[tag] = String.fromCharCode(exifData[tag][0], exifData[tag][1], exifData[tag][2], exifData[tag][3]);
	                        break;

	                    case "ComponentsConfiguration" :
	                        exifData[tag] =
	                            StringValues.Components[exifData[tag][0]] +
	                            StringValues.Components[exifData[tag][1]] +
	                            StringValues.Components[exifData[tag][2]] +
	                            StringValues.Components[exifData[tag][3]];
	                        break;
	                }
	                tags[tag] = exifData[tag];
	            }
	        }

	        if (tags.GPSInfoIFDPointer) {
	            gpsData = readTags(file, tiffOffset, tiffOffset + tags.GPSInfoIFDPointer, GPSTags, bigEnd);
	            for (tag in gpsData) {
	                switch (tag) {
	                    case "GPSVersionID" :
	                        gpsData[tag] = gpsData[tag][0] +
	                            "." + gpsData[tag][1] +
	                            "." + gpsData[tag][2] +
	                            "." + gpsData[tag][3];
	                        break;
	                }
	                tags[tag] = gpsData[tag];
	            }
	        }

	        // extract thumbnail
	        tags[thumbnailProp] = readThumbnailImage(file, tiffOffset, firstIFDOffset, bigEnd);

	        return tags;
	    }

	    function getUint8Wrap(file , offset , littleEndian){
	    	if(file.byteLength <= (offset )){
	    		return 0;
	    	}
	    	return file.getUint8(offset, littleEndian);
		}

		function getUint16Wrap(file , offset , littleEndian){
	    	if((file.byteLength-2) <= (offset )){
	    		return 0;
	    	}
	    	return file.getUint16(offset, littleEndian);
		}

		function getUint32Wrap(file , offset , littleEndian){
	    	if((file.byteLength-4) <= (offset )){
	    		return 0 ;
	    	}
	    	return file.getUint32(offset, littleEndian);
		}

	}
} )
;( function( cb ){
	if( typeof define == "function" && define.amd ){
		define( [ "@zoho/lyte-dom" ], cb );
	} else {
		cb( window.$L );
	}
} )( function( $L ){
	if( $L ){

		function getScope( elem, scope ){
			var data = elem._finddata;
			scope = data.dynamicScope ? data.dynamicScope( elem ) : scope;
			if( data.checkFromParent ){
			scope = elem.parentNode;
			}
			return scope;
		}

		function switchfn( text, value, method ){
			var flag
			switch( ( method || "" ).toLowerCase() ){
				case 'startswith' : {
					flag = text.indexOf( value ) == 0;
					break;
				}
				case 'endswith' : {
					var idx = text.lastIndexOf( value );
					if( idx != -1 ){
						flag = idx + value.length == text.length;
					}
					break;
				}
				default : {
					flag = text.indexOf( value ) != -1;
				}
			}
			return flag;
		}

		function treecheck( visible, hidden, scope, value, data ){
			var rgx1 = new RegExp( '(' + ( value || '' ).replace( /(\\|\'|\"|\?|\^|\$|\.|\||\*|\+|\(|\)|\[|\]|\{|\})/g,  '\\$1' ) + ')', 'ig' ),
			rgx2 = /(?!>)([^><]+)(?=<)/ig;
			for( var i = 0; i < visible.length; i++ ){
				var vis = $L( visible[ i ] ).closest( 'lyte-tree' )[ 0 ];
				for( var j = 0; j < hidden.length; j++ ){
					var hid = $L( hidden[ j ] ).closest( 'lyte-tree' )[ 0 ];
					if( vis == hid || hid.contains( vis ) ){
						data.highlight && hide( hidden[ j ] )
						hidden.splice( j, 1 );
						j--;
					}
				}
			}
			for( var i = 0; i < visible.length; i++ ){
				value.length && data.highlight && highlightnode( visible[ i ], value, data, rgx1, rgx2 );
				value.length && scope.ltProp( 'stateAttr', $L( visible[ i ] ).closest( 'lyte-tree' ).attr( 'temp-var' ) )
			}
			for( var i = 0; i < hidden.length; i++ ){
				hide( hidden[ i ] )
				if( value.length ){
					var inn = $L( 'lyte-yield:not(.noChildClass) lyte-tree-icon', $L( hidden[ i ]  ).closest( 'lyte-tree' ).parent() ).eq( 0 );
					inn.hasClass( 'lyteIconOpened' ) && inn.click();
				}
			}
			if( !value.length ) {
				closealltree.call( this, scope )
			}
		}

		function closealltree( scope ){
			var icons = $L( 'lyte-yield:not(.noChildClass) lyte-tree-icon', scope );
			for( var i = icons.length - 1; i >= 0; i-- ){
				var cur = icons.eq( i );
				cur.hasClass( 'lyteIconOpened' ) && cur.click();
			}
		}

		function highlightnode( element, value, data, rgx1 ){

			var exspan = element._findelement,
			cloned_element = element.cloneNode( true ),
			first_time;

			$L( element ).addClass( 'lyteSearchHidden' );

			cloned_element.normalize();

			if( !exspan ){
				var allow_attrs = data.keepAttributes;

				exspan = $L( allow_attrs ? cloned_element : document.createElement( element.tagName ) ).addClass( 'lyteHighlightdiv' ).get( 0 );
				window._lyteUiUtils.insertAfter( element, exspan );

				element._findelement = exspan;
				exspan._originalelement = element;

				if( allow_attrs ){
					first_time = 1;
				}
			}

			exspan.style.display = '';

			convertString( Array.from( cloned_element.childNodes ), value, data );

			if( first_time ){
				return;
			}

			var __child = Array.from( cloned_element.childNodes );

			exspan.innerHTML = '';

			__child.forEach( function( item ){
				exspan.appendChild( item );
			});
		}

		function convertString( nodes, value, data ){
			var str = '';
			nodes.forEach( function( item ){
				var tag = item.tagName || '';
				if( /^template$/i.test( tag ) ){
					item.remove();
				} else if( tag ){
					convertString( Array.from( item.childNodes ), value, data );
				} else {
					var str = item.nodeValue,
					lower = str.toLowerCase(),
					index = lower.indexOf( value ),
					is_modified,
					ref = item;

					while( index != -1 ){
						var first = str.slice( 0, index ),
						limit = index + value.length,
						second = str.slice( index, limit ),
						third = str.slice( limit ),
						is_modified = true;

						if( first ){
							var node = document.createTextNode( first );
							_lyteUiUtils.insertAfter( ref, ref = node );
						}

						var node = $L( document.createElement( 'span' ) ).addClass( 'lyteFindHighlight '+ ( data.highlightclass || '' ) ).get( 0 );
						node.textContent = second;

						_lyteUiUtils.insertAfter( ref, ref = node );
						str = third;
						lower = str.toLowerCase();
						index = lower.indexOf( value );
					}

					if( is_modified ){
						if( str ){
							var node = document.createTextNode( str );
							_lyteUiUtils.insertAfter( ref, node );
						}
						item.remove();
					}
				}
			});
		}

		function hide( elem ){
			$L( elem ).removeClass( 'lyteSearchHidden' );
			$L( elem._findelement ).css( 'display', 'none' );
		}

		function acccheck( visible, hidden, scope, value, data ){
			// var rgx1 = new RegExp( '(' + ( value || '' ).replace( /(\\|\'|\"|\?|\^|\$|\.|\||\*|\+|\(|\)|\[|\]|\{|\})/g,  '\\$1' ) + ')', 'ig' ),
			// rgx2 = /(?!>)([^><]+)(?=<)/ig, 

			var exs = scope.ltProp( 'exclusive' );

			for( var i = 0; i < visible.length; i++ ){
				for( var j = 0; j < hidden.length; j++ ){
					if( $L( hidden[ j ] ).closest( 'lyte-accordion-item' ).is( $L( visible[ i ] ).closest( 'lyte-accordion-item' ) ) ){
						data.highlight && hide( hidden[ j ] );
						hidden.splice( j, 1 );
						j--; continue;
					}
				}
				if( visible[ i + 1 ] ){
					if( $L( visible[ i ] ).closest( 'lyte-accordion-item' ).is( $L( visible[ i + 1 ] ).closest( 'lyte-accordion-item' ) ) ){
						value.length && data.highlight && highlightnode( visible[ i + 1 ], value, data/*, rgx1, rgx2*/ );
					}
				}
				value.length && data.highlight && highlightnode( visible[ i ], value, data/*, rgx1, rgx2*/ )
			}

			for( var i = 0; i < visible.length; i++ ){
				!value.length && hide( visible[ i ] );
				var close = $L( visible[ i ] ).closest( 'lyte-accordion-item ', scope )
				if( !close.hasClass( 'lyteAccordionActive' ) ){
					if( exs && i != visible.length - 1 ){
						continue;
					}
					value && close.click()
				} else if( !value ){
					close.click();
				}
			}

			for( var i = 0; i < hidden.length; i++ ){
				data.highlight && hide( hidden[ i ] );
				$L( hidden[ i ] ).closest( 'lyte-accordion-item.lyteAccordionActive' , scope ).click()
			}
			
		}

		function commonCheck( visible, hidden, scope, value, data ){
			var rgx1 = new RegExp( '(' + ( value || '' ).replace( /(\\|\'|\"|\?|\^|\$|\.|\||\*|\+|\(|\)|\[|\]|\{|\})/g,  '\\$1' ) + ')', 'ig' ),
			rgx2 = /(?!>)([^><]+)(?=<)/ig;

			if( value.length ){
				for( var i = 0; i < visible.length; i++ ){
					data.highlight && highlightnode( visible[ i ], value, data, rgx1, rgx2 );
				}
			}

			for( var i = 0; i < hidden.length; i++ ) {
				data.highlight && hide( hidden[ i ] );
			}

			if( !value.length ){
				for( var i = 0; i < visible.length; i++ ){
					data.highlight && hide( visible[ i ] );
				}
			}

		}

		function processing( evt ){
			var data = this._finddata,
			scope = $L( getScope( this, data.scope ) )[ 0 ],
			comp = data.component,
			search = $L( data.search || data.target, scope ),
			method = data.method,
			value = ( this.tagName != "LYTE-INPUT" ? this.value : this.querySelector( 'input,textarea' ).value ).toLowerCase(), text = [], visible = [], hidden = [];
			if( data.trim ){
				value = value.trim();
			}
			for( var i = 0; i < search.length; i++ ){
				if( search.eq( i ).hasClass( 'lyteHighlightdiv' ) ){
					continue;
				}
				if( switchfn( search[ i ].textContent.trim().toLowerCase(), value, method ) ){
					visible.push( search[ i ] )
				} else {
					hidden.push( search[ i ] )
				}	
			}
			if( data.onSearch && data.onSearch.call( this, visible, hidden, evt, value, this ) == false ){
				return;
			}
			( comp == 'tree' && treecheck.call( this, visible, hidden, scope, value, data ) ) || ( comp == "accordion" && acccheck.call( this, visible, hidden, scope, value, data ) ) || ( comp == undefined && commonCheck.call( this, visible, hidden, scope, value, data ) );
		}

		function eventFunc( evt ){
			clearTimeout( this._timeout );
			this._timeout = setTimeout( processing.bind( this, evt ), 250 );
		}

		function setValue( value ){
			if( this.tagName != "LYTE-INPUT" ){
				this.value = value;
			} else{
				this.ltProp( 'value', value );
			}
			eventFunc.call( this, {} ); 
		}

		$L.prototype.lytefind = function( data ){
			data = data || {};
			data.highlight = data.highlight != undefined ? data.highlight : true;
			var current = this.get( 0 );
			if( current._finddata ){
				this.eq( 0 ).removefind();
			}
			current._finddata = data;
			current.setValueForFind = current.setValue = setValue.bind( current );
			// current.resetValue = setValue.bind( current );
			current.addEventListener( 'input', eventFunc );
			return this;
		}

		$L.prototype.removefind = function(){
			for( var i = 0; i < this.length; i++ ){
				var cur = this[ i ];
				if( cur._finddata ){
					var spans = $L( '.lyteHighlightdiv', getScope( cur, cur._finddata.scope ) ),
					_length = spans.length;
					
					for( var j = 0; j < _length; j++ ){
						// $L( spans[ j ] ).parent().children( '.lyteSearchHidden' ).removeClass( 'lyteSearchHidden' );
						var current = spans[ j ];
						if( current._originalelement ){
							$L( current._originalelement ).removeClass( 'lyteSearchHidden' );
							delete current._originalelement._findelement;
							delete current._originalelement;
						}
						current.remove();
					} 
					clearTimeout( cur._timeout );
					cur.removeEventListener( 'input', eventFunc );
					delete cur._finddata; delete cur._timeout; delete cur.setValue; delete cur.setValueForFind;
					// delete cur.resetValue;
				}
			}
			return this;
		}
 	}
} ); 
( function( factory ) {
	if( typeof define === "function" && define.amd ) {
        define( [ "@zoho/lyte-dom" ], factory );
    }
    else {
        factory( $L );
    }
} )( function( $L ) {

	/** Think about the from = 'italics' problem that you faced and fix that
	We removed a condition which would normally convert a italics symbol into a text
	refer the other types to get a better understanding
	**/

	if( $L.markdown ) {
		return ;
	}

	var reg_sinks = {
		// 'text': /[a-zA-Z]/i,
		'line_break': /(\n|\r\n|\r)/,
		'special': /[*#\-_~!`()\\\[\]\.|"]/,
		'spl_except_forw_slsh': /[*#\-_~!`()\[\]\.|"]|^www|^https:|^http:/,
		'space': /[ ]/,
		'number': /\d/
	};

	var typeMap = {
		'b': 'bold',
		'i': 'italics',
		'u': 'underline',
		's': 'strike',
		'div': 'para',
		'table': 'table',
		'thead': 'thead',
		'tbody': 'tbody',
		'tr': 'tr',
		'td': 'td',
		'th': 'th',
		'img': 'image',
		'a': 'hyperlink',
		'ul': 'ul',
		'ol': 'ol',
		'li': 'li',
		'mark': 'mark',
		'blockquote': 'blockquote',
		'h1': 'h1',
		'h2': 'h2',
		'h3': 'h3',
		'h4': 'h4',
		'h5': 'h5'
	};

	function flushBuf( buf ) {
		var ret = buf.flush();

		if( ret ) {
			return new token( ret, 'text' );	
		}
	}

	function token( value, type ) {
		var obj = {
			value: value,
			type: type
		};

		this.get = function( name ) {
			return obj[ name ] || '';
		}

		return this;
	}

	function buffer() {
		var buffer = [];

		this.push = function( char ) {
			buffer.push( char );
		}

		this.flush = function() {
			var temp = buffer;

			buffer = [];

			return temp.join( "" );
		}
	}

	function tokenList() {
		var tokens = [],
		pointer = 0;

		this.push = function( token ) {
			if( token ) {
				tokens.push( token );
			}
		}

		this.peek = function() {
			return tokens[ pointer ] || new token();
		}

		this.peekback = function() {
			return tokens[ pointer - 1 ] || new token();
		}

		this.peekbacktwice = function() {
			return tokens[ pointer - 2 ] || new token();
		}

		this.eat = function() {
			return tokens[ pointer++ ] || new token();
		}

		this.pointer = function( num ) {
			return !isNaN( num ) ? ( pointer = num ) : pointer;
		}

		this.moveback = function() {
			pointer--;
		}

		/* probably not this guy */		
		this.flush = function() {
			pointer = 0;
			tokens = [];
		}
	}

	function stack() {
		var stack = [];

		this.push = function( val ) {
			stack.push( val );

			return val;
		}

		this.pop = function() {
			stack.pop();
		}

		this.callStackContains = function( val ) {
			return !!~stack.indexOf( val );
		}

		this.isEmpty = function() {
			return stack.length === 0;
		}
	}

	function isSpace( char ) {
		return reg_sinks.space.test( char );
	}

	function isLineBreak( char ) {
		return reg_sinks.line_break.test( char );
	}

	// function isText( char ) {
	// 	return reg_sinks.text.test( char );
	// }

	function isSpecial( char ) {
		return char.match( reg_sinks.special );
	}

	function lex( text ) {
		var i = 0, length = text.length,
		buf = new buffer(), char, ret, _special, 
		list = new tokenList();

		for( ; i < length; i++ ) {
			char = text.charAt( i );

			if( isLineBreak( char ) ) {
				list.push( flushBuf( buf ) );
				list.push( new token( char, 'line_break' ) );
			}
			else if( ( _special = isSpecial( char ) ) ) {
				list.push( flushBuf( buf ) );
				list.push( new token( char, 'special' + _special[ 0 ] ) );
			}
			else if( isSpace( char ) ) {
				list.push( flushBuf( buf ) );
				list.push( new token( char, 'space' ) );
			} 
			else {
				buf.push( char );
			}
		}

		list.push( flushBuf( buf ) );

		return list;
	}


	// Node can either be a text or a node
	function getText( node ) {
		var text;

		if( typeof node !== 'string' ) {
			text = $L._lyteHTMLToText( node );
		}
		else {
			text = node;
		}

		return text;
	}

	/* The buildConfig is used to create a closure variable(an interface) which can be used to access the individual properties */
	/* 
	For now we are returning all attributes in a config but there can be a case where one of the attributes is a tagname instead of an
	attribute 
	*/
	function buildConfig( totalConfiguration ) {
		var attributes = [ 
						'bold', 'italics', 'strike', 'underline', 'blockquote', 'mark',
						'para',  
						'hyperlink', 'image', 
						'header', 'h1', 'h2', 'h3', 'h4', 'h5',
						'ol', 'ul', 'li',
						'table', 'thead', 'tbody', 'tr', 'th', 'td' ],

		configs = {};

		totalConfiguration = totalConfiguration || {};

		attributes.forEach( function( item ) {
			configs[ item ] = new config( totalConfiguration[ item ] );
		} );

		return {
			getAllAttributes: function( configName ) {
				return configs[ configName ].getAllAttributes();
			},

			getAttribute: function( configName, attributeName ) {
				return configs[ configName ].getAttribute( attributeName ) || '';
			}
		};
	}

	function config( config ) {
		var configStore = config || {};

		this.getAttribute = function( name ) {
			return configStore[ name ];
		}

		this.getAllAttributes = function() {
			return configStore;
		}

		return this;
	}

	function _rDP( list, totalConfiguration ) {
		var cs = new stack(),
		userConfig = buildConfig( totalConfiguration ),
		isTableCell, onBeforeAppend = ( totalConfiguration || {} ).onBeforeAppend;

		function join( high, low ) {
			var obj = {};

			$L.extend( obj, low );
			$L.extend( obj, high );

			return obj;
		}

		function addAllAttributes( node, configName ) {
			var attributes, key,
			domObj = $L( node );

			if( !!~[ 'h1', 'h2', 'h3', 'h4', 'h5' ].indexOf( configName ) ) {
				attributes = join( userConfig.getAllAttributes( configName ), userConfig.getAllAttributes( 'header' ) );
			}
			else {
				attributes = userConfig.getAllAttributes( configName );
			}

			for( key in attributes ) {
				if( key !== 'ltPropPreventSecurityPrefix'){
					domObj.attr( key, attributes[ key ] );
				}

			}
		}

		function checkForSecurityPrefix( ) {
			var shouldPrevent = userConfig.getAttribute( 'hyperlink', 'ltPropPreventSecurityPrefix' );

			return shouldPrevent === true;
		}


		var capture = function() {
			return list.pointer();
		}

		var backtrack = function( val ) {
			list.pointer( val );
		}

		var isEmpty = function( frag ) {
			if( typeof frag === 'boolean' ) {
				return true;
			}

			// Added a fix for IE where you have to trim the textContent or else its flags empty fragments as non empty
			return !frag.querySelector( '*' ) && !frag.textContent.trim();
		}

		var buildHeader = function() {
			var count = 0, header;

			count = findHeaders();

			if( count <= 5 
				&& (
					( !shouldConsiderWhiteSpace() && !isWhiteSpace() ) 
					|| ( shouldConsiderWhiteSpace() && isWhiteSpace( list.eat() ) )
				)
				&& hasTextualCharacter() 
			) {

				header = document.createElement( 'h' + count );
				addAllAttributes( header, 'h' + count );
				para( header );

				return header;
			}
		}

		var shouldConsiderWhiteSpace = function() {
			return !userConfig.getAttribute( 'header', 'ignoreWhiteSpaceJoiner' );
		}

		var hasTextualCharacter = function() {
			var mem = capture();

			while( !endOfLine() ) {
				if( !isWhiteSpace() ) {
					backtrack( mem );

					return true;
				}

				list.eat();
			}

			backtrack( mem );

			return false;
		} 

		var findHeaders = function() {
			var count = 0;

			while( list.peek().get( 'type' ) === 'special#' ) {
				count++;
				list.eat();
			}

			return count;
		}

		var buildQuote = function() {
			var quote;

			if( hasTextualCharacter() ) {
				quote = document.createElement( 'blockquote' );
				addAllAttributes( quote, 'blockquote' );
				para( quote );

				return quote;
			}
			
		}

		var getType = function( tag ) {
			return typeMap[ tag ];
		}

		var getElementToAppend = function( element ) {
			var tag = element.tagName.toLowerCase(),
			type = getType( tag ), ret;

			if( onBeforeAppend ) {
				ret = onBeforeAppend.call( window, element, type );
			}

			return ret ? ret : element;
		}

		var appendElement = function( parent, child ) {
			if( !parent || !child ) {
				return ;
			}

			var nodeType = child.nodeType;

			if( nodeType === 1 ) {
				child = getElementToAppend( child );	
			}
			
			parent.appendChild( child );
		}

		var buildMarkdown = function() {
			var div = document.createElement( 'div' ), ret;

			while( list.peek().get( 'type' ) !== '' ) {
				ret = buildBasedOnFirstCharacter() || document.createDocumentFragment();

				// Eating the last line line_break in para
				if( list.peek().get( 'type' ) === 'line_break' ) {
					list.eat();
				}

				appendElement( div, ret );
			}

			return div;
		}

		var buildBasedOnFirstCharacter = function() {
			var p = document.createElement( 'div' ), 
			children, mem, header, quote, table, ret, token;

			addAllAttributes( p, 'para' );
			mem = capture();

			if( isStartOfHeader() ) {
				mem = capture();
				ret = buildHeader();

				if( ret ) {
					appendElement( p, ret );
				}
				else {
					backtrack( mem );
					para( p );
				}
			}

			else if( isQuoteStart() ) {
				token = list.eat();
				window.token_aft = list.peek();
				mem = capture();
				ret = getImage();

				if( ret ) {
					appendElement( p, ret );

					// Image should use para
					para( p );
				}
				else {
					backtrack( mem );
					ret = buildQuote();

					if( ret ) {
						// This guy doesn't need para
						appendElement( p, ret );
					}
					else {
						backtrack( mem );
						consumeCharacter( p, token, token_aft );
						para( p );
					}
				}
			}

			else if( isOrderedListStart() ) {
				// Need to fix this
				appendElement( p, buildOrderedList() );
			}

			else if( isUnorderedListStart() ) {
				// Need to fix this
				appendElement( p, buildUnorderedList() );
			}

			else if( isTableStart() ) {
				table = buildTable();

				if( table ) {
					appendElement( p, table );
					list.moveback();
				}
				else {
					backtrack( mem );
					para( p );
				}
			}
			else {
				backtrack( mem );
				para( p );
			}

			return p;

		}

		var isStartOfHeader = function() {
			var mem = capture();

			consumeLeadingWhiteSpaces();

			if( list.peek().get( 'type' ) === 'special#' ) {
				return true;
			}
			else {
				backtrack( mem );

				return false;
			}
		}

		var isQuoteStart = function() {
			var mem = capture();

			consumeLeadingWhiteSpaces();

			if( isImageStart() ) {
				return true;
			}
			else {
				backtrack( mem );

				return false;
			}
		}

		var consumeLeadingWhiteSpaces = function() {
			while( isWhiteSpace() ) {
				list.eat();
			}
		}

		var isTableStart = function() {
			var mem = capture(), token,
			type;

			consumeLeadingWhiteSpaces();

			token = list.peek(),
			type = token.get( 'type' )

			if( type === 'special|' ) {
				return true;
			}
			else {
				backtrack( mem );

				return false;
			}
		}

		var buildTable = function() {
			var table = document.createElement( 'table' ),
			tableHeader = getTableHeader(),
			tableRow, isProperSyntax;

			if( !tableHeader ) {
				return false;
			}

			isProperSyntax = consumeHeaderFooter( tableHeader.column_count );

			if( !isProperSyntax ) {
				return false;
			}

			appendElement( table, tableHeader.header );
			isProperSyntax = buildTableBody( tableHeader.column_count );

			if( !isProperSyntax ) {
				return false;
			}

			appendElement( table, isProperSyntax );
			addAllAttributes( table, 'table' );

			return table;
		}

		var buildTableBody = function( column_count ) {
			var tableRow, body = document.createElement( 'tbody' );

			while( isValidRow( buildLine() ) ) {
				tableRow = getTableRow( column_count );

				if( !tableRow ) {
					return false;
				}

				appendElement( body, tableRow );
			}

			if( body.children.length === 0 ) {
				return false;
			}

			addAllAttributes( body, 'tbody' );

			return body;
		}

		var buildLine = function() {
			var mem = capture(),
			res = '';

			while( !endOfLine() ) {
				res = res + list.eat().get( 'value' );
			}

			backtrack( mem );

			return res;
		}

		var isValidRow = function( res ) {
			return !!~res.indexOf( '|' )
		}

		var getTableRow = function( column_count ) {
			var row = document.createElement( 'tr' ), cell,
			mem = capture(), currentColumnCount = 0;

			consumeLeadingWhiteSpaces();

			while( list.eat().get( 'type' ) === 'special|' ) {
				cell = buildCell();

				if( cell ) {
					currentColumnCount++;
					appendElement( row, cell );
				}
			}

			if( currentColumnCount < column_count ) {
				addRemainingColumns( row, currentColumnCount, column_count );
			}

			if( currentColumnCount > column_count ) {
				return false;
			}

			addAllAttributes( row, 'tr' );

			return row;

		}

		var addRemainingColumns = function( row, cur, max ) {
			var cell;

			for( var i = cur; i < max; i++ ) {
				cell = document.createElement( 'td' );
				appendElement( row, cell );
				addAllAttributes( cell, 'td' );
			}
		}

		var buildCell = function() {
			var frag = document.createDocumentFragment(),
			cell = document.createElement( 'td' );

			isTableCell = true;
			para( frag );
			isTableCell = false;
			trimFragment( frag );

			if( isEmpty( frag ) ) {
				return false;
			}

			cell.appendChild( frag );
			addAllAttributes( cell, 'td' );

			return cell;
		}

		var trimFragment = function( frag ) {
			trimLeadingSpaces( frag );
			trimTrailingSpaces( frag );
		}

		var trimLeadingSpaces = function( frag ) {
			var firstNode = frag.childNodes[ 0 ], 
			value, rLeadingSpace = /^\s+/g;

			if( firstNode 
				&& firstNode.nodeType === 3 
			) {
				value = firstNode.nodeValue;
				value = value.replace( rLeadingSpace, '' );
				firstNode.nodeValue = value;
			}
		}

		var trimTrailingSpaces = function( frag ) {
			var length = frag.childNodes.length,
			lastNode = frag.childNodes[ length - 1 ],
			value, rTrailingSpace = /\s+$/g;

			if( lastNode 
				&& lastNode.nodeType === 3 
			) {
				value = lastNode.nodeValue;
				value = value.replace( rTrailingSpace, '' );
				lastNode.nodeValue = value;
			}
		}

		var consumeHeaderFooter = function( column_count ) {
			var columnCount = 0, hasNonTrailingCharacters;

			consumeLeadingWhiteSpaces();

			while( !endOfLine() ) {

				if( trailingCharacter() ) {
					break;
				}

				if( list.peek().get( 'type' ) !== 'special|' && list.peek().get( 'type' ) !== 'special-' ) {
					return false;
				}

				if( list.eat().get( 'type' ) === 'special|' && list.peek().get( 'type' ) === 'special-' ) {
					columnCount++;
				}
			}

			hasNonTrailingCharacters = consumeTrailingCharacters();

			if( hasNonTrailingCharacters ) {
				return false;
			}

			return columnCount === column_count;
		}

		var getTableHeader = function() {
			var header = document.createElement( 'thead' ),
			row = document.createElement( 'tr' ),
			column_count, head, hasNonTrailingCharacters;

			while( list.peek().get( 'type' ) === 'special|' ) {
				list.eat();
				head = buildHead();

				if( head ) {
					appendElement( row, head );
				}
			}

			column_count = row.children.length;

			if( column_count === 0 ) {
				return false;
			}
			
			appendElement( header, row );			
			hasNonTrailingCharacters = consumeTrailingCharacters();
			
			if( hasNonTrailingCharacters ) {
				return false;
			}

			addAllAttributes( header, 'thead' );
			addAllAttributes( row, 'tr' );

			return {
				column_count: column_count,
				header: header
			}
		}

		var buildHead = function() {
			var frag = document.createDocumentFragment(),
			headerCell = document.createElement( 'th' );

			isTableCell = true;
			para( frag );
			isTableCell = false;
			trimFragment( frag );

			if( isEmpty( frag ) ) {
				return false;
			}

			headerCell.appendChild( frag );
			addAllAttributes( headerCell, 'th' );

			return headerCell;
		}

		var endOfCell = function() {
			return list.peek().get( 'type' ) === 'special|' 
				|| list.peek().get( 'type' ) === 'line_break' 
				|| list.peek().get( 'type' ) === ''
		}

		var consumeTrailingCharacters = function() {
			while( !endOfLine() ) {
				if( !trailingCharacter() ) {
					return false;
				}

				list.eat();
			}

			list.eat();
		}

		var trailingCharacter = function() {
			return list.peek().get( 'type' ) === 'line_break' 
				|| list.peek().get( 'type' ) === '' 
				|| isWhiteSpace()
		}

		var endOfLine = function() {
			return list.peek().get( 'type' ) === 'line_break' || list.peek().get( 'type' ) === ''
		}

		var buildOrderedList = function() {
			var parent = document.createElement( 'ol' );

			do {
				appendElement( parent, buildListItem() );
				consumeTrailingCharacters();
			}while( isStartOfList() );

			addAllAttributes( parent, 'ol' );

			return parent;
		}

		var buildUnorderedList = function() {
			var parent = document.createElement( 'ul' );

			do {
				appendElement( parent, buildListItem() );
				consumeTrailingCharacters();
			}while( isStartOfList() );

			addAllAttributes( parent, 'ul' );

			return parent;
		}

		var buildListItem = function() {
			var item = document.createElement( 'li' ),
			frag = document.createDocumentFragment();

			para( frag );

			item.appendChild( frag );	

			return item;
		}

		var isStartOfList = function() {
			var mem = capture(),
			isListStart = isOrderedListStart() || ( backtrack( mem ), isUnorderedListStart() );

			if( !isListStart ) {
				backtrack( mem );
			}

			return isListStart;
		}

		var isOrderedListStart = function() {
			var mem = capture(), 
			token, value, type, isValidStart;

			consumeLeadingWhiteSpaces();

			token = list.eat();
			value = token.get( 'value' );
			type = token.get( 'type' );

			if( type === 'text' && !isNaN( value ) ) {
				isValidStart = list.eat().get( 'type' ) === 'special.' && list.eat().get( 'type' ) === 'space';
			}

			if( !isValidStart ) {
				backtrack( mem );
			}

			return isValidStart;
		}

		var isUnorderedListStart = function() {
			var mem = capture(), 
			token, value, type, isValidStart;

			consumeLeadingWhiteSpaces();

			token = list.eat();
			value = token.get( 'value' );
			type = token.get( 'type' );

			if( type === 'special*' || type === 'special-' ) {
				isValidStart = list.eat().get( 'type' ) === 'space';
			}

			if( !isValidStart ) {
				backtrack( mem );
			}

			return isValidStart;
		}

		var getEmphasisOrConsumeCharacter = function() {
			var value = list.peek().get( 'value' ), 

			// It can have text because bold, italics, strike and underline call it as well
			type = list.peek().get( 'type' ), frag, ret, mem;

			switch( value ) {
				case '*':
					if( cs.callStackContains( 'bold' ) ) {

						return true;
					}
					else if( !cs.callStackContains( 'bold' ) && ( mem = capture(), ret = bold() ) && !isEmpty( ret ) ) {
						return ret;
					}
					else {
						backtrack( mem );
						list.eat();
						ret = document.createTextNode( '*' );
						

						return ret;	
					}
					
				case '_': 
					mem = capture();

					if( isUnderLineStart() ) {
						backtrack( mem );

						if( cs.callStackContains( 'underline' ) ) {
							return true;
						}

						return buildUnderline();
					}
					else {
						backtrack( mem );

						if( cs.callStackContains( 'italics' ) ) {
							return true;
						}

						return buildItalics();
					}

				case '~':
					if( cs.callStackContains( 'strike' ) ) {

						return true;
					}
					else if( !cs.callStackContains( 'strike' ) && ( mem = capture(), ret = strike() ) && !isEmpty( ret ) ) {
						return ret;
					}
					else {
						backtrack( mem );
						list.eat();
						ret = document.createTextNode( '~' );
						

						return ret;	
					}

			}
		}

		var buildItalics = function() {
			var mem = capture(), ret;

			if( cs.callStackContains( 'italics' ) ) {

				return true;
			}
			else if( !cs.callStackContains( 'italics' ) && ( mem = capture(), ret = italics() ) && !isEmpty( ret ) ) {
				return ret;
			}
			else {
				backtrack( mem );
				list.eat();
				ret = document.createTextNode( '_' );
				

				return ret;	
			}
		}

		var buildUnderline = function() {
			var mem = capture(), ret;

			if( cs.callStackContains( 'underline' ) ) {

				return true;
			}
			else if( !cs.callStackContains( 'underline' ) && ( mem = capture(), ret = underline() ) && !isEmpty( ret ) ) {
				return ret;
			}
			else {
				backtrack( mem );
				list.eat();
				ret = document.createTextNode( '_' );
				

				return ret;	
			}
		}

		var isUnderLineStart = function() {
			var first = list.eat(),
			second = list.eat();

			return first.get( 'type' ) === 'special_' && second.get( 'type' ) === 'special_';
		}

		var italics = function() {
			var mem, frag, start, container;

			list.eat();
			mem = capture();
			cs.push( 'italics' );

			if( !isWhiteSpace()
				&& para( frag = document.createDocumentFragment() )
				&& !isWhiteSpace( list.peekback() )
				&& list.eat().get( 'type' ) === 'special_' 
			) {
				container = document.createDocumentFragment();
				container.appendChild( frag );
				cs.pop();

				return createItalics( container );
			}

			cs.pop();

			return false;

		}

		var underline = function() {
			var mem, frag, container;

			list.eat();
			list.eat();
			mem = capture();
			cs.push( 'underline' );

			if( !isWhiteSpace()
				&& para( frag = document.createDocumentFragment() )
				&& !isWhiteSpace( list.peekback() )
				&& list.eat().get( 'type' ) === 'special_'
				&& list.eat().get( 'type' ) === 'special_'
			) {
				container = document.createDocumentFragment();
				container.appendChild( frag );
				cs.pop();

				return createUnderline( container );
			}

			cs.pop();

			return false;
		}

		var bold = function() {
			var mem, frag, end, container;

			list.eat();
			mem = capture();
			cs.push( 'bold' );
			
			if( !isWhiteSpace()
				&& para( frag = document.createDocumentFragment() )
				&& !isWhiteSpace( list.peekback() )
				&& list.eat().get( 'type' ) === 'special*' 
			) {
				container = document.createDocumentFragment();
				container.appendChild( frag );
				cs.pop();

				return createBold( container );
			}

			cs.pop();

			return false;

		}

		var strike = function() {
			var mem, frag, end, container;

			list.eat();
			mem = capture();
			cs.push( 'strike' );
			
			if( !isWhiteSpace()
				&& para( frag = document.createDocumentFragment() )
				&& !isWhiteSpace( list.peekback() )
				&& list.eat().get( 'type' ) === 'special~' 
			) {
				container = document.createDocumentFragment();
				container.appendChild( frag );
				cs.pop();

				return createStrike( container );
			}

			cs.pop();

			return false;
		}


		var para = function( parent ) {
			var token = list.peek(), 
			ret, mem, char, code,
			type = token.get( 'type' );

			if( isURL() ) {
				mem = capture();
				ret = getURL();
				appendElement( parent, ret );
				processNextCharacter( parent );

				return ret;

			}

			// Found textual character
			if( isTextualCharacter() || isWhiteSpace() ) {
				ret = consumeText( parent );
				processNextCharacter( parent );

				return ret;
			}

			// Found a possible image
			else if( isImageStart() ) {
				token = list.eat();
				window.token_aft = list.peek();
				mem = capture();
				ret = getImage();

				if( ret ) {
					appendElement( parent, ret );
					processNextCharacter( parent );

					return ret;
				}
				else {
					backtrack( mem );			
					consumeCharacter( parent, token, token_aft );
					processNextCharacter( parent );

					return token.get( 'value' );
				}
			}
			
			// Found a possible emphasis token
			else if ( isEmphasis() ) {
				ret = getEmphasisOrConsumeCharacter();
				
				if( ret ) {
					if( typeof ret === 'object' ) {
						appendElement( parent, ret );
						processNextCharacter( parent );
					}
					
					return parent;
				}
			}

			// Found highlight character
			else if( isHighlight() ) {
				token = list.eat();
				window.token_aft = list.peek();
				mem = capture();
				ret = getHighlight();

				if( ret ) {
					appendElement( parent, ret );
					processNextCharacter( parent );

					return ret;
				}
				else {
					backtrack( mem );
					consumeCharacter( parent, token, token_aft );
					processNextCharacter( parent );

					return token.get( 'value' );
				}
			}

			// Found a link
			else if( isLink() ) {
				token = list.eat();
				window.token_aft = list.peek();
				mem = capture();
				ret = getLink();

				if( ret ) {
					appendElement( parent, ret );
					processNextCharacter( parent );

					return ret;
				}
				else {
					backtrack( mem );
					consumeCharacter( parent, token, token_aft );
					processNextCharacter( parent );

					return token.get( 'value' );
				}
			}

			// Found a line_break. End it.
			else if( delimiter() ) {
				return false;
			}
			
			
			// Found a weirdo. Consume weirdo as text.
			else if( !hasEnded( list ) ) {
				token = list.eat();
				window.token_aft = list.peek();
				mem = capture();
				consumeCharacter( parent, token, token_aft );
				processNextCharacter( parent );

				return token.get( 'value' );

			}

			if( hasEnded( list ) ) {
				return parent;
			}
		}

		var isURL = function() {
			var mem = capture(),
			token_bef = list.peekback(),
			token = list.eat(),
			value = token.get( 'value' ),
			type = token.get( 'type' ),
			nextToken = list.peek();

			backtrack( mem );

			return type === 'text' 
				&& ( 
					value.startsWith( 'htt' + 'ps://' ) 
					|| value.startsWith( 'htt' + 'p://' )
					|| ( 
						value.startsWith( 'www' ) 
						&& nextToken.get( 'type' ) === 'special.' 
					) 
				) && token_bef.get( 'value' ) !== '\\' ;
		}

		var getURL = function() {
			var href, text, a, textNode;

			href = text = consumeURL();

			a = document.createElement( 'a' );
			href = href.trim();

			var shouldPreventCheck = checkForSecurityPrefix();

			if( !shouldPreventCheck && !href.startsWith( 'htt' + 'ps://' ) && !href.startsWith( 'htt' + 'p://' ) ) {
				href = 'htt' + 'ps://' + href;
			}

			a.href = href
			a.setAttribute( 'target', '_blank' );
			a.setAttribute( 'rel', 'noopener noreferrer' );

			textNode = document.createTextNode( text );
			a.appendChild( textNode );

			addAllAttributes( a, 'hyperlink' );

			return a;

		}

		var consumeURL = function() {
			var str = '';
			
			while( !isWhiteSpace() && !delimiter() ) {
				str += list.eat().get( 'value' );
			}

			return str;	
		}

		var getLink = function() {
			var ret, allowSpace = true, text, textNode,
			href, a, title;

			if( !cs.callStackContains( 'link' ) ) {		
				text = getInnerText();

				if( list.eat().get( 'type' ) !== 'special]' ) {
					return false;
				}

				if( list.eat().get( 'type' ) !== 'special(' ) {
					return false;
				}

				href = consumeAsTextForLink();

				if( ( href || "" ).trim().length === 0 ) {
					return false;
				}

				if( list.peek().get( 'type' ) === 'special"' ) {
					list.eat();
					title = consumeTextAsTitle();

					if( list.eat().get( 'type' ) !== 'special"' ) {
						return false;
					}
				}

				if( list.eat().get( 'type' ) !== 'special)' ) {
					return false;
				}

				a = document.createElement( 'a' );
				a.href = checkAndPrefixWithHttp( href.trim() );
				a.setAttribute( 'target', '_blank' );
				a.setAttribute( 'rel', 'noopener noreferrer' )

				if( text.trim().length === 0 ) {
					text = href.trim();
				}

				textNode = document.createTextNode( text );
				a.appendChild( textNode );

				if( title ) {
					a.setAttribute( 'title', title );
				} 

				addAllAttributes( a, 'hyperlink' );

				return a;
			}

			return false;
		}

		var checkAndPrefixWithHttp = function( href ) {
			var shouldPreventCheck = checkForSecurityPrefix();

			if( shouldPreventCheck || href.startsWith( 'ht' + 'tp' ) || href.startsWith( 'ht' + 'tps' ) ) {
				return href;
			}

			return 'https://' + href;
		}

		var consumeCharacter = function( parent, token, token_aft ) {
			var value = token.get( 'value' ),
			value_aft = token_aft.get( 'value' );
			
			// if( ( value !== '\\' || value_bef === '\\' ) ){}
			
			if( value != '\\' || ( !value_aft.match(reg_sinks.spl_except_forw_slsh) ) ){
				var textNode = document.createTextNode( value );
				parent.appendChild( textNode );
			}

		}


		var isLink = function() {
			var token = list.peek();
			var token_bef = list.peekback();

			return token.get( 'type' ) === 'special[' && token_bef.get( 'type' ) !== 'special!'; //&& token_bef.get( 'type' ) !== 'special\\';
		}

		var getImage = function() {
			var text, img, alt = '';

			// I don't think this is needed
			if( alreadProcessingLink() ) {
				return false;
			}

			if( list.eat().get( 'type' ) === 'special[' ) {
				alt = consumeAsTextForAlt();

				if( list.eat().get( 'type' ) !== 'special]' ) {
					return false;
				}

				if( list.eat().get( 'type' ) !== 'special(' ) {
					return false;
				}

				text = consumeAsTextForSrc();

				if( list.peek().get( 'type' ) === 'special)' ) {
					list.eat();
				}
				else {
					return false;
				}

				if( ( text || "" ).trim().length === 0 ) {
					return false;
				}

				img = document.createElement( 'img' );
				img.alt = alt;
				img.src = text;
				addAllAttributes( img, 'image' );

				return img;
			}
			else {
				return false;
			}
		}

		var getHighlight = function() {
			var mark, ret;

			if( cs.isEmpty() ) {
				ret = consumeAsTextForHighlight() || "";

				if( ret.trim().length !== 0 && isHighlight() ) {
					list.eat();
					mark = document.createElement( 'mark' );
					mark.appendChild( document.createTextNode( ret ) );
					addAllAttributes( mark, 'mark' );

					return mark;
				}
			}
			
			return false;
		}

		var isHighlight = function() {
			var token_bef = list.peekback();
			var token = list.peek();
			
			return token.get( 'type' ) === 'special`' && token_bef.get( 'value' ) !== '\\';
		}

		var alreadProcessingLink = function() {
			return cs.callStackContains( 'link' );
		}

		var processNextCharacter = function( parent ) {
			var mem = capture();

			if( !para( parent ) ) {
				backtrack( mem );
			}
		}

		var isImageStart = function() {
			var token = list.peek();
			var token_bef = list.peekback();

			return token.get( 'type' ) === 'special!' && token_bef.get('type') !== 'special\\';
		}

		var consumeText = function( parent ) {
			var ret = text();

			parent.appendChild( document.createTextNode( ret ) );

			return ret;
		}

		var isEmphasis = function() {
			var token_bef = list.peekback(),
			token_tbef = list.peekbacktwice(),
			value_bef = token_bef.get( 'value' );

			var token = list.peek(),
			type = token.get( 'type' );

			var bool = true;

			if( token_bef.get( 'type' )  === 'special_' ){
				bool = token_tbef.get( 'value' ) !== '\\';
			}

			return (type === 'special*' || type === 'special_' || type === 'special~') && value_bef !== '\\' && bool;
		}

		var consumeAsTextForLink = function() {
			var str = '';

			while( list.peek().get( 'type' ) !== 'special)'
				&& list.peek().get( 'type' ) !== 'special"'
				&& !delimiter()
			) {
				
				str += list.eat().get( 'value' );
			}

			return str;
		}

		var consumeTextAsTitle = function() {
			var str = '';

			while( list.peek().get( 'type' ) !== 'special"'
				&& !delimiter()
			) {
				
				str += list.eat().get( 'value' );
			}

			return str;
		}

		var consumeAsTextForSrc = function() {
			var str = '';

			while( list.peek().get( 'type' ) !== 'special)'
				&& !delimiter()
			) {
				
				str += list.eat().get( 'value' );
			}

			return str;
		}

		var consumeAsTextForAlt = function() {
			var str = '';

			while( list.peek().get( 'type' ) !== 'special]'
				&& !delimiter()
			) {
				
				str += list.eat().get( 'value' );
			}

			return str;
		}

		var consumeAsTextForHighlight = function() {
			var str = '';

			while( list.peek().get( 'type' ) !== 'special`'
				&& !delimiter()
			) {
				
				str += list.eat().get( 'value' );
			}

			return str;
		}

		var getInnerText = function() {
			var str = '';

			while( list.peek().get( 'type' ) !== 'special]'
				&& !delimiter() 
			) {
				str += list.eat().get( 'value' );
			}

			return str; 
		}

		var delimiter = function() {
			var token = list.peek();

			return isTableCell ? ( token.get( 'type' ) === '' || token.get( 'type' ) === 'line_break' || token.get( 'type' ) === 'special|' )
								: ( token.get( 'type' ) === 'line_break' || token.get( 'type' ) === '' );
		}

		var hasEnded = function( list ) {
			return delimiter();
		}


		var createBold = function( frag ) {
			var b = document.createElement( 'b' );

			b.appendChild( frag );
			addAllAttributes( b, 'bold' );

			return b;
		}

		var createUnderline = function( frag ) {
			var u = document.createElement( 'u' );

			u.appendChild( frag );
			addAllAttributes( u, 'underline' );

			return u;
		}

		var createItalics = function( frag ) {
			var i = document.createElement( 'i' );

			i.appendChild( frag );
			addAllAttributes( i, 'italics' );

			return i;
		}

		var createStrike = function( frag ) {
			var s = document.createElement( 's' );

			s.appendChild( frag );
			addAllAttributes( s, 'strike' );

			return s;
		}

		var text = function() {
			var ret = '';

			while( isTextualCharacter()
				|| isWhiteSpace()
			) {
				ret = ret + list.eat().get( 'value' );
			}

			return ret;
		}

		var isTextualCharacter = function( token ) {
			token = token ? token : list.peek();

			return isTableCell ? isTextContentWhenTable( token ) : isTextContentWhenNormal( token );
		}

		var isTextContentWhenTable = function( token ) {
			return ( isText( token ) || token.get( 'type' ) === 'special.' || token.get( 'type' ) === 'special"' ) && !isURL();
		}

		var isTextContentWhenNormal = function( token ) {
			return ( isText( token ) || token.get( 'type' ) === 'special.' || token.get( 'type' ) === 'special|' || token.get( 'type' ) === 'special"' ) && !isURL();
		}

		var isWhiteSpace = function( token ) {
			token = token ? token : list.peek();

			return token.get( 'type' ) === 'space'
		}

		var isText = function( token ) {
			token = token ? token : list.peek();

			return token.get( 'type' ) === 'text'; 
		}

		return buildMarkdown();
	}

	var convertToString = function( dom ) {
		var dummyDiv = document.createElement( 'div' );

		dummyDiv.appendChild( dom );

		// SECURITY: XSS issues over here
		return dummyDiv.innerHTML;
	}

	var getReturnBasedOnType = function( type, dom ) {
		type = ( type || "dom" ).toLowerCase();

		if( type === 'dom' ) {
			return dom;
		}
		else if( type === 'domstring' ) {
			return convertToString( dom );
		}

		return dom;
	}


	$L.markdown = function( node, config ) {
		var dom, list, text, type, ret;

		config = config || {};
		type = config.type;
		text = getText( node )
		list = lex( text )
		dom = _rDP( list, config );
		list.flush();

		ret = getReturnBasedOnType( type, dom );

		return ret;
	};

	( function() {

		var wrapMap = {
			'b': {
				'start': '*',
				'end': '*'
			},
	
			'p': {
				'start': '',
				'end': '\n'
			},
	
			'div': {
				'start': '',
				'end': '\n'
			},
	
			'br': {
				'start': '',
				'end': '\n'
			},
	
			'span': {
				'start': '',
				'end': ''
			}
		}
	
		function shouldAddWrapper( node ) {
			var parent = node.parentNode,
			isLineBreak = node.nodeName.toLowerCase() === 'br',
			isParentParaOrDiv = parent.nodeName.toLowerCase() === 'div' || parent.nodeName.toLowerCase() === 'p',
			isSingleChild = parent.childNodes.length === 1;
	
			return !isLineBreak || !isParentParaOrDiv || !isSingleChild;
	
		}
	
		function wrapText( node, text ) {
			var tagName = node.nodeName.toLowerCase(),
			wrapObj = wrapMap[ tagName ],
			ret;
	
			if( shouldAddWrapper( node ) ) {
				ret = wrapObj.start + text + wrapObj.end;
			}
			else {
				ret = text;
			}
	
			return ret;
		}
	
	
		function getText( node, isFirstNode ) {
			var res = '',
			childNodes = node.childNodes;
	
			$L( childNodes ).each( function( index, node ) {
				isFirstNode = isFirstNode && ( index === 0 );
	
				if( isFirstNode ) {
					if( node.nodeType === 1 ) {
						res += getText( node ) + ( shouldAddNewLine( childNodes ) ? '\n' : '' );
					}
					else if( node.nodeType === 3 ) {
						res += node.nodeValue + ( shouldAddNewLine( childNodes ) ? '\n' : '' );
					}
				}
				else if( node.nodeType === 1 ) {
					res += wrapText( node, getText( node ) );
				}
				else if( node.nodeType === 3 ) {
					res += node.nodeValue;
				}
			} );
	
			return res;
		}
	
		function shouldAddNewLine( children ) {
			return children.length > 1;
		}
	
		$L._lyteHTMLToText = function( node ) {
			return getText( node, true );
		}
	} )();
} );

( function( factory ) {
    if( typeof define === "function" && define.amd ) {
        define( [ "@zoho/lyte-dom" ], factory );
    }
    else {
        factory( $L );
    }
} )(function( $L ) {

	if($L){	
		var postpone = (function () {
		    var fnMap = new Map(), idMap = new Map(), fnId = 0;
		    var msg = { fnId: 0 };
		    function _postpone(fn) {
		        if (!fnMap[fn]) {
		            fnId++;
		            fnMap[fn] = fnId;
		            idMap[fnId] = fn;
		        }
		        msg.fnId = fnMap[fn];
		        postMessage(msg, '*');
		    }
		    function _postponeListener(e) {
		        var fnId = e.data.fnId;
		        if (fnId) {idMap[fnId]()};
		    }
		    document.addEventListener("message", _postponeListener);
		    return _postpone;
		}());
		
		$L.prototype.mIManager = {
			KEY : { BACKSPACE : 8, TAB : 9, RETURN : 13, ESC : 27, LEFT : 37, UP : 38, RIGHT : 39, DOWN : 40, COMMA : 188, SPACE : 32, HOME : 36, END : 35 }, // Keys "enum"
			inputBuffer : [],
			currentDataQuery : null,
			textarea : null,
			escapeMap : { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#x27;', '`': '&#x60;'},
			bindResize : false,
			id : null,
			bindScroll : false,
			bindClick : false,
			searchTriggeredId : false,
			mentionRegex : new RegExp("\\@\\[\\d+\\:\\w+\\]","gi"),
			encodeMsg : function(str, mentionsArray){
				var mIManager = $L.prototype.mIManager, newStr = "", pos = 0;
				mentionsArray.forEach(function(mention){
					if(str.indexOf(mention) != -1){
						newStr += mIManager.htmlEncode(str.substring(0, str.indexOf(mention))) + mention;
						pos = str.indexOf(mention) + mention.length;
						str = str.substring(pos);
					}
				});
				newStr += mIManager.htmlEncode(str);
				return newStr;
			},
			htmlEncode : function (str) {
			  var mIManager = $L.prototype.mIManager;
			  var escaper = function(match){
			  	return mIManager.escapeMap[match];
			  }
			  var src = '(?:' + Object.keys(mIManager.escapeMap).join('|') + ')';
			  var testRegexp = RegExp(src);
    		  var replaceRegexp = RegExp(src, 'g');
    		  str = str == null ? '' : '' + str;
		      return testRegexp.test(str) ? str.replace(replaceRegexp, escaper) : str;
		    },
		    mentionsSyntax : function(mention){
		    	return "["+mention.value+":"+mention.id+"]";
		    },
			createElement : function(tagName,id,className){
				var element = document.createElement(tagName);
				if (id) {
					element.id = id;
				}
				if (className) {
					$L(element).addClass(className);
				}
				return element;
			},
			setCaratPosition : function (domNode, caretPos) {
		      if (domNode.createTextRange) {
		        var range = domNode.createTextRange();
		        range.move('character', caretPos);
		        range.select();
		      } else {
				  if (domNode.selectionStart) {
					  if (domNode.tagName === 'LYTE-INPUT') {
						  var input = domNode.querySelector('INPUT');
						  input.setSelectionRange(caretPos, caretPos);
					  } else {
						  domNode.setSelectionRange(caretPos, caretPos);
					  }
		          domNode.focus();
		        //   domNode.setSelectionRange(caretPos, caretPos);
		        } else {
		          domNode.focus();
		        }
		      }
		    },
			init: function (element) {
				var mIManager = $L.prototype.mIManager;
				var ele1 = mIManager.createElement("div", null, "lyteMIWrapper");
				window._lyteUiUtils.insertBefore(element, ele1);
				window._lyteUiUtils.appendChild(ele1, element);
				// ele1.append(element);
				var ele = mIManager.createElement("div", null, "lyteMIDropdown");
				window._lyteUiUtils.insertAfter(element, ele);
				mIManager.copyTextarea(element);
				var cs = window.getComputedStyle(element);
				var ele2 = mIManager.createElement("div", null, "lyteMentions");
				ele2.style.fontFamily = cs.fontFamily;
				ele2.style.fontSize = cs.fontSize;
				ele2.style.fontWeight = cs.fontWeight;
				var ele3 = mIManager.createElement("div", null, "lyteMentionsInnerDiv");
				window._lyteUiUtils.appendChild(ele2, ele3);
				// ele2.append(mIManager.createElement("div",null,"lyteMentionsInnerDiv"));
				window._lyteUiUtils.insertBefore(element, ele2);
				return ele;
			},
			rtrim : function(string) {
    			return string.replace(/\s+$/,"");
  			},
  			ltrim : function(string) {
    			return string.replace(/^\s+/,"");
  			},
  			highlightContent : function (value, term) {
			    if (!term && !term.length) {
			      return value;
			    }
			    return value.replace(new RegExp("(?![^&;]+;)(?!<[^<>]*)(" + term + ")(?![^<>]*>)(?![^&;]+;)", "gi"), "<b>$1</b>");
		    },
		    copyTextarea : function(element) {
		      var mIManager = $L.prototype.mIManager;
		      //	We will create a div clone of the textarea
		      //	by copying these attributes from the textarea to the div.
		      var attrs = [ 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'fontSize', 'lineHeight', 'fontFamily', 'width', 'fontWeight', 'border-top-width', 'border-right-width', 'border-bottom-width', 'border-left-width', 'borderTopStyle', 'borderTopColor', 'borderRightStyle', 'borderRightColor', 'borderBottomStyle', 'borderBottomColor', 'borderLeftStyle', 'borderLeftColor', 'box-sizing', '-moz-box-sizing', '-webkit-box-sizing'];

		        // CopyTextarea only works on textareas
				// if (element.type !== 'textarea') {
				//   return false;
				// }
				if (element.type !== 'textarea' && element.type !== 'text') {
					return false;
				}
		        var mITextarea = $L(element),
		          cloneTextarea = $L(mIManager.createElement('div')).css({'display':'none','word-wrap':'break-word'}),
		          lineHeight = parseInt(mITextarea.css('line-height'), 10) || parseInt(mITextarea.css('font-size'), '10'),
		          minheight = parseInt(mITextarea.css('height'), 10) || lineHeight * 3,
		          maxheight = parseInt(mITextarea.css('max-height'), 10) || Number.MAX_VALUE,
		          goalheight = 0;

		          cloneTextarea.addClass('lyteMIOffsetDiv');
		        // Updates the width of the twin. (solution for textareas with widths in percent)
		        function setCloneDivWidth(textareaWidth, cloneWidth) {
		          var curatedWidth = Math.floor(parseInt((textareaWidth || mITextarea.outerWidth()), 10));

		          if(mITextarea[0]._mIData && mITextarea[0]._mIData._overlayDiv){
		          	$L(mITextarea[0].previousElementSibling).css("fontSize",mITextarea.css("fontSize"));
		          }
		          if ((cloneWidth || cloneTextarea.outerWidth()) !== curatedWidth) {
		            cloneTextarea.css({'width': curatedWidth + 'px', 'fontSize': mITextarea.css("fontSize")});

		            if(cloneTextarea[0].getAttribute('setHeight') === "true"){
		            	cloneTextarea[0].setAttribute('setHeight',"false");
		            }
		            else{
		            	// Update height of textarea
		            	updateTextarea(true);
		            }
		            
		          }
		        }

		        // Sets a given height and overflow state on the textarea
		        function setHeightAndOverflow(height, overflow, textareaHeight) {

		          var curratedHeight = Math.floor(parseInt(height, 10));
		          if (textareaHeight !== curratedHeight) {
		            mITextarea.css({'height': curratedHeight + 'px','overflow':overflow});

		            // // Fire the custom event resize
		            setCloneDivWidth();

		          }
		        }

		        // This function will update the height of the textarea if necessary
		        var updateTextarea = function(forced) {
					var minheight = parseInt(mITextarea.css('height'), 10) || lineHeight * 3
		        	cloneTextarea[0].style.display = "block";
		        	
		        	// Get curated content from the textarea.

			        var textareaContent = mITextarea[0].value.replace(/&/g, '&amp;').replace(/ {2}/g, '&nbsp;').replace(/<|>/g, '&gt;').replace(/\n/g, '<br />');
			        
			        // Compare curated content with curated twin.

			        
			        var cloneContent = (cloneTextarea[0].innerHTML).replace(/<br>/ig, '<br />');

			        if (forced || mITextarea[0].value + '&nbsp;' !== cloneContent) {
			        		
			            // Add an extra white space so new rows are added when you are at the end of a row.
			            cloneTextarea[0].innerHTML = ' ';

			            cloneTextarea[0].innerHTML = textareaContent +'&nbsp;';
			           

			            var cloneHeight = cloneTextarea.outerHeight(), 
			            	textareaHeight = mITextarea.outerHeight();
			            // Change textarea height if twin plus the height of one line differs more than 3 pixel from textarea height
			            if (Math.abs(cloneHeight + lineHeight - textareaHeight) >= 3 || textareaContent === "") {

			            	cloneTextarea[0].setAttribute('setHeight',"true");
				            var goalheight = cloneHeight;
				            if (goalheight >= maxheight) {
				                setHeightAndOverflow(maxheight, 'auto', textareaHeight);
				            } else if (goalheight <= minheight) {
				                setHeightAndOverflow(minheight, 'hidden', textareaHeight);
				            } else {
				                setHeightAndOverflow(goalheight, 'hidden', textareaHeight);
				            }
			            }

			            var cloneWidth = cloneTextarea.outerWidth(),
			            	textareaWidth = mITextarea.outerWidth();
			            //Check for the width changes in textarea
			            if(textareaWidth != cloneWidth){
			            	cloneTextarea[0].setAttribute('setHeight',"true");
			            	setCloneDivWidth(textareaWidth, cloneWidth);
			            }
			            cloneTextarea[0].style.display = "";
			        }

		        };

		        // Opera returns max-height of -1 if not set
		        if (maxheight < 0) {
		          maxheight = Number.MAX_VALUE;
		        }

		        // Append the twin to the DOM
		        // We are going to meassure the height of this, not the textarea.

		        window._lyteUiUtils.insertAfter(mITextarea[0],cloneTextarea[0]);

		        // Copy the essential styles (attrs) from the textarea to the twin
		        var i = attrs.length;
		        while (i--) {

		          if (attrs[i].toString() === 'width' && mITextarea.css(attrs[i].toString()) === '0px') {
		            setCloneDivWidth();
		          } else {
		            cloneTextarea.css(attrs[i].toString(), mITextarea.css(attrs[i].toString()));
		            // console.log(attrs[i].toString() +"===" + mITextarea.css(attrs[i].toString()))
		          }
		        }
		        updateTextarea(true);

		        // Update textarea size on keyup, change, cut and paste
		        mITextarea[0]._closureEvnt = updateTextarea;
		        mITextarea[0].addEventListener('input', mITextarea[0]._closureEvnt);
		        mITextarea[0].addEventListener('change', mITextarea[0]._closureEvnt);

		    },

		    //Call setCloneDivWidth function at the end of the resize event so that the changes are available for calculation
	        callAtTheEndOfResize : function (e){
	        	var mIManager = $L.prototype.mIManager;
	        	clearTimeout(mIManager.id);
				mIManager.id = setTimeout(function(){
					var mentionElems = document.querySelectorAll('textarea[data-lyte-mentions="true"]');
					if(mentionElems.length > 0){
						for(var i = 0; i<mentionElems.length; i++){
							var mITextarea = $L(mentionElems[i]),
								cloneTextarea = $L(mentionElems[i].nextElementSibling),
								curatedWidth = Math.floor(parseInt(mITextarea.outerWidth(), 10));
							if(mITextarea[0]._mIData && mITextarea[0]._mIData._overlayDiv){
								$L(mITextarea[0].previousElementSibling).css("fontSize",mITextarea.css("fontSize"));
							}
							if (cloneTextarea.outerWidth() !== curatedWidth) {
								cloneTextarea.css({'width': curatedWidth + 'px', 'fontSize': mITextarea.css("fontSize")});
								if(cloneTextarea[0].getAttribute('setHeight') === "true"){
					            	cloneTextarea[0].setAttribute('setHeight',"false");
					            }
					            else{
					            	// Update height of textarea
					            	var evt;
									if(typeof(Event) === 'function') {
									    evt = new Event('change');
									}else{
									    evt = document.createEvent('Event');
									    evt.initEvent('change', true, true);
									}
					            	mITextarea[0].dispatchEvent(evt);
					            }
							}
						}
					}
				}, 200);
	        }

		}


		$L.prototype.mentionsInput = function(object) {
			var mIManager = $L.prototype.mIManager;
			if(!mIManager.bindResize){
				//findIndex
				if (!Array.prototype.findIndex) {
				  Object.defineProperty(Array.prototype, 'findIndex', {
				    value: function(predicate) {
				     // 1. Let O be ? ToObject(this value).
				      if (this == null) {
				        throw new TypeError('"this" is null or not defined');
				      }

				      var o = Object(this);

				      // 2. Let len be ? ToLength(? Get(O, "length")).
				      var len = o.length >>> 0;

				      // 3. If IsCallable(predicate) is false, throw a TypeError exception.
				      if (typeof predicate !== 'function') {
				        throw new TypeError('predicate must be a function');
				      }

				      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
				      var thisArg = arguments[1];

				      // 5. Let k be 0.
				      var k = 0;

				      // 6. Repeat, while k < len
				      while (k < len) {
				        // a. Let Pk be ! ToString(k).
				        // b. Let kValue be ? Get(O, Pk).
				        // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
				        // d. If testResult is true, return k.
				        var kValue = o[k];
				        if (predicate.call(thisArg, kValue, k, o)) {
				          return k;
				        }
				        // e. Increase k by 1.
				        k++;
				      }

				      // 7. Return -1.
				      return -1;
				    },
				    configurable: true,
				    writable: true
				  });
				}

	        	document.addEventListener('resize', mIManager.callAtTheEndOfResize);
	        	mIManager.bindResize = true;
	        }



			/*--------------------------------  UTILITY FUNCTIONS START  ----------------------------------*/
			var lyteMIList, textarea,
	            lyteMIActiveItem = [],
	            lyteMICollection = [],
	            currentDataQuery = '';

			var resetBuffer = function(){
				mIManager.inputBuffer = [];
			};

			var callOnBeforeAdd = function(data, selectedObj, newValue){
				return data.onBeforeAdd(selectedObj, newValue);
			}
			var callOnAdd = function(data,selectedObj){
		    	data.onAdd(selectedObj);
		    };

		    var callonRemove = function(data,removedCollection){
		    	if(data.onRemove){
		    		data.onRemove(removedCollection);
		    	}
		    }

			var filterDuplicateResult = function(rArray,mArray){
				for(var i = 0; i<mArray.length; i++){
					for(var j = 0; j<rArray.length; j++){
						if(mArray[i].id == rArray[j].id){
							rArray.splice(j,1);
						}
					}
				}
				return rArray;
			};

			var getIndexPosition = function(message, str){
				return message.indexOf(str) + str.length;
			};
			var updateMentionsposition  = function(range){
				var mentions = textarea._mIData.lyteMICollection;
				var searchBy = textarea._mIData.searchBy;

				mentions.forEach(function(mention,index){
					if(range.start <= mention.position.start ){
						var textLength = range.currentEnd - range.end;
						mention.position.start += textLength;
						mention.position.end = mention.position.start + mention[searchBy].length - 1;
					}
					mentions[index] = mention;
				});
				textarea._mIData.lyteMICollection = mentions;
			}

			var modifyNodeContent = function () {
				if (textarea.tagName === 'LYTE-INPUT') {
					var input = textarea.querySelector('INPUT');
					var syntaxMessage = input.value;
					var mentionText = input.value;
					textarea.selectionStart = input.selectionStart;
					textarea.value = input.value;

				} else {
					var syntaxMessage = textarea.value || "";
					var mentionText = textarea.value || "";
				}

				var searchBy = textarea._mIData.searchBy;
				var indPos = 0, processedStr = "", mentionsArray = [];
				var newPos = 0;
				var cursor = textarea.selectionStart;
				for (var i = 0; i < textarea._mIData.lyteMICollection.length; i++) {
					// textarea._mIData.lyteMICollection.forEach(function (mention) {
					var mention = textarea._mIData.lyteMICollection[i];

					var textSyntax = textarea._mIData.triggerChar + mIManager.mentionsSyntax({ id: mention.id, value: mention[textarea._mIData.searchBy] });
					mentionsArray.push(textSyntax);
					var text = textarea.value.substring(mention.position.start , mention.position.start + mention[searchBy].length);
					newPos += mentionText.indexOf(mention[textarea._mIData.searchBy]);
					// if(text == mention[searchBy] && mention.position.start !== newPos){
					// 	indPos += text.length;
					// }
					if(text == mention[searchBy]){
						var posdiff = (mention.position.start - newPos);
						if(mention.position.start !== newPos){
							
							indPos += (mention.position.start - newPos);
							newPos +=  (mention.position.start - newPos);
						}
						processedStr = syntaxMessage.substring(0,indPos);
						syntaxMessage = processedStr + syntaxMessage.substring(indPos).replace(mention[textarea._mIData.searchBy], textSyntax);
						indPos = indPos + getIndexPosition(syntaxMessage.substring(indPos),textSyntax);
						newPos += text.length ;
						mentionText = mentionText.substring(  mentionText.indexOf(mention[textarea._mIData.searchBy]) +posdiff  +  text.length );	
					}
					else {
						newPos -= mentionText.indexOf(mention[textarea._mIData.searchBy]);
						var removeEntireMentionOnBackspace = textarea._mIData.removeEntireMentionOnBackspace;
						if (removeEntireMentionOnBackspace) {
							var mentionedText = mention[textarea._mIData.searchBy];
							var startPos = mention.position.start;
							var endPos = mention.position.end;
							var extractedSubstring = textarea.value.substring(startPos, endPos);

							if (extractedSubstring !== mentionedText) {
								var tempTextareavalue = textarea.value;
								var part1 = tempTextareavalue.slice(0, startPos);
								var part2 = tempTextareavalue.slice(endPos);
								tempTextareavalue = part1 + part2;
								textarea.value = tempTextareavalue;
								if (textarea.tagName === 'LYTE-INPUT') {
									textarea.setData('ltPropValue', tempTextareavalue);
								}
								if (indPos > 0) {
									processedStr = syntaxMessage.substring(0, indPos + 1);
									var remainingStr = syntaxMessage.substring(indPos + extractedSubstring.length + 1);
									var length = mentionedText.length - 2;
									// remainingStr = remainingStr.substring(indPos - length, remainingStr.length);
									syntaxMessage = processedStr + remainingStr;
									mentionText = remainingStr
								}
								else {
									syntaxMessage = tempTextareavalue;
									mentionText = tempTextareavalue;
								}
								updatePositions(mention, 'modifyNodeContent');
								i--;
							}
						}
						// Remove the substring using replace
					}
				};
				var mentionText = mIManager.htmlEncode(syntaxMessage);
				var mentionText = mIManager.encodeMsg(syntaxMessage, mentionsArray);
				// console.log(textarea._mIData);
				var closeButton = textarea._mIData.closeButton;
				textarea._mIData.lyteMICollection.forEach(function (mention) {
					var textSyntax = textarea._mIData.triggerChar + mIManager.mentionsSyntax({ id: mention.id, value: mention[textarea._mIData.searchBy] });
					if (closeButton) {
						var textHighlight = "<strong class='lyteMentionsStrongDiv'><span>" + mention[textarea._mIData.searchBy].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;") + "</span><span class='lyteCloseIcon' id='lyteMentionClose-" + mention.id + "'></span></strong>";
					} else {
						var textHighlight = "<strong class='lyteMentionsStrongDiv'><span>" + mention[textarea._mIData.searchBy].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;") + "</span></strong>";
					}
					mentionText = mentionText.replace(textSyntax, textHighlight);


				});
				mentionText = mentionText.replace(/\n/g, '<br/>');
				mentionText = mentionText.replace(/ {2}/g, '&nbsp; ');
				textarea._mIData.syntaxMessage = syntaxMessage;
				textarea._mIData._overlayDiv.innerHTML = mentionText;
				textarea._mIData.lyteMICollection.forEach(function (mention) {
					var closeButton = document.getElementById('lyteMentionClose-' + mention.id);
					if (closeButton) {
						document.getElementById('lyteMentionClose-' + mention.id).onclick = (function (mentionId) {
							return function () {
								handleCloseButtonClick(mentionId);
							};
						})(mention.id, textarea);
					}
				});
			}

			var getLength = function (deletedMention, callee) {
				if (callee === 'modifyNodeContent') {
					var deletedStart = deletedMention.position.start;
					var deletedEnd = deletedMention.position.end;
					var length = deletedEnd - deletedStart;
				}
				else if (callee === 'handleCloseButtonClick') {
					var searchBy = textarea._mIData.searchBy;
					var deletedStart = deletedMention.position.start;
					var length = deletedMention[searchBy].length;
				}
				return length;
			}

			var updatePositions = function (deletedMention, callee) {
				var mentionId = deletedMention.id;
				var deletedStart = deletedMention.position.start;
				var length = getLength(deletedMention, callee);
				for (var i = 0; i < textarea._mIData.lyteMICollection.length; i++) {
					var mention = textarea._mIData.lyteMICollection[i];
					var start = mention.position.start;
					var end = mention.position.end;
					if (start > deletedStart) {
						textarea._mIData.lyteMICollection[i].position.start = start - length;
						textarea._mIData.lyteMICollection[i].position.end = end - length;
					}
					if (mention.id === mentionId) {
						textarea._mIData.lyteMICollection.splice(i, 1);
						i--;
					}
				}

			}

			var handleCloseButtonClick = function (mentionId) {
				var appendSpaceOnAdd = textarea._mIData.appendSpaceOnAdd;
				var mention = textarea._mIData.lyteMICollection.find(function (mention) {
					return mention.id === mentionId;
				});

				textarea._mIData.lyteMICollection = textarea._mIData.lyteMICollection.filter(function (item) {
					return item.id !== mentionId;
				});
				var mentionText = textarea.value;
				var startPos = mention.position.start;
				var endPos = mention.position.end;
				var part1 = mentionText.slice(0, startPos);
				var part2 = mentionText.slice(endPos + 1);
				if (part2 && appendSpaceOnAdd) {
					if (part2.startsWith(' ')) {
						part2 = part2.slice(1);
					}
				}
				var tempTextareavalue = part1 + part2;
				if (textarea.tagName === 'LYTE-INPUT') {
					textarea.setData('ltPropValue', tempTextareavalue);
				}
				else {
					textarea.value = tempTextareavalue;
				}

				updatePositions(mention, 'handleCloseButtonClick');
				modifyNodeContent();
				triggerChangeEvt(textarea);
			}

			var handleCloseButtonClickForAdvanced = function (mentionId) {
				var appendSpaceOnAdd = textarea._mIData.appendSpaceOnAdd;
				var mention = textarea._mIData.lyteMICollection.find(function (mention) {
					return mention.id === mentionId;
				});

				textarea._mIData.lyteMICollection = textarea._mIData.lyteMICollection.filter(function (item) {
					return item.id !== mentionId;
				});
				var mentionText = textarea.value;
				var startPos = mention.position.start;
				var endPos = mention.position.end;
				var part1 = mentionText.slice(0, startPos);
				var part2 = mentionText.slice(endPos);
				if (part2 && appendSpaceOnAdd) {
					if (part2.startsWith(' ')) {
						part2 = part2.slice(1);
					}
				}
				var tempTextareavalue = part1 + part2;
				if (textarea.tagName === 'LYTE-INPUT') {
					textarea.setData('ltPropValue', tempTextareavalue)
				}
				textarea.value = tempTextareavalue
				var skipUpdate;
				var valueMap = textarea._valueMap;
				if (valueMap.undoAndRedo) {
					if (valueMap.oldText === textarea.value) {
						skipUpdate = true;
					}
					delete valueMap.undoAndRedo;
				};
				var range = {
					start: endPos,
					end: endPos,
					currentEnd: endPos - 1
				};
				var returnValue = skipUpdate ? { newValue: valueMap.oldSyntax } : updateMentions(textarea.value, range);
				var newMappedValue = returnValue.newValue;
				var selectionEnd = returnValue.selectionEnd;
				valueMap.newSyntax = newMappedValue;
				var newText = getText(newMappedValue);
				var removed = updateAdvancedCollections(newMappedValue);
				advancedModifyNodeContent(newText);
				if (removed) {
					textarea.value = newText;
					setSelectionPosition(selectionEnd);
				}
				setSelection(textarea);
				if (textarea._mIData.dropbody || textarea._mIData.validateCollections || data.alwaysCallOnReomve) {
					!data.removeHighlightCompletely && updatelyteMICollection();
				}
			}

		    var updatelyteMICollection = function() {
		      var inputText = textarea.value;
		      var syntaxMessage = textarea._mIData.syntaxMessage;
		      var searchBy = textarea._mIData.searchBy;

		      lyteMICollection = textarea._mIData.lyteMICollection;
		      var newCollection = [], removedCollection = [];
		      var indPos = 0;
			for(var i = 0; i < lyteMICollection.length; i++){
				indPos +=  inputText.indexOf(lyteMICollection[i][searchBy]);
		      	var collection = lyteMICollection[i][searchBy]+":"+lyteMICollection[i].id;
				var startPos = lyteMICollection[i].position.start;
		      	if(lyteMICollection[i][searchBy] && (syntaxMessage.indexOf(collection)) !== -1  ){
					var text = textarea.value.substring(startPos,startPos+lyteMICollection[i][searchBy].length);
					if(indPos === startPos ){
						newCollection.push(lyteMICollection[i]);
						syntaxMessage = syntaxMessage.substring(syntaxMessage.indexOf(collection) + 1 + collection.length);
						indPos += lyteMICollection[i][searchBy].length;
						inputText = inputText.substring( inputText.indexOf(lyteMICollection[i][searchBy]) + lyteMICollection[i][searchBy].length );

					}else if(text === lyteMICollection[i][searchBy] ){
						newCollection.push(lyteMICollection[i]);
						syntaxMessage = syntaxMessage.substring(syntaxMessage.indexOf(collection) + 1 + collection.length);
						indPos = startPos + lyteMICollection[i][searchBy].length;
						inputText = inputText.substring( inputText.indexOf(lyteMICollection[i][searchBy]) + lyteMICollection[i][searchBy].length );
					}else{
						removedCollection.push(lyteMICollection[i]);
						indPos -= inputText.indexOf(lyteMICollection[i][searchBy]);
					}
					
			      }
		      	else{
		      		removedCollection.push(lyteMICollection[i]);
		      	}
		      }
		      textarea._mIData.lyteMICollection = newCollection;
		      if(removedCollection.length){
		      	callonRemove(textarea._mIData,removedCollection);
		      }
		    }

		    var positionalPush = function(data, msg){
		    	var indPos = 0,
		    		count = 0,
		    		searchBy = textarea._mIData.searchBy,
		    		lyteMICollection = textarea._mIData.lyteMICollection, processedStr="";
		    	for(var i = 0; i < lyteMICollection.length; i++){


		    		var ind = msg.substring(indPos).indexOf(lyteMICollection[i][searchBy]);
		    		if(ind == -1){
		    			break;
		    		}
		    		else{
		    			indPos += getIndexPosition(msg.substring(indPos),lyteMICollection[i][searchBy]);
		    			++count;
		    		}
				}
				textarea._mIData.lyteMICollection.splice(count,0,data);

		    }
			

			var updateCollection = function(data) {
				textarea._addedMentions = true;
				if (textarea.tagName === 'LYTE-INPUT') {
					var input = textarea.querySelector('INPUT')
					textarea.value = input.value;
					textarea.selectionEnd = input.selectionEnd;
				}
				var currentMessage = textarea.value;
				var appendSpaceOnAdd = textarea._mIData.appendSpaceOnAdd;
				var value = data[textarea._mIData.searchBy];
				//Get the mentions position based on cursor position
				var startCaretPosition = textarea.selectionEnd - mIManager.currentDataQuery.length - 1;
				var currentCaretPosition = textarea.selectionEnd;

				//If the string received based on cursor position dosent match the query, get the query position
				if(currentMessage.substring(startCaretPosition,currentCaretPosition) !== textarea._mIData.triggerChar + mIManager.currentDataQuery){ 
					// Using a regex to figure out positions
					var regex = new RegExp("\\" + textarea._mIData.triggerChar + mIManager.currentDataQuery, "gi");
					regex.exec(currentMessage);

					startCaretPosition = regex.lastIndex - currentDataQuery.length - 1;
					currentCaretPosition = regex.lastIndex;
				}
				
				var start = currentMessage.substr(0, startCaretPosition);
				var end = currentMessage.substr(currentCaretPosition, currentMessage.length);
				var startEndIndex = (start + value).length + (appendSpaceOnAdd?1:0);

				var updatedMessageText = start + value +(appendSpaceOnAdd?" ":"") + end;
				data.position = {start : startCaretPosition, end : startCaretPosition + value.length - 1};

				var selection = textarea._selection;

				var range = {
						start : selection.end,
						end : selection.end,
						currentEnd : ((currentCaretPosition ) + (( value.length ) - (currentCaretPosition - startCaretPosition)))   
					}
				updateMentionsposition(range);
			



				if(textarea._mIData.onBeforeAdd &&  callOnBeforeAdd(textarea._mIData,data, updatedMessageText) ===  false){
					hideDropdown();
					return;
				}
				positionalPush(data, start);

				// Cleaning before inserting the value, otherwise auto-complete would be triggered with "old" inputbuffer
				resetBuffer();
				mIManager.currentDataQuery = '';
				hideDropdown();

				// Mentions - syntax message
				if (textarea.tagName === 'LYTE-INPUT') {
					textarea.setData('ltPropValue', updatedMessageText);
				}
				else {
					textarea.value = updatedMessageText;
				}
				modifyNodeContent();
				triggerChangeEvt(textarea);
			//    var evt;
				// if(typeof(Event) === 'function') {
				//     evt = new Event('change');
				// }else{
				//     evt = document.createEvent('Event');
				//     evt.initEvent('change', true, true);
				// }
			//    textarea.dispatchEvent(evt);
				// Set correct focus and selection
				// textarea.focus();
				setTimeout( function(){
					mIManager.setCaratPosition(textarea, startEndIndex);
				},50);
				if(textarea._mIData.onAdd){
					callOnAdd(textarea._mIData,data);
				}
		    }

			var hideDropdown = function(input, dropdown){
				var tArea = input ? input : textarea;
				lyteMIActiveItem = [];
				dropdown = dropdown || lyteMIList;
				if(!dropdown){
					dropdown = tArea._mIData.lyteMIList;
				}
				if(tArea._mIData.onHide){
					tArea._mIData.onHide(dropdown, tArea);
				}
				if(tArea._mIData.dropbody){
					dropdown.innerHTML = "";
				}
				if(tArea._mIData.preventParentScroll && tArea._scrollDisabled) {
					disableParentListeners(tArea);
				}
				
				dropdown.classList.remove('lyteMIDisplayBlock','lyteMIAddOverflow','lyteMIListAppended','lyteMIDropdown__Down','lyteMIDropdown__Up');
				if(tArea._mIData.dropdownClass) {
					dropdown.classList.remove(tArea._mIData.dropdownClass);
				}
				dropdown.style = "";
			};

			var createLiElement = function(data){
				var ele = mIManager.createElement('lyte-mentions-item');
				ele._mentionsData = data;
				var value = $L.texthighlighter(data[textarea._mIData.searchBy],mIManager.currentDataQuery,'b');
				var span = mIManager.createElement('span','','lyteMIItemContent');
				span.appendChild(value);
				ele.appendChild(span);
				return ele;
			};
			var updateAdvancedCollections = function(newSyntax){
				lyteMICollection = textarea._mIData.lyteMICollection;
				var newCollection = [], removedCollection = [];
				var searchBy = textarea._mIData.searchBy;
				var mentionsSyntax = mIManager.mentionsSyntax;
				var triggerChar = textarea._mIData.triggerChar;
				var regex = new RegExp(textarea._mIData.triggerChar+"\\[(.+?)\\:(.+?)\\]",'gi');
				var start = 0, mappedStart = 0, end;
				for(var i = 0; i<lyteMICollection.length; i++){
					var actualValue =  lyteMICollection[i][searchBy];
					var mentionObj = {id: lyteMICollection[i].id, value: actualValue};
					var mentionSyntax = triggerChar+mentionsSyntax(mentionObj);
					var index = newSyntax.indexOf(mentionSyntax);
					var previousString = newSyntax.substring(0,index);
					var missed = regex.exec(previousString);
					if(missed === null && index != -1 ){
						start += (index + actualValue.length);
						mappedStart = index + mentionSyntax.length;
						lyteMICollection[i].position = {start : (start - actualValue.length) ,end: start};
						newCollection.push(lyteMICollection[i]);
						newSyntax = newSyntax.substring(mappedStart);
					}
					else{
						removedCollection.push(lyteMICollection[i]);
						end = lyteMICollection[i].position.end;
					}
				}
				textarea._mIData.lyteMICollection = newCollection;
				if(removedCollection.length){
					callonRemove(textarea._mIData,removedCollection);
					return {end: end};
				}
			};

			var addToCollections = function(data, startIndex){
		    	var index = 0,
		    	lyteMICollection = textarea._mIData.lyteMICollection;
		    	for(; index < lyteMICollection.length; index++){
		    		if(lyteMICollection[index].position.end > startIndex) {
						break;
					}
		    	}
		    	textarea._mIData.lyteMICollection.splice(index,0,data);
		    };

			var advancedModifyNodeContent = function (newText) {
				var newSyntax = textarea._valueMap.newSyntax;
				var mentions = [];
				textarea._mIData.lyteMICollection.forEach(function(mention){
					mentions.push(textarea._mIData.triggerChar+mIManager.mentionsSyntax({id : mention.id, value : mention[textarea._mIData.searchBy]}));
				});
				var mentionText = mIManager.encodeMsg(newSyntax, mentions);
				var newTextValue = newText;
				var closeButton = textarea._mIData.closeButton;

				textarea._mIData.lyteMICollection.forEach(function (mention, index) {
					var textSyntax = mentions[index];
					if (closeButton) {
						var textHighlight = "<strong class='lyteMentionsStrongDiv'><span>" + mention[textarea._mIData.searchBy].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;") + "</span><span class='lyteCloseIcon' id='lyteMentionClose-" + mention.id + "'></span></strong>";
					} else {
						var textHighlight = "<strong class='lyteMentionsStrongDiv'><span>" + mention[textarea._mIData.searchBy].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;") + "</span></strong>";
					}
					mentionText = mentionText.replace(textSyntax, textHighlight);
				});
				mentionText = mentionText.replace(/\n/g, '<br />');
				mentionText = mentionText.replace(/ {2}/g, '&nbsp; ');
				textarea._valueMap = {
					oldSyntax: newSyntax,
					oldText: newText
				}
				textarea._mIData.syntaxMessage = newSyntax;
				textarea._mIData._overlayDiv.innerHTML = mentionText;
				// textarea._mIData._overlayDiv.appendChild(document.createTextNode(mentionText));
				textarea._mIData.lyteMICollection.forEach(function (mention) {
					var closeButton = document.getElementById('lyteMentionClose-' + mention.id);
					if (closeButton) {
						document.getElementById('lyteMentionClose-' + mention.id).onclick = (function (mentionId) {
							return function () {
								handleCloseButtonClickForAdvanced(mentionId);
							};
						})(mention.id, textarea);
					}
				});
			};
			var copyObject = function(object){
				return Object.assign({},object);
			};
			
			var addMentions = function(mention){
				mention =  copyObject(mention);
				textarea._addedMentions = true;
				var appendSpaceOnAdd = data.appendSpaceOnAdd;
				var str = textarea._valueMap.oldSyntax;
				var startCaretPosition = textarea.selectionEnd - mIManager.currentDataQuery.length - 1;
				var currentCaretPosition = textarea.selectionEnd;
				var start = mapTextIndex(str, startCaretPosition, 'start');
   				var end = start + currentCaretPosition - startCaretPosition;
				var insert = textarea._mIData.triggerChar+mIManager.mentionsSyntax({id : mention.id, value : mention[textarea._mIData.searchBy]})+(appendSpaceOnAdd?" ":"");
				var newValue = str.substring(0,start)+insert+str.substring(end);
				var newText = getText(newValue);
				if(textarea._mIData.onBeforeAdd &&  callOnBeforeAdd(textarea._mIData, data, newText) ===  false){
					hideDropdown();
					return;
				}
				textarea._valueMap.newSyntax =  newValue; 
				addToCollections(mention,startCaretPosition);
				// if(newText !=  textarea.value) {

				resetBuffer();
				mIManager.currentDataQuery = '';
				hideDropdown();

				textarea.value = newText;
				if (textarea.tagName === 'LYTE-INPUT') {
					textarea.component.setData('ltPropValue', newText)
				}
				updateAdvancedCollections(newValue);
				advancedModifyNodeContent(newText);

				setSelectionPosition(mention.position.end+(appendSpaceOnAdd?1:0));// 1 for space
				if(textarea._mIData.onAdd){
					callOnAdd(textarea._mIData,data);
				}
				// }
			};

			var setSelectionPosition = function(end){
				triggerChangeEvt(textarea);
				// textarea.focus();
				setTimeout( function(){
					mIManager.setCaratPosition(textarea, end);
					setSelection(textarea);
				},10);
			};

			var onSelect = function(event) {
		    	var elmTarget = $L(this);
		    	if(!lyteMIList){
		    		lyteMIList = this.closest('.lyteMIDropdown');
		    	}
		    	textarea = lyteMIList._textarea;
				var advanced = data.removeHighlightCompletely;
				if(advanced) {
					addMentions(elmTarget[0]._mentionsData);
				}
				else {
					
					updateCollection(elmTarget[0]._mentionsData);
				}
		    	// updateCollectionPosition(textarea);
		    	// textarea.dispatchEvent(new InputEvent('change'));

		    	event.stopPropagation();
		    }


			var onKeyUpOrDown = function(ele){
				if(!ele){
					return;
				}

				if($L('lyte-mentions-item'/*textarea._mIData.listItemTag*/,lyteMIList).length){
					$L('lyte-mentions-item'/*textarea._mIData.listItemTag*/,lyteMIList).removeClass(textarea._mIData.activeItem);
				}
				$L(ele).addClass(textarea._mIData.activeItem);
				lyteMIActiveItem = [];
		    	lyteMIActiveItem.push(ele);
			};

			var getCursorXY = function(textarea, scrolled){
				var customDiv = document.createElement('div');
				var styles = getComputedStyle(textarea);
				
				var currentMessage = textarea.value;
				var properties = {};
				for(var prop in styles){
					if(!((/[\d -]+/g).test(prop) || typeof styles[prop] == "function") ){
						
						if( prop == "lineHeight" ){
							properties[prop] = styles[prop];
						}
						if( prop == "letterSpacing" ){
							properties[prop] = styles[prop];
						}
						if( prop == "height" ){
							properties[prop] = "auto";
						}
						if( prop == "width" ){
							properties[prop] = styles[prop];
						}
						if( prop == "fontSize" ){
							properties[prop] = styles[prop];
						}
						if( prop == "paddingLeft" ){
							properties[prop] = styles[prop];
						}
						if( prop == "paddingRight" ){
							properties[prop] = styles[prop];
						}
						if( prop == "paddingTop" ){
							properties[prop] = styles[prop];
						}
						if( prop == "paddingBottom" ){
							properties[prop] = styles[prop];
						}
						if( prop == "marginLeft" ){
							properties[prop] = styles[prop];
						}
						if( prop == "marginRight" ){
							properties[prop] = styles[prop];
						}
						if( prop == "marginTop" ){
							properties[prop] = styles[prop];
						}
						if( prop == "marginBottom" ){
							properties[prop] = styles[prop];
						}
						if( prop == "borderLeft" ){
							properties[prop] = styles[prop];
						}
						if( prop == "borderRight" ){
							properties[prop] = styles[prop];
						}
						if( prop == "borderTop" ){
							properties[prop] = styles[prop];
						}
						if( prop == "borderBottom" ){
							properties[prop] = styles[prop];
						}
						if( prop == "boxSizing" ){
							properties[prop] = styles[prop];
						}
						if( prop == "whiteSpace" ){
							properties[prop] = styles[prop];
						}
						if( prop == "fontWeight" ){
							properties[prop] = styles[prop];
						}
						if( prop == "fontFamily" ){
							properties[prop] = styles[prop];
						}
						if( prop == "testAlign" ){
							properties[prop] = styles[prop];
						}
						if( prop == "display" ){
							properties[prop] = styles[prop];
						}
						if( prop == "direction" ){
							properties[prop] = styles[prop];
						}
						if( prop == "wordBreak" ){
							properties[prop] = styles[prop];
						}
						if( prop == "wordWrap" ){
							properties[prop] = styles[prop];
						}
						if( prop == "wordSpacing" ){
							properties[prop] = styles[prop];
						}
						if( prop == "position" ){
							properties[prop] = "relative";
						}
					}
				}
				for(var prop in properties){
					customDiv.style[prop] = styles[prop];
				}


			    // Figure out positions
				var selectionStart =  scrolled?textarea._prevSelectionStart:textarea.selectionStart;
			    var startCaretPosition = selectionStart - (mIManager.currentDataQuery.length+1);

				var textContent = currentMessage.substr(0, startCaretPosition);
				customDiv.textContent = textContent;
				// customDiv.style.height = 'auto';
				var span = document.createElement('span');
				span.textContent = currentMessage.substr(startCaretPosition, mIManager.currentDataQuery.length+1) || '.';
				customDiv.appendChild(span);
				var customWrapper = document.createElement('div');
				customWrapper.className = "lyteMentionsCustomWrapper";
				customWrapper.appendChild(customDiv);
				document.body.appendChild(customWrapper);
				var textareaOffset = textarea.getBoundingClientRect();
				var spanOffset = span.getBoundingClientRect();
				var xscroll = window.pageXOffset || document.documentElement.scrollLeft;
                var yscroll = window.pageYOffset || document.documentElement.scrollTop;
				var offset = {
					x : textareaOffset.left + xscroll + span.offsetLeft - textarea.scrollLeft,
					y : textareaOffset.top + yscroll + span.offsetTop - textarea.scrollTop,
					height : spanOffset.height,
					width : spanOffset.width
				}
				customWrapper.remove();
				return offset;
			};

			var resetScrollForParent = function(event) {
				var scrollTop = $L( this ).data( 'lyte-scrollTop' ),
				scrollLeft = $L( this ).data( 'lyte-scrollLeft' );
				this.scrollTop = scrollTop;
				this.scrollLeft = scrollLeft;
			};

			var disableLyteScrollBar = function( event ) {
				event.stopPropagation();
			};

			var isScrollable = function( index, item ) {
				var overflowY = $L( item ).css( 'overflow-y' ),
				overflowX = $L( item ).css( 'overflow-x' );
				var allowableValue = ["scroll","auto"];
				if( ( item.clientWidth < item.scrollWidth && allowableValue.indexOf(overflowX) > -1 ) || ( item.clientHeight < item.scrollHeight && allowableValue.indexOf(overflowY) > -1 ) ) {
					return true;
				}
		
				return false;
			};

			var isLyteScrollBar = function( index, item ) {
				return item.classList.contains( 'lyteScrollBar' );
			};

			var disableParentListeners =  function(textarea) {
				var scrollableParents = textarea._scrollableParents;
				var lyteScrollBarParents =  textarea._lyteScrollBarParents;
				if( scrollableParents ) {
					scrollableParents.off( 'scroll', textarea._resetScrollFunc );
					delete textarea._scrollableParents;
					delete textarea._resetScrollFunc;
				}
				if( lyteScrollBarParents ) {

					lyteScrollBarParents.each( function( index, item ) {
		
						if( item ) {
							item.removeEventListener( 'touchmove', textarea._disableLyteScrollBar, true );
							item.removeEventListener( 'wheel', textarea.disableLyteScrollBar, true );
						}
						
					} );
					delete textarea._lyteScrollBarParents;
					delete textarea._disableLyteScrollBar;
				}
				delete textarea._scrollDisabled;
			};

			var preventParentScroll = function(dropdown, textarea) {

				var parents = $L( textarea ).parents(),
				lyteScrollBarParents;
		
				parents = parents.filter( isScrollable );

				lyteScrollBarParents = parents.filter( isLyteScrollBar );

				lyteScrollBarParents = lyteScrollBarParents.map( function( index, item ) {
					return item.parentNode;
				} );
				parents.each( function( index, item ) {
					$L( item ).data( 'lyte-scrollTop', item.scrollTop );
					$L( item ).data( 'lyte-scrollLeft', item.scrollLeft );
				} );
				textarea._disableLyteScrollBar = disableLyteScrollBar;
				lyteScrollBarParents.each( function( index, item ) {
					if( item ) {
						item.addEventListener( 'touchmove', textarea._disableLyteScrollBar, true );
						item.addEventListener( 'wheel', textarea._disableLyteScrollBar, true );
					}
				} );
				textarea._scrollableParents = parents;
				textarea._lyteScrollBarParents = lyteScrollBarParents;
				textarea._scrollDisabled = true;
				textarea._resetScrollFunc  = resetScrollForParent;
				parents.on( 'scroll', textarea._resetScrollFunc );
		
				document.body.classList.add( 'lyteBodyWrapper' );
			};

			var positionDropdown = function(lyteMIList, scrolled){
				var textarea = lyteMIList._textarea;
				if(scrolled && textarea._mIData.preventParentScroll) {
					return;
				}
			    var textareaOffset = textarea.getBoundingClientRect();
			    var listOffset = lyteMIList.getBoundingClientRect();
			    var winH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
				var winWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
			    var xscroll = window.pageXOffset || document.documentElement.scrollLeft;
                var yscroll = window.pageYOffset || document.documentElement.scrollTop;
			    winH += yscroll;
			    var xy = getCursorXY(textarea, scrolled);
			    // console.log("listOffset.height ====" + listOffset.height);
			    // console.log("winH - textareaOffset.bottom ====" + (winH - textareaOffset.bottom));
			    // console.log("winH - textareaOffset.top ====" + (winH - textareaOffset.top));
			    if(listOffset.height < (winH - (xy.y + xy.height + 5))){  //Appending at Bottom
			    	lyteMIList.style.top = (xy.y + xy.height + 5) + "px";
			    	$L(lyteMIList).removeClass('lyteMIDropdown__Up');
			    	$L(lyteMIList).addClass('lyteMIDropdown__Down');
			    }
			    else if(listOffset.height < xy.y){  //Appending at Top
			    	lyteMIList.style.top = xy.y - listOffset.height + "px";
			    	$L(lyteMIList).removeClass('lyteMIDropdown__Down');
			    	$L(lyteMIList).addClass('lyteMIDropdown__Up');
			    }
			    else{  //Appending at Bottom Forcefully
			    	var position = getPositionUpOrDown(winH, xy.y, xy.height);
			    	if(position == "up"){
			    		lyteMIList.style.top = "5px";
				    	$L(lyteMIList).height(xy.y - 5);
				    	$L(lyteMIList).addClass('lyteMIAddOverflow','lyteMIDropdown__Up');
			    	}
			    	else{
			    		lyteMIList.style.top = (xy.y + xy.height + 5) + "px";
				    	$L(lyteMIList).height(winH - (xy.y + xy.height + 5) - 5);
				    	$L(lyteMIList).addClass('lyteMIAddOverflow','lyteMIDropdown__Down');
			    	}
			    }
			    if((xy.x + listOffset.width) < textareaOffset.right){
			    	lyteMIList.style.left = xy.x + "px";
			    }
			    else{
			    	var leftVal = (xy.x + xy.width) - listOffset.width;
			    	if(leftVal < 0){
			    		if(xy.x + xy.width <= textareaOffset.left + (textareaOffset.width / 2)){
			    			lyteMIList.style.maxWidth = (textareaOffset.right - xy.x) + "px";
			    			leftVal = xy.x;
			    		}
			    		else{
			    			lyteMIList.style.maxWidth = (listOffset.width + leftVal) - 10 + "px";
			    			leftVal = 10;
			    		}
			    	}
			    	else if(leftVal > textareaOffset.right){
			    		leftVal = textareaOffset.left;
			    	}
					var dropdownRight = leftVal+listOffset.width;
					if(dropdownRight > winWidth) {
						leftVal = leftVal + (winWidth - dropdownRight);
					}
			    	lyteMIList.style.left = leftVal + "px";
			    }
			    
			    if(!scrolled){
					$L(lyteMIList).addClass('lyteMIListAppended');
					if(textarea._mIData.preventParentScroll && !textarea._scrollDisabled) {
						preventParentScroll(lyteMIList, textarea);
					}
					if(textarea._mIData.onBeforeShow){
				    	textarea._mIData.onBeforeShow(lyteMIList,textarea);
				    }
					textarea._prevSelectionStart = textarea.selectionStart;
				}
			    
			}

			var getPositionUpOrDown = function(winH,tATop,tAHeight){
				if((tATop - 5) > (winH - (tATop + tAHeight + 5))){
					return "up";
				}
				else{
					return "down";
				}
			}

			var checkForMaxWidth = function(lyteMIList){
				if(getComputedStyle(lyteMIList).maxWidth === "none"){
					var cs = getComputedStyle(lyteMIList._textarea);
					lyteMIList.style.maxWidth = (parseFloat(cs.width) - (parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight))) + "px";
				}
			}

			//Create the dropdown
			var populateDropdown = function(results){
				if (!results.length) {
			        // hideDropdown();
			        return;
			      }

			      var elmDropDownList = mIManager.createElement('ul');

			      for(var i = 0; i<results.length; i++){
			      	  var liEle = createLiElement(results[i]);
			      	  liEle.addEventListener('click',onSelect,true);
			          
				      if(textarea._mIData.avatars && results[i].avatar){
				      	  var elmIcon = new Image();
				      	  elmIcon.src = results[i].avatar;
				      	  liEle.prepend(elmIcon);
				      }
				      elmDropDownList.append(liEle);
				      liEle = null;
			      }
			      lyteMIList.append(elmDropDownList);
			      if(!lyteMIList._appended){
			      	window._lyteUiUtils.appendChild(document.body, lyteMIList);
			      	lyteMIList._appended = true;
			      }
			      onKeyUpOrDown(elmDropDownList.children[0]);
				  if(textarea._mIData.dropdownClass) {
					$L(lyteMIList).addClass(textarea._mIData.dropdownClass);
				  }
			      $L(lyteMIList).addClass('lyteMIHide');
			      $L(lyteMIList).addClass('lyteMIDisplayBlock');
			      checkForMaxWidth(lyteMIList);
			      positionDropdown(lyteMIList);
			      $L(lyteMIList).removeClass('lyteMIHide');
			};

			var filterData = function(responseData){
				var mode = textarea._mIData.mode,
					searchBy = textarea._mIData.searchBy,
					query = mIManager.currentDataQuery,
					results = [];
				if(responseData.length)
                {
                   for(var i = 0; i < responseData.length; i++){
                      	switch(mode){
                          	case 'contains' : {
                              	if(responseData[i][searchBy].trim().toLowerCase().indexOf(query.toLowerCase()) >= 0)
                               	  {
                                      results.push(responseData[i]);
                                  }
                              break;    
                           	}
                           	case 'startsWith' : {
                                if(responseData[i][searchBy].trim().toLowerCase().startsWith(query.toLowerCase()))
                                   {
                                      results.push(responseData[i]);
                                   }
                                break;
                           	}
                           	case 'endsWith' : {
                                if(responseData[i][searchBy].trim().toLowerCase().endsWith(query.toLowerCase()))
                                   {
                                        results.push(responseData[i]);
                                   }
                                break;
                           	}
                        }  
                    }

                    populateDropdown(textarea._mIData.allowDuplicates ? results : filterDuplicateResult(results,textarea._mIData.lyteMICollection));
                }
			};

			var trigerSearch = function(){
				var query = mIManager.currentDataQuery;
				if (((textarea._mIData.minChars == 0) || (query && query.length && query.length >= textarea._mIData.minChars))
					&& ((textarea._mIData.maxChars === Infinity) || (query && query.length && query.length <= textarea._mIData.maxChars))) {
      				var responseData = textarea._mIData.onDataRequest(query);
      				if(responseData){
  						if( responseData.then ) {
							Promise.resolve( responseData ).then( function( arg ) {
								if(data.dropbody === false) {
									if(!lyteMIList._appended){
								      	window._lyteUiUtils.appendChild(document.body, lyteMIList);
								      	lyteMIList._appended = true;
								    }
									var returnVal = data.displayMentions(arg, query, lyteMIList);
									var dropdown = $L(textarea._mIData.dropdown);
									if (dropdown.length) {
										dropdown.addClass('lyteMIHide');
										// onKeyUpOrDown(lyteMIList.querySelector('lyte-mentions-item'/*data.listItemTag*/));
										dropdown[0]._textarea = lyteMIList._textarea;
										positionDropdown(dropdown[0]);
										dropdown.removeClass('lyteMIHide');
									}
									else if (returnVal === undefined || returnVal) {
										if(returnVal === "bindClick"){
											textarea._mIData.validateCollections = true;
											var listItems = $L('lyte-mentions-item',lyteMIList);
											for(var i = 0; i<listItems.length; i++){
												listItems[i].addEventListener('click',onSelect,true);
											}
										}
										onKeyUpOrDown(lyteMIList.querySelector('lyte-mentions-item'/*data.listItemTag*/));
										$L(lyteMIList).addClass('lyteMIHide');
									    $L(lyteMIList).addClass('lyteMIDisplayBlock');
									    checkForMaxWidth(lyteMIList);
									    positionDropdown(lyteMIList);
									    $L(lyteMIList).removeClass('lyteMIHide');
									}
								} else {
									populateDropdown(arg);
								}
							}, function(e) {
								console.error(e);
							});
						} else {
							filterData(responseData);
						}
      				}
    			}
			};

			var scrollIntoView = function(parent, element, move ) {
				var offsetTop = element.offsetTop,
				scrollT = parent.scrollTop,
				height = parent.getBoundingClientRect().height,
				elementHeight = element.getBoundingClientRect().height;

				if( move === 'down' 
					&& scrollT + height < offsetTop + elementHeight 
				) {
					parent.scrollTop = parent.scrollTop + offsetTop + elementHeight - ( height + scrollT );
				}
				else if( move === 'up' 
						&& offsetTop < scrollT 
					) {
					parent.scrollTop = offsetTop
				}
			};

			var getElement = function(element, cond){
				var reqdEle = null, tag = element.tagName;
				if(cond == "next"){
					while(element.nextElementSibling){
						if(element.nextElementSibling.tagName === tag){
							reqdEle = element.nextElementSibling;
							break;
						}
						element = element.nextElementSibling;
					}
				}
				if(cond == "prev"){
					while(element.previousElementSibling){
						if(element.previousElementSibling.tagName === tag){
							reqdEle = element.previousElementSibling;
							break;
						}
						element = element.previousElementSibling;
					}
				}
				return reqdEle;
			};

			var getLastIndex = function(message, query){	//gets the particular word without space and returns the index of the query
				// var lastSpaceIndex = message.lastIndexOf(" ");
				// var msg = message.substring(lastSpaceIndex === -1 ? 0 : lastSpaceIndex+1);
					
				// 	// Scenarios to be considered -
				// 	// * Valid if only one @ is present and it is the first alphabet of the word. eg- @sam
				// 	// * Invalid if more than one @ is present.Dropdown should be hidden. eg- @sam@zoho
				// 	// * Invalid if there are more characters or alphabets before @. eg- random@sam
				
				// if((msg.match(new RegExp(query,"g")) || []).length == 1 && (msg.indexOf(query) == 0)){
				// 	return message.lastIndexOf(query);
				// }
				// console.log("from getLastIndex",message);
				var occurences = (message.match(new RegExp(query,"g")) || []).length;
				var lastIndex;
				var withSpace =  data.triggerWithSpace;
				while(occurences > 0 && message){
					lastIndex = message.lastIndexOf(query);
					if(lastIndex == 0){
						return lastIndex;
					}
					if(lastIndex > 0 && (!withSpace || (message.charAt(lastIndex - 1) == " ") || (message.charAt(lastIndex - 1) == "\n"))){
						return lastIndex;
					}
					message = message.substring(0,lastIndex);
					occurences = (message.match(new RegExp(query,"g")) || []).length;
				}
				return -1;
			};

			var omitMentionedFromTextInput = function(message){
				var mentions = textarea._mIData.lyteMICollection;
				if(mentions.length > 0){
					for(var i = mentions.length - 1; i >= 0; i--){
						if(mentions[i].position.end <= message.length){
							return message.substring(mentions[i].position.end);
						}
					}
				}
				return message;
			};


			var isValidQuery = function(query){
				/*Notes : here query.indexOf("\n") > -1 added to fix the currentDataQuery 
				example @someName \n someName here search should not be triggered.
				*/
				if((query.charAt(0) == " ") || (query.charAt(0) == "\n") || query.indexOf("\n") > -1){
					return false;
				}
				return true;
			};


			var triggerChangeEvt = function(textarea){
				var evt;
				if(typeof(Event) === 'function') {
				    evt = new Event('change');
				}else{
				    evt = document.createEvent('Event');
				    evt.initEvent('change', true, true);
				}
				textarea.dispatchEvent(evt);
			};


			var processMentions = function (value, markupIterator, textIterator) {
				var regex = new RegExp(textarea._mIData.triggerChar + "\\[(.+?)\\:(.+?)\\]", 'gi');
				regex = new RegExp(regex);
				var match;
				var start = 0;
				var currentTextIndex = 0;
				var offset = textarea._mIData.triggerChar.length + 1;
				while ((match = regex.exec(value)) !== null) {
					var id = match[2];
					var matchedValue = match[1];
					var substr = value.substring(start, match.index);
					textIterator(substr, start, currentTextIndex);
					currentTextIndex += substr.length
					markupIterator(match[0], match.index, currentTextIndex, id, matchedValue);
					currentTextIndex += matchedValue.length;
					start = regex.lastIndex;
				}

				if (start < value.length) {
					textIterator(value.substring(start), start, currentTextIndex);
				}
			};

			var extractPlainText = function (value) {
				var result = '';
				var textIteratorNew = function (matchedValue) {
					result += matchedValue;
				};
				var markupIteratorNew = function (markup, index, mentionTextIndex, id, text) {
					result += text;
				}
				processMentions(value, markupIteratorNew, textIteratorNew);
				return result;
			}
			var translateTextIndex = function (value, indexInText, operation) {
				if (typeof indexInText !== 'number') {
					return indexInText;
				}

				var result;
				var textIteratorNew = function (substr, index, substrTextIndex) {
					if (result !== undefined) {
						return;
					}
					if (substrTextIndex + substr.length >= indexInText) {
						result = index + indexInText - substrTextIndex;
					}
				}
				var markupIteratorNew = function (markup, index, mentionTextIndex, id, display) {
					if (result !== undefined) {
						return;
					}

					if (mentionTextIndex + display.length > indexInText) {
						if (!operation) {
							result = null;
						} else {
							result = index + (operation === 'end' ? markup.length : 0)
						}
					}
				}
				processMentions(value, markupIteratorNew, textIteratorNew);
				return result === undefined ? value.length : result;
			};
			var replaceTriggerTextWithMention = function (mentionObj) {
				var mentionText = textarea.value;


				if (textarea.tagName === 'LYTE-INPUT') {
					var input = textarea.querySelector('INPUT');
					textarea._selection = {
						start: input.selectionStart,
						end: input.selectionEnd
					}
					textarea.selectionEnd = input.selectionEnd;
					textarea.selectionStart = input.selectionStart;
					textarea.value = input.value;
				} else {
					textarea._selection = {
						start: textarea.selectionStart,
						end: textarea.selectionEnd
					}
				}
				var mentionValue = mentionObj[textarea._mIData.searchBy];
				var selectionEnd = textarea._selection.end;

				var index = -1;
				var triggerChar = textarea._mIData.triggerChar;
				for (let i = selectionEnd - 1; i >= 0; i--) {
					if (mentionText[i] === triggerChar) {
						index = i; // Return the index of the closest triggerChar to the left
					}
				}
				if (index > -1) {
					var removeHighlightCompletely = textarea._mIData.removeHighlightCompletely;
					var triggerText = mentionText.substring(index + 1, selectionEnd);
					var part1 = mentionText.slice(0, index);
					var part2 = mentionText.slice(index + 1 + triggerText.length);
					mentionText = part1 + mentionValue + part2;
					mIManager.currentDataQuery = triggerText;
					if (removeHighlightCompletely) {
						mention = copyObject(mentionObj);
						textarea._addedMentions = true;
						var appendSpaceOnAdd = textarea._mIData.appendSpaceOnAdd;
						var str = textarea._valueMap.oldSyntax;
						var startCaretPosition = textarea.selectionEnd - mIManager.currentDataQuery.length - 1;
						var currentCaretPosition = textarea.selectionEnd;
						// var start = index;
						var start = translateTextIndex(str, startCaretPosition, 'start');

						var end = start + currentCaretPosition - startCaretPosition;
						var insert = textarea._mIData.triggerChar + mIManager.mentionsSyntax({ id: mention.id, value: mention[textarea._mIData.searchBy] }) + (appendSpaceOnAdd ? " " : "");
						var newValue = str.substring(0, start) + insert + str.substring(end);
						// var newText = mentionText;
						var newText = extractPlainText(newValue);
						if (textarea._mIData.onBeforeAdd && callOnBeforeAdd(textarea._mIData, data, newText) === false) {
							// hideDropdown();
							return;
						}
						textarea._valueMap.newSyntax = newValue;
						addToCollections(mention, startCaretPosition);
						// if(newText !=  textarea.value) {

						resetBuffer();
						mIManager.currentDataQuery = '';
						// hideDropdown();

						textarea.value = newText;
						if (textarea.tagName === 'LYTE-INPUT') {
							textarea.component.setData('ltPropValue', newText)
						}
						updateAdvancedCollections(newValue);
						advancedModifyNodeContent(newText);

						var end = mention.position.end + (appendSpaceOnAdd ? 1 : 0);// 1 for space
						triggerChangeEvt(textarea);
						// textarea.focus();
						setTimeout(function () {
							mIManager.setCaratPosition(textarea, end);
							if (textarea.tagName === 'LYTE-INPUT') {
								var input = textarea.querySelector('INPUT');
								textarea._selection = {
									start: input.selectionStart,
									end: input.selectionEnd
								}
								textarea.selectionEnd = input.selectionEnd;
								textarea.selectionStart = input.selectionStart;
								textarea.value = input.value;
							} else {
								textarea._selection = {
									start: textarea.selectionStart,
									end: textarea.selectionEnd
								}
							}
						}, 10);

						if (textarea._mIData.onAdd) {
							callOnAdd(textarea._mIData, data);
						}
					} else {
						updateCollection(mentionObj);
					}
				}
				triggerChangeEvt(textarea);
				var evt;
				if (typeof (Event) === 'function') {
					evt = new Event('change');
				} else {
					evt = document.createEvent('Event');
					evt.initEvent('change', true, true);
				}
				textarea.dispatchEvent(evt);
				textarea.focus();
			}

			/*--------------------------- UTILITY FUNCTIONS END ----------------------------*/

			/*--------------------------- INITIALIZATION STARTS -------------------------*/

			if(typeof object === "string"){
				
				if(object === "setMessage"){

					textarea =  this.length > 0 ? (this[0].tagName === "LYTE-INPUT" && this[0].ltProp('type') == "textarea" ? this[0].querySelector('textarea') : this[0]) : null;
					if(textarea && textarea.getAttribute('data-lyte-mentions')){
						if(typeof arguments[1] === "object"){
							if(textarea.value){
								this.mentionsInput('reset');
							}
							var message = arguments[1].message;
							var mentionText = message;
							var collection = arguments[1].collection ? arguments[1].collection : textarea._mIData.onDataRequest();
							var newCollection = [],
							msgArr = [],
							currMsg = message;
							collection.forEach(function(mention){
								mention = copyObject(mention);
								var mentionObj = {id : mention.id, value : mention[textarea._mIData.searchBy]};
								var textSyntax = textarea._mIData.triggerChar+mIManager.mentionsSyntax(mentionObj);
								var index = message.indexOf(textSyntax);
		        	
								if(index != -1){
									var ind = currMsg.indexOf(textSyntax);
									msgArr.push(currMsg.substring(0,ind));
									currMsg = currMsg.substring(ind+textSyntax.length);

									mention.position = {start : index, end : index + mentionObj.value.length};
									newCollection.push(mention);
									var textHighlight = "<strong class='lyteMentionsStrongDiv'><span>"+mentionObj.value.replace(/&/g,"&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")+"</span></strong>";
									message = message.replace(textSyntax,mentionObj.value);
									mentionText = mentionText.replace(textSyntax,textHighlight);
									msgArr.push(textHighlight);
								}
							});
							
							msgArr.push(currMsg);
								mentionText = mentionText.replace(/\n/g, '<br />');
						    mentionText = mentionText.replace(/ {2}/g, '&nbsp; ');
						    if(textarea._callee && textarea._callee.tagName == "LYTE-INPUT"){
						    	textarea._callee.ltProp('value',message);
						    }
						    else{
						    	textarea.value = message;
						    }
						    textarea._mIData.syntaxMessage = arguments[1].message + " ";
						    // textarea._mIData._overlayDiv.innerHTML = mentionText;
						    msgArr.forEach(function(text,index){
						    	
						    	if(index%2 == 0){
						    		var textNode = document.createTextNode(text);
						    		textarea._mIData._overlayDiv.appendChild(textNode);
						    	}
						    	else{
						    		textarea._mIData._overlayDiv.innerHTML = textarea._mIData._overlayDiv.innerHTML + text;
						    	}
						    });
						    textarea._mIData.lyteMICollection = newCollection;
						    triggerChangeEvt(textarea);
							if(textarea._mIData.removeHighlightCompletely){
								textarea._valueMap = {
									oldSyntax: arguments[1].message,
									oldText: message
								};
							}
						 //    var evt;
							// if(typeof(Event) === 'function') {
							//     evt = new Event('change');
							// }else{
							//     evt = document.createEvent('Event');
							//     evt.initEvent('change', true, true);
							// }
							// textarea.dispatchEvent(evt);
							textarea.focus();	
						}
						else{

							if(!textarea){
							console.error("Element doesnt exist.Please check.");
							return null;
						}
							console.error("Inappropriate arguments passed. Please pass an object containing a message and a collection to be set.");
							return null;
						}
					}
					else{
						console.error(this + " is not Initialized using lyte-mentions plugin.Please check.");
						return null;
					}
				}

				if(object === "getMessage"){

					textarea =  this.length > 0 ? (this[0].tagName === "LYTE-INPUT" && this[0].ltProp('type') == "textarea" ? this[0].querySelector('textarea') : this[0]) : null;
					if(textarea && textarea.getAttribute('data-lyte-mentions')){
						return (textarea._mIData.syntaxMessage ? textarea._mIData.syntaxMessage : textarea.value);
					}
					else{
						if(!textarea){
							console.error("Element doesnt exist.Please check.");
							return null;
						}
						console.error(this + " is not Initialized using lyte-mentions plugin.Please check.");
						return null;
					}
				}

				if(object === "getCollection"){

					textarea =  this.length > 0 ? (this[0].tagName === "LYTE-INPUT" && this[0].ltProp('type') == "textarea" ? this[0].querySelector('textarea') : this[0]) : null;
					if(textarea && textarea.getAttribute('data-lyte-mentions')){
						return textarea._mIData.lyteMICollection;
					}
					else{
						if(!textarea){
							console.error("Element doesnt exist.Please check.");
							return null;
						}
						console.error(this + " is not Initialized using lyte-mentions plugin.Please check.");
						return null;
					}
				}

				if(object === "destroy"){

					textarea =  this.length > 0 ? (this[0].tagName === "LYTE-INPUT" && this[0].ltProp('type') == "textarea" ? this[0].querySelector('textarea') : this[0]) : null;
					if(textarea && textarea.getAttribute('data-lyte-mentions')){
						textarea.removeAttribute('data-lyte-mentions');
						if(textarea._mIData.removeHighlightCompletely) { 
							textarea.removeEventListener('mouseup',textarea._lyteMenIpMouseUpEvent);
							delete textarea._lyteSetSelection;
							delete textarea._lyteMenIpMouseUpEvent;
						}
						if(textarea.scrollableParents && textarea._scrollDisabled) {
							disableParentListeners(textarea);
						}
						var wrapper = textarea.parentElement;
						window._lyteUiUtils.insertBefore(wrapper,textarea);
						textarea._mIData._overlayDiv = null;
						textarea._mIData.lyteMIList.removeEventListener('scroll', textarea._mIData.lyteMIList._lyteMentionScrollDropDown);
						delete textarea._mIData.lyteMIList._lyteMentionScrollDropDown;
						textarea._mIData.lyteMIList._textarea = null;
						textarea._mIData.element = null;
						textarea._mIData.lyteMIList.remove();
						textarea._mIData.lyteMIList = null;
						textarea._mIData = null;
						wrapper.remove();
						textarea.removeEventListener('keydown', textarea._lyteMenIpKeydownEvent);
				    	textarea.removeEventListener('keypress', textarea._lyteMenIpKeypressEvent);
						textarea.removeEventListener('input', textarea._lyteMenIpInputEvent);
						textarea.removeEventListener('click', textarea._lyteMenIpOnClickEvent);
				    	// textarea.removeEventListener('click', textarea._lyteMenIpClickEvent, true);
				    	// textarea.removeEventListener('blur', textarea._lyteMenIpBlurEvent);
				    	textarea.removeEventListener('paste', textarea._lyteMenIpPasteEvent);
				    	textarea.removeEventListener('input',textarea._closureEvnt);
				    	textarea.removeEventListener('change',textarea._closureEvnt);
						delete textarea._prevSelectionStart;
				    	delete textarea._lyteMenIpKeydownEvent;
				    	delete textarea._lyteMenIpKeypressEvent;
						delete textarea._lyteMenIpInputEvent;
						delete textarea._lyteMenIpOnClickEvent;
				    	delete textarea._lyteMenIpClickEvent;
				    	delete textarea._lyteMenIpBlurEvent;
				    	delete textarea._closureEvnt;
						delete textarea._lyteMenIpPasteEvent;
						delete textarea._valueMap;
						delete textarea._selection;
						delete textarea._mIData;
						delete textarea._lytePosDropdown;
						delete textarea._lyteHideDropdown;
						delete textarea.triggerInputEvent;
						delete textarea._lyteDisableParentScrollListeners;
				    	if(mIManager.bindResize && document.querySelectorAll('textarea[data-lyte-mentions="true"]').length == 0){
				    		document.removeEventListener('resize', mIManager.callAtTheEndOfResize);
				    		mIManager.bindResize = false;
				    	}
				    	if(mIManager.bindClick && document.querySelectorAll('textarea[data-lyte-mentions="true"]').length == 0){
				    		document.body.removeEventListener('click', mIManager.onClick, true);
							mIManager.onClick = null;
				    		mIManager.bindClick = false;
				    	}
				    	if(mIManager.bindScroll && document.querySelectorAll('textarea[data-lyte-mentions="true"]').length == 0){
				    		document.removeEventListener('scroll', mIManager.onScroll, true);
							mIManager.onScroll = null;
				    		mIManager.bindScroll = false;
				    	}
						if(mIManager.bindSelect && document.querySelectorAll('textarea[data-lyte-mentions="true"]').length == 0){
				    		document.body.removeEventListener('selectionchange', mIManager.onSelection, true);
							mIManager.onSelection = null;
				    		mIManager.bindSelect = false;
				    	}
					}
					else{
						if(!textarea){
							console.error("Element doesnt exist.Please check.");
							return null;
						}
						console.error(this + " is not Initialized using lyte-mentions plugin.Please check.");
						return null;
					}
				}

				if(object === "reset"){

					textarea =  this.length > 0 ? (this[0].tagName === "LYTE-INPUT" && this[0].ltProp('type') == "textarea" ? this[0].querySelector('textarea') : this[0]) : null;
					if(textarea && textarea.getAttribute('data-lyte-mentions')){
						if(textarea._callee && textarea._callee.tagName == "LYTE-INPUT"){
					    	textarea._callee.ltProp('value', '');
					    }
					    else{
					    	textarea.value = '';
					    }
						if(textarea._mIData.removeHighlightCompletely){
							textarea._valueMap = {
								newText : "",
								newSyntax: ""
							};
							updateAdvancedCollections("");
							advancedModifyNodeContent("");
						}
						else {
							modifyNodeContent();
							updatelyteMICollection();
						}
						triggerChangeEvt(textarea);
						// var evt;
						// if(typeof(Event) === 'function') {
						//     evt = new Event('change');
						// }else{
						//     evt = document.createEvent('Event');
						//     evt.initEvent('change', true, true);
						// }
						// textarea.dispatchEvent(evt);
					}
					else{
						if(!textarea){
							console.error("Element doesnt exist.Please check.");
							return null;
						}
						console.error(this + " is not Initialized using lyte-mentions plugin.Please check.");
						return null;
					}
				}

				if (object === "setMention") {
					textarea = this.length > 0 ? (this[0].tagName === "LYTE-INPUT" && this[0].ltProp('type') == "textarea" ? this[0].querySelector('textarea') : this[0]) : null;
					if (textarea && textarea.getAttribute('data-lyte-mentions')) {
						if (typeof arguments[1] === "object") {
							var mentionId = arguments[1].id;
							var allMentionData = textarea._mIData.onDataRequest();

							// If Promise - resolve and get data
							// else get data directly
							if (allMentionData.then) {
								try {
									Promise.resolve(allMentionData).then(function (allMentionData) {
										var mentionObj = allMentionData.find(item => item.id == mentionId);
										if (mentionObj) {
											replaceTriggerTextWithMention(mentionObj);
										}
									})
								} catch (error) {
									console.error(error);
									return;
								}
							} else {
								mentionObj = allMentionData.find(item => item.id == mentionId);
								if (mentionObj) {
									replaceTriggerTextWithMention(mentionObj);
								}
							}
						}
						else {

							if (!textarea) {
								console.error("Element doesnt exist.Please check.");
								return null;
							}
							console.error("Inappropriate arguments passed. Please pass an object containing a message and a collection to be set.");
							return null;
						}
					}
					else {
						console.error(this + " is not Initialized using lyte-mentions plugin.Please check.");
						return null;
					}
				}
				return true;
			}
			var data = object ? object : {};
			var element;

			if(this.length > 1){
				var elemArray = this;
				for(var i=0; i<elemArray.length; i++){
					if(elemArray[i].tagName == "LYTE-INPUT" && elemArray[i].ltProp('type') == "textarea"){
						var elem = elemArray[i].querySelector('textarea');
						var copyData = Object.assign({},data);
						copyData.isLyteInput = true;
						$L(elem).mentionsInput(Object.assign({},copyData));
					}
					else{
						$L(elemArray[i]).mentionsInput(Object.assign({},data));
					}
					
				}
				return;
			}
			else{
				if(this[0].tagName == "LYTE-INPUT"){
					if(this[0].ltProp('type') == "textarea"){
						element = this[0].querySelector('textarea');
						data.isLyteInput = true;
					}else if(this[0].ltProp('type') == "input"){
						element = this[0].querySelector('input');
						data.isLyteInput = true;
					}
					
				}
				else{
					element = this[0];
				}
			}
			if(element.getAttribute('data-lyte-mentions')){
				if(element._mIData){
					element._mIData.mode = data.mode ? data.mode : element._mIData.mode;
					element._mIData.activeItem = data.activeItem ? data.activeItem : element._mIData.activeItem;
					element._mIData.triggerChar = data.triggerChar ? data.triggerChar : element._mIData.triggerChar;
					element._mIData.minChars = data.minChars == undefined ? element._mIData.minChars : parseInt(data.minChars);
					element._mIData.maxChars = data.maxChars === undefined ? element._mIData.maxChars : parseInt(data.maxChars);
					element._mIData.avatars = data.avatars == undefined ? element._mIData.avatars : data.avatars;
					element._mIData.searchBy = data.searchBy ? data.searchBy : element._mIData.searchBy;
					element._mIData.dropbody = data.dropbody == undefined ? element._mIData.dropbody : data.dropbody;
					element._mIData.listItemTag = data.listItemTag == undefined ? element._mIData.listItemTag : data.listItemTag;
					element._mIData.interval = data.interval ? parseInt(data.interval) : element._mIData.interval;
					element._mIData.onDataRequest = data.onDataRequest ? data.onDataRequest : element._mIData.onDataRequest;
					element._mIData.onAdd = data.onAdd ? data.onAdd : element._mIData.onAdd;
					element._mIData.onBeforeAdd = data.onBeforeAdd ? data.onBeforeAdd : element._mIData.onBeforeAdd;
					element._mIData.onRemove = data.onRemove ? data.onRemove : element._mIData.onRemove;
					element._mIData.alwaysCallOnReomve = data.alwaysCallOnReomve ? data.alwaysCallOnReomve : element._mIData.alwaysCallOnReomve;
					element._mIData.displayMentions = data.displayMentions ? data.displayMentions : element._mIData.displayMentions;
					element._mIData.onHide = data.onHide ? data.onHide : element._mIData.onHide;
					element._mIData.removeEntireMentionOnBackspace = data.removeEntireMentionOnBackspace ? data.removeEntireMentionOnBackspace : element._mIData.removeEntireMentionOnBackspace;
					element._mIData.dropdown = data.dropdown ? data.dropdown : '';
				}
				else{
					element._mIData = data;
					console.error("ALERT ! You are trying to bind mentions behaviour to a textarea which already has it enabled. Please don't call it twice to avoid abnormal behaviour.");
				}
				return this;
			}
			element.setAttribute('data-lyte-mentions',true);
			//Initialize values
			data.element = element;
			data.mode = data.mode ? data.mode : "contains"; //contains,startsWith, endsWith
			data.activeItem = data.activeItem ? data.activeItem : "lyteMIActive";
			data.triggerChar = data.triggerChar ? data.triggerChar : '@';
			data.minChars = data.minChars == undefined ? 1 : parseInt(data.minChars);
			data.maxChars = data.maxChars === undefined ? Infinity : parseInt(data.maxChars);
			data.avatars = data.avatars == undefined ? true : data.avatars;
			data.searchBy = data.searchBy ? data.searchBy : "name";
			data.lyteMICollection = [];
			data.dropbody = data.dropbody == undefined ? true : data.dropbody;
			data.listItemTag = data.listItemTag == undefined ? 'li' : data.listItemTag;
			data.interval = data.interval ? parseInt(data.interval) : 0;
			data.allowDuplicates = data.allowDuplicates ? true : false;
			data.removeHighlightCompletely = data.removeHighlightCompletely? true : false;
			data.triggerWithSpace =  data.triggerWithSpace === undefined? true : data.triggerWithSpace;
			data.appendSpaceOnAdd = data.appendSpaceOnAdd === undefined? true : data.appendSpaceOnAdd;
			data.dropdownClass =  data.dropdownClass === undefined ? "" : data.dropdownClass;
			data.preventParentScroll = data.preventParentScroll === undefined ? false : data.preventParentScroll;
			data.onEscapeClose = data.onEscapeClose == undefined ? true : data.onEscapeClose;
			data.alwaysCallOnReomve = data.alwaysCallOnReomve == undefined ? false : data.alwaysCallOnReomve;
			data.removeEntireMentionOnBackspace = data.removeEntireMentionOnBackspace ? true : false;
			data.dropdown = data.dropdown ? data.dropdown : '';

			var clickEvent = function (event) {
				resetBuffer();
			};
			var inputClickEvent = function (event) {
				textarea = this;
				var cursor = event.target.selectionStart;
				var mention;
				for (var i = 0; i < textarea._mIData.lyteMICollection.length; i++) {
					// textarea._mIData.lyteMICollection.forEach(function (mention) {
					var mentionItem = textarea._mIData.lyteMICollection[i];
					var menPosition = mentionItem.position;
					var startPos = menPosition.start;
					var endPos = menPosition.end;
					if (cursor <= endPos && cursor >= startPos) {
						mention = mentionItem;
					}
				}
				if (textarea._mIData.onClick) {
					textarea._mIData.onClick(event, mention);
				}
				return true;
			};
			var inputEvent = function(event){
				textarea = this;
				var input;
				if (this.tagName === 'LYTE-INPUT') {
					input = this.querySelector('INPUT');
					textarea.selectionEnd = input.selectionEnd;
					textarea.selectionStart = input.selectionStart;
					textarea.value = input.value;
				}
				lyteMIList = textarea._mIData.lyteMIList;
				// console.log("inputEvent",cursorPos.prev,event);
				if(textarea._mIData.removeHighlightCompletely) {
					var skipUpdate;
					var valueMap = textarea._valueMap;
					if(valueMap.undoAndRedo){
						if(valueMap.oldText === textarea.value) {
							skipUpdate = true;
						}
						delete valueMap.undoAndRedo;
					} ;
					var selection = textarea._selection;
					var range = {
						start : selection.start,
						end : selection.end,
						currentEnd : textarea.selectionEnd
					};
					var returnValue = skipUpdate ?{newValue:valueMap.oldSyntax}:updateMentions(textarea.value,range);
					var newMappedValue = returnValue.newValue;
					var selectionEnd = returnValue.selectionEnd;
					valueMap.newSyntax = newMappedValue;
					var newText = getText(newMappedValue);
					var removed = updateAdvancedCollections(newMappedValue);
					advancedModifyNodeContent(newText);
					if(removed) {
						textarea.value = newText;
						if (this.tagName === 'LYTE-INPUT') {
							this.setData('ltPropValue', newText);
						}
						setSelectionPosition(selectionEnd);
					}
					setSelection(textarea);
				}
				else {
					var selection = textarea._selection;
					var range = {
						start : selection.start,
						end : selection.end,
						currentEnd : textarea.selectionEnd
					};	
					updateMentionsposition(range);
					modifyNodeContent();
				}
				if(textarea._mIData.dropbody || textarea._mIData.validateCollections || data.alwaysCallOnReomve){
					!data.removeHighlightCompletely && updatelyteMICollection();
				}
				 // updateCollectionPosition(textarea);
	        	 hideDropdown();
	        	 getInputBuffer(textarea);
	        	 // console.log("input",mIManager.inputBuffer);
	        	 // var triggerCharIndex = findLastIndex(mIManager.inputBuffer, textarea._mIData.triggerChar); //Returns the last match of the triggerChar in the inputBuffer
	        	 var triggerCharIndex = getLastIndex(mIManager.inputBuffer.join(''), textarea._mIData.triggerChar);
	        	 if (triggerCharIndex > -1 && isValidQuery(mIManager.inputBuffer.slice(triggerCharIndex + 1).join(''))) { //If the triggerChar is present in the inputBuffer array
					 if (mIManager.searchTriggeredId) {
						 clearTimeout(mIManager.searchTriggeredId);
						 mIManager.searchTriggeredId = false;
					 }
	        	 	mIManager.searchTriggeredId = setTimeout(function(){
	        	 		mIManager.searchTriggeredId = false;
	        	 		currentDataQuery = mIManager.inputBuffer.slice(triggerCharIndex + 1).join(''); //Gets the currentDataQuery
		        	    mIManager.currentDataQuery = currentDataQuery/*mIManager.ltrim(currentDataQuery)*/; //Deletes the whitespaces
		        	    // console.log("before requesting",mIManager.currentDataQuery);
		        	    trigerSearch(); //Invoking the function trigerSearch
	        	 	},textarea._mIData.interval);
	        	 }
	        	 else{
	        	 	if(mIManager.searchTriggeredId){
	        	 		clearTimeout(mIManager.searchTriggeredId);
	        	 		mIManager.searchTriggeredId = false;
	        	 	}
	        	 }
			};

			var getInputBuffer = function(textarea){
				var currentMessage = textarea.value || "";
				mIManager.inputBuffer = [];
				// var typedValue = event.key/*String.fromCharCode(event.which || event.keyCode)*/;
				if(textarea.selectionStart < textarea.selectionEnd/* && typedValue*/){
					currentMessage = currentMessage.substring(0,textarea.selectionStart);
					// mIManager.inputBuffer = [];
				}
				currentMessage = omitMentionedFromTextInput(currentMessage.substring(0,textarea.selectionEnd))/* + typedValue*/;
				// console.log("message in keypress",currentMessage);
				var triggerCharIndex = getLastIndex(currentMessage, textarea._mIData.triggerChar)/*currentMessage.lastIndexOf(textarea._mIData.triggerChar)*/;
				if(triggerCharIndex > -1){
					var bufferMessage = currentMessage.substring(triggerCharIndex)/* + typedValue*/;
					mIManager.inputBuffer = bufferMessage.split("");
				}
			};
			var initializeSelection= function() {
				if(!mIManager.bindSelect) {
					mIManager.onSelection = function(){
						var activeElement = document.activeElement;
						if(activeElement.getAttribute("data-lyte-mentions")) {
							activeElement._lyteSetSelection(activeElement);
						}
					};
					document.body.addEventListener('selectionchange',mIManager.onSelection,true);
					mIManager.bindSelect = true;
				}
			};
			var keypressEvent = function(event){
				textarea = this;
				// console.log("calling from key press"+mIManager.inputBuffer+"===="+String.fromCharCode(event.which || event.keyCode))
				var KEY = mIManager.KEY;
				if((event.keyCode === KEY.LEFT && event.key !== "%") || (event.keyCode === KEY.RIGHT && event.key !== "'") || (event.keyCode === KEY.HOME && event.key !== "$") || (event.keyCode === KEY.END && event.key !== "#") || (event.keyCode === KEY.UP && event.key !== "&") || (event.keyCode === KEY.DOWN && event.key !== "(") || event.keyCode === KEY.BACKSPACE || event.keyCode === KEY.TAB || event.keyCode === KEY.RETURN || event.keyCode === KEY.ESC || event.key === "Shift" || event.key == "Control" || event.key == "Alt" || event.key == "Meta"){
					return;
				}
				// if(mIManager.inputBuffer.length != 0 || (mIManager.inputBuffer.length == 0 && textarea.selectionStart == 0) || textarea._addedMentions){
					// var typedValue = event.key/*String.fromCharCode(event.which || event.keyCode)*/;
    //   				mIManager.inputBuffer.push(typedValue);
    //   				textarea._addedMentions = false;
    //   				console.log("pushing it",mIManager.inputBuffer);
				// }
				// else{	//when the cursor is taken out of the textarea and again it is cliked to type any alphabet
					// console.log("calling it",mIManager.inputBuffer);
					var currentMessage = textarea.value || "";
					var typedValue = event.key/*String.fromCharCode(event.which || event.keyCode)*/;
					if(textarea.selectionStart < textarea.selectionEnd && typedValue){
						currentMessage = currentMessage.substring(0,textarea.selectionStart) + typedValue;
						mIManager.inputBuffer = [];
					}
					currentMessage = omitMentionedFromTextInput(currentMessage.substring(0,textarea.selectionStart)) + typedValue;
					// console.log("message in keypress",currentMessage);
					var triggerCharIndex = getLastIndex(currentMessage, textarea._mIData.triggerChar)/*currentMessage.lastIndexOf(textarea._mIData.triggerChar)*/;
					if(triggerCharIndex > -1){
						var bufferMessage = currentMessage.substring(triggerCharIndex)/* + typedValue*/;
						mIManager.inputBuffer = bufferMessage.split("");
					}
				// }
			};

			var keydownEvent = function(event){
				textarea = this;
				var KEY = mIManager.KEY;
				if(data.onEscapeClose && event.keyCode == KEY.ESC){
					hideDropdown(event.target);
				}
				// This also matches HOME/END on OSX which is CMD+LEFT, CMD+RIGHT
	            if (event.keyCode === KEY.LEFT || event.keyCode === KEY.RIGHT || event.keyCode === KEY.HOME || event.keyCode === KEY.END) {
	                // Defer execution to ensure carat pos has changed after HOME/END keys then call the resetBuffer function
	                // _.defer(resetBuffer);
	                postpone(resetBuffer);

	                return;
	            }
				// if(data.removeHighlightCompletely) {
					setSelection(textarea);
				// }
	            //If the key pressed was the backspace or cut(ctrl+x or cmd+x) or 
	            //to clear the text to ths left of the cursor in that line by pressing cmd+backspace in mac
	            if (event.keyCode === KEY.BACKSPACE || ((event.metaKey || event.ctrlKey) && event.keyCode == 88)) {
	            	var length = textarea.selectionStart - textarea.selectionEnd;
	            	// var userDeleted = checkForDeletedUser(textarea);
	            	// if(userDeleted){
	            	// 	event.preventDefault();
	            	// }
					// console.log("keydown delete or remove",textarea.selectionStart,textarea.selectionEnd);
	            	if(Math.abs(length) > mIManager.inputBuffer.length || (event.metaKey && (event.keyCode === KEY.BACKSPACE))/* || userDeleted*/){
						mIManager.inputBuffer = [];
	            	}
	            	else{
	            		mIManager.inputBuffer = mIManager.inputBuffer.slice(0, (length == 0 ? -1 : length) + mIManager.inputBuffer.length); // Can't use splice, not available in IE
	            	} 
	                return;
	            }

	            //if key pressed is undo(ctrl+z or cmd+z), then hide the dropdown and empty the inputBuffer
	            if(((event.metaKey || event.ctrlKey) && event.keyCode == 90)){
					if(data.removeHighlightCompletely) {
						textarea._valueMap.undoAndRedo = true;
					}
	            	resetBuffer();
	            }

	            //If the lyteMIList is hidden
	            if(!lyteMIList){
	            	lyteMIList = textarea._mIData.lyteMIList;
	            }
	            if ($L(lyteMIList).css("display") != "block") {
	            	// keypressEvent.call(this, event);
	                return ;
	            }

	            switch (event.keyCode) {
	                case KEY.UP: //If the key pressed was UP or DOWN
	                case KEY.DOWN:
	                    var lyteMICurrentItem = null, move;
	                    if (event.keyCode === KEY.DOWN) { //If the key pressed was DOWN
	                        if (lyteMIActiveItem && lyteMIActiveItem.length) { //If lyteMIActiveItem exits
	                        	lyteMICurrentItem = getElement(lyteMIActiveItem[0], "next"); //Gets the next li element in the list
	                            // lyteMICurrentItem = lyteMIActiveItem[0].nextElementSibling; 
	                        	move = "down";
	                        } else {
	                            lyteMICurrentItem = lyteMIList.querySelector('lyte-mentions-item'/*textarea._mIData.listItemTag*/); //Gets the first li element found
	                        	move = "up";
	                        }
	                    } else {
	                    	lyteMICurrentItem = getElement(lyteMIActiveItem[0], "prev"); //The key pressed was UP and gets the previous li element
	                        // lyteMICurrentItem = lyteMIActiveItem[0].previousElementSibling; 
	                    	move = "up";
	                    }
	                    if (lyteMICurrentItem) {
	                        onKeyUpOrDown(lyteMICurrentItem);
	                        scrollIntoView(lyteMIList, lyteMICurrentItem, move);
	                    }
	                    event.preventDefault();
	                    event.stopPropagation();
	                    break;
	                case KEY.RETURN: //If the key pressed was RETURN or TAB
	                case KEY.TAB:
	                    if (lyteMIActiveItem && lyteMIActiveItem.length) {
				            // lyteMIActiveItem[0].click();
				            lyteMIActiveItem[0].dispatchEvent(new Event('click'));
				            event.preventDefault();
				            event.stopPropagation();
				          }
	                	break;
	                // default:
	                // 	keypressEvent.call(this, event);
	            }
	            return;
			};

			var blurEvent = function(event){
				hideDropdown(event.target);
			};

			var mouseoverEvent = function(event){
				textarea = window._lyteUiUtils.getCurrentTarget( event )._textarea;
				var target = event.target.closest('lyte-mentions-item'/*textarea._mIData.listItemTag*/);
				onKeyUpOrDown(target);
			};

			var setSelection = function (textarea) {
				if (textarea.tagName === 'LYTE-INPUT') {
					var input = textarea.querySelector('INPUT');
					textarea._selection = {
						start: input.selectionStart,
						end: input.selectionEnd
					}
					textarea.selectionEnd = input.selectionEnd;
					textarea.selectionStart = input.selectionStart;
					textarea.value = input.value;
				} else {
					textarea._selection = {
						start: textarea.selectionStart,
						end: textarea.selectionEnd
					}
				}
			};

			var iterateMentions = function(value, markupIterator, textIterator) {
				var regex = new RegExp(textarea._mIData.triggerChar+"\\[(.+?)\\:(.+?)\\]",'gi');
				regex =  new RegExp(regex);
				var match;
				var start = 0;
				var currentTextIndex = 0;
				var offset = textarea._mIData.triggerChar.length + 1;
				while ((match = regex.exec(value)) !== null) {
					var id = match[2];
					var matchedValue = match[1];
					var substr = value.substring(start, match.index);
					textIterator(substr, start, currentTextIndex);
					currentTextIndex += substr.length
					markupIterator(match[0],match.index,currentTextIndex,id,matchedValue);
					currentTextIndex += matchedValue.length;
					start = regex.lastIndex;
				}

				if (start < value.length) {
					textIterator(value.substring(start), start, currentTextIndex);
				}
			};

			var getText = function(value) {
				var result = '';
				var textIterator = function(matchedValue) {
					result += matchedValue;
				};
				var markupIterator = function(markup,index,mentionTextIndex,id,text) {
					result += text;
				}
				iterateMentions(value,markupIterator,textIterator);
				return result;
			}
			var mapTextIndex = function(value, indexInText, operation){
				if (typeof indexInText !== 'number') {
				  return indexInText;
				}
			  
				var result;
				var textIterator = function(substr, index, substrTextIndex) {
				  if (result !== undefined) {
					return;
				  } 
				  if (substrTextIndex + substr.length >= indexInText) {
					result = index + indexInText - substrTextIndex;
				  }
				}
				var markupIterator = function(markup,index,mentionTextIndex,id,display) {
				  if (result !== undefined){
					return;
				  } 
			  
				  if (mentionTextIndex + display.length > indexInText) {
					if (!operation) {
						result = null;
					} else {
					  result = index + (operation === 'end' ? markup.length : 0)
					}
				  }
				}
				iterateMentions(value, markupIterator, textIterator);
				return result === undefined ? value.length : result;
			};

			var updateMentions = function( newText, range) {
				var valueMap = textarea._valueMap;
				var oldText = valueMap.oldText;
				var oldSyntaxString = valueMap.oldSyntax;
				var prevStart = range.start,
				prevEnd = range.end,
				currentEnd = range.currentEnd;
				var delta  = oldText.length -  newText.length;
				// console.log(prevStart,prevEnd,currentEnd);
				if (prevStart === undefined) {
					prevStart = currentEnd + delta;
				}

				if (prevEnd === undefined) {
					prevEnd = prevStart;
				}

				if (prevStart === prevEnd && prevEnd === currentEnd && oldText.length === newText.length) {
					prevStart = prevStart - 1;
				}
				
				
				var insert = newText.slice(prevStart, currentEnd);
				var start = Math.min(prevStart, currentEnd);
				var end = prevEnd;
				if (prevStart === currentEnd) {
					end = Math.max(prevEnd, prevStart + delta);
				}

				var mappedStart = mapTextIndex(oldSyntaxString, start, 'start');
				var mappedEnd = mapTextIndex(oldSyntaxString, end, 'end');
				var mismatchedStart = mapTextIndex(oldSyntaxString, start);
				var mismatchedEnd = mapTextIndex(oldSyntaxString, end);
				var willRemove = mismatchedStart === null || mismatchedEnd === null;
				var newValue = oldSyntaxString.substring(0, mappedStart) + insert + oldSyntaxString.substring(mappedEnd);
				var returnObject = {};
				//TO handle undo and redo mismatch.
				var oldTextValue = getText(oldSyntaxString.substring(0, mappedStart));
				returnObject.selectionEnd = oldTextValue.length +  insert.length;
				if(!willRemove) {
					var mismatchedValue = getText(newValue);
					var maxCount = 50;
					var loopCount = 0;
					while (mismatchedValue !== newText && loopCount <= maxCount ) {
						start = 0;
						while (newText[start] === mismatchedValue[start]){
							start++;
						}
						insert = newText.slice(start, currentEnd);

						// find index of the unchanged remainder
						end = oldText.lastIndexOf(newText.substring(currentEnd));

						// re-map the corrected indices
						mappedStart = mapTextIndex(oldSyntaxString, start, 'start');
						mappedEnd = mapTextIndex(oldSyntaxString, end, 'end');
						newValue = oldSyntaxString.substring(0, mappedStart) + insert + oldSyntaxString.substring(mappedEnd);
						mismatchedValue = getText(newValue);
						loopCount++;
					}
					if(loopCount > maxCount) {
						console.warn("lyte mentionsInput match failed");
					}
				}
				returnObject.newValue = newValue;
				return returnObject;
			};

			var mouseupEvent = function(event){
				setSelection(event.target);
			};

			var pasteEvent = function(event){
				textarea = this;
				// console.log("pasteEvent",textarea.selectionStart,textarea.selectionEnd);
				if(textarea.selectionStart == textarea.selectionEnd){
					// var paste = textarea.value + (event.clipboardData || window.clipboardData).getData('text');
					var paste = omitMentionedFromTextInput(textarea.value) + (event.clipboardData || window.clipboardData).getData('text');
				}
				else{
					var paste = textarea.value.substring(0,textarea.selectionStart) + (event.clipboardData || window.clipboardData).getData('text');
					var restMsg = textarea.value.substring(textarea.selectionEnd);
					if(restMsg.length > 0){
						var lastSpaceIndex = restMsg.indexOf(' ');
						paste += restMsg.substring(0,(lastSpaceIndex > -1 ? lastSpaceIndex : restMsg.length));
					}
				}
				mIManager.inputBuffer = paste.split("");
			};

			var triggerInputEv = function(){
	    		var evt;
				if(typeof(Event) === 'function') {
				    evt = new Event('input');
				}else{
				    evt = document.createEvent('Event');
				    evt.initEvent('input', true, true);
				}
	    		element.dispatchEvent(evt);
	    	};
			var dropDownScroll = function(event){
				var lyteMIList = event.target;
				var scrollHeight = lyteMIList.scrollHeight;
				if(lyteMIList.getBoundingClientRect().height + lyteMIList.scrollTop  >= scrollHeight){
					if(data.onScrollEnd){
						var responseData = data.onScrollEnd();
						if(responseData){
							if(responseData.then){
								responseData.then( function( Data ) {
									appendNewData(Data);
								})
							}else{
								appendNewData(responseData);
							}
						}
					}
				}
			}
			var appendNewData =  function(LiElements){
				LiElements.forEach(function(data){
					var ListElem = createLiElement(data);
					lyteMIList.appendChild(ListElem);
					ListElem.addEventListener('click',onSelect,true);
					if(textarea._mIData.avatars && data.avatar){
						var elmIcon = new Image();
						elmIcon.src = data.avatar;
						ListElem.prepend(elmIcon);
					  }
				})
			}
			/*---------------- BIND EVENTS AND DATA ------------------*/

			data.lyteMIList = mIManager.init(element);
			data.lyteMIList._textarea = element;
			data._overlayDiv = element.previousElementSibling.children[0];
			if (!data._overlayDiv) {
				data._overlayDiv = element.children[0].children[0].children[1].children[0];
			}
			if (!data.isLyteInput) {
				$L(element.previousElementSibling).addClass('lyteMentionsNormalTextarea');
			}
	        element._mIData = data;
	        element._lyteMenIpKeydownEvent = keydownEvent;
	        element._lyteMenIpKeypressEvent = keypressEvent;
	        element._lyteMenIpInputEvent = inputEvent;
			element._lyteMenIpClickEvent = clickEvent;
			element._lyteMenIpOnClickEvent = inputClickEvent;
	        element._lyteMenIpBlurEvent = blurEvent;
	        element._lyteMenIpPasteEvent = pasteEvent;
			element._lyteHideDropdown = hideDropdown;
			element._lytePosDropdown = positionDropdown;
			data.lyteMIList._lyteMentionScrollDropDown = dropDownScroll;
			element._valueMap = {oldText: "", oldSyntax: ""};
			element._selection = {};
			element._lyteDisableParentScrollListeners = disableParentListeners;
			data.lyteMIList.addEventListener('scroll',data.lyteMIList._lyteMentionScrollDropDown);
	    	element.addEventListener('keydown', element._lyteMenIpKeydownEvent);
	    	// element.addEventListener('keypress', element._lyteMenIpKeypressEvent);	/*Removed keypress as it is not supported by mobile browsers*/
	    	element.addEventListener('input', element._lyteMenIpInputEvent);
	    	element.triggerInputEvent = triggerInputEv;
			element.addEventListener('click', element._lyteMenIpOnClickEvent, true);
	    	// element.addEventListener('click', element._lyteMenIpClickEvent, true);
	    	// element.addEventListener('blur', element._lyteMenIpBlurEvent);
	    	element.addEventListener('paste', element._lyteMenIpPasteEvent);
	    	data.lyteMIList.addEventListener('mouseover',mouseoverEvent);
			if(element._mIData.removeHighlightCompletely) {
				element._lyteSetSelection = setSelection;
				element._lyteMenIpMouseUpEvent = mouseupEvent;
				element.addEventListener('mouseup', element._lyteMenIpMouseUpEvent);
				initializeSelection();
			}
	    	if(!mIManager.bindScroll){
	    		mIManager.onScroll = function(event){
	    			if(!event || !event.target || event.target.nodeName == '#document' || event.target.tagName == "HTML" || event.target.closest('.lyteMIDropdown')){
	    				return;
	    			}
	    			var elems = document.querySelectorAll('.lyteMIListAppended');
	    			if(elems.length > 0){
	    				for(var i = 0; i<elems.length; i++){
	    					positionDropdown(elems[i],true);
	    				}
	    			}
	    		}
	    		document.addEventListener('scroll',mIManager.onScroll,true);
	    		mIManager.bindScroll = true;
	    	}
	    	if(!mIManager.bindClick){
	    		mIManager.onClick = function(event){
	    			var target = event.target;
	    			while(target){
	    				if((target.tagName === "TEXTAREA" && target.getAttribute('data-lyte-mentions') === "true") || target.tagName == "HTML"){
	    					break;
	    				}
	    				target = target.parentElement;
	    			}
	    			if(target && target.tagName === "TEXTAREA"){
	    				target._lyteMenIpClickEvent(event);
	    				var openLists = document.querySelectorAll('.lyteMIDropdown.lyteMIDisplayBlock');
	    				for(var i = 0; i < openLists.length; i++){
	    					if(!(target._mIData.lyteMIList.isEqualNode(openLists[i]))){
								var textarea = openLists[i]._textarea;
	    						textarea._lyteHideDropdown(openLists[i]._textarea);
	    					}
	    				}
	    				target._addedMentions = false;
	    			}
	    			else if(target && target.tagName === "HTML"){
	    				var openLists = document.querySelectorAll('.lyteMIDropdown.lyteMIDisplayBlock');
	    				for(var i = 0; i < openLists.length; i++){
							var textarea = openLists[i]._textarea;
	    					textarea._lyteHideDropdown(textarea,openLists[i]);
	    				}
	    			}
	    		}
	    		document.body.addEventListener('click',mIManager.onClick,true);
	    		mIManager.bindClick = true;
	    	}
	    	/*---------------------------------------------------------*/

	    	/*--------------------------- INITIALIZATION ENDS -------------------------*/

	    	return this;
		}
		
	}

})

( function( factory ) {
    if( typeof define === "function" && define.amd ) {
        define( [ "@zoho/lyte-dom" ], factory );
    }
    else {
        factory( $L );
    }
} )(function($L){
 	
	$L.prototype.placement = function( config ) {
	   var elem = this.get(0);
	   this.data  = config;
	   this.container = $L(this.container).length ? $L(this.container)[0] : $L('body')[0];

	   setDefaultConfig( config );

	   if( config.append ) {
		   appendElement( config , elem );
	   }
	   window.addEventListener('resize',function(event){
			if( config.originElement ) {
				alignWithOriginElement( config , elem );
			}else{
				alignWithWindow( config , elem );
			}
	   });
	   if( config.originElement ) {

			var origin_elem = $L( config.originElement ).get(0);
			var scrollDiv = findSrcollableParent(origin_elem);
			if(scrollDiv){
				scrollDiv.addEventListener('scroll',function(event){
					alignWithOriginElement( config , elem );
				});
			}
		   	alignWithOriginElement( config , elem );						
	   }else{
		   alignWithWindow( config , elem );
	   }			
   }
   	function findSrcollableParent(elem){
		var parent = elem.parentElement;
		while(elem.parentElement){
			elem = elem.parentElement;
			if((parent.scrollHeight > elem.clientHeight) && (parent.scrollWidth > elem.clientWidth) && ((window.getComputedStyle(elem).overflowY != "hidden" && window.getComputedStyle(elem).overflow != "visible")) || ((window.getComputedStyle(elem).overflowX != "hidden" && window.getComputedStyle(elem).overflow != "visible") || elem.matches('.lyteScrollBar')) /*!(elem.style.overflow && elem.style.overflow == 'hidden')*/){
				return elem;
			}
		}
		return null;
	}

   function setDefaultConfig( config ) {
	   config = config || {};

	   if( !( 'append' in config ) ) {
		   config.append = true;
	   }
   }


   function alterElementPosition( alterposition , elem ){
	   if( alterposition ){
		   elem.style.left = elem.offsetLeft + alterposition.left + 'px';
		   elem.style.top = elem.offsetTop + alterposition.top + 'px';
	   }
   }
		   
   function appendElement( config , elem ){
	   var appendto;
	   elem.style.position = 'absolute';
	   if( config.appendTo ){
		   appendto = document.querySelector( config.appendTo );
		   if( appendto == undefined ){
			   appendto = $L('body').get(0);
		   }
	   }else{
		   appendto = document.getElementsByTagName('body')[0];
	   }
		   appendto.appendChild(elem);
   }

   function alignRight( origin_elem , elem , container){
	   
	   var actualposition = origin_elem.getBoundingClientRect().right;
	   var marginLeft = parseInt(window.getComputedStyle(container).marginLeft); 

	   if( isWindowLeftExceeded( actualposition , elem ,container ) ){
		   elem.style.left = origin_elem.getBoundingClientRect().left - elem.offsetParent.getBoundingClientRect().left  + origin_elem.offsetWidth + marginLeft + "px";
	   }else{
		   if(canElementFitLeft( (origin_elem.offsetLeft - elem.offsetWidth) , container )){
			   elem.style.left = origin_elem.offsetLeft - elem.offsetWidth + "px";
		   }else {
			   elem.style.left = origin_elem.getBoundingClientRect().left - elem.offsetParent.getBoundingClientRect().left  + origin_elem.offsetWidth + marginLeft + "px";
		   }
	   }
	   
   }
		   
   function alignLeft( origin_elem , elem , container ){
	   var leftBoundary = origin_elem.getBoundingClientRect().left - elem.offsetParent.getBoundingClientRect().left - elem.offsetWidth;
	   var marginLeft = parseInt(window.getComputedStyle(container).marginLeft); 
	   if( canElementFitLeft( leftBoundary , container ) ){
		   elem.style.left = leftBoundary + "px";
	   }else{
		   var actualposition = origin_elem.getBoundingClientRect().right;
		   if( isWindowLeftExceeded( actualposition , elem ,container ) ){
			   elem.style.left = origin_elem.offsetParent.getBoundingClientRect().left - origin_elem.getBoundingClientRect().left + origin_elem.offsetWidth + marginLeft + "px";
		   }else{
			   elem.style.left = leftBoundary + "px";
		   }
	   }
   }
   
   function alignTop( origin_elem , elem ,container ){
	   var topBoundary =  origin_elem.getBoundingClientRect().top - elem.offsetHeight;
	   var marginTop = parseInt(window.getComputedStyle(container).marginTop); 
	   if( canElementFitAbove( topBoundary ,container) ){
		   elem.style.top = topBoundary - elem.offsetParent.getBoundingClientRect().top + marginTop + 'px';
	   }else{
		   var actual_top = origin_elem.getBoundingClientRect().bottom;
		   if( !isWindowTopExceeded( actual_top , elem  ,container) ){
			   elem.style.top =  origin_elem.getBoundingClientRect().top  - elem.offsetParent.getBoundingClientRect().top + origin_elem.offsetHeight + marginTop + 'px';
		   }else{
			   elem.style.top = topBoundary - elem.offsetParent.getBoundingClientRect().top + marginTop + 'px';
		   }

	   }

   }
   
   function alignBottom(origin_elem , elem , container){
	   var originElementBoundingRect = origin_elem.getBoundingClientRect(), 
	   originElementBottom = originElementBoundingRect.bottom,
	   originElementTop = originElementBoundingRect.top;

	   fixElementLeft( origin_elem , elem, container );

	   if( isWindowTopExceeded( originElementBottom, elem, container ) ) {
		   elem.style.top = addTopScroll( elem ) + originElementBottom + 'px';
	   }else{
		   elem.style.top = addTopScroll( elem ) + originElementTop - elem.offsetHeight + 'px';
	   }

   }

   function alignBottomRight(origin_elem , elem , container){
	   alignBottom( origin_elem , elem , container );
	   alignRight( origin_elem , elem , container);
   }

   function alignTopRight( origin_elem , elem , container ){
	   alignTop( origin_elem , elem , container );
	   alignRight( origin_elem , elem , container);
   }
   
   function alignTopLeft( origin_elem , elem , container ){
	   alignTop( origin_elem , elem , container );
	   alignLeft( origin_elem , elem , container);

   }
   
   function alignBottomLeft( origin_elem , elem , container ){
	   alignBottom( origin_elem , elem , container );
	   alignLeft( origin_elem , elem , container);
   }

   function alignTopCenter( origin_elem , elem , container ){
	   elem.style.left = origin_elem.getBoundingClientRect().left - elem.offsetParent.getBoundingClientRect().left + origin_elem.offsetWidth/2 - elem.offsetWidth/2 + "px";
	   alignTop( origin_elem , elem , container );
   }
   
   function alignBottomCenter( origin_elem , elem , container ){
	   var marginTop = parseInt(window.getComputedStyle(container).marginTop);
	   elem.style.left = origin_elem.offsetLeft + origin_elem.offsetWidth/2 - elem.offsetWidth/2 + "px";
	   alignBottom( origin_elem , elem , container);
   }
   
   function alignCenterRight( origin_elem , elem , container ){
	   alignRight( origin_elem , elem , container);
	   FixElementTopCenter( origin_elem , elem , container );
   }
   function alignCenter( origin_elem , elem , container ){
	   var center = origin_elem.getBoundingClientRect().left + origin_elem.offsetWidth/2 ;
	   if( isWindowLeftExceeded( center , elem , container)){
		   elem.style.left = center - elem.offsetParent.getBoundingClientRect().left + 'px'; 
	   }else{
		   elem.style.left = origin_elem.getBoundingClientRect().left - elem.offsetParent.getBoundingClientRect().left + origin_elem.offsetWidth/2 - elem.offsetWidth + 'px';
	   }
	   FixElementTopCenter( origin_elem , elem , container);
   }
   
   function alignCenterLeft( origin_elem , elem , container ){
	   alignLeft( origin_elem , elem , container );
	   FixElementTopCenter( origin_elem , elem , container);
   }
   
   function FixElementTopCenter( origin_elem , elem ,container){
	   var top = origin_elem.getBoundingClientRect().top + origin_elem.offsetHeight/2; 
	   if( !isWindowTopExceeded( top , elem, container ) ){
		   elem.style.top = top - elem.offsetParent.getBoundingClientRect().top - elem.offsetHeight + "px";
	   }else{
		   elem.style.top = top - elem.offsetParent.getBoundingClientRect().top + "px";
	   }
   }
   
   function canElementFitAbove( topBoundary ,container){

	   if( topBoundary >= container.getBoundingClientRect().top ){
		   return true;
	   }
	   else{
		   return false;
	   }
   } 
		   
   function canElementFitLeft( leftBoundary ,container){
	   if( leftBoundary >= container.getBoundingClientRect().left ){
		   return true;
	   }
	   else{
		   return false;
	   }
   }
   
   function isWindowTopExceeded( position , elem ,container){
	   if( ( position + elem.offsetHeight ) < window.innerHeight ){
		   return true;
	   }
	   else{
		   return false;
	   }
   }
   
   function isWindowLeftExceeded( position , elem , container){	
	   if( ( position + elem.offsetWidth ) < (container.getBoundingClientRect().left + container.getBoundingClientRect().width) ){
		   return true;	
	   }
	   else{
		   return false;
	   }
   }	
   
   
   function placeAtBottom( origin_elem , elem , container){
	   var marginTop = parseInt(window.getComputedStyle(container).marginTop);
	   elem.style.top = origin_elem.getBoundingClientRect().top - elem.offsetParent.getBoundingClientRect().top - marginTop  + "px"; 
   }

   function placeAtTop( origin_elem , elem , container ){	
	   var marginTop = parseInt(window.getComputedStyle(container).marginTop);
	   elem.style.top = origin_elem.getBoundingClientRect().top -  elem.offsetParent.getBoundingClientRect().top + marginTop  + "px";
   }
   
   function FixElementTop( origin_elem , elem , container ){
	   if( !isWindowTopExceeded( origin_elem.getBoundingClientRect().top , elem, container ) ){
		   placeAtBottom( origin_elem , elem ,container );
	   }else{
		   placeAtTop( origin_elem , elem ,container);
	   }
   }
   
   function alignWithOriginElement( config , elem ){
	   var body = $L( "body" ).get(0);
	   
	   if( window.getComputedStyle(body).direction == 'rtl'){
		   Changedirection( config );
	   }
	   if( config.alignment ){
		   alignWithLeftTop( config , elem );
	   }else{
		   alignWithPosition( config , elem  );
	   }
	   alterElementPosition( config.alterposition , elem );
   }
   
   function alignWithLeftTop( config , elem ){
	   var origin_elem = $L( config.originElement ).get(0);
	   var container =  $L(config.container).length ? $L(config.container).get(0) : $L('body').get(0);
	   var elem_left = config.alignment.left;
	   var elem_top = config.alignment.top;

	   switch(elem_top){
		   case 'top':
			   if( !elem_left ){
				   alignTop( origin_elem , elem , container );
				   fixElementLeft( origin_elem , elem , container  );
			   }
			   else if( elem_left == 'left' ){
				   alignTopLeft( origin_elem , elem , container );
			   }
			   else if( elem_left == 'right'){
				   alignTopRight( origin_elem , elem , container );
			   }
			   else{
				   alignTopCenter( origin_elem , elem , container ); 
			   }
			   break;
		   case 'bottom':
			   if( !elem_left ){
				   alignBottom( origin_elem , elem , container );
				   fixElementLeft( origin_elem , elem , container  );
			   }
			   else if( elem_left == 'left' ){
				   alignBottomLeft( origin_elem , elem , container );
			   }
			   else if( elem_left == 'right'){
				   alignBottomRight( origin_elem , elem , container );
			   }
			   else{
				   alignBottomCenter( origin_elem , elem , container ); 
			   }
			   break;
		   case 'center':
			   if( !elem_left ){
				   alignCenter( origin_elem , elem , container );
			   }
			   else if( elem_left == 'left' ){
				   alignCenterLeft( origin_elem , elem , container );
			   }
			   else if( elem_left == 'right'){
				   alignCenterRight( origin_elem , elem , container );
			   }
			   else{
				   alignCenter( origin_elem , elem , container );				
			   }
			   break;
		   default :
			   switch(elem_left){
				   case 'left':
					   alignLeft( origin_elem , elem , container );
					   FixElementTop(origin_elem , elem , container );
					   break;
				   case 'right':
					   alignRight( origin_elem , elem , container );
					   FixElementTop(origin_elem , elem , container );
					   break;
				   case 'center':
					   alignCenter( origin_elem , elem , container );
					   break;
				   default :
					   alignBottom( origin_elem , elem , container );
					   break;
			   }
	   }
   }
   
   function alignWithPosition( config , elem ){
	   var origin_elem = $L( config.originElement ).get(0);
	   var container =  $L(config.container).length ? $L(config.container).get(0) : $L('body').get(0);

	   switch ( config.position ) {
		   case 'right':
			   alignRight( origin_elem , elem , container );
			   FixElementTop( origin_elem , elem , container );
			   break;
		   case 'left':
			   alignLeft( origin_elem , elem , container  );
			   FixElementTop(origin_elem , elem , container );
			   break;
		   case 'top':
			   alignTop( origin_elem , elem , container  );
			   fixElementLeft( origin_elem , elem , container  );
			   break;
		   case 'bottomright':
			   alignBottomRight( origin_elem , elem , container  );
			   break;
		   case 'bottomleft':
			   alignBottomLeft( origin_elem , elem , container  );
			   break;
		   case 'topright':
			   alignTopRight( origin_elem , elem , container  );
			   break;
		   case 'topleft':
			   alignTopLeft( origin_elem , elem , container );
			   break;
		   case 'bottom':
		   default :
			   alignBottom( origin_elem , elem , container  );
			   fixElementLeft( origin_elem , elem , container  );
			   break;
	   }
   }
   
   function alignWithWindow( config , elem ){
	   var offset = config.offset ? config.offset : {};
	   
	   if(isoffset( offset ) ){
		   if( isRtl() ){
			   offset.left = window.innerWidth - offset.left.match(/(\d+)/)[0] - elem.offsetWidth + 'px';
		   }
		   setTopLeft( offset , elem );
	   }else{
		   elem.style.left = ( window.innerWidth/2 - elem.offsetWidth/2 )  + 'px';
		   elem.style.top = ( window.innerHeight/2 - elem.offsetHeight/2 )  + 'px';	
	   }
   }
   function Changedirection( config ){
	   if(config.alignment){
		   if( config.alignment.left == 'right' ){
			   config.alignment.left = 'left';
		   }else if( config.alignment.left == 'left' ){
			   config.alignment.left = 'right';
		   }
	   }else{
		   if( config.position == 'left' ){
			   config.position = 'right';
		   }else if( config.position == 'topleft' ){
			   config.position = 'topright';
		   }else if( config.position == 'bottomleft' ){
			   config.position = 'bottomright';
		   }else if( config.position == 'right' ){
			   config.position = 'right';
		   }else if( config.position == 'topright' ){
			   config.position = 'topleft';
		   }else if( config.position == 'bottomright' ){
			   config.position = 'bottomleft';
		   }
	   }
   }
   function fixElementLeft( origin_elem , elem ,container){
	   var leftBoundary = origin_elem.offsetLeft - elem.offsetWidth;
	   if( !isWindowLeftExceeded( origin_elem.offsetLeft , elem ,container ) ){
		   elem.style.left = window.innerWidth - elem.offsetWidth + 'px';
	   }else{
		   elem.style.left = origin_elem.offsetLeft + 'px';
	   }
   }
   function isRtl(){
	   var body = $L('body').get(0);
	   if(window.getComputedStyle(body).direction == 'rtl'){
		   return true;
	   }
	   else{
		   return false;
	   }
   }
   function setTopLeft( offset , elem ){
	   var left = offset.left ? offset.left : '0px';
	   var top = offset.top ? offset.top : '0px';
	   elem.style.left = left;
	   elem.style.top = top;
   }
   function isoffset( offset ){
	   if(offset.left  || offset.top ){
		   return true;
	   }
	   else{
		   return false;
	   }
   }

   function addTopScroll( elementToPosition ) {
	   var offsetParent = elementToPosition.offsetParent;

	   if( offsetParent.tagName === 'BODY' ) {
		   return window.pageYOffset || document.documentElement.scrollTop;
	   }

	   // TODO: Add this
	   return 0;
   }

})

( function( factory ) {
	if( typeof define === "function" && define.amd ) {
        define( [ "@zoho/lyte-dom" ], factory );
    }
    else {
        factory( $L );
    }
} )( function( $L ) {
	if( $L.requestQueue ) {
		return ;
	}
	
	var empty = function() {},
	ignore = [];

	/* constructor */
	function reqQueue( obj ) {
		this.queue = [];
		this.total = 0;
		this.sequential = ( obj || {} ).hasOwnProperty( 'sequential' ) ? obj.sequential : true;

		this.success = {};
		this.error = {};
		this.complete = {};
		this.order = [];


		return this;
	}

	/* private functions */
	function generateID( reqQ ) {
		return reqQ.total++;
	}

	function makeRequestWhenAjax( obj, reqQ, id ) {
		var success = obj.success || empty,
		complete = obj.complete || empty,
		error = obj.error || empty,
		beforeSend = obj.beforeSend,
		prom, copy = {};

		prom = new Promise( function( res, rej ) {

			$L.extend( copy, obj );

			copy.complete = function() {
				if( !reqQ.sequential ) {
					complete.apply( this, arguments );
				}
				else if( nextInQueue( reqQ ) === id ) {
					complete.apply( this, arguments );
					reqQ.order.shift();
					flush( reqQ );
				}
				else {
					reqQ.complete[ id ] = {
						fn: complete,
						context: this,
						args: arguments
					}
				}
			}

			copy.success = function() {
				if( !reqQ.sequential || nextInQueue( reqQ ) === id ) {
					success.apply( this, arguments );
				}
				else {
					reqQ.success[ id ] = {
						fn: success,
						context: this,
						args: arguments
					};
				}	

				res( {
					statusText: arguments[ 1 ],
					id: id,
					options: obj,
					lXHR: arguments[ 2 ],
					data: arguments[ 0 ],
					passed: true
				} );
			}

			copy.error = function() {
				if( !reqQ.sequential || nextInQueue( reqQ ) === id ) {
					error.apply( this, arguments );
				}
				else {
					reqQ.error[ id ] =  {
						fn: error,
						context: this,
						args: arguments
					};
				}

				rej( {
					id: id,
					options: obj,
					lXHR: arguments[ 0 ],
					statusText: arguments[ 1 ],
					error: error,
					passed: false
				} );
			}

			copy.beforeSend = function() {
				var ret;

				if( beforeSend ) {
					ret = beforeSend.apply( this, arguments );

					if( ret === false ) {
						ignore.push( id );
						rej( {
							id: id,
							options: obj,
							lXHR: arguments[ 0 ],
							passed: false
						} );
					}

					return ret;
				}
			}


			$L.ajax( copy );	
		} );

		return prom;
	}


	
	function nextInQueue( reqQ ) {
		var next = ( reqQ.order || [] )[ 0 ];

		if( !!~ignore.indexOf( next ) ) {
			reqQ.order.shift();

			next = nextInQueue( reqQ );
		}

		return next;
	}

	function flush( reqQ ) {
		var arr = [ 'success', 'error', 'complete' ],
		next, obj, cb, args, context, empty;

		while( ( next = nextInQueue( reqQ ) ) ) {
			empty = true;

			arr.forEach( function( item ) {
				empty = $L.isEmptyObject( obj = reqQ[ item ][ next ] || {} ) && empty;
				context = obj.context;
				args = obj.args;
				cb = obj.fn;

				if( cb ) {
					cb.apply( context, args );
				}
			} );

			if( empty ) {
				break;
			}

			reqQ.order.shift();
		}

	}

	function findType( obj ) {
		var type = 'Object';

		if( obj instanceof Promise ) {
			type = 'Promise'
		}

		return type;
	}

	function disableSequentialFlag( reqQ ) {
		reqQ.sequential = false;
	}


	function processResults( res, rej, results ) {
		var failed = [],
		success = [];

		// Reset ignores
		ignore = [];

		results.forEach( function( item ) {
			var isSuccess = item.passed;

			if( isSuccess ) {
				success.push( item );
			}
			else {
				failed.push( item );
			}
		} );

		if( failed.length === 0 ) {
			res( {
				success: success,
				failure: failed
			} );
		}
		else {
			rej( {
				success: success,
				failure: failed
			} );
		}
	}


	function setCallbacksWhenPromise( promise, id ) {
		var wrapper = new Promise( function( res, rej ) {
			
			promise.then( function() {
				res( {
					data: arguments,
					passed: true,
					id: id
				} );
			}, function() {
				rej( {
					data: arguments,
					passed: false,
					id: id
				} );
			} );
		} );
		

		return wrapper;
	}

	/* public functions */
	reqQueue.prototype.initiate = function() {
		var queue = this.queue,
		obj, opts, id, prom = [], ret, type;

		while( obj = queue.shift() ) {
			opts = obj.options;
			id = obj.id;
			type = obj.type

			this.order.push( id );

			if( type === 'Object' ) {
				prom.push( makeRequestWhenAjax( opts, this, id ) );	
			}
			else {
				disableSequentialFlag( this );
				prom.push( setCallbacksWhenPromise( opts, id ) );
			}
		}

		ret = new Promise( function( res, rej ) {
			Promise.all( 
				prom.map( function( p ) {
					return p.catch( function( e ) {
						return e;
					} );
				} )
			).then( processResults.bind( this, res, rej ) );
		} );

		this.queue = [];

		return ret;
		
	}

	reqQueue.prototype.add = function( obj ) {
		var id, that = this;

		if( Array.isArray( obj ) ) {
			return obj.map( function( item ) {
				return that.add( item );
			} );
		}
		else {
			id = generateID( this );

			this.queue.push( {
				id: id,
				options: obj,
				type: findType( obj )
			} );

			return id;	
		}		
	}


	reqQueue.prototype.removeAll = function() {
		var queue = this.queue;

		this.remove( 
			queue.map( function( item ) {
				return item.id;
			} ) 
		);
	}

	reqQueue.prototype.remove = function( id ) {
		var queue = this.queue,
		ind, that = this;

		id = Array.isArray( id ) ? id : [ id ];

		this.queue = queue.filter( function( item ) {
			var ind = id.indexOf( item.id ),
			present = !!~ind;

			return !present;
			
		} );		
	}

	$L.reqQueue = function( obj ) {
		var reqQ = new reqQueue( obj );

		return reqQ;
	}
} );


;( function( cb ){
	if( typeof define == "function" && define.amd ){
		  define( [ "@zoho/lyte-dom" ], cb );
	  } else {
		  cb( window.$L );
	  }
} )( function( $L ){
    if( $L ){
        var isRtl;

        function rtlfunc( lft, bcr, ww ) {
                if( isRtl ) {
                    if( bcr ) {
                        if( lft == 'right' ) {
                            return ww - bcr.left;
                        } else if( lft == 'clientX' ) {
                            return ww - bcr.clientX
                        }
                        return ww - bcr.right;
                    } else if( lft == 'left' ) {
                        return 'right';
                    } 
                }
                return bcr ? bcr[ lft ] : lft;
            }

        function destroy(){
            var remove_global_events = function( win_elem, elem ){
                if( win_elem && elem.contains( win_elem ) ){
                    document.removeEventListener( 'mousemove', mousemove, true );
                    document.removeEventListener( 'mouseup', mouseup, true );
                    document.removeEventListener( 'touchmove', mousemove, true );
                    document.removeEventListener( 'touchend', mouseup, true );
                    mouseup( {}, true );
                }
            };
            this.each( function( index, item ){
                var current = $L( item ),
                activeElems = current.data( 'activeElems' ) || {},
                elem = current.get( 0 ),
                resizeData = elem._resizeData,
                win_elem = window._resizeelem;

                if( !resizeData ){
                    return;
                }

                remove_global_events( win_elem, elem );

                for( var key in activeElems ){  
                    activeElems[ key ].remove();
                }
                if( resizeData.component == 'table' ){
                    removeActive.call( elem );
                    elem.removeEventListener( 'mousemove', tableMove, true );
                    elem.removeEventListener( 'mousedown', tableDown, true );
                    elem.removeEventListener( 'mouseout', removeActive, true );
                    elem.removeEventListener( 'touchmove', tableMove, true );
                    elem.removeEventListener( 'touchstart', tableDown, true );
                }
                if( elem._clone ){
                    elem._clone.remove();
                    delete elem._clone._elem;
                    delete elem._clone;
                }
            })
            return this;
        }

        function getBcr( elem ){
            var bcr = elem.getBoundingClientRect();
            return {
                left : bcr.left,
                right : bcr.right,
                top : bcr.top,
                bottom : bcr.bottom,
                width : elem.offsetWidth,
                height : elem.offsetHeight
            };
        }

        function getStyle( elem ){
            return window.getComputedStyle( elem );
        }

        function bind( obj ){
            this.each( function( index, item ){
                if( item._resizeData ){
                    $L( item ).enableResize( 'destroy' );
                }
                bindEvents( item, $L.extend( true, {}, obj ) );
            }) 
        }

        function bindEvents( item, obj ){
            item._resizeData = obj;

            if( obj.component == "table" ){
                item.addEventListener( 'mousedown', tableDown, true );
                item.addEventListener( 'touchdown', tableDown, true );
                item.addEventListener( 'mousemove', tableMove, true );
                item.addEventListener( 'mouseout', removeActive, true );
            }

            createResize( item );
        }

        function changeCursor(){
            var elem = this,
            $elem = $L( elem ),
            parent = elem.parentNode,
            angle = find_angle( window.getComputedStyle( parent ) ) / Math.PI * 180,
            value = $elem.data( 'value' ),
            modified_value = $elem.data( "modified_value" ) || value,
            count = Math.round( angle / 45 ),
            keys = [ "N", "NE", "E", "SE", "S", "SW", "W", "NW" ],
            new_value = keys[ ( keys.indexOf( value ) + count ) % keys.length ];

            if( modified_value != new_value ){
                var ns = "lyteResizeCursor";
                $elem.removeClass( ns + modified_value ).addClass( ns + new_value ).data( "modified_value", new_value );
            }
        }

        function createResize( elem ){
                var obj = elem._resizeData,
                directions = obj.directions,
                rotation = obj.rotationHandling,
                activeElems = {},
                dirs = { N : { height : true, top : true }, S : { height : true }, W : { left : true, width : true }, E : { width : true }, SW : { height : true, left : true, width : true }, SE : { height : true, width : true }, NW : { top : true, height : true, left : true, width : true }, NE : { top : true, height : true, width : true } },
                clone;
                $L( elem ).data( 'activeElems', activeElems ).addClass( 'lyteResizeElement' );
                if( obj.clonedShape ){
                    clone = $L( document.createElement( 'div' ) ).addClass( 'lyteResizeClone' ).get( 0 );
                }
                for( var i = 0; i < directions.length; i++ ){
                    var curDir = directions[ i ],
                    newelem = $L( document.createElement( 'div' ) ).addClass( 'lyteResizeHandle', 'lyteResize' + curDir, 'lyteResizeCursor' + curDir ).data( { directions : dirs[ curDir ], element : elem, value : curDir } ).get( 0 );
                    activeElems[ curDir ] = newelem;
                    ( clone || elem ).appendChild( newelem );
                    newelem.addEventListener( 'mousedown', mousedown, true );
                    newelem.addEventListener( 'touchstart', mousedown, true );

                    if( rotation ){
                        newelem.addEventListener( "mouseenter", changeCursor, true );
                    }
                }
                if( clone ){
                    elem.appendChild( clone );
                    clone._elem = elem;
                    elem._clone = clone;
                }
            }


        function getCell( element, direction ){
            var data = this._resizeData,
            tags = data.tags,
            __matches = function( query, __element ){
                if( __element.matches ){
                    return __element.matches( query );
                }
                return getIndex( toArray( this.querySelectorAll( query ) ), __element ) != -1;
            }.bind( this );

            if( __matches( tags.th, element ) ){
                return element;
            }
            var row = element.parentNode,
            cells = toArray( row.children ),
            tbody = row.parentNode,
            rows = toArray( tbody.children ),
            cellIndex = getIndex( cells, element ),
            rowIndex = getIndex( rows, row );

            if( direction ){
                var rowSpan = element.rowSpan || 1;
                if( rowSpan == 1 ){
                    return element;
                }
                var newrow = rows[ rowIndex + rowSpan - 1 ],
                newcells = newrow.children,
                new_length = newcells.length;

                for( var i = 0; i < new_length; i++ ){
                    var cur = newcells[ i ];
                    if( cur.style.display == "none" || ( cur.rowSpan || 1 ) != 1 ){
                        continue;
                    }
                    return cur;
                }

                new_length = cells.length;

                for( var i = 0; i < new_length; i++ ){
                    var cur = cells[ i ];
                    if( cur.style.display == "none" || ( cur.rowSpan || 1 ) != 1 ){
                        continue;
                    }
                    return cur;
                }
                return element;
            } else {
                return tbody.previousElementSibling.children[ 0 ].children[ cellIndex + ( element.colSpan || 1 ) - 1 ];
            }
        }

        function border( style, direction ){
            return ( direction ? 
                        parseFloat( style.borderTopWidth ) + parseFloat( style.borderBottomWidth ) : 
                        parseFloat( style.borderLeftWidth ) + parseFloat( style.borderRightWidth ) );
        }

        function padding( style, direction ){
            var width = 0;
            if( style.boxSizing == "content-box" ){
                width = direction ? 
                        parseFloat( style.paddingTop ) + parseFloat( style.paddingBottom ) : 
                        parseFloat( style.paddingLeft ) + parseFloat( style.paddingRight );

                width += border( style, direction );
            }   
            return width
        }

        function mousedown( ev ){
            var evt = ev,
            isTch = /touch/i.test( ev.type );
            if( isTch ){
                if( ev.touches.length > 1 ){
                    return;
                }
                evt = ev.touches[ 0 ];
            }
            var elem = this,
            targetElem = $L( this ).data( 'element' ),
            data = targetElem._resizeData,
            directions = $L( elem ).data( 'directions' );
            if( data.onBeforeSelect && data.onBeforeSelect( elem, targetElem, ev, elem._clone ) == false ){
                return;
            }
            window._resizeelem = this;

            var width = targetElem.offsetWidth,
            height = targetElem.offsetHeight,
            bcr = getBcr( elem ),
            iw = window.innerWidth,
            style = getStyle( targetElem ),
            originalValue = {},
            clone = targetElem._clone;
            width -= padding( style );
            height -= padding( style, true ),
            rotation_handling = data.rotationHandling;

            originalValue.height = directions.height || rotation_handling ? targetElem.style.height = height + 'px' : void 0;
            originalValue.width = directions.width || rotation_handling ? targetElem.style.width = width + 'px' : void 0;
            originalValue[ rtlfunc( 'left' ) ] = directions.left || rotation_handling ? targetElem.style[ rtlfunc( 'left' ) ] = style[ rtlfunc( 'left' ) ] : void 0;
            originalValue.top = directions.top || rotation_handling ? targetElem.style.top = style.top : void 0;

            this._clientX = rtlfunc( 'clientX', evt, iw ) - rtlfunc( 'right', bcr, iw );
            this._clientY = evt.clientY - bcr.bottom;
            this._original = originalValue;

            if( data.component == "table" ){
                var cells = $L( targetElem ).children().children().children( data.tags.td + ',' + data.tags.th );
                
                $L.each( cells, function( index, item ){
                    directions.width ? item.style.width = '' : void 0;
                    directions.height ? item.style.height = '' : void 0;
                });
            }

            targetElem._owidth =  targetElem.style.width;
            targetElem._oheight = targetElem.style.height;
            targetElem._mwidth = targetElem.style.maxWidth;
            targetElem.style.width = 0;
            targetElem.style.height = 0;
            targetElem.style.maxWidth = 0;
            $L.fastdom.measure( function(){
                targetElem._minWidth = targetElem.offsetWidth;
                targetElem._minHeight = targetElem.offsetHeight;
                if( clone ){
                    clone._minHeight = targetElem._minHeight;
                    clone._minWidth = targetElem._minWidth;
                }

                if( rotation_handling ){
                    this.__resize_rotate = find_angle( style );
                }
            }.bind( this ) )
            $L.fastdom.mutate( function(){
                targetElem._tableDown = true;
                targetElem.style.width = targetElem._owidth;
                targetElem.style.height = targetElem._oheight;
                targetElem.style.maxWidth = targetElem._mwidth;
                if( clone ){
                    clone.style.width = width + 'px';
                    clone.style.height = height + 'px';
                    clone.style[ rtlfunc( 'left' ) ] = 0;
                    clone.style.top = 0;
                }
                delete targetElem._oheight; delete targetElem._owidth; delete targetElem._mwidth;

                document.addEventListener( isTch ? 'touchmove' : 'mousemove', mousemove, true );
                document.addEventListener( isTch ? 'touchend' : 'mouseup', mouseup, true );
                data.onSelect && data.onSelect( elem, targetElem, ev, elem._clone );
                evt.stopPropagation();
            } )
        }

        function find_angle( style ){
            var transform = style.transform,
            match = transform.match( /matrix\((.+)\)/ );
            if( match ){
                var split = match[ 1 ].split( "," ),
                hori = parseFloat( split[ 0 ] ),
                vert = parseFloat( split[ 1 ] ),
                angle = ( Math.atan2( vert, hori ) / Math.PI * 180 + 360 ) % 360;

                return angle * Math.PI / 180;
            }
            return 0;
        }

        function tableDown( ev ){
            var data = this._resizeData,
            isTch = /touch/i.test( ev.type ),
            evt = ev;

            if( isTch ){
                if( evt.touches.length > 1 ){
                    return;
                } 
                evt = evt.touches[ 0 ];
                tableMove.call( this, evt );
            }
            var active = data.active;
            if( !active || ev.buttons == 2 ){
                return;
            }
            if( data.onBeforeSelect && data.onBeforeSelect( this, active.element, ev ) == false ){
                return;
            }
            var preventTable = data.preventTable,
            direction = active.direction == "vertical",
            element = getCell.call( this, active.element, direction ),
            winwidth = window.innerWidth,
            style = getStyle( element ),
            bcr = getBcr( element ),
            row = element.parentNode,
            table = row.parentNode.parentNode,
            tableStyle = getStyle( table ),
            tableBcr = getBcr( table ),
            next = !direction && preventTable ? element.nextElementSibling : void 0,
            nextstyle,
            cells = toArray( row.children ),
            final = [],
            allCells = toArray( $L( table ).children().children().children( data.tags.td + ',' + data.tags.th ) );

            element._next = next;

            if( !preventTable ){
                table._original = { width : table.style.width, height : table.style.height };
            }

            if( direction ){
                cells.forEach( function( item ){
                    if( item.style.display == "none" ){
                        return;
                    }
                    var obj = {
                        node  : item,
                        style : getStyle( item ),
                        bcr : getBcr( item )
                    }
                    final.push( obj );
                } )
                table.style.height = ( tableBcr.height - padding( tableStyle, true ) ) + 'px';

                final.forEach( function( item ){
                    item.node._original = { height : item.node.height, width : item.node.height };
                    item.node.style.height = ( item.bcr.height - padding( item.style, true ) ) + 'px';
                } )

                allCells.forEach( function( item ){
                    item._hgt = item.style.height;
                    item.style.height = 0;
                } )
                table._hgt = table.style.height;
                table.style.height = 0;
            } else {
                element._original = { width : element.style.width, height : element.style.height };

                element.style.width = ( bcr.width -  padding( style ) ) + 'px';
                if( !preventTable ){
                    table.style.width = ( tableBcr.width - padding( tableStyle ) ) + 'px';
                }
                if( next ){
                    next._original = { width : next.style.width, height : next.style.height };
                    var nextbcr = getBcr( next );
                    nextstyle = getStyle( next );
                    next.style.width = ( nextbcr.width - padding( nextstyle ) ) + 'px';
                }
                table.style.maxWidth = 0;
            }

            $L.fastdom.measure( function(){
                    if( direction ){
                        final.forEach( function( item ){
                            var exp_min = 0,
                            measured_min = parseFloat( item.style.minHeight ),
                            measured_max = parseFloat( item.style.maxHeight );

                            item.node._minHeight = getBcr( item.node ).height - padding( item.style, true );

                            if( !isNaN( measured_min ) ){
                                item.node._minHeight = measured_min
                            }

                            if( !isNaN( measured_max ) ){
                                item.node._maxHeight = measured_max;
                            }
                        });
                        if( !preventTable ){
                        table._minHeigth = getBcr( table ).height - padding( tableStyle, true );
                        }
                    } else {
                        element._minWidth = getBcr( element ).width - padding( style );
                        if( next ){
                        next._minWidth = getBcr( next ).width - padding( nextstyle );
                        }
                        if( !preventTable ){
                        table._minWidth = getBcr( table ).width - padding( tableStyle );
                        }
                    }
                }.bind( this ) )

                $L.fastdom.mutate( function(){
                    if( direction ){
                        allCells.forEach( function( item ){
                            if( item.parentNode == element.parentNode && element != item ){
                                item.style.height = "";
                            } else {
                                item.style.height = item._hgt;
                            }
                            delete item._hgt;
                        } )
                        table.style.height = table._hgt;
                        delete table._hgt;
                    } else {
                    table.style.maxWidth = "";
                    }
                    element._clientX = rtlfunc( 'clientX', evt, winwidth ) - rtlfunc( 'right', bcr, winwidth );
                    element._clientY = evt.clientY - bcr.bottom;
                    window._resizeelem = element;
                    $L( element ).data( 'element', this );
                    $L( element ).data( 'directions', { width : !direction, height : direction } );

                    document.addEventListener( isTch ? 'touchmove' : 'mousemove', mousemove, true );
                    document.addEventListener( isTch ? 'touchend' : 'mouseup', mouseup, true );
                    data.onSelect && data.onSelect( this, element, ev );
                    evt.stopPropagation();
                    this._tableDown = true;
                }.bind( this ) )
        }

        function mousemove( ev ){
            var evt = ev,
            isTch = /touch/i.test( ev.type );
            if( isTch ){
                if( evt.touches.length > 1 ){
                    return;
                }
                evt = evt.touches[ 0 ];
            }
            var elem = window._resizeelem,
            targetElem = $L( elem ).data( 'element' ) || elem,
            directions = $L( elem ).data( 'directions' ),
            data = targetElem._resizeData,
            winwidth = window.innerWidth,
            newX = rtlfunc( 'clientX', evt, winwidth ),
            newY = evt.clientY,
            newLeft,
            newTop,
            preventTable = data.preventTable,
            bcr = getBcr( elem ),
            isTable = targetElem._resizeData.component == 'table',
            next = elem._next,
            xIncr = newX - rtlfunc( 'right', bcr, winwidth ) - elem._clientX,
            yIncr = newY - bcr.bottom - elem._clientY,
            clone = targetElem._clone,
            x = ( window.pageXOffset || document.documentElement.scrollLeft ) * ( isRtl ? -1 : 1 ),
            y = window.pageYOffset || document.documentElement.scrollTop,
            xFact = directions.left ? -1 : 1,
            yFact = directions.top ? -1 : 1,
            angle = elem.__resize_rotate,
            is_left = directions.left,
            is_top = directions.top,
            is_width = directions.width,
            is_height = directions.height;

            if( angle ){
                var flip = function(){
                    yIncr *= -1;
                    xIncr *= -1
                },
                interchange = function(){
                    var temp = xIncr;
                    xIncr = yIncr;
                    yIncr = temp * -1;
                },
                to_degree = 180 / Math.PI * angle;

                if( to_degree >= 45 && to_degree <= 135 ){
                interchange();
                } else if( to_degree > 135 && to_degree <= 225 ){
                flip();
                } else if( to_degree > 225 && to_degree <= 315 ){
                    interchange();
                    flip();
                }
            }
            
            targetElem = clone || targetElem;

            if( data.boundary && !next ){
                var bbcr;
                if( data.boundary.constructor == String ){
                var bcr1 = getBcr( $L( targetElem ).closest( data.boundary ).get( 0 ) );
                bbcr = {
                    left : bcr1[ rtlfunc( 'left' ) ],
                    right : bcr1[ rtlfunc( 'right' ) ],
                    top : bcr1.top,
                    bottom :bcr1.bottom
                }
                } else {
                    bbcr = data.boundary;
                }

                if( newX > bbcr[ rtlfunc( 'right' ) ] ){
                    xIncr -= ( newX - bbcr[ rtlfunc( 'right' ) ] );
                }

                if( newX < bbcr[ rtlfunc( 'left' ) ] ){
                    xIncr += ( bbcr[ rtlfunc( 'left' ) ] - newX );
                }

                if( newY > bbcr.bottom ){
                    yIncr -= ( newY - bbcr.bottom );
                }

                if( newY < bbcr.top ){
                    yIncr += ( bbcr.top - newY );
                }
            }

            if( data.showInfo ){
                if( !elem._moved ){
                    var infoDiv =  document.createElement( 'div' );
                    infoDiv.classList.add( 'lyteResizeInfoDiv', data.infoClass );
                    document.body.appendChild( infoDiv );
                    elem._infoDiv = infoDiv;
                } 
            } 
            elem._moved = true;

            if( is_width ){
                if( !preventTable ){
                    var min = data.minWidth || targetElem._minWidth || 0,
                    max = data.maxWidth || Infinity,
                    originalWidth = parseFloat( targetElem.style.width ),
                    modifiedWidth = originalWidth + xIncr * xFact,
                    final = Math.min( max, Math.max( min, modifiedWidth ) );
                    xIncr  = ( final - originalWidth ) * xFact;
                }

                if( isTable ){
                    var originalWidth = parseFloat( elem.style.width ),
                    modifiedWidth = originalWidth + xIncr,
                    final = Math.max( elem._minWidth, modifiedWidth );
                    xIncr = final - originalWidth;
                    if( next ){
                        originalWidth = parseFloat( next.style.width );
                        modifiedWidth = originalWidth - xIncr;
                        final = Math.max( next._minWidth, modifiedWidth );
                        xIncr = originalWidth - final;
                    }
                }
            }

            if( is_height ){
                var min = data.minHeight || targetElem._minHeight || 0,
                max = data.maxHeight || Infinity,
                originalHeight = parseFloat( targetElem.style.height ),
                modifiedHeight = originalHeight + yIncr * yFact,
                final = Math.min( max, Math.max( min, modifiedHeight ) );
                yIncr  = ( final - originalHeight ) * yFact;
                
                if( isTable ){
                    originalHeight = parseFloat( elem.style.height );
                    modifiedHeight = originalHeight + yIncr;
                    final = Math.min( Math.max( elem._minHeight, modifiedHeight ), elem._maxHeight || Infinity );
                    yIncr = final - originalHeight;
                }
            }

            if( is_left ){
                var left = parseFloat( targetElem.style[ rtlfunc( 'left' ) ] ),
                newLeft = left + xIncr,
                minLeft = data.minLeft || -Infinity,
                maxLeft = data.maxLeft || Infinity,
                finalLeft = Math.max( Math.min( maxLeft, newLeft ), minLeft );

                xIncr = finalLeft - left;
            }

            if( is_top ){
                var tp = parseFloat( targetElem.style.top ),
                newTop = tp + yIncr,
                minTop = data.minTop || -Infinity,
                maxTop = data.maxTop || Infinity,
                finalTop = Math.max( Math.min( maxTop, newTop ), minTop );

                yIncr = finalTop - tp;
            }

            var prev_width = parseFloat( targetElem.style.width ),
            prev_height = parseFloat( targetElem.style.height ),
            new_width = prev_width,
            new_height = prev_height;

            if( is_width ){
                if( !preventTable ){
                    targetElem.style.width = ( new_width = prev_width + xIncr * xFact ) + 'px';
                }
                if( isTable ){
                    elem.style.width = ( parseFloat( elem.style.width ) + xIncr ) + 'px';
                    if( next ){
                        next.style.width = ( parseFloat( next.style.width ) - xIncr ) + 'px';
                    }
                }
            }

            if( is_height ){
                targetElem.style.height = ( new_height = prev_height + yIncr * yFact ) + 'px';
                // var cells = toArray( elem.parentNode.children );
                elem.style.height = ( parseFloat( elem.style.height ) + yIncr ) + 'px'
            }

            if( angle ){

                var __fn = function( old_w, old_h, new_w, new_h ){
                    var is_width_change = new_w - old_w,
                    is_height_change = new_h - old_h,
                    ret  = check_rotational_modification( angle, old_w, old_h, new_w, new_h, xFact, yFact ),
                    original_left = parseFloat( targetElem.style.left ),
                    original_top = parseFloat( targetElem.style.top ),
                    x_fact = is_left ? -1 : 1,
                    y_fact = is_top ? -1 : 1;

                    if( is_width_change ){
                        targetElem.style.left = ( original_left + ret.x_diff * x_fact ) + "px";
                        targetElem.style.top = ( original_top + ret.y_diff * x_fact ) + "px";
                    } else if( is_height_change ){
                        targetElem.style.left = ( original_left - ret.x_diff * y_fact ) + "px";
                        targetElem.style.top = ( original_top + ret.y_diff * y_fact ) + "px";
                    }
                };

                __fn( prev_width, prev_height, new_width, prev_height );
                __fn( new_width, prev_height, new_width, new_height );
            } else {
                if( is_left ) {
                    targetElem.style.left = ( parseFloat( targetElem.style.left ) + xIncr ) + 'px';
                }
        
                if( is_top ) {
                    targetElem.style.top = ( parseFloat( targetElem.style.top ) + yIncr ) + 'px';
                }
            }

            if( data.showInfo ){
                var __info_elem = elem._infoDiv;

                __info_elem.innerHTML = data.getText ? data.getText( elem, Math.round( parseFloat( targetElem.style.width ) ), Math.round( parseFloat( targetElem.style.height ) ) ) : ( Math.round( parseFloat( targetElem.style.width ) ) + ' x ' + Math.round( parseFloat( targetElem.style.height ) ) );
                __info_elem.style[ rtlfunc( 'left' ) ] = ( newX + x + 15 ) + 'px';
                __info_elem.style.top = ( newY + y + 15 ) + 'px';
            }
            data.onMove && data.onMove( elem, $L( elem ).data( 'element' ), ev );
            evt.preventDefault();
        }

        function check_rotational_modification( angle, prev_width, prev_height, new_width, new_height, x_fact, y_fact ){
        var fn = function( __width, __height ){
                var obj = {
                    width : Math.cos( angle ) * __width + Math.sin( angle ) * __height,
                    height : Math.sin( angle ) * __width + Math.cos( angle ) * __height
                };

                obj.mid_x = obj.width / 2;
                obj.mid_y = obj.height / 2;

                return obj;
        },
        prev_rot = fn( prev_width, prev_height ),
        cur_rot = fn( new_width, new_height );

        return {
            x_diff : cur_rot.mid_x - prev_rot.mid_x - ( new_width - prev_width ) / 2 * x_fact,
            y_diff : cur_rot.mid_y - prev_rot.mid_y - ( new_height - prev_height ) / 2 * y_fact
        };
        }

        function mouseup( evt, frm_remove ){
            var isTch = /touch/i.test( evt.type );
            document.removeEventListener( isTch ? 'touchmove' : 'mousemove', mousemove, true );
            document.removeEventListener( isTch ? 'touchend' : 'mouseup', mouseup, true );
            var elem = window._resizeelem,
            targetElem = $L( elem ).data( 'element' ),
            data = targetElem._resizeData,
            next = elem._next,
            isTable = data.component == "table",
            directions = $L( elem ).data( 'directions' );

            if( elem._moved ){
                if( elem._infoDiv ){
                    elem._infoDiv.remove();
                    delete elem._infoDiv;
                }
                if( !frm_remove && data.onBeforeDrop && data.onBeforeDrop( elem, targetElem, evt, targetElem._clone ) == false ){
                    $L( targetElem._clone || targetElem ).css( elem._original );
                    if( isTable ){
                        if( directions.width ){
                            $L( elem ).css( elem._original );
                            delete elem._original;
                            if( next ){
                                $L( next ).css( next._original );
                                delete next._original;
                            }
                        } else {
                            toArray( elem.parentNode.children ).forEach( function( item ){
                                $L( item ).css( item._original );
                                delete item._original;
                            } )
                        }
                    }
                    delete elem._original;
                } else {
                    if( targetElem._clone ){
                        var lft = rtlfunc( 'left' );
                        targetElem.style[ lft ] = ( parseFloat( targetElem.style[ lft ] ) + parseFloat( targetElem._clone.style[ lft ] ) ) + 'px';
                        targetElem.style.top = ( parseFloat( targetElem.style.top )  + parseFloat( targetElem._clone.style.top ) ) + 'px';
                        targetElem.style.width = targetElem._clone.style.width;
                        targetElem.style.height = targetElem._clone.style.height;
                        targetElem._clone.style[ rtlfunc( 'left' ) ] = 0;
                        targetElem._clone.style.top = 0;
                    }
                    !frm_remove && data.onDrop && data.onDrop( elem, targetElem, evt, elem._original, targetElem._clone );
                }
            } else {
                !frm_remove && data.onRelease && data.onRelease( elem, targetElem, evt, targetElem._clone );
            }
            delete window._resizeelem; delete elem._moved;

            delete elem._clientX;
            delete elem._clientY;
            delete elem.__resize_rotate;
            delete elem._original;

            if( targetElem._resizeData.component == 'table' ){
                if( elem._next ){
                    delete elem._next._originalValue;
                    delete elem._next;
                }
                if( !elem.classList.contains( 'lyteResizeHandle' ) ){
                    $L( elem ).removeData( 'element' );
                    $L( elem ).removeData( 'directions');
                }
                if( targetElem.contains( evt.target ) ){
                    window._preventresizeClick = true;
                    setTimeout( function(){
                        delete this._preventresizeClick;
                    }, 0 );
                }
            }
        }

        function tableMove( evt ){
            if( window._resizeelem || evt.type == "mousemove" && evt.buttons ){
                return;
            }

            var data = this._resizeData,
            offset = data.offset,
            elementQuery = data.tags.td + ',' + data.tags.th,
            closest = $L( evt.target ).closest( elementQuery, this ).get( 0 ),
            winwidth = window.innerWidth,
            cx = rtlfunc( 'clientX', evt, winwidth ),
            cy = evt.clientY;
            if( !closest ){
                return;
            }

            var cells = closest.parentNode.children,
            index = getIndex( toArray( cells ), closest ),
            bcr = getBcr( closest ),
            isHori = cx > rtlfunc( 'right', bcr, winwidth ) - offset && cx < rtlfunc( 'right', bcr, winwidth ),
            isVert = cy > bcr.bottom - offset && cy < bcr.bottom,
            active = data.active,
            cursor,
            direction;

            if( data.preventTable && isHori ){
                if( index + ( closest.colSpan || 1 ) - 1 == cells.length - 1 ){
                    return;
                }
            }

            if( ( isHori && !data.preventHorizontal ) || ( isVert && !data.preventVertical ) ){
                    active && active.element != closest && removeActive.call( this );
                    cursor = closest._cursor == undefined ? closest.style.cursor : closest._cursor;
                    if( isVert ){
                        direction = 'vertical';
                        closest.style.cursor = data.rowResize;
                    } else if( isHori ){
                        direction = 'horizontal';
                        closest.style.cursor = data.colResize;

                    }   
                    closest._cursor = cursor;
                    data.active = { cursor : cursor, element : closest, direction : direction };
                } else {
                    active && removeActive.call( this );       
                }
        }

        function removeActive(){
            var active = this._resizeData.active;
            if( active ){
                active.element.style.cursor = active.element._cursor;
                delete active.element._cursor;
                delete this._resizeData.active;
            }
        }

        function getIndex( array, elem ){
            return array.indexOf( elem );
        }

        function toArray( arr ){
            if( Array.from ){
                return Array.from( arr );
            }
            return Array.apply( Array, arr );
        }

        $L.prototype.enableResize = function( obj ){
            if( obj == 'destroy' ){
                return destroy.call( this );
            }
            obj = obj || {};
            obj.directions = obj.directions || [ 'N', 'S', 'W', 'E', 'SW', 'SE', 'NW', 'NE' ];
            obj.rotation = obj.rotation == undefined ? true : obj.rotation;
            obj.tags = obj.tags || { td : "td", th : "th", tr : "tr", table : "table", thead : "thead", tbody : "tbody" };
            obj.rowResize = obj.rowResize || "row-resize";
            obj.colResize = obj.colResize || "col-resize";
            obj.offset = obj.offset || 10;
            bind.call( this, obj );
            return this;
        }

        document.addEventListener( 'click', function( evt ){
            var active = document.getElementsByClassName( 'lyteResizeSelected' ),
            _length = active.length;

            for( var i = 0; i < _length; i++ ){
                active[ i ].classList.remove( 'lyteResizeSelected' );
            }
            !window._preventresizeClick && $L( evt.target ).closest( '.lyteResizeElement' ).addClass( 'lyteResizeSelected' ).children( '.lyteResizeClone' ).attr( 'style', '' );
        }, true )
    }
} );
;( function( cb ){
	if( typeof define == "function" && define.amd ){
		  define( [ "@zoho/lyte-dom" ], cb );
	  } else {
		  cb( window.$L );
	  }
} )( function( $L ){
   if( $L ) {
    var uA = window.navigator.userAgent, 
    isSaf =  { 
        uA : uA, 
        isUbuntu : /ubuntu/ig.test( uA ), 
        isIpad : /ipad/ig.test( uA ), 
        safari : /safari/ig.test( uA ), 
        isIE11Lyte : /rv:11/ig.test( uA ), 
        isEdgeLyte : /Edge/ig.test( uA ), 
        mode : {}, 
        chrome  : !!window.chrome , 
        firefox : /firefox/ig.test( uA ) 
    };

    function appendDiv( className, obj, dir, is_parent ) {
        var div = document.createElement( 'div' ), innerDiv;
        div.className = className;
        div._scrolldiv = this;
        div.style.visibility = 'hidden';
        innerDiv = document.createElement( 'div' );
        innerDiv.classList.add( 'lyteScrollDiv' );
        if( obj.handlerClass ) {
            innerDiv.classList.add( obj.handlerClass );
        }
        if( obj.containerClass ) {
            div.classList.add( obj.containerClass )
        }
        div.appendChild(innerDiv);
        if( dir ) {
            innerDiv._direction = dir;
            if( obj.horizontalContainerClass ){
                div.classList.add( obj.horizontalContainerClass );
            }
            if( obj.horizontalHandlerClass ) {
                innerDiv.classList.add( obj.horizontalHandlerClass );
            }
            this._horiDiv = div;
        } else {
            if( obj.verticalContainerClass  ) {
                div.classList.add( obj.verticalContainerClass );
            }
            if( obj.verticalHandlerClass ){
                innerDiv.classList.add( obj.verticalHandlerClass );
            }
            this._vertDiv = div;
        }

        ( is_parent ? this.parentElement : this ).appendChild( div )
        
        div.addEventListener( 'click', outerDivClick, true );
        innerDiv.addEventListener( 'mousedown', innerDivClick );
        if( !this._infiniteScroll ){        
            innerDiv.addEventListener( 'touchstart', innerDivClick );       
        }
        return div;
    }   

    function set( elem, prop, val ) {
        if( elem.style[ prop ] != val ){
            elem.style[ prop ] = val
        }
    }

    function checkscrollable( evt ){
        evt = evt || { target : this };
        var target = evt.target.correspondingElement || evt.target, ret;

        if( target.closest( '.lyteConnectWrapper.preventWheel' ) ){
            return true;
        }
        
        while( target && target != this ) {
            if( target.classList.contains( 'preventWheel' ) ) {
                ret = true;
                break;
            }
            target = target.parentElement
        }
        return ret
    }

    function check( flag, elem, obj, mode, evt ){
        var fg;
        evt = evt || {};

        window.fn = function( elem ){
            set( elem, 'visibility', 'hidden' );
            elem.classList.remove( 'visible' );
        };

        if( !flag.scroll ) {
            var is_showon_scroll = this._scrollData.showOn == 'scroll';
            if( !( [ 'mouseenter', 'touchstart' ].indexOf( evt.type ) != -1 && is_showon_scroll ) ){
                var from_reset = ( this._enableScroll = !flag.frm_reset ),
                is_event_added = $L( this ).hasClass( "eventBinded" );

                if( elem && ( !is_showon_scroll || !flag.frm_reset ) ) {
                    clearTimeout( elem._entertimeout );
                    clearTimeout( elem._leavetimeout );
                    delete elem._entertimeout; delete elem._leavetimeout;
                    if( !flag.scrollbar ){

                        if( !from_reset && !is_event_added ){
                            return;
                        }

                        if( evt.type == "touchstart" ){
                            elem._entertimeout = setTimeout( set.bind( this, elem, 'visibility', 'visible' ), 150 );
                        } else {
                            set( elem, 'visibility', 'visible' );
                        }
                        elem.classList.add( 'visible' );
                        updatePos.call( this, mode, undefined, {}, obj );
                    } else{
                        window.fn( elem );
                    }
                }
            }
            fg = true
        } else {
            if( elem ) {
               window.fn( elem );
            }
        }
        return fg
    }

    function initialWheel( evt ){
        this.removeEventListener( 'wheel', initialWheel, true )
        if( !this.classList.contains( 'eventBinded' ) ){
            var close_connect = this.closest( "lyte-connect" );
            if( !close_connect ){
                mouseenter.call( this, { type : 'mouseenter' } );
            }
        }
        evt.preventDefault()
    }

    function format_bcr( bcr ){
        var obj = {};
        [ 'x', 'y', 'bottom', 'height', 'top', 'width', 'left', 'right' ].forEach( function( item ){
            obj[ item ] = Math.round( bcr[ item ] );
        });
        return obj;
    }

    function mouseenter( evt, frm_reset ) {
        // console.log( evt.target, evt.type, evt.currentTarget );
        if( this.classList.contains( 'eventBinded' ) && evt != true ){
            return
        }
        if( evt.type == 'mouseenter' && this._prtmseenr ){
            return;
        }
        var flag, 
        obj = { scrollLeft : Math.round( this.scrollLeft ), scrollTop : Math.round( this.scrollTop ), scrollWidth : this.scrollWidth, scrollHeight : this.scrollHeight, bcr : format_bcr( this.getBoundingClientRect() ) },
        scrolldata = this._scrollData;

        this._wheelObj = obj
        if( this.classList.contains( 'lyteTableScroll' ) ){
            forTable.call( this, obj )
        }
        this._direction = window.getComputedStyle(  this ).direction;
        obj.vertbcr = this._vertDiv ?  this._vertDiv.getBoundingClientRect() : {}
        obj.horbcr = this._horiDiv ?  this._horiDiv.getBoundingClientRect() : {}
        flag = check.call( this, fitForScroll.call( this, true, obj, frm_reset ), this._vertDiv, obj, true, evt )
        flag = check.call( this, fitForScroll.call( this, false, obj, frm_reset ), this._horiDiv, obj, false, evt ) || flag
        if( flag && evt ) {
            this._mouseleave = this._mouseleave || mouseleave.bind( scrolldata.appendTo == "parent" ? this.parentElement : this );
            if( evt.type == "touchstart" ) {
               if( evt.touches.length == 1 ){
                    clearTimeout( this._tchtime );
                    document.addEventListener( 'touchcancel', this._mouseleave, true )
                } else {
                    return;
                }
            } else {
                this.addEventListener( 'wheel', wheelEvent, true );
                this.addEventListener('keydown', keydownFunc, true);
                if( this._scrollData.showOn == 'scroll' ){
                    this.addEventListener( 'mousemove', hideScrollbar, true );
                }
            }
            this._allowTouch = true;
            document.addEventListener( 'touchend', this._mouseleave, true )
            this.classList.add( 'eventBinded' )
            this._tabindex = this._tabindex == undefined ? this.tabIndex : this._tabindex;
            if(this.tabIndex == -1){
                this.tabIndex = scrolldata.tabIndex || 0;
            }
        }
    } 

    function keydownFunc( evt ) {
        if( evt.target != this ){
            return
        }

        var key = evt.key,
        elem = this,
        sL =  Math.round( elem.scrollLeft ),
        sT = Math.round( elem.scrollTop ),
        wd = elem.offsetWidth,
        hgt = elem.offsetHeight,
        s_wd = elem.scrollWidth,
        s_hgt = elem.scrollHeight,
        obj = { 
            scrollLeft : sL, 
            scrollTop : sT, 
            scrollWidth : s_wd, 
            scrollHeight : s_hgt, 
            bcr : elem.getBoundingClientRect() 
        },
        step = this._scrollData.keyStep,
        dir = this._direction == 'rtl',
        pos,
        mode,
        __new,
        is_negative = dir && ( !window._lyteUiUtils || window._lyteUiUtils.isNegativeScroll() ),
        meta = evt.metaKey || evt.ctrlKey;

        switch( key ){
            case "ArrowLeft" : {
                mode = false;

                if( meta ){
                    if( dir ){
                        if( is_negative ){
                            __new = wd - s_wd;
                        } else {
                            __new = s_wd - wd;
                        }
                    } else {
                        __new = 0;
                    }
                } else {
                    if( dir && is_negative ){
                        dir = false;
                    }
                    __new = sL - step * ( dir ? -1 : 1 );
                }
            }
            break;
            case "ArrowRight" : {
                mode = false;
                
                if( meta ){
                    if( dir ){
                        if( is_negative ){
                            __new = 0;
                        } else {
                            __new = wd - s_wd;
                        }
                    } else {
                        __new = s_wd - wd;
                    }
                } else {
                    if( dir && is_negative ){
                        dir = false;
                    }
                    __new = sL + step * ( dir ? -1 : 1 );
                }
            }
            break;
            case "ArrowDown" : {
                __new = Math.min( sT + step, s_hgt - hgt );
                mode = true;
            }
            break;
            case "ArrowUp" : {
                __new = Math.max( 0, sT - step );
                mode = true;
            }
            break;
            case "PageDown" : {
                __new = Math.min( sT + hgt, s_hgt - hgt );
                mode = true;
            }
            break;
            case "PageUp" : {
                __new = Math.max( sT - hgt, 0 );
                mode = true;
            }
            break;
            case "Home" : {
                __new = 0;
                mode = true;
            }
            break;
            case "End" : {
                __new = s_hgt - hgt;
                mode = true;
            }
            break;
        }

        if( mode != void 0 && shouldPrevent.call( elem, obj, mode, __new - ( mode ? sT : sL ) ) ){
            elem[ mode ? 'scrollTop' : 'scrollLeft' ] = __new;
            scroll.call( elem, evt )
            evt.preventDefault();
        }
    }

    function mouseleave( evt ){
        evt = evt || {};
        if( ( evt.relatedTarget && this.contains( evt.relatedTarget ) ) || document._scrollmouseup ){
            return
        }
        if( evt.type == 'touchend' ) {     
            var tar = evt.target.correspondingElement || evt.target;        
            if( tar && tar.classList.contains( 'lyteScrollContainer' ) ) {      
                return;     
            }       
        }
        var bars = $L( this ).children( '.lyteScrollContainer' ), scrlDiv = this._scrolldiv || this;
        if( bars.length ) {
            for(  var i = 0; i < bars.length; i++ ) {
                var __cur_bar = bars[ i ];

                clearTimeout( __cur_bar._entertimeout );
                clearTimeout( __cur_bar._leavetimeout );
                delete __cur_bar._entertimeout;
                delete __cur_bar._leavetimeout;

                __cur_bar.classList.remove( 'visible' )
                if( evt.type == 'touchend' ){
                    __cur_bar._leavetimeout = setTimeout( set.bind( this, __cur_bar, 'visibility', 'hidden'), 150 )
                } else {
                    __cur_bar.style.visibility = 'hidden';
                }
            }
            if( evt.type == 'mouseleave' ) {
                scrlDiv.removeEventListener('wheel', wheelEvent, true);
                scrlDiv.removeEventListener('keydown', keydownFunc, true);
                scrlDiv.removeEventListener( 'mousemove', hideScrollbar, true );
                scrlDiv.addEventListener( 'wheel', initialWheel, true );
            } else if( evt.type == 'touchend' || evt.type == "touchcancel" ) {
                scrlDiv._prtmseenr = true;
                scrlDiv._tchtime = setTimeout( function(){
                    delete scrlDiv._prtmseenr;
                }, 500 )
                document.removeEventListener( 'touchcancel', scrlDiv._mouseleave, true )
            }
            if( evt.type ){
                document.removeEventListener( 'touchend', scrlDiv._mouseleave, true )
                delete scrlDiv._allowTouch;
                scrlDiv.classList.remove( 'eventBinded' );
                // scrlDiv.tabIndex = this._scrolldiv._tabindex;
                // delete scrlDiv._tabindex;
                 delete scrlDiv._wheelObj;
                delete scrlDiv._prevPosY; delete scrlDiv._mouseleave;
                delete scrlDiv._prevPosX; delete scrlDiv._wheelEvt;
            }
            delete scrlDiv._enableScroll;
        }
    }

    function outerDivClick( evt ) {
        if( !this.classList.contains( 'visible' ) ){
            return
        }
        var isTch = evt.type == "touchmove";       
        if( isTch ) {       
            if( evt.touches.length > 1 ){       
                return;     
            } else {        
                evt.preventDefault();       
                evt = evt.touches[ 0 ]      
            }       
        }       
        var elem = this._scrolldiv, mode, inn = this.children[ 0 ], outBcr = this.getBoundingClientRect(), inBcr = inn.getBoundingClientRect(),
        obj = { scrollLeft : Math.round( elem.scrollLeft ), scrollTop : Math.round( elem.scrollTop ), scrollWidth : elem.scrollWidth, scrollHeight : elem.scrollHeight, bcr : elem.getBoundingClientRect() },
        hgt = 'width', top1 = 'left', sT = 'scrollLeft', sH = 'scrollWidth', bt = 'right', cY = 'clientX';
        if( this.classList.contains( 'lyteTableScroll' ) && !obj.$nodeClient ){
            forTable.call( this, obj )
        }
        obj.vertbcr = this._vertDiv ?  this._vertDiv.getBoundingClientRect() : {}
        obj.horbcr = this._vertDiv ?  this._horiDiv.getBoundingClientRect() : {}
        if(!inn._direction){
            mode = true;
            hgt = 'height', top1 = 'top', sT = 'scrollTop', sH = 'scrollHeight', bt = 'bottom', cY = 'clientY';
        }
        var scramt = evt.type != 'click' ? ( evt[ cY ] - ( this.prev || evt[ cY ] ) ) : ( evt[ cY ] - ( inBcr[ top1 ] + inBcr[ hgt ] / 2 ) ), newsL;
        newsL = ( scramt / ( obj.bcr[ hgt ] + obj.bcr[ top1 ] - outBcr[ top1 ] ) * obj[ sH ] )
        elem[ sT ] += ( newsL ) ;
        scroll.call( elem, evt );
        this.prev = evt[ cY ];
    }

    function innerDivClick( evt ) {
       var isTch = evt.type == "touchstart",
       __parentNode = this.parentNode,
       __document = document,
       ael = 'addEventListener';

        __document[ ael ]( isTch ? 'touchmove' : 'mousemove', __document._scrollmousemove = outerDivClick.bind( __parentNode ), true );
        __document[ ael ]( isTch ? 'touchend' : 'mouseup', __document._scrollmouseup = mouseup.bind( __parentNode ), true );

        evt.preventDefault();
        evt.stopPropagation();
    }

    function mouseup( evt ) {
        var isTch = evt.type == "touchend",
        __document = document,
        rel = "removeEventListener",
        scroll_elem = this._scrolldiv || this,
        target = evt.target,
        scrolldata = scroll_elem._scrollData;

        __document[ rel ]( isTch ? 'touchmove' : 'mousemove', __document._scrollmousemove, true );
        __document[ rel ]( isTch ? 'touchend' : 'mouseup', __document._scrollmouseup, true );

        delete __document._scrollmousemove;
        delete __document._scrollmouseup; 
        delete this.prev;

        if( !scroll_elem.contains( target.correspondingElement || target ) && scrolldata.showOn != 'always' ){
            mouseleave.call( scrolldata.appendTo == "parent" ? scroll_elem.parentNode : scroll_elem , { type : 'mouseleave' } );
        }
    }

    function mousedown( evt ) {

        var scrolldata = this._scrollData,
        __document = document;

        if( __document._scrollmouseup ) {
            return
        }
        __document.addEventListener( 'mouseup', __document._scrollmouseup = mouseup.bind( scrolldata.appendTo == "parent" ? this.parentElement : this ), true )
    }

    function fitForScroll( mode, obj, frm_reset ) {
        var sL = 'scrollTop', sW = 'scrollHeight', wd = 'height', elem = mode ? this._vertDiv : this._horiDiv,
        scrolldata = this._scrollData,
        margin = scrolldata.scrollYMarginOffset;

        if( !mode ) {
            sL = 'scrollLeft', sW = 'scrollWidth', wd = 'width';
            margin = scrolldata.scrollXMarginOffset;
        }
        if( obj[ sL ] + obj.bcr[ wd ] >= obj[ sW ] && obj[ sL ] == 0 ){
            if( elem && elem.classList.contains( 'visible' ) ) {
                check.call( this, { scroll : true, scrollbar : true }, elem )
            }
            return {
                scroll : true,
                scrollbar : true,
                frm_reset : frm_reset
            }
        }

        return{
            scroll : false,
            scrollbar : ( obj[ sW ] - obj.bcr[ wd ] ) <= margin,
            frm_reset : frm_reset
        }
    }

    function wheelEvent( evt ){
         if( checkscrollable.call( this, evt ) ) {
                return
            }
        if( evt.type == 'touchmove' ) { 
            if( this._allowTouch && evt.touches.length == 1 ) {
                var curr = evt.touches[ 0 ];
                wheelEvent1.call( this, evt, [ (this._prevPosX || curr.clientX ) - curr.clientX,  ( this._prevPosY || curr.clientY ) - curr.clientY ] )
                this._prevPosY = curr.clientY;
                this._prevPosX = curr.clientX;
            }
        } else {   
            wheelEvent1.call( this, evt )
        }
    }

    function shouldPrevent( obj, mode, val ){
        var sL = 'scrollTop', sW = 'scrollHeight', wd = 'height', elem = mode ? this._vertDiv : this._horiDiv;
        if( !mode ) {
            sL = 'scrollLeft';
            sW = 'scrollWidth';
            wd = 'width';
        }

        if( mode ){
            if( ( val > 0 && Math.round( obj[ sL ] + obj.bcr[ wd ] ) >= obj[ sW ] ) || ( val < 0 && obj[ sL ] == 0 ) ){
                return false
            }
        } else {
            if( ( val > 0 && Math.round( obj[ sL ] + obj.bcr[ wd ] ) >= obj[ sW ] ) || ( val < 0 && Math.round( -obj[ sL ] + obj.bcr[ wd ] ) >= obj[ sW ] ) ){
                return false
            } else if( !mode && isSaf.firefox && this._direction == 'rtl' && ( val < 0 && obj[ sL ] == 0 ) ){
                return true
            } else if( ( val < 0 && obj[ sL ] == 0 ) && !( val < 0 && isSaf.safari && this._direction == 'rtl' && obj[ sL ] == 0 ) ){
                return false;
            }
        }
        return true
    }

    function getWheel( evt ) {
        var data = this._scrollData, min = data.min, max = data.max,
        fact1 = data.wheelSpeed, fact = fact1, uA = isSaf.uA.toLowerCase(), inf = this._infiniteScroll, ie = isSaf.isIE11Lyte;
        if( ( uA.indexOf('edge') != -1 || (( uA.indexOf('trident') != -1 || uA.indexOf('msie') != -1)) ) && this._direction == 'rtl' ){
            fact1 *= -1
        }
        // if( evt.shiftKey ) {
        //     fact1 *= -1; fact *= -1; 
        // }
        var x, 
        y, 
        delta = evt.deltaMode && evt.deltaMode == 1,
        __deltaX = evt.deltaX,
        __deltaY = evt.deltaY;

        if( evt.shiftKey ){
            var __temp = __deltaX;
            __deltaX = __deltaY;
            __deltaY = __temp;
        }

        if( __deltaX > 0 ) {
            x = Math.max( delta ? ( __deltaX * 6 ) :  __deltaX, (inf ? 0 : 4 ) )
        } else if( __deltaX < 0 ) {
            x = Math.min( inf ? 0 : -4, delta ? ( __deltaX * 6 ) : __deltaX )
        }
        if( __deltaY > 0 ) {
            y = Math.min( max, Math.max( delta ? ( __deltaY * 6 ) : __deltaY, inf ? 0 : 4 ), ie ? 20 : Infinity );
        } else if( __deltaY < 0 ) {
            y = Math.max( min, Math.min( inf ? 0 : -4, delta ? ( __deltaY * 6 ) : __deltaY ), ie ? -20 : -Infinity );
        }
        return [ x * fact1, y * fact ]
    }

    function nestedScroll( evt, ret ){  
        var target = evt.target;
        while( target != this ) {
            var sT = Math.round( target.scrollTop ),
            sH = target.scrollHeight,
            oH = target.offsetHeight,
            compsty = window.getComputedStyle( target ),
            isMatch = ( /scroll|auto/i.test( compsty.overflowY ) || ( target.classList.contains( 'lyteScrollBar' ) && /hidden/i.test( compsty.overflowY  ) ) );


            if( oH < sH  ){
                if( ret ){
                    if( oH + sT < sH && isMatch ){
                        return true;
                    }
                } else {
                    if( sT && isMatch ){
                        return true;
                    }
                }
            }
            target = target.parentNode;
        }
    }

    function wheelEvent1( evt, tch ) {            
        var ret = tch || getWheel.call( this, evt );
        var a = ret[ 0 ] || 0, 
        b = ret[ 1 ] || 0, 
        mode = false, 
        obj = this._wheelObj || {} , 
        fit, 
        stpre, 
        isTable = this.classList.contains( 'lyteTableScroll' ),
        __deltaX = evt.deltaX,
        __deltaY = evt.deltaY,
        scrolldata = this._scrollData;

        if( evt.shiftKey ){
            var __temp = __deltaX;
            __deltaX = __deltaY;
            __deltaY = __temp;
        }

        if( Math.abs( tch ? a : ( __deltaX || 0 ) ) <= Math.abs( tch ? b : ( __deltaY || 0 ) ) ) {
            mode = true
        }
        if( scrolldata.nested && mode && nestedScroll.call( this, evt, b > 0 ) ){
            return;
        }

        if( scrolldata.showOn == 'scroll' ){
            if( !this._enableScroll ){
                mouseenter.call( this, true )
                evt.preventDefault();
                return
            }
            clearTimeout( this._scrollplugin )  
            this._scrollplugin = setTimeout(mouseleave.bind( scrolldata.appendTo == "parent" ? this.parentElement : this, {} ), scrolldata.tOut )
        }

        if( this._scrollEnd ) {
            obj= { scrollLeft : Math.round( this.scrollLeft ), scrollTop : Math.round( this.scrollTop ), scrollWidth : this.scrollWidth, scrollHeight : this.scrollHeight, bcr : format_bcr( this.getBoundingClientRect() ) };
            this._wheelObj = obj
            if( this.classList.contains( 'lyteTableScroll' ) ){
                forTable.call( this, obj )
            }
        }
        if( this._wheelObj ){
            fit = fitForScroll.call( this, mode, obj );
            if(( fit.scroll && mode /*&& b > 0*/ && (  !this._vertDiv || ( this._vertDiv && !this._vertDiv.classList.contains( 'visible' ) ) ) ) || ( fit.scroll && !mode /*&& a < 0*/ && ( !this._horiDiv || ( this._horiDiv && !this._horiDiv.classList.contains( 'visible' ) ) ) ) ){
                return
            }
            stpre = shouldPrevent.call( this, obj, mode, mode ? b : a ); 


            var is_inf = this._infiniteScroll,
            is_stopped = is_inf ? this.comp._stopScroll : false;

            if( ( is_inf && b > 0 ) || stpre ){
                 evt.preventDefault();
                if( !stpre && isTable && mode ) {
                    this.comp.scrollTable.call( this.comp, { yScroll : b }, this._wheelObj )
                }
            } else{
                if( scrolldata.preventOnEnd ){
                    evt.preventDefault();
                }
                return
            }
        }
        if( mode ) {
            if( isSaf.isIE11Lyte ) {
                if( this._wheelObj ){
                    this._wheelObj.scrollTop = Math.max( Math.min( this._wheelObj.scrollTop + b, this._wheelObj.scrollHeight - this._wheelObj.bcr.height ), 0 )
                    if(  isTable ) {
                        evt.yScroll = b;
                        this.comp.scroll.call( this, evt )
                    }
                    this.scrollTop += b;
                } 
            } else if( !isSaf.isIE11Lyte ) {
                this.scrollTop += b;
            }
        } else {
             if( isSaf.isIE11Lyte ) {
                if( this._wheelObj ) {
                    this._wheelObj.scrollLeft = Math.max( Math.min( this._wheelObj.scrollLeft + a, this._wheelObj.scrollWidth - this._wheelObj.bcr.width ), 0 )
                    if(  isTable ) {
                        evt.xScroll = a;
                        this.comp.scroll.call( this, evt )
                    }
                    this.scrollLeft += a;
                }
            } else {
               this.scrollLeft += a; 
            }
         }   
        if( isSaf.safari || isSaf.isIE11Lyte || isSaf.isIpad ) {
                this._alive = true;
                clearTimeout( this._alivetime )
                this._alivetime = setTimeout( function(){
                   delete this._alive; delete this._alivetime; 
                }.bind( this ), 16 )
            this._scrollFun.call( this, evt )
        }


        // if( this.comp ){
        //     clearTimeout( this._overlay.time );
        //     !this._overlay.classList.contains( 'lytescrolling' ) && this._overlay.classList.add( 'lytescrolling' );
        //     this._overlay.time = setTimeout( function(){
        //         this._overlay.classList.remove( 'lytescrolling' );
        //         delete this._overlay.time;
        //     }.bind( this ), 250 ) 
        // }
    }

    function scroll( evt ) {
        var a, b, issafIE = isSaf.isIE11Lyte || isSaf.safari || isSaf.isIpad, isIe = isSaf.isIE11Lyte ;
        if( issafIE && evt && evt.type == 'scroll' && ( this._alive && !evt._byFunc ) ) {
            trigEvt.call( this, isSaf.mode.a, isSaf.mode.b, this._wheelObj || { bcr : {} }, evt )
        } else{
            var obj= { scrollLeft : Math.round( this.scrollLeft ), scrollTop : Math.round( this.scrollTop ), scrollWidth : this.scrollWidth, scrollHeight : this.scrollHeight, bcr : this.getBoundingClientRect() };
            this._wheelObj = obj
            if( this.classList.contains( 'lyteTableScroll' ) ){
                forTable.call( this, obj )
            }
            if( this.prevScrlLeft != obj.scrollLeft ) {
                a = obj.scrollLeft - ( this.prevScrlLeft || 0 );
                b = 0;
                updatePos.call( this, false, a , evt, obj )
            } 
            if( this.prevScrlTop!= obj.scrollTop ) {
                b = obj.scrollTop - ( this.prevScrlTop || 0 );
                a = 0;
                updatePos.call( this, true, b , evt, obj )
            }
            isSaf.mode.b = b; isSaf.mode.a = a;
            if( !isIe || ( issafIE && ( !this._alive || evt._byFunc ) ) ) {
               if(  this.classList.contains( 'lyteTableScroll' ) ) {
                    this.comp.scroll.call( this, evt )
                }
            }
        }
    }

     function hideScrollbar( evt ) {
        clearTimeout( this._scrollplugin );  
        this._scrollplugin = setTimeout( mouseleave.bind( this._scrollData.appendTo == "parent" ? this.parentElement : this ), 500 );
    }

    function forTable( obj ) {
        var component =  this.comp, headerList = component.$node.getElementsByTagName( 'lyte-th' )
        if( this._infiniteScroll ){
            obj.$nodeClient = this.parentElement.getBoundingClientRect();
            var dummy =  this.getElementsByClassName( 'lytePreventInfiniteScroll' );
            obj.neglected = [];
            for( var m = 0; m < dummy.length; m++ ) {
                if( /*isVisible( dummy[ m ] )*/ !dummy[ m ].classList.contains( 'lyteHidden' ) ) {
                    obj.neglected.push( dummy[ m ] );
                }
            }

            obj.compNeg = dummy;
            if( this.comp._top != undefined ) {
                obj.topElem = [];
                var body = this.getElementsByTagName( 'lyte-tbody' )[ 0 ],
                another = body.getElementsByTagName( 'lyte-tr' );
                for( var n = 0; n < another.length; n++ ) {
                    if( !another[ n ].classList.contains( 'dummy' ) ) {
                        obj.topElem.push( another[ n ] );
                    }
                }
                obj.topElem = obj.topElem[ this.comp._top + obj.compNeg.length ]
                obj.topElemClient = obj.topElem ? this.comp.topElem( obj.topElem ) : {};
                obj.bottmElem = body.querySelector( 'lyte-tr:nth-of-type(' + ( ( this.comp._bottom + 1 + obj.compNeg.length ) ) + ')' );
                obj.bottmElemClient = obj.bottmElem ? this.comp.topElem( obj.bottmElem ) : {}
                obj.tbody = body
                obj.tbodyClient = obj.tbody ? obj.tbody.getBoundingClientRect() : {};
            }
        }
        obj.scrollDivClient = obj.bcr;
        for(var k = 0; k < headerList.length; k++)
            {
                headerList[k].property = headerList[k].getBoundingClientRect();
                headerList[k].order = k
            }
        obj.calculated = true;  
    }

    function trigEvt( a, b, obj, evt ) {
        delete this._scrollEnd; 

        var offset = this._scrollData.offset,
        __direction = this._direction == "rtl";

        if( ( ( Math.ceil( obj.scrollLeft + obj.bcr.width + offset.x ) >= obj.scrollWidth ) && !( __direction && isSaf.chrome ) ) || ( ( isSaf.firefox || isSaf.safari ) && __direction && ( Math.ceil( -obj.scrollLeft + obj.bcr.width + offset.x ) >= obj.scrollWidth ) ) || ( __direction && isSaf.chrome &&  obj.scrollLeft == offset.x ) ) {
            evt.horiScrollEnd = true;
        }
        if( Math.ceil( obj.scrollTop + obj.bcr.height + offset.y ) >= obj.scrollHeight ) {
            this._scrollEnd = evt.vertScrollEnd = true;
        }
        evt.yScroll = b; evt.xScroll = a;
        evt._byPlugin = true;
        this._wheelObj = obj;
    }

    function updatePos( mode, a, evt, obj ){
        var __this = this,
        __vert = __this._vertDiv,
        __hori = __this._horiDiv;

        if( parseInt( Math.abs( a ) ) == 0 || ( mode && !__vert ) ||( !mode && !__hori ) ){
            return;
        }

        var __out = mode ? __vert : __hori,
        rail_bcr = obj[ ( mode ? 'vert' : 'hori' ) + 'bcr' ] || __out.getBoundingClientRect(),
        __inn = __out.children[ 0 ],
        sL = "scrollTop",
        sW = "scrollHeight",
        wd = "height",
        lt = "top",
        direction = __this._direction == "rtl",
        btm = "bottom",
        __scrolldata = __this._scrollData,
        __bcr = obj.bcr,
        is_container = __scrolldata.appendTo != "parent",
        top_offset = mode ? ( __scrolldata.topOffset || 0 ) : 0;

        if( is_container ){
            rail_bcr = __bcr;
        }

        if( !mode ){
            sL = "scrollLeft";
            sW = "scrollWidth";
            wd = "width";
            lt = "left";
        }

        var __width = __bcr[ wd ],
        rail_bcr_lt = rail_bcr[ lt ],
        __rt = ( __width - ( rail_bcr_lt + top_offset - __bcr[ lt ] ) ) / obj[ sW ],
        trt = obj[ sL ] / obj[ sW ],
        mL = __scrolldata.minLength,
        minLength = mL ? ( mL != "auto" ? mL : 0 ) : 0.1 * __width,
        __final;

        set( __inn, wd, Math.max( __rt * __width, minLength ).toFixed( 3 ) + 'px' );

        if( direction && __inn._direction ){
            if( ( isSaf.safari && (  window._lyteUiUtils.isNegativeScroll() || !window.chrome ) ) || isSaf.firefox ) {
                __final =  ( ( obj[ sL ] / obj[ sW ] * 100 )  * obj.bcr[ wd ] / parseFloat( Math.max( __rt * __width, minLength ).toFixed( 3 ) ) );;
            } else {
                __final =  ( ( -( obj[ sW ] - __width - obj[ sL ] ) / obj[ sW ] * 100 ) * __width / parseFloat( Math.max( __rt * __width, minLength ).toFixed( 3 ) ) );
            }
            __final = 'translateX(' + __final + '%)';
        } else {
            __final = ( mode ? 'translateY' : 'translateX' ) + '(' + trt * ( __width - ( rail_bcr_lt - __bcr[ lt ] ) - ( Math.max( 0, minLength - __rt * __width ) ) ) + 'px)';
        }

        set( __inn, 'transform', __final );

        if( is_container ){
            set( __out, wd, __width + 'px' );

            var __other_elem = mode ? __hori : __vert,
            __to_set = 'translate' + '(' + obj.scrollLeft + 'px,' + obj.scrollTop + 'px)';

            set( __other_elem, 'transform', __to_set );
            set( __out, 'transform', __to_set );
        }

        __this.prevScrlLeft = obj.scrollLeft; 
        __this.prevScrlTop = obj.scrollTop;

        if( evt.type ){
            trigEvt.call( __this, mode ? 0 : a, mode ? a : 0, obj, evt );
        }
    }

    function removeScroll(){
        var elements = this;
        for( var i = 0; i < elements.length; i++ ) {
            var elem = elements[ i ], wrap = elem.parentElement;
            if( !wrap ){
                continue;
            }

            var scrolldata = elem._scrollData;

            if( scrolldata ) {

                if( scrolldata.appendTo != "parent" ){
                    wrap = elem;
                }

                delete elem._scrollData;
            }
            var scrollDivs = wrap.querySelectorAll( 'div.lyteScrollContainer' );
            for(var k = 0; k < scrollDivs.length; k++){
                if( scrollDivs[k].parentElement == wrap ) {
                    delete scrollDivs[ k ]._entertimeout;
                    delete scrollDivs[ k ]._leavetimeout;
                    wrap.removeChild(scrollDivs[k]);
                }
            }
            elem.classList.remove( 'lyteScrollBar', 'eventBinded' );
            elem.removeEventListener( 'mouseenter', mouseenter, true );
            elem.removeEventListener( 'wheel', initialWheel, true );
            elem.removeEventListener( 'touchstart', mouseenter, true )
            wrap.removeEventListener( 'mouseleave', mouseleave, true );
            elem.removeEventListener( 'mousedown', mousedown );
            elem.removeEventListener( 'touchmove', wheelEvent, { passive : false } )
            elem.removeEventListener( 'scroll', scroll, true );
            clearTimeout( elem._tchtime );
            if( elem._mouseleave ){
                document.removeEventListener( 'touchcancel', elem._mouseleave, true );
                document.removeEventListener( 'touchend', elem._mouseleave, true );
            }
            delete elem._wheelObj; delete elem._vertDiv; delete elem._horiDiv;
            delete elem._scrollFun; delete elem._alivetime; delete elem._alive; delete elem._wheelObj;
            delete elem.resetScrollbar; delete wrap._scrolldiv; delete elem._tchtime;
            delete elem._allowTouch;
            elem.classList.remove( 'eventBinded' );
            elem.tabIndex = elem._tabindex;
            delete elem._tabindex; delete elem._wheelObj;
            delete elem._prevPosY; delete elem._mouseleave;
            delete elem._prevPosX; delete elem._wheelEvt;
        }
        return this;
    }

    function destroy(){
        $L( '.lyteScrollBar' ).scroll( 'destroy' );
        window.removeEventListener('scroll', globalscroll, true ); 
        return this; 
    }

    function reset(){
        var elements = this;
        for( var i = 0; i < elements.length; i++ ){
            var __elems = elements[ i ],
            data = __elems._scrollData;

            if( data ){
                if( data.appendTo != "parent" ){
                    var obj = {
                        transform : "",
                        width : "",
                        height : ""
                    };
                    
                    $L( __elems._horiDiv ).css( obj );
                    $L( __elems._vertDiv ).css( obj );
                }
               __elems.resetScrollbar( true, true );
            }
        }
        return this;
    }

    $L.prototype.removeScroll = function(){
        // console.warn( 'removeScroll deprecated. Use scroll("destroy") instead' );
        return removeScroll.call( this );
    }

    $L.prototype.scroll = function( obj ) {
        if( obj && obj.constructor == String ){
            if( obj == "destroy" ){
                return removeScroll.call( this );
            } else if( obj == "destroyScroll" ){
                destroy.call( this );
            } else if( obj == "reset" ){
                reset.call( this );
            }
            return;
        }

        var fn = function( obj, name, _default ){
            var value = obj[ name ];
            if( value == void 0 ){
                value = _default;
            }
            obj[ name ] = value;
        };

        obj = obj || {};
        obj.showOn = obj.showOn || 'hover';
        obj.keyStep = obj.keyStep || 30;
        obj.wheelSpeed = obj.wheelSpeed || 1;
        // its a major change. to ensure same behaviour of normal scroll and to overcome issue in browser zoomed state changed this to false
        fn( obj, 'preventOnEnd', false );
        obj.offset = obj.offset || { x : 0, y : 0 };
        obj.tOut = obj.scrollTimeout || 500;
        obj.nested = obj.nested || false;
        obj.min = obj.min || -Infinity;
        obj.max = obj.max || Infinity;

        obj.appendTo = obj.appendTo || "parent";

        fn( obj, 'scrollYMarginOffset', 5 );
        fn( obj, 'scrollXMarginOffset', 5 );
        if( obj.preventXScroll ){
            obj.preventHorizontal = true; 
        }
        if( obj.preventYScroll ){
            obj.preventVertical = true;
        }
        var elements = this,
        is_parent = obj.appendTo == "parent";

        for( var i = 0; i < elements.length; i++ ) {
            var elem =  elements[ i ], vertDiv, horiDiv, wrp = elem.parentElement;
            is_parent && set( wrp, 'position', 'relative' );
            if( elem._scrollData ) {
                $L( elem ).removeScroll()
            }
            elem.resetScrollbar = mouseenter.bind( elements[ i ] );
            is_parent && ( wrp._scrolldiv = elem );
            elem._scrollData = obj;
            if( !obj.preventVertical ) {
                vertDiv = appendDiv.call( elem, 'lyteScrollContainer lyteScrollContainerY', obj, void 0, is_parent );
                if(obj.verticalPosition == 'left'){
                    vertDiv.classList.add('left');
                }
            }
            if( !obj.preventHorizontal ) {
                vertDiv = appendDiv.call( elem, 'lyteScrollContainer lyteScrollContainerX', obj, true, is_parent );
                if(obj.horizontalPosition == 'top'){
                    vertDiv.classList.add('top');
                }
            }
            if(isSaf.firefox ){
                elem.scrollLeft = 0;
                elem.scrollTop = 0;
            } 
            elem.addEventListener( 'mouseenter', mouseenter, true )
            elem.addEventListener( 'touchstart', mouseenter, true )
            elem.addEventListener( 'touchmove', wheelEvent, { passive : false } )
            elem.addEventListener( 'mousedown', mousedown );
            elem.addEventListener( 'wheel', initialWheel, true );
            
            if( obj.showOn != 'always' ){
                ( is_parent ? wrp : elem ).addEventListener( 'mouseleave', mouseleave, true )
            } else {
                setTimeout( mouseenter.bind( elem ), 100, {} )
            }

            elem.classList.add( 'lyteScrollBar' )
            elem._scrollFun = scroll;
        }
      return this;
    }

    $L.prototype.destroyLyteScroll = function(){
        // console.warn( 'destroyLyteScroll deprecated. Use scroll("destroyScroll") instead' );
        return destroy.call( this );  
    }

    $L.prototype.resetScrollbar = function(){
        // console.warn( 'resetScrollbar deprecated. Use scroll("reset") instead' );
        return reset.call( this );
    }

    function globalscroll( evt ){
        var el = evt.target.correspondingElement || evt.target;
        if( el != document && el != document.body && el._scrollFun ) {
            el._scrollFun.call( el, evt );
        }
        if( evt._byFunc ) {
            evt.preventDefault();
            evt.stopPropagation();
            evt.stopImmediatePropagation();
        }
    }
    window.addEventListener('scroll', globalscroll, true ); 
   }
} );
;(function( cb ){
	if( typeof define == "function" && define.amd ){
		  define( [ "@zoho/lyte-dom" ], cb );
	  } else {
		  cb( window.$L );
	  }
})( function( $L ){
	if( $L ){
		function is_doc( elem ){
			return elem == document || elem == document.documentElement || elem == document.body;
		}

		function process_query( query, suff ){
			var split = query.split( ',' ),
			str = '';

			split.forEach( function( item ){
				str += ( ( str ? ',' : '' ) + item + suff );
			});

			return str;
		}

		function __bcr( elem ){

			if( is_doc( elem ) ){
				return {
					left : 0,
					top : 0,
					width : innerWidth,
					height : innerHeight	
				};
			}

			return elem.getBoundingClientRect();
		}

		function fndChdrn( ori ){
			var ns = ".lyteScrollSpy ",
			__obj = this._scrollspy.obj,
			query = process_query( __obj.query, ":not(template)" ), 
			ignore = __obj.ignore,
			__is_doc = is_doc( this );

			if( ignore.constructor == String ) {
				ignore = ignore.split( ',' );
			}
			for( var i = 0; i < ignore.length; i++ ) {
				query += ":not(" + ignore[ i ].trim() + ")";
			}

			if( !__is_doc ){
				query = ns + query;
			}
			
			return ( __is_doc ? document.body : this.parentElement ).querySelectorAll( query );
		}

		function intEl( prev, curr, cd ){
			var grp = [];
			for( var i = 0; i < cd.length; i++ ) {
				var __cur = cd[ i ];

				if( __cur != prev && __cur != curr && ( ( __cur.off > prev.off && __cur.off < curr.off ) || ( __cur.off < prev.off && __cur.off > curr.off ) ) ) {
					grp.push( __cur ); 
				}
			}	
			return grp;
		}

		function oT( src, sT, flag ) {
			var bcr = __bcr( src );
			return Math.round( Math.max( 0, ( -__bcr( this ).top + sT + bcr.top + ( flag ? bcr.height : 0 ) ) ) );
		}

		function spyall( cd, hgt, sT, cge ) {
			var curr = [], 
			prev = [], 
			map = [], 
			chged,
			__active = 'lyteSpyActive';


			for( var i = 0; i < cd.length; i++ ) { 

				var __cur_elem = cd[ i ],
				$cur = $L( __cur_elem );

				map.push( { topp : oT.call( this, __cur_elem, sT ), hgt : __cur_elem.offsetHeight } );

				var cls = $cur.hasClass( __active ),
				cur_map = map[ i ];
				
				if( ( cur_map.topp <= sT + hgt && cur_map.topp > sT  ) || ( ( cur_map.topp + map[ i ].hgt ) >= sT && ( cur_map.topp + map[ i ].hgt ) <= sT + hgt ) || ( cur_map.topp <= sT && ( cur_map.topp + cur_map.hgt ) >= sT + hgt ) ) {
						if( !cls ) {
							$cur.addClass( __active );
							chged = true
						}
						curr.push( __cur_elem )
				} else if( cls ) {
					$cur.removeClass( __active );
					prev.push( __cur_elem ) 
					chged = true
				}	
			}
			if( chged && cge && cge.constructor == Function ){
				cge( curr, prev ,this )
			}
		}

		function setClass( cd ){
			var wO = this._wheelObj, 
			__is_doc = is_doc( this ),
			hgt = __is_doc ? window.innerHeight : this.offsetHeight, 
			spy = this._scrollspy.obj, 
			sT = ( wO ? wO.scrollTop : ( __is_doc ? window.pageYOffset : this.scrollTop ) ), 
			prev = ( __is_doc ? document.body : this.parentElement ).querySelector( ( __is_doc ? "" : '.lyteScrollSpy ' ) + process_query( spy.query, '.lyteSpyActive:not(template)' ) ), 
			curr, 
			cge = spy.onChange;

			if( cd.length ) {
				if( spy.position == "all" ) {
					spyall.call( this, cd, hgt, sT, cge )
				} else {
					if( spy.position == "bottom" ) {
						for( var i = cd.length - 1; i >= 0; i-- ) {

							var __cur = cd[ i ];

							__cur.off = oT.call( this, __cur, sT, true ); 
							if( sT + hgt - spy.offset > __cur.off ) {
								if( curr && __cur.off < curr.off ){
									continue;
								}
								curr = __cur;
							}
						}
					} else {
						for( var i = 0; i < cd.length; i++ ) {

							var __cur = cd[ i ];

							__cur.off = oT.call( this, __cur, sT ) + __cur.offsetHeight; 
							if( sT + spy.offset < cd[ i ].off ) {
								if( curr && __cur.off > curr.off ){
									continue;
								}
								curr = __cur;
							}
						}
					}
					if( prev != curr ) {
						$L( prev ).removeClass( 'lyteSpyActive' );
						$L( curr ).addClass( 'lyteSpyActive' );
						if( cge && cge.constructor == Function ){
							cge( curr, prev, prev && curr ? intEl.call( this, prev, curr, cd ) : [] ,this )
						}
					}
				}
			}	

		}
		function innfun(){
			var chdrn = setClass.call( this, fndChdrn.call( this ) );	
			delete this._scrollspy.obj._spytime;
		}

		function glbscrll( evt ) {
			var tg = evt.target,
			spy = tg._scrollspy;

			if( spy ) {
				if( spy.obj.position == "visible" ){
					intersection_scroll.call( tg );
				} else{
					if( tg._scrollFun ) {
						clearTimeout( spy.obj._spytime );
						spy.obj._spytime = setTimeout( innfun.bind( tg ) , 0 );
					} else {
						innfun.call( tg );
					}
				}
			}
		}

		function intersection_scroll(){
			var bcr = this.getBoundingClientRect(),
			active = [],
			in_active = [],
			obj = this._scrollspy.obj,
			class_name = obj.activeClass,
			callback = obj.onChange,
			offset = obj.offset,
			left_str = "left",
			right_str = "right",
			top_str = "top",
			bottom_str = "bottom",
			partial = function( __bcr, to_check, _left, _right ){
				var value = __bcr[ to_check ];
				return ( ( bcr[ _left ] - offset ) <= value ) && ( value <= ( bcr[ _right ] + offset ) );
			},
			is_visible = function( __bcr ){
				return ( partial( __bcr, left_str, left_str, right_str ) || partial( __bcr, right_str, left_str, right_str ) ) && ( partial( __bcr, top_str, top_str, bottom_str ) || partial( __bcr, bottom_str, top_str, bottom_str ) );
			};

			Array.from( fndChdrn.call( this ) ).forEach( function( item ){
				var __bcr = item.getBoundingClientRect(),
				$elem = $L( item ),
				_has = $elem.hasClass( class_name );

				if( is_visible( __bcr ) ){
					if( !_has ){
						active.push( item );
						// $elem.addClass( class_name );
					}
				} else if( _has ){
					in_active.push( item );
					// $elem.removeClass( class_name );
				}
			});

			active.forEach( function( item ){
				$L( item ).addClass( class_name );
			});

			in_active.forEach( function( item ){
				$L( item ).removeClass( class_name );
			});

			if( callback && ( active.length || in_active.length ) ){
				callback( active, in_active, this );
			}
		}

		$L.prototype.removeScrollspy = function(){

			var len = this.length,
			fn = function( __class, _this ){
				$L( fndChdrn.call( _this ) ).removeClass( __class );
			};

			for( var i = 0; i < len; i++ ){
				var current = this.eq( i ),
				dom = current.get( 0 ),
				data = dom._scrollspy;

				if( data ){
					fn( data.obj.activeClass, dom );

					current.removeClass( 'lyteScrollSpy' );
					clearTimeout( data.obj._spytime );
					delete dom._scrollspy;
				}
			}
		}
		$L.prototype.scrollspy = function( obj ) {
			var length = this.length;

			if( obj == "reset" ){
				for( var i = 0; i < length; i++ ) {
				 	glbscrll( { target : this[ i ] } );
				}
				return this;
			}
			obj = obj || {};
			obj.activeClass = obj.activeClass || 'lyteSpyActive';
			obj.offset = obj.offset || 0; obj.ignore = obj.ignore || [];
			obj.position = obj.position || "top";
			obj.query = obj.query || ">*";

			for( var i = 0; i < length; i++ ) {
				var jelem = this.eq( i ),
				dom = jelem.get( 0 ),
				copy_obj = $L.extend( true, {}, obj );

				dom._scrollspy = {
					obj : copy_obj
				};

				jelem.addClass( 'lyteScrollSpy' );
				setTimeout( glbscrll, 20, { target : dom } );
			}
			return this;	
		}
		window.addEventListener( 'scroll', glbscrll, true );
	}
} );
( function( factory ) {
	if( typeof define === "function" && define.amd ) {
        define( [ "@zoho/lyte-dom" ], factory );
    }
    else {
        factory( $L );
    }
} )( function( $L ) {
	if( $L.scrollTo ) {
		return ;
	}
	
	function returnCallback( settings, val, last, parent ) {
		var opts = $L.extend( {}, settings ), 
		key = !last ? 'onAfterFirst' : 'onAfter', 
		after = opts[ key ];

		if( after ) {
			opts.complete = function( settings ) {
				after.call( parent, val, opts );
			}
		}

		return opts;
	}

	// last animations will have the onAfter callback as the complete function
	// first animations will have onAfterFirst callback as the complete function
	function scrollTo( parent, change, options, val, last ) {
		$L( parent ).animate( change, 
			returnCallback( 
				options, 
				val, 
				last,
				parent 
		) );
	}

	function buildProps( dimensions, parent, change, len, options, val, item, index ) {
		var suffix = item === 'x' ? 'Left' : 'Top',
		obj = $L( parent ),
		queue = options.queue,
		prop = 'scroll' + suffix,
		lower = suffix.toLowerCase(),
		final =  dimensions.dom ? 
					dimensions[ suffix ] + obj[ prop ]() 
					: dimensions[ lower ],
		isNegativeScroll = window._lyteUiUtils.isNegativeScroll();

		change[ prop ] = Math.abs( final );

		if( isNegativeScroll && change.scrollLeft >= 0 ) {
			change.scrollLeft = change.scrollLeft * -1;
		}
		
		if( queue ) {
			scrollTo( parent, change, options, val, index === len - 1 );
		}
		else if( len - 1 === index ) {
			scrollTo( parent, change, options, val, true );
		}
	}

	function findAxis( dimensions, parent, val, options ) {
		var axis = options.axis,
		dirs = axis.split( '' ),
		change = {}, len = dirs.length,
		queue = options.queue;

		if( queue ) {
			options.duration /= 2;
		}

		dirs.forEach( function( item, index ) {
			if( queue ) {
				change = {};
			}

			buildProps.call( this, dimensions, parent, change, len, options, val, item, index )
		} );
	}

	function setDimensions( item, options, dimensions, obj, vBCR, pBCR ) {
		var margin = options.margin,
		prop = item.toLowerCase(), extra;

		extra = margin ? parseInt( obj.css( 'margin' + item ), 10 ) + parseInt( obj.css( 'border' + item + 'Width' ), 10 ) : 0;
		dimensions[ item ] = vBCR[ prop ] - pBCR[ prop ] - extra;
	}

	function findMax( elem, iswin, prop ) {
		var obj = $L( elem ),
		doc = elem.document,
		dim = prop.toLowerCase(),
		html = ( doc || {} ).documentElement,
		htmlObj = $L( html );

		return iswin ? htmlObj[ dim ]() - elem[ 'inner' + prop ] : elem[ 'scroll' + prop ] - obj[ dim ]();
	}

	function findDimensions( val, parent, options ) {
		// val can be object aswell with left and top
		var dimensions = val, 
		percent, rpercent = /([0-9]*)%/g, 
		obj, arr = [ 'Left', 'Top' ],
		iswin = $L.isWindow( parent ), pBCR, vBCR;

		switch( typeof val ) {
			case 'number':
			case 'string':
				percent = ( rpercent.exec( val ) || [] )[ 1 ];
				dimensions = {
					top: percent ? 0.01 * percent * findMax( parent, iswin, 'Height' ) : parseFloat( val ),
					left: percent ? 0.01 * percent * findMax( parent, iswin, 'Width' ) : parseFloat( val ),
					dom: false
				};
				break;
				
			// Its a DOMElement or lyteDomObj
			case 'object':
				if( val.nodeType 
					|| ( val instanceof $L 
						&& ( val = val.get( 0 ) ) 
				) ) {
					obj = $L( val );
					dimensions = {};
					vBCR = val.getBoundingClientRect();
					pBCR = $L.isWindow( val ) ? { top: 0, left: 0 } : parent.getBoundingClientRect();

					arr.forEach( function( item ) {
						setDimensions( item, options, dimensions, obj, vBCR, pBCR );
					} );

					dimensions.dom = true;
				}
				else {
					dimensions.dom = false;
				}
				break;

		}

		subtractOffset( dimensions, options.offset );

		return dimensions;
	}

	function subtractOffset( dimensions, obj ) {
		var obj = typeof obj === 'object' ? obj : { left: obj, top: obj }, key;

		for( key in dimensions ) {
			dimensions[ key ] = dimensions[ key ] + ( obj[ key.toLowerCase() ] || 0 ) 
		}

	}

	$L.prototype.scrollTo = function( val, duration, options ) {
		var dimensions;

		if( typeof options === 'function' ) {
			options = { onAfter: options };
		}

		if( typeof duration === 'object' ) {
			if( ( options || {} ).onAfter ) {
				duration.onAfter = options.onAfter;
			} 

			options = duration;
			duration = options.duration; 
		}

		if( !options ) {
			options = {};
		}

		options = $L.extend( {}, $L.scrollTo.defaults, options );
		
		this.each( function() {
			killOtherScrollTo( this );
			dimensions = findDimensions( val, this, options );
			findAxis( dimensions, this, val, options );
		} );
		
	}

	function killOtherScrollTo( element ) {
		var rAFScrollLeft = element.rAFscrollLeft,
		rAFScrollTop = element.rAFscrollTop,
		forceRemove = true;

		window.cancelAnimationFrame( rAFScrollLeft );
		window.cancelAnimationFrame( rAFScrollTop );

		$L.animate.tryDequeue( element, undefined, forceRemove );		
	}

	$L.scrollTo = function() {
		$L( window ).scrollTo();
	}

	$L.scrollTo.defaults = {
		axis: 'xy',
		duration: 0
	};

	$L.each( [ 'scrollLeft', 'scrollTop' ], function( index, fn ) {
		$L.Tween.propHooks[ fn ] = {
			get: function( elem ) {
				return elem[ fn ]();
			},

			set: function( elem, value, options ) {
				var rounded = Math.round( value ),
				curr = elem[ fn ](), key = '_old' + fn;

				if( options.interrupt && options[ key ] && options[ key ] !== curr ) {
					elem.stop( false, false );
					options._stopped = true;
				}

				options[ key ] = rounded;
				elem[ fn ]( rounded );
			}
		}
	} ); 
} );
;( function( cb ){
  if( typeof define == "function" && define.amd ){
		define( [ "@zoho/lyte-dom" ], cb );
	} else {
		cb( window.$L );
	}
})( function( $L ){
    if( $L ){
      function getScope( elem, scope ){
          var data = elem._searchPluginData;
          scope = data.dynamicScope ? data.dynamicScope( elem ) : scope;
          if( data.checkFromParent ){
            scope = elem.parentNode;
          }
          return scope;
      }

     function keyUpBind( event ){
         if([37,13,38,39,40,91,27,16,18].indexOf(event.keyCode) > -1){ 
           return
         }
         var element = this,
         data = element._searchPluginData,
         searchDelay = data.searchDelay;

         clearTimeout(this.timeout); 
         clearTimeout( this._iptime );
         if( searchDelay == void 0 ){
            pressFunc.call( this, event );
         } else {
            this.timeout = setTimeout( pressFunc.bind( this ), searchDelay, event );
         }
      }

      function inputBind( event ){
         clearTimeout( this._iptime );
         this._iptime = setTimeout( pressFunc.bind( this ), 250, event );
      }

      function pressFunc( event ){
          var element = this;
          event = event || {};
          var data = this._searchPluginData,
          ret = findingList.call(this,event),
          searchList = ret[0],
          targetList = ret[1],
          searchComp = ret[2],
          related = ret[ 3 ],
          casesen  = data.caseSensitive,
          minLength = data.minLength ? data.minLength : 0,
          method = data.method ? data.method : 'contains',
          keyCode = event.keyCode || event.which,
          val = fNcase( casesen, element.tagName == 'LYTE-INPUT' ? element.querySelector( 'input,textarea' ).value : element.value, data.trim ),
          visibleList = [], flag, comp = data.component, hiddenList = [],
          hiddenSelector = data.hiddenSelector;

          if( data.diacritic ){
             val = window._lyteUiUtils.convert_diacritics( val );
          }

          if(val.length >= minLength || keyCode == 8 || keyCode == 46 )
            { 
              if(val.length)
                  {
                    for( var i = 0; i < searchList.length; i++ ) { 
                        var str = fNcase( casesen, searchList[i].trim() );
                        if( switchfun( method, val, str ) ) {
                            visibleList.push( searchComp[i] );
                        } else {
                           hiddenList.push( searchComp[ i ] );
                        }   
                    }
                  }
               else
                  {
                    visibleList = Array.apply( Array, searchComp );
                  }   
              if( data.onSearch && data.onSearch( visibleList, event , val ) == false ){
                return;
              }
               for(var i = 0; i < searchList.length; i++)
                   {  
                       var str = fNcase( casesen, searchList[i].trim() ), val = val;
                       additionalHand.call( this, targetList[i], switchfun( method, val, str ) , val )   
                   } 
              if( !/tree|accordion/.test( comp ) ) {
                  for( var i = 0; i < related.length; i++ ) {
                      if( related[ i ].querySelectorAll( data.target || data.search ).length == related[ i ].querySelectorAll( '.lyteSearchHidden' + ( hiddenSelector ? ( ',' + hiddenSelector ) : '' ) ).length ) {
                          related[ i ].classList.add( 'lyteSearchHidden' );
                      } else {
                          related[ i ].classList.remove( 'lyteSearchHidden' );
                      }
                   }
              } else if( comp == 'accordion' ){
                  $L.fastdom.measure( accfilter.bind( this, visibleList, hiddenList, val ) )
              } else if( comp == "tree" ){
                 $L.fastdom.measure( treefilter.bind( this, visibleList, hiddenList, val ) )
              }
          }                 
      }

      function arrayFrom( nodeList ){
          var arrayList = [];
          for(var i = 0; i < nodeList.length; i++)
            {
              arrayList.push(nodeList[i]);
            }
          return arrayList.slice(); 
      }

        function fNcase( bool, value, trim ){
          if( !bool ){
              value = value.toLowerCase();
          }
          if( trim ){
              value = value.trim();
          }
          return value;
        }

        function switchfun( method, val, str ){
          var check;
          switch( method )
            {
              case 'contains' : {
                  check = str.indexOf( val ) >= 0
                  break;    
              }
              case 'startsWith' : {
                    check = str.indexOf( val ) == 0; 
                    break;
              }
              case 'endsWith' : {
                    var ind = str.lastIndexOf( val );
                    if( ind != -1 ){
                      check = ( ind  + val.length ) == str.length;
                    }
                    break;
              }
            }
            return check;
        }

        function hiderecurse( elem ){
          for( var i = elem.length - 1; i >= 0; i-- ) {
              var icon = elem.eq( i );
              if( icon.hasClass( 'lyteIconOpened' ) ){
                  setTimeout( icon.click.bind( icon ) , 20 );
              }
          }
        }

        function searchListFind( nodeName ){
              var searchList = [];
              var target = [];
              for(var i = 0; i < nodeName.childElementCount; i++)
                {
                  while(nodeName.children[i].childElementCount)
                    {
                        window.returnedVal = searchListFind(nodeName.children[i]);
                        searchList = searchList.concat(window.returnedVal[0]);
                        target = target.concat(window.returnedVal[1]);
                        break;
                    }
                  if(!nodeName.children[i].childElementCount) 
                      {
                        searchList.push(nodeName.children[i].textContent);
                        target.push(nodeName.children[i]);
                      }
                }
              return [searchList,target];
        };

        function findingList(){
              var data = this._searchPluginData;
              var scope = getScope( this, typeof data.scope == 'string' ? document.querySelector(data.scope) : data.scope );
              var searchList = [], targetList = [], searchComp = [], related = [];

              if( !scope ){
                  return [ searchList, targetList, searchComp, related ];
              }

              if(data.search)   
                  {
                      searchComp = scope.querySelectorAll( data.search.trim() )
                      var target = data.target ? data.target : data.search;
                      for(var j = 0; j < searchComp.length; j++){
                          var valueToPush = searchComp[ j ].textContent;
                          if( data.diacritic ){
                            valueToPush = window._lyteUiUtils.convert_diacritics( valueToPush );
                          }
                          searchList.push( valueToPush );
                      }
                      targetList = scope.querySelectorAll( target )
                  }
              else
                  {
                      var callSearchList = searchListFind(scope)
                      searchList = callSearchList[0];
                      targetList = callSearchList[1];
                      searchComp = targetList.slice();
                  } 
                if( data.related && ( data.target || data.scope  ) ) {
                    related = scope.querySelectorAll( data.related );
                }
                return [searchList, targetList, searchComp, related];  
        };

        function accfilter ( vis, hid, value ){
              var scope = $L( getScope( this, this._searchPluginData.scope ) )[ 0 ];
              for( var i = 0; i < vis.length; i++ ){
                var close1 = $L( vis[ i ] ).closest( 'lyte-accordion-item', scope )
                for( var j = 0; j < hid.length; j++ ){
                  var close2 = $L( hid[ j ] ).closest( 'lyte-accordion-item', scope )
                  if( close1[ 0 ] == close2[ 0 ] ){
                      hid.splice( j, 1 );
                      j--; continue;
                  }
                }
                if( vis[ i + 1 ] ) {
                  var close2 = $L( vis[ i + 1 ] ).closest( 'lyte-accordion-item', scope );
                  if( close1[ 0 ] == close2[ 0 ] ){
                      vis.splice( i + 1, 1 );
                      i--;
                  }
                }
              }
              // scope[ 0 ].component.getAllHeights();
              $L.fastdom.mutate( function(){
                  for( var i = scope.ltProp( 'exclusive' ) ? ( vis.length - 1 ) : 0; i < vis.length; i++ ){
                    var isclose = false, close = $L( vis[ i ] ).closest( 'lyte-accordion-item' );
                    isclose = !close.hasClass( 'lyteAccordionActive' );
                    if( !value ){
                        isclose = !isclose
                    }
                    if( isclose ){
                        close.click();
                    }
                  }

                  for( var j = 0; j < hid.length; j++ ){
                      var close = $L( hid[ j ] ).closest( 'lyte-accordion-item' )
                      close.hasClass( 'lyteAccordionActive' ) && close.click();
                  }
              })
        }

        function treeinremove ( arr ){
            for( var i = 0; i < arr.length; i++ ){
                if( arr[ i + 1 ] ){
                  var cur = $L( arr[ i ] ).closest( '.lyteTreeBodyDiv' )[ 0 ], next = $L( arr[ i + 1 ] ).closest( '.lyteTreeBodyDiv' )[ 0 ];
                  if( cur.contains( next ) ){
                      arr.splice( i + 1, 1 );
                  } else if(next.contains( cur ) ){
                      arr.splice( i, 1 );
                      i--;
                  }
                }
            }
        }

        function treefilter( vis, hid, value, clear ){
          var scope = $L( getScope( this, this._searchPluginData.scope ) )[ 0 ];
          for( var i = 0; i < vis.length; i++ ){
            var cur = $L( vis[ i ] ).closest( '.lyteTreeBodyDiv' );
            for( var j = 0; j < hid.length; j++ ){
              var hide = $L( hid[ j ] ).closest( '.lyteTreeBodyDiv' ),
              flg = cur[ 0 ].contains( hide[ 0 ] ) || hide[ 0 ].contains( cur[ 0 ] );
              if( flg ){
                  hide.addClass( 'lyteSearchHidden' );
                  hid.splice( j, 1 );
                  j--;
              }
            }
          }
          for( var i = 0; i < vis.length; i++ ){
            removeClse( vis[ i ], scope )
            value.length && scope.ltProp( 'stateAttr', $L( vis[ i ] ).closest( 'lyte-tree-body' ).attr( 'data-value' ) )
          }
          if( value.length ) {
            for( var i = 0; i < hid.length; i++ ){
              $L( hid[ i ] ).closest( '.lyteTreeBodyDiv' ).addClass( 'lyteSearchHidden' )
            }
          } else {
            hiderecurse( $L( 'lyte-yield:not(.noChildClass) lyte-tree-icon', scope ), clear );
          }
        }

        function removeClse( target, scope ){
            var el = $L( target ).closest( '.lyteSearchHidden', scope );
            if( el.length ){
              el.removeClass( 'lyteSearchHidden' );
              removeClse( target, scope );
            }
        }

        function additionalHand( target, check, val ){
            var query = this._searchPluginData, comp = query.component;
            if( check ){
                if( comp == 'dropdown' ){
                  var clo = $L( target ).closest( 'lyte-drop-box' )[ 0 ] 
                  if( clo ) {
                    clo.classList.contains( 'lyteDropdownHidden' ) && ( clo.origindd ? clo.origindd.toggle() : $L( clo ).closest( 'lyte-dropdown' ).get( 0 ).toggle() )
                  }
                } 
              target.classList.remove( 'lyteSearchHidden' );
            } else if( comp != "tree" ) {
              if( target.classList.contains( 'lyteSearchHidden' ) ){
                  return;
              }
              target.classList.add( 'lyteSearchHidden' );
            }
        }

        $L.prototype.search = function( data ){
            data = data ? data : {};
            if(!data.scope)
                {
                    console.error('scope is not given');
                    return;
                }
            // var scope = typeof data.scope == 'string' ? document.body.querySelector( data.scope.trim() ) : data.scope;    
            var element = this[ 0 ]
            var searchList = [], targetList = [], searchComp = [];
            element._searchPluginData = data;

            if( !data.hasOwnProperty( 'searchDelay' ) ){
              data.searchDelay = 100;
            }

            if( data.component == "accordion" ){
              data.related = "lyte-accordion-item";
            } else if( data.component == "tree" ){
              data.related = ".lyteTreeBodyDiv lyte-yield:not(.noChildClass) lyte-tree-icon";
            }

            element.setValueForSearch = element.setValue = function(value){
                var element = this
                value = value != undefined ? value : '';
                element.tagName == 'LYTE-INPUT' ? element.ltProp({'value' : value}) : element.value = value;
                var evt = new Event('keyup');
                evt.which = evt.keyCode = 8;
                element.dispatchEvent(evt);
            }

        element.addEventListener('keyup', keyUpBind ); 

        element.addEventListener( 'input', inputBind);
        element.reset = pressFunc.bind( element );                  
        return this;
      }

      $L.prototype.removeSearch = function(){
          var removeElements = this;

          for( var i = 0; i < removeElements.length; i++ ){
              var current = removeElements[ i ],
              scope, search, related;
              if( !current._searchPluginData ){
                continue;
              }

              delete current.reset; 
              scope = current._searchPluginData.scope;
              search = current._searchPluginData.target || current._searchPluginData.search;
              related = current._searchPluginData.related;
              if( !scope ){
                continue;
              }
              scope = $L( getScope( current, scope ) );
              scope.find( search ).removeClass( 'lyteSearchHidden' );
              related && scope.find( related ).removeClass( 'lyteSearchHidden' );
              delete current._searchPluginData;
              delete current.setValueForSearch; delete current.setValue;

              current.removeEventListener( 'input', inputBind );
              current.removeEventListener( 'keyup', keyUpBind );
          }
          return this;
      }
    }
});

( function( factory ) {
	if( typeof define === "function" && define.amd ) {
        define( [ "@zoho/lyte-dom" ], factory );
    }
    else {
        factory( $L );
    }
} )( function( $L ) {
  if($L){

    $L.prototype.selector = function(selections){
  
      // if(!selections){
      //   selections = {}
      // }
  
      var imageTagOriginal = this[0];
      var parentDiv = imageTagOriginal.parentElement;
      var scaleFactor = 1;
      if(selections === undefined){
        selections = {}
      }
  
      if(selections && selections.destroy){
        if($L(parentDiv).find('.lyteSelectionWrapperBox')[0]){
          parentDiv.removeChild($L(parentDiv).find('.lyteSelectionWrapperBox')[0])
          imageTagOriginal.style.display = "block"
          $L(imageTagOriginal).data('classes' , undefined)
          $L(imageTagOriginal).data('lyteSelector' , undefined)
          parentDiv.removeEventListener('mousedown' , parentDiv.mousedownFun)
        }
        return;
      }
      var selectionArray = [];
      selectionArray = $L(imageTagOriginal).data('classes');
      var currentClass = ''
      var wrapperDiv = document.createElement('DIV');
      var imageTag = document.createElement('IMG');
      imageTag.src = imageTagOriginal.src;
      imageTag.setAttribute('class' , 'lyteSelectorBackImage' )
      var selectionData = {};
      var maxCount
      var updateMaxCount = false
      var initialVals = {}
      var fromOnCreate
    
  
      if(selections && selections.maxCount){
        maxCount = selections.maxCount
      } else {
        maxCount = 1
        updateMaxCount = true
      }
  
      var imageMinWidth,imageMinHeight;
  
      if(selections && selections.initWidth){
        imageMinWidth = selections.initWidth
      } else {
        imageMinWidth = 20
      }
      if(selections && selections.initHeight){
        imageMinHeight = selections.initHeight
      } else {
        imageMinHeight = 20
      }
  
      var imageTop,imageLeft,imageRight,imageBottom,imageHeight,imageWidth;
  
      var currentX , currentY;
      var prevLeft, prevTop, prevRight, prevBottom; // VARIABLES USED IN moveSelection FUNCTION
      var rpLeft, rpTop, rpRight, rpBottom, rpWidth, rpHeight; // VARIABLES USED IN resizeSelectionBox FUNCTION RESIZE PREVIOUS VALUES
      var currentHandle; // CURRENT HANDLE HOLDED FOR RESIZING THE SELECTION BOX
      var zoomEnabled = false;
  
      var currentDeleteBtn; // CURRENT DELETE BTN
      var deleteAllButton={};
      // var selectionStart = selectionEnd = deleteSingle = deleteMul = function(){};
  
      var onBeforeCreate = function(){}
      ,onCreate = function(){}
      ,onDragStart = function(){}
      ,onDragEnd = function(){}
      ,onResizeStart = function(){}
      ,onResizeEnd = function(){}
      ,onSelectionLimitReached = function(){}
      ,onDeleteOne = function(){}
      ,onDeleteAll = function(){}
      ,onOverlap = function(){}
  
      // if(!preventEvent){
      // } else {
      //   preventEvent = true;
      // }
  
      if(selections){
  
        if(selections.onBeforeCreate){
          onBeforeCreate = selections.onBeforeCreate
        }
        if(selections.onCreate){
          onCreate = selections.onCreate
        }
        if(selections.onDragStart){
          onDragStart = selections.onDragStart
        }
        if(selections.onDragEnd){
          onDragEnd = selections.onDragEnd
        }
        if(selections.onResizeStart){
          onResizeStart = selections.onResizeStart
        }
        if(selections.onResizeEnd){
          onResizeEnd = selections.onResizeEnd
        }
        if(selections.onDeleteOne){
          onDeleteOne = selections.onDeleteOne
        }
        if(selections.onDeleteAll){
          onDeleteAll = selections.onDeleteAll
        }
        if(selections.onOverlap){
          onOverlap = selections.onOverlap
        }
        if(selections.onSelectionLimitReached){
          onSelectionLimitReached = selections.onSelectionLimitReached
        }
        if(selections.preventOverlap === undefined){
          selections.preventOverlap = false;
        }
        if(!selections.classAttr){
          selections.classAttr = ""
        }
        if(!selections.classList){
          selections.classAttr = ""
        }
        if(selections.zoomEnabled){
          zoomEnabled = true;
        }
  
        if(selections.selections){
  
          // Predefined Selecitons creation
  
          var preDefselections = selections.selections;
  
          imageTag.onload = function(){
  
            if(!$L(parentDiv).find('.lyteSelectorBackImage')[0]){
              wrapperDiv.appendChild(imageTag);
              imageTag.style.height = imageTagOriginal.getBoundingClientRect().height + "px";
              imageTag.style.width = imageTagOriginal.getBoundingClientRect().width + "px";
  
              imageTagOriginal.style.display = "none"
            }
  
            if(!$L(parentDiv).find('.lyteSelectionWrapperBox')[0]){
  
              wrapperDiv.setAttribute('class' , 'lyteSelectionWrapperBox');
              parentDiv.appendChild(wrapperDiv);
              wrapperDiv.style.height = imageTag.getBoundingClientRect().height+"px";
              wrapperDiv.style.width = "auto";
  
              if(!($L(parentDiv).find('.lyteSelectionFreezeLayer')[0])){
                var freezeLayer = document.createElement('DIV');
                freezeLayer.setAttribute('class' , 'lyteSelectionFreezeLayer');
                wrapperDiv.appendChild(freezeLayer);
                freezeLayer.style.top = "0px";
                freezeLayer.style.left = "0px";
                freezeLayer.style.height = imageTag.getBoundingClientRect().height + "px";
                freezeLayer.style.width = imageTag.getBoundingClientRect().width + "px";
              }
  
  
  
              for(var i=0;i<preDefselections.length;i++){
                var dummyDiv = document.createElement('DIV');
                dummyDiv.classList.add('lyteSelector'+(i+1));
                currentClass = 'lyteSelector'+(i+1);
                dummyDiv.classList.add('lyteSelectionBox')
  
                if(!selectionArray){
                  selectionArray = []
                }
  
                selectionArray.push(currentClass)
                $L(parentDiv).find(imageTagOriginal).data('classes' , selectionArray)
  
                var tlCorner = document.createElement('DIV');
                var trCorner = document.createElement('DIV');
                var brCorner = document.createElement('DIV');
                var blCorner = document.createElement('DIV');
  
                var tEdge = document.createElement('DIV');
                var bEdge = document.createElement('DIV');
                var rEdge = document.createElement('DIV');
                var lEdge = document.createElement('DIV');
  
                var deleteBtn = document.createElement('DIV');
                var workArea = document.createElement('DIV');
  
                var selectorLabelTop = document.createElement('DIV');
                var selectorLabelBottom = document.createElement('DIV');
  
                tlCorner.setAttribute('class' , 'lyteSelectorHandles lyteTLCorner')
                trCorner.setAttribute('class' , 'lyteSelectorHandles lyteTRCorner')
                brCorner.setAttribute('class' , 'lyteSelectorHandles lyteBRCorner')
                blCorner.setAttribute('class' , 'lyteSelectorHandles lyteBLCorner')
                tEdge.setAttribute('class' , 'lyteSelectorHandles lyteTEdge')
                bEdge.setAttribute('class' , 'lyteSelectorHandles lyteBEdge')
                rEdge.setAttribute('class' , 'lyteSelectorHandles lyteREdge')
                lEdge.setAttribute('class' , 'lyteSelectorHandles lyteLEdge')
  
                deleteBtn.setAttribute('class' , 'lyteSelectorDeleteBtn')
                workArea.setAttribute('class' , 'lyteSelectorWorkArea')
  
                selectorLabelTop.setAttribute('class' , 'lyteSelectorLabel')
                selectorLabelBottom.setAttribute('class' , 'lyteSelectorLabel')
  
                var onBeforeCreateVar = onBeforeCreate(dummyDiv , false)
  
                if(onBeforeCreateVar === false){
                  return false
                }
  
                dummyDiv.appendChild(tlCorner)
                dummyDiv.appendChild(trCorner)
                dummyDiv.appendChild(brCorner)
                dummyDiv.appendChild(blCorner)
                dummyDiv.appendChild(tEdge)
                dummyDiv.appendChild(bEdge)
                dummyDiv.appendChild(rEdge)
                dummyDiv.appendChild(lEdge)
                dummyDiv.appendChild(deleteBtn)
                dummyDiv.appendChild(workArea)
  
                dummyDiv.appendChild(selectorLabelTop)
                dummyDiv.appendChild(selectorLabelBottom)
  
  
                if(preDefselections[i].borderColor){
                  dummyDiv.style.borderColor = preDefselections[i].borderColor;
                }
  
                if(preDefselections[i].dataLabel){
                  selectorLabelTop.classList.add('lyteSelectorLabelTop')
                  selectorLabelBottom.classList.add('lyteSelectorLabelBottom')
                  selectorLabelTop.classList.add(preDefselections[i].dataLabel[0].className)
                  selectorLabelBottom.classList.add(preDefselections[i].dataLabel[1].className)
                  selectorLabelTop.innerText = preDefselections[i].dataLabel[0].label;
                  selectorLabelBottom.innerText = preDefselections[i].dataLabel[1].label;
                }
  
                wrapperDiv.appendChild(dummyDiv)
  
                $L(dummyDiv).data('index' , i);
  
                var ar = imageTag.naturalWidth / imageTag.getBoundingClientRect().width;
  
                $L(parentDiv).find('.'+currentClass)[0].style.width = preDefselections[i].width / ar + "px";
                $L(parentDiv).find('.'+currentClass)[0].style.height = preDefselections[i].height / ar + "px";
                $L(parentDiv).find('.'+currentClass)[0].style.top = preDefselections[i].top / ar + "px";
                $L(parentDiv).find('.'+currentClass)[0].style.left = preDefselections[i].left / ar + "px";
  
                $L(parentDiv).find('.'+currentClass)[0].style.backgroundImage = "url('"+ imageTag.src +"')"
                $L(parentDiv).find('.'+currentClass)[0].style.backgroundPosition = (-($L(parentDiv).find('.'+currentClass)[0].getBoundingClientRect().left - imageTag.getBoundingClientRect().left)-1) + "px " + (-($L(parentDiv).find('.'+currentClass)[0].getBoundingClientRect().top - imageTag.getBoundingClientRect().top)-1) + "px"
                $L(parentDiv).find('.'+currentClass)[0].style.backgroundSize = imageTag.getBoundingClientRect().width + "px " + imageTag.getBoundingClientRect().height + "px";
                $L(parentDiv).find('.'+currentClass)[0].style.backgroundRepeat = "no-repeat";
  
  
                onCreate(dummyDiv , false)
                if(updateMaxCount){
                  maxCount += 1;
                }
  
              }
  
            }
          }
  
          if(!preDefselections.classAttr){
            preDefselections.classAttr = ""
          }
  
        }
      }
  
      var mainFun = function(event){
  
        var imgDim = imageTag.getBoundingClientRect()
  
        imageTop = imgDim.top;
        imageLeft = imgDim.left;
        imageRight = imgDim.left + imgDim.width;
        imageBottom = imgDim.top + imgDim.height;
        imageHeight = imgDim.height;
        imageWidth = imgDim.width;
  
        // event.preventDefault();
  
        if((event.target.nodeName === 'IMG')||(event.target.className === 'lyteSelectionFreezeLayer')){
  
          currentX = event.clientX;
          currentY = event.clientY;
  
          if((!selectionArray) || (selectionArray.length < 1)){
            selectionArray = [];
            selectionArray.push('lyteSelector1')
            currentClass = 'lyteSelector1'
            $L(imageTagOriginal).data('classes' , selectionArray)
            // getSelectedData();
          } else {
            if(selections && ($L(parentDiv).find('.lyteSelectionBox').length < maxCount)){
              var arr = $L(imageTagOriginal).data('classes');
              var regex = /\d+/g
              var test = parseInt(arr[arr.length-1].match( regex )[0])
              test +=1
              var newClass = arr[arr.length-1].replace(regex , test);
              selectionArray.push(newClass)
              currentClass = newClass
              $L(imageTagOriginal).data('classes' , selectionArray)
            }
          }
          var createSelec = createSelection()
  
          if(createSelec === false){
            return;
          }
          fromOnCreate = true
          window.addEventListener('mousemove' , setDim);
          window.addEventListener('mouseup' , removeMoveEve)
          
        } else if($L(event.target).hasClass('lyteSelectionBox')) {
  
          var elem = event.target;
  
          fromOnCreate = false
  
          var ondragstartvar = onDragStart(elem , event);
          if($L(parentDiv).find('.lyteSelectorActiveBox')[0]){
            $L(parentDiv).find('.lyteSelectorActiveBox')[0].classList.remove('lyteSelectorActiveBox');
          }
  
          
          elem.classList.add('lyteSelectorActiveBox')
          if(ondragstartvar === false){
            window.addEventListener('mouseup' , removeMoveEve)
            return false
          }
  
          // Move selection function
  
          currentX = event.clientX;
          currentY = event.clientY;
  
          prevLeft = elem.getBoundingClientRect().left;
          prevTop = elem.getBoundingClientRect().top;
          prevRight = elem.getBoundingClientRect().left+elem.getBoundingClientRect().width;
          prevBottom = elem.getBoundingClientRect().top + elem.getBoundingClientRect().height;
  
          $L(elem).data().previousDim = {
            left : prevLeft,
            top : prevTop,
            right : prevRight,
            bottom : prevBottom,
            width : elem.getBoundingClientRect().width-2,
            height : elem.getBoundingClientRect().height-2
          }
          
          window.addEventListener('mousemove' , moveSelection);
          window.addEventListener('mouseup' , removeMoveEve)
  
  
        } else if($L(event.target).hasClass('lyteSelectorHandles')){
  
          fromOnCreate = false
  
  
          var acele = $L(parentDiv).find('.lyteSelectorActiveBox')[0]; // ACTIVE ELEMENT acele
  
          var onresizestartvar = onResizeStart(acele , event);
          if(onresizestartvar === false){
            window.addEventListener('mousemove' , resizeSelectionBox);
            window.addEventListener('mouseup' , removeReEve);
            return
          }
  
          var currentHold = event.target.className.split(' ');
          currentHandle = currentHold[1];
  
          currentX = event.clientX;
          currentY = event.clientY;
  
          rpLeft = acele.getBoundingClientRect().left;
          rpTop = acele.getBoundingClientRect().top;
          rpBottom = acele.getBoundingClientRect().top + acele.getBoundingClientRect().height;
          rpRight = acele.getBoundingClientRect().left + acele.getBoundingClientRect().width;
  
          rpWidth = acele.getBoundingClientRect().width;
          rpHeight = acele.getBoundingClientRect().height;
  
          $L(acele).data().previousDim = {
            left : rpLeft,
            top : rpTop,
            right : rpRight,
            bottom : rpBottom,
            width : rpWidth-2,
            height : rpHeight-2
          }
  
          window.addEventListener('mousemove' , resizeSelectionBox);
          window.addEventListener('mouseup' , removeReEve);
  
        } else if($L(event.target).hasClass('lyteSelectorDeleteBtn')){
  
          deleteOne();
  
        }
  
  
  
      }
  
      parentDiv.mousedownFun = mainFun
      parentDiv.addEventListener('mousedown' , parentDiv.mousedownFun)
      // window.addEventListener('mouseup' , removeAllFun);
  
      // function removeAllFun(){
      //   removeReEve()
      //   removeMoveEve()
      // }
  
      imageTagOriginal.addEventListener('load' , function(){
        if(zoomEnabled){
  
          if(!$L(parentDiv).find('.lyteSelectorBackImage')[0]){
            wrapperDiv.setAttribute('class' , 'lyteSelectionWrapperBox');
            parentDiv.appendChild(wrapperDiv);
            wrapperDiv.style.height = imageTagOriginal.getBoundingClientRect().height+"px";
            wrapperDiv.style.width = imageTagOriginal.getBoundingClientRect().width+"px";
          }
          if(!$L(parentDiv).find('.lyteSelectorBackImage')[0]){
            wrapperDiv.appendChild(imageTag);
            imageTag.style.height = imageTagOriginal.getBoundingClientRect().height + "px";
            imageTag.style.width = imageTagOriginal.getBoundingClientRect().width + "px";
    
            initialVals.imageDim = imageTagOriginal.getBoundingClientRect()
    
            imageTagOriginal.style.display = "none"
          }
        }
      })
  
      function createSelection(){
  
        var div = document.createElement('DIV');
        div.setAttribute('class' , currentClass);
        div.classList.add('lyteSelectionBox');
  
        if(!$L(parentDiv).find('.lyteSelectorBackImage')[0]){
          wrapperDiv.appendChild(imageTag);
          imageTag.style.height = imageTagOriginal.getBoundingClientRect().height + "px";
          imageTag.style.width = imageTagOriginal.getBoundingClientRect().width + "px";
  
          initialVals.imageDim = imageTagOriginal.getBoundingClientRect()
  
          imageTagOriginal.style.display = "none"
        }
  
        if($L(parentDiv).find('.lyteSelectionBox').length+1 > maxCount){
          onSelectionLimitReached()
          return true;
        }
  
        var tlCorner = document.createElement('DIV');
        var trCorner = document.createElement('DIV');
        var brCorner = document.createElement('DIV');
        var blCorner = document.createElement('DIV');
  
        var tEdge = document.createElement('DIV');
        var bEdge = document.createElement('DIV');
        var rEdge = document.createElement('DIV');
        var lEdge = document.createElement('DIV');
  
        var deleteBtn = document.createElement('DIV');
        var workArea = document.createElement('DIV');
  
        var selectorLabelTop = document.createElement('DIV');
        var selectorLabelBottom = document.createElement('DIV');
        tlCorner.setAttribute('class' , 'lyteSelectorHandles lyteTLCorner')
        trCorner.setAttribute('class' , 'lyteSelectorHandles lyteTRCorner')
        brCorner.setAttribute('class' , 'lyteSelectorHandles lyteBRCorner')
        blCorner.setAttribute('class' , 'lyteSelectorHandles lyteBLCorner')
        tEdge.setAttribute('class' , 'lyteSelectorHandles lyteTEdge')
        bEdge.setAttribute('class' , 'lyteSelectorHandles lyteBEdge')
        rEdge.setAttribute('class' , 'lyteSelectorHandles lyteREdge')
        lEdge.setAttribute('class' , 'lyteSelectorHandles lyteLEdge')
  
        selectorLabelTop.setAttribute('class' , 'lyteSelectorLabel')
        selectorLabelBottom.setAttribute('class' , 'lyteSelectorLabel')
  
        deleteBtn.setAttribute('class' , 'lyteSelectorDeleteBtn')
        workArea.setAttribute('class' , 'lyteSelectorWorkArea')
  
        var onBeforeCreateVar = onBeforeCreate(div , true)
        
        if(onBeforeCreateVar === false){
          return false
        }
  
        div.appendChild(tlCorner)
        div.appendChild(trCorner)
        div.appendChild(brCorner)
        div.appendChild(blCorner)
        div.appendChild(tEdge)
        div.appendChild(bEdge)
        div.appendChild(rEdge)
        div.appendChild(lEdge)
  
        div.appendChild(selectorLabelTop)
        div.appendChild(selectorLabelBottom)
        if($L(parentDiv).find('.lyteSelectionBox').length >= maxCount){
          window.removeEventListener('mousemove' , setDim);
          onSelectionLimitReached()
          return
        }
        wrapperDiv.appendChild(div)
  
        var arr = $L(imageTagOriginal).data('classes');
        $L(div).data('index' , parseInt(arr[arr.length-1].match( /\d+/g )[0]) - 1 );
  
        if(!$L(parentDiv).find('.lyteSelectionWrapperBox')[0]){
          wrapperDiv.setAttribute('class' , 'lyteSelectionWrapperBox');
          parentDiv.appendChild(wrapperDiv);
          wrapperDiv.style.height = imageTag.getBoundingClientRect().height+"px";
          wrapperDiv.style.width = imageTag.getBoundingClientRect().width+"px";
        }
  
  
        if($L(parentDiv).find('.lyteSelectorActiveBox')[0]){
          $L(parentDiv).find('.lyteSelectorActiveBox')[0].classList.remove('lyteSelectorActiveBox');
        }
  
        if(!($L(div).hasClass('lyteSelectorActiveBox'))){
          div.classList.add('lyteSelectorActiveBox');
        }
  
        if(!($L(parentDiv).find('.lyteSelectionFreezeLayer')[0])){
          var freezeLayer = document.createElement('DIV');
          freezeLayer.setAttribute('class' , 'lyteSelectionFreezeLayer');
          wrapperDiv.appendChild(freezeLayer);
          freezeLayer.style.height = imageTag.getBoundingClientRect().height + "px";
          freezeLayer.style.top = 0 + "px"
          freezeLayer.style.width = imageTag.getBoundingClientRect().width + "px";
        }
  
        $L(parentDiv).find('.'+currentClass)[0].style.backgroundImage = "url('"+ imageTag.src +"')"
        $L(parentDiv).find('.'+currentClass)[0].style.backgroundPosition = (-($L(parentDiv).find('.'+currentClass)[0].getBoundingClientRect().left - imageTag.getBoundingClientRect().left)-1) + "px " + (-($L(parentDiv).find('.'+currentClass)[0].getBoundingClientRect().top - imageTag.getBoundingClientRect().top)-1) + "px"
        $L(parentDiv).find('.'+currentClass)[0].style.backgroundSize = imageTag.getBoundingClientRect().width + "px " + imageTag.getBoundingClientRect().height + "px";
        $L(parentDiv).find('.'+currentClass)[0].style.backgroundRepeat = "no-repeat";
  
        window.addEventListener('mouseup' , removeEve)
  
        function removeEve(event){
          if(updateMaxCount){
            maxCount+=1;
          }
          window.removeEventListener('mousemove' , setDim);
          window.removeEventListener('mouseup' , removeEve);
          window.removeEventListener('mousedown' , parentDiv.mousedownFun);
          var currentDiv = $L(parentDiv).find('.'+currentClass)[0]
          if(currentDiv){
            if((currentDiv.getBoundingClientRect().width<imageMinWidth)||(currentDiv.getBoundingClientRect().height<imageMinHeight)){
              currentDiv.style.width = imageMinWidth + 'px';
              currentDiv.style.height = imageMinHeight + 'px';
              if(currentY + imageMinHeight > (imageTag.getBoundingClientRect().top+imageTag.getBoundingClientRect().height)){
                currentDiv.style.top = (imageTag.getBoundingClientRect().bottom - imageTag.getBoundingClientRect().top) - imageMinHeight - 2 +'px';
              } else if(currentY - imageMinHeight < imageTag.getBoundingClientRect().top){
                currentDiv.style.top = "0px";
              } else {
                currentDiv.style.top = currentY - (imageMinHeight/2) - imageTag.getBoundingClientRect().top+'px';
              }
              if(currentX + imageMinWidth > (imageTag.getBoundingClientRect().left+imageTag.getBoundingClientRect().width)){
                currentDiv.style.left = (imageTag.getBoundingClientRect().right - imageTag.getBoundingClientRect().left) - imageMinWidth - 2 +'px';
              } else if(currentX - imageMinWidth < imageTag.getBoundingClientRect().left){
                currentDiv.style.left = "0px";
              } else {
                currentDiv.style.left = currentX - (imageMinWidth/2) -imageTag.getBoundingClientRect().left+'px';
              }
              currentDiv.style.backgroundImage = "url('"+ imageTag.src +"')"
              currentDiv.style.backgroundPosition = (-(currentDiv.getBoundingClientRect().left - imageTag.getBoundingClientRect().left)-1) + "px " + (-(currentDiv.getBoundingClientRect().top - imageTag.getBoundingClientRect().top)-1) + "px"
              currentDiv.style.backgroundSize = imageTag.getBoundingClientRect().width + "px " + imageTag.getBoundingClientRect().height + "px";
              currentDiv.style.backgroundRepeat = "no-repeat";
  
            }
          }
          div.appendChild(deleteBtn)
          div.appendChild(workArea)
  
  
          if(selections.preventOverlap){
            deleteOverlap()
            if(updateMaxCount){
              maxCount-=1
            }
          }
  
          onCreate(div , true)
  
        }
  
      }
  
      function deleteOverlap(node){
        var boxes = $L(parentDiv).find('.lyteSelectionBox')
        var remTotal = boxes.length;
        var newClasses = []
        $L(imageTagOriginal).data('classes' , [])
        for(var i=0;i<remTotal;i++){
          if(!$L(boxes[i]).attr(selections.classAttr)){
            $L(boxes[i]).addClass('lyteSelector'+(i+1)+' lyteSelectionBox '+selections.classList)  
          } else {
            $L(boxes[i]).addClass('lyteSelector'+(i+1)+' lyteSelectionBox '+selections.classList+' '+$L(boxes[i]).attr(selections.classAttr))
          }
          newClasses.push('lyteSelector'+(i+1))
          if(i+1 === remTotal){
            $L(boxes[i]).addClass('lyteSelectorActiveBox')
          }
        }
        $L(imageTagOriginal).data('classes',newClasses)
  
        var arr = $L(imageTagOriginal).data('classes');
        var selectionBoxes = $L(wrapperDiv).find('.lyteSelectionBox');
        var regex = /\d+/g
        var test = parseInt(arr[arr.length-1].match( regex )[0])
        var totalSelections = $L(imageTagOriginal).data().lyteSelector.getData().imageSelections
        var currentSelectionBox = $L(parentDiv).find('.lyteSelectorActiveBox')[0]
        var currentCreatedBox = totalSelections[test-1]
        var currentRight = currentCreatedBox.left + currentCreatedBox.width
        var currentLeft = currentCreatedBox.left
        var currentTop = currentCreatedBox.top
        var currentBottom = currentCreatedBox.top + currentCreatedBox.height
        var imageDatas = $L(imageTagOriginal).data().lyteSelector
  
        var selectorBorderSize = 1;
  
        selectorBorderSize = parseFloat(window.getComputedStyle(currentSelectionBox).borderWidth)
  
        if(totalSelections.length > 1){
  
          var mouseleavexpos = window.event.clientX - imageTag.getBoundingClientRect().left
          var mouseleaveypos = window.event.clientY - imageTag.getBoundingClientRect().top
          var flag = 0;
  
          for(var i=0;i<totalSelections.length;i++){
  
            if(i === selectionBoxes.indexOf(currentSelectionBox)){
              continue
            }          
  
            if(
              ((currentRight > totalSelections[i].left - selectorBorderSize ) && ((currentRight < (totalSelections[i].left+totalSelections[i].width)))) &&
              ((currentBottom > totalSelections[i].top - selectorBorderSize ) && ((currentBottom < (totalSelections[i].top+totalSelections[i].height))))
            ){
              flag = 1;
            }
  
            if(
              ((currentLeft < totalSelections[i].left - selectorBorderSize ) && ((currentRight > (totalSelections[i].left+totalSelections[i].width)))) &&
              ((currentBottom > totalSelections[i].top - selectorBorderSize ) && ((currentBottom < (totalSelections[i].top+totalSelections[i].height))))
            ){
              flag = 1;
            }
  
            if(
              ((currentLeft < totalSelections[i].left - selectorBorderSize ) && ((currentRight > (totalSelections[i].left+totalSelections[i].width)))) &&
              ((currentTop < totalSelections[i].top - selectorBorderSize ) && ((currentBottom > (totalSelections[i].top+totalSelections[i].height))))
            ){
              flag = 1;
            }
  
            if(
              ((currentLeft > totalSelections[i].left - selectorBorderSize ) && ((currentLeft < (totalSelections[i].left+totalSelections[i].width)))) &&
              ((currentTop < totalSelections[i].top - selectorBorderSize ) && ((currentBottom > (totalSelections[i].top+totalSelections[i].height))))
            ){
              flag = 1;
            }
  
            if(
              ((currentRight > totalSelections[i].left - selectorBorderSize ) && ((currentRight < (totalSelections[i].left+totalSelections[i].width)))) &&
              ((currentTop < totalSelections[i].top - selectorBorderSize ) && ((currentBottom > (totalSelections[i].top+totalSelections[i].height))))
            ){
              flag = 1;
            }
  
            if(
              ((currentLeft < totalSelections[i].left - selectorBorderSize ) && ((currentRight > (totalSelections[i].left+totalSelections[i].width)))) &&
              ((currentTop > totalSelections[i].top - selectorBorderSize ) && ((currentTop < (totalSelections[i].top+totalSelections[i].height))))
            ){
              flag = 1;
            }
  
            if(
              ((currentRight > totalSelections[i].left - selectorBorderSize ) && ((currentRight < (totalSelections[i].left+totalSelections[i].width)))) &&
              ((currentTop > totalSelections[i].top - selectorBorderSize ) && ((currentTop < (totalSelections[i].top+totalSelections[i].height))))
            ){
              flag = 1;
            }
  
            if(
              ((currentLeft > totalSelections[i].left - selectorBorderSize ) && ((currentLeft < (totalSelections[i].left+totalSelections[i].width)))) &&
              ((currentTop > totalSelections[i].top - selectorBorderSize ) && ((currentTop < (totalSelections[i].top+totalSelections[i].height))))
            ){
              flag = 1;
            }
  
            if(
              ((currentLeft > totalSelections[i].left - selectorBorderSize ) && ((currentLeft < (totalSelections[i].left+totalSelections[i].width)))) &&
              ((currentBottom > totalSelections[i].top - selectorBorderSize ) && ((currentBottom < (totalSelections[i].top+totalSelections[i].height))))
            ){
              flag = 1;
            }
  
            if(flag){
              imageDatas.deleteSelection("."+currentClass)
              onOverlap()
              i = totalSelections.length
            }
  
          }
  
        }
      }
  
      function deleteOverlapMove(){
  
        var totalSelections = $L(imageTagOriginal).data().lyteSelector.getData().imageSelections
  
        var oldplace = $L(parentDiv).find('.lyteSelectorActiveBox').data().previousDim
        var selectionBoxes = $L(wrapperDiv).find('.lyteSelectionBox');
        var currentCreatedBox = $L(parentDiv).find('.lyteSelectorActiveBox')[0]
        var currentRight = (currentCreatedBox.getBoundingClientRect().left + currentCreatedBox.getBoundingClientRect().width) - imageTag.getBoundingClientRect().left;
        var currentLeft = currentCreatedBox.getBoundingClientRect().left - imageTag.getBoundingClientRect().left;
        var currentTop = currentCreatedBox.getBoundingClientRect().top - imageTag.getBoundingClientRect().top;
        var currentBottom = (currentCreatedBox.getBoundingClientRect().top + currentCreatedBox.getBoundingClientRect().height) - imageTag.getBoundingClientRect().top;
        var imageDatas = $L(imageTagOriginal).data().lyteSelector
        var selectorBorderSize = 1;
  
        selectorBorderSize = parseFloat(window.getComputedStyle(currentCreatedBox).borderWidth)
  
        if(totalSelections.length > 1){
  
  
          var mouseleavexpos = window.event.clientX - imageTag.getBoundingClientRect().left
          var mouseleaveypos = window.event.clientY - imageTag.getBoundingClientRect().top
          var flag = 0;
  
          for(var i=0;i<totalSelections.length;i++){
  
            if(i === selectionBoxes.indexOf(currentCreatedBox)){
              continue
            } 
            if(
              ((currentRight > totalSelections[i].left - selectorBorderSize) && ((currentRight < (totalSelections[i].left+totalSelections[i].width)))) &&
              ((currentBottom > totalSelections[i].top - selectorBorderSize) && ((currentBottom < (totalSelections[i].top+totalSelections[i].height))))
            ){
              flag = 1;
            }
  
            if(
              ((currentLeft < totalSelections[i].left - selectorBorderSize) && ((currentRight > (totalSelections[i].left+totalSelections[i].width)))) &&
              ((currentBottom > totalSelections[i].top - selectorBorderSize) && ((currentBottom < (totalSelections[i].top+totalSelections[i].height))))
            ){
              flag = 1;
            }
  
            if(
              ((currentLeft < totalSelections[i].left - selectorBorderSize) && ((currentRight > (totalSelections[i].left+totalSelections[i].width)))) &&
              ((currentTop < totalSelections[i].top - selectorBorderSize) && ((currentBottom > (totalSelections[i].top+totalSelections[i].height))))
            ){
              flag = 1;
            }
  
            if(
              ((currentLeft > totalSelections[i].left - selectorBorderSize) && ((currentLeft < (totalSelections[i].left+totalSelections[i].width)))) &&
              ((currentTop < totalSelections[i].top - selectorBorderSize) && ((currentBottom > (totalSelections[i].top+totalSelections[i].height))))
            ){
              flag = 1;
            }
  
            if(
              ((currentRight > totalSelections[i].left - selectorBorderSize) && ((currentRight < (totalSelections[i].left+totalSelections[i].width)))) &&
              ((currentTop < totalSelections[i].top - selectorBorderSize) && ((currentBottom > (totalSelections[i].top+totalSelections[i].height))))
            ){
              flag = 1;
            }
  
            if(
              ((currentLeft < totalSelections[i].left - selectorBorderSize) && ((currentRight > (totalSelections[i].left+totalSelections[i].width)))) &&
              ((currentTop > totalSelections[i].top - selectorBorderSize) && ((currentTop < (totalSelections[i].top+totalSelections[i].height))))
            ){
              flag = 1;
            }
  
            if(
              ((currentRight > totalSelections[i].left - selectorBorderSize) && ((currentRight < (totalSelections[i].left+totalSelections[i].width)))) &&
              ((currentTop > totalSelections[i].top - selectorBorderSize) && ((currentTop < (totalSelections[i].top+totalSelections[i].height))))
            ){
              flag = 1;
            }
  
            if(
              ((currentLeft > totalSelections[i].left - selectorBorderSize) && ((currentLeft < (totalSelections[i].left+totalSelections[i].width)))) &&
              ((currentTop > totalSelections[i].top - selectorBorderSize) && ((currentTop < (totalSelections[i].top+totalSelections[i].height))))
            ){
              flag = 1;
            }
  
            if(
              ((currentLeft > totalSelections[i].left - selectorBorderSize) && ((currentLeft < (totalSelections[i].left+totalSelections[i].width)))) &&
              ((currentBottom > totalSelections[i].top - selectorBorderSize) && ((currentBottom < (totalSelections[i].top+totalSelections[i].height))))
            ){
              flag = 1;
            }
  
            if(flag && oldplace){
              currentCreatedBox.style.left = (oldplace.left - imageTag.getBoundingClientRect().left) +"px"
              currentCreatedBox.style.top = (oldplace.top - imageTag.getBoundingClientRect().top) +"px"
              currentCreatedBox.style.width = oldplace.width +"px"
              currentCreatedBox.style.height = oldplace.height +"px"
              currentCreatedBox.style.backgroundPosition = (-(currentCreatedBox.getBoundingClientRect().left - imageTag.getBoundingClientRect().left)-1) + "px " + (-(currentCreatedBox.getBoundingClientRect().top - imageTag.getBoundingClientRect().top)-1) + "px"
              onOverlap()
              i = totalSelections.length
            }
  
          }
  
        }
  
      }
  
      function setDim(){
  
        var xChange = currentX - window.event.clientX;
        var yChange = currentY - window.event.clientY;
        if(xChange < 0){
          $L(parentDiv).find('.'+currentClass)[0].style.left = currentX - imageTag.getBoundingClientRect().left + 'px'
        } else {
          $L(parentDiv).find('.'+currentClass)[0].style.left = window.event.clientX - imageTag.getBoundingClientRect().left + 'px'
        }
        if(yChange < 0){
          $L(parentDiv).find('.'+currentClass)[0].style.top = currentY - imageTag.getBoundingClientRect().top + 'px'
        } else {
          $L(parentDiv).find('.'+currentClass)[0].style.top = window.event.clientY - imageTag.getBoundingClientRect().top + 'px'
        }
  
  
        $L(parentDiv).find('.'+currentClass)[0].style.width = Math.abs(xChange) + 'px'
        $L(parentDiv).find('.'+currentClass)[0].style.height = Math.abs(yChange) + 'px'
  
        if(window.event.clientX <= imageTag.getBoundingClientRect().left ){
  
          $L(parentDiv).find('.'+currentClass)[0].style.left = '0px';
          $L(parentDiv).find('.'+currentClass)[0].style.width = currentX - imageTag.getBoundingClientRect().left + 'px';
  
        }
  
        if(window.event.clientY <= imageTag.getBoundingClientRect().top ){
  
          $L(parentDiv).find('.'+currentClass)[0].style.top = '0px';
          $L(parentDiv).find('.'+currentClass)[0].style.height = currentY - imageTag.getBoundingClientRect().top + 'px';
  
        }
  
        if(window.event.clientX >= (imageTag.getBoundingClientRect().left + imageTag.getBoundingClientRect().width)){
  
          $L(parentDiv).find('.'+currentClass)[0].style.width = ( ( imageTag.getBoundingClientRect().left +  imageTag.getBoundingClientRect().width ) - currentX) + 'px';
  
        }
  
        if(window.event.clientY >= (imageTag.getBoundingClientRect().top + imageTag.getBoundingClientRect().height) ){
  
          $L(parentDiv).find('.'+currentClass)[0].style.height = ( (imageTag.getBoundingClientRect().top + imageTag.getBoundingClientRect().height) - currentY) + 'px';
  
        }
  
        $L(parentDiv).find('.'+currentClass)[0].style.backgroundPosition = (-($L(parentDiv).find('.'+currentClass)[0].getBoundingClientRect().left - imageTag.getBoundingClientRect().left)-1) + "px " + (-($L(parentDiv).find('.'+currentClass)[0].getBoundingClientRect().top - imageTag.getBoundingClientRect().top)-1) + "px"
  
      }
  
      function moveSelection(){
  
        var imageGBCR = imageTag.getBoundingClientRect();
        var selectionWrapperBox = imageTag.parentElement;
        var selectionWrapperBoxGBCR = selectionWrapperBox.getBoundingClientRect();
        var leftVal = prevLeft - (currentX - window.event.clientX) - imageGBCR.left - (selectionWrapperBoxGBCR.left - imageGBCR.left);
        var topVal = prevTop - (currentY - window.event.clientY) - imageTag.getBoundingClientRect().top - (selectionWrapperBoxGBCR.top - imageGBCR.top);
  
        if(leftVal < 0){
  
          leftVal = 0;
  
        }
  
        if(topVal < 0){
  
          topVal = 0;
  
        }
  
        if((leftVal + $L(parentDiv).find('.lyteSelectorActiveBox')[0].getBoundingClientRect().width) >= imageTag.getBoundingClientRect().width){
  
          leftVal = imageTag.getBoundingClientRect().width - $L(parentDiv).find('.lyteSelectorActiveBox')[0].getBoundingClientRect().width
  
        }
  
        if((topVal + $L(parentDiv).find('.lyteSelectorActiveBox')[0].getBoundingClientRect().height) >= imageTag.getBoundingClientRect().height){
  
          topVal = imageTag.getBoundingClientRect().height - $L(parentDiv).find('.lyteSelectorActiveBox')[0].getBoundingClientRect().height
  
        }
  
        $L(parentDiv).find('.lyteSelectorActiveBox')[0].style.left = leftVal + "px";
        $L(parentDiv).find('.lyteSelectorActiveBox')[0].style.top = topVal + "px";
  
        $L(parentDiv).find('.lyteSelectorActiveBox')[0].style.backgroundPosition = (-($L(parentDiv).find('.lyteSelectorActiveBox')[0].getBoundingClientRect().left - imageTag.getBoundingClientRect().left)-1) + "px " + (-($L(parentDiv).find('.lyteSelectorActiveBox')[0].getBoundingClientRect().top - imageTag.getBoundingClientRect().top)-1) + "px"
  
  
      }
  
      function removeMoveEve(){
        if(selections.preventOverlap){
          deleteOverlapMove()
        }
  
        var curNode = window.event.target;
        if($L(window.event.target).hasClass('lyteSelectorHandles')){
          curNode = $L(window.event.target).closest('.lyteSelectionBox')[0]
        }
        
        if(!fromOnCreate){
          onDragEnd(curNode);
        }
  
        window.removeEventListener('mousemove' , moveSelection);
        window.removeEventListener('mouseup' , removeMoveEve);
        window.removeEventListener('mousedown' , parentDiv.mousedownFun);
      }
  
      function resizeSelectionBox(event){
  
  
        var th = $L(parentDiv).find('.lyteSelectorActiveBox')[0];
  
        switch (currentHandle) {
  
          case 'lyteTLCorner':
          th.style.height = rpHeight + (currentY - event.clientY) - 2 + "px";
          th.style.top = rpTop - (currentY - event.clientY) - imageTag.getBoundingClientRect().top + "px";
          th.style.width = rpWidth + (currentX - event.clientX) - 2 + "px";
          th.style.left = rpLeft - (currentX - event.clientX) - imageTag.getBoundingClientRect().left + "px";
  
          if(event.clientX <= imageLeft){
            th.style.width = rpRight - imageLeft - 2 + "px";
            th.style.left = imageLeft - imageTag.getBoundingClientRect().left + "px";
          }
          if(event.clientX >= rpRight){
            th.style.width = "1px";
            th.style.left = rpRight-3 - imageTag.getBoundingClientRect().left + "px";
          }
          if(event.clientY <= imageTop){
            th.style.height = rpBottom - imageTop - 2 + "px";
            th.style.top = imageTop - imageTag.getBoundingClientRect().top + "px";
          }
          if(event.clientY >= rpBottom){
            th.style.height = "1px";
            th.style.top = rpBottom-3 - imageTag.getBoundingClientRect().top + "px";
          }
  
          if((rpHeight + (currentY - event.clientY) - 2) <= imageMinHeight){
            th.style.height = imageMinHeight + "px";
            th.style.top = rpBottom - 2 - imageTag.getBoundingClientRect().top - imageMinHeight + "px";
          }
  
          if((rpWidth + (currentX - event.clientX) - 2) <= imageMinWidth){
            th.style.width = imageMinWidth + "px";
            th.style.left = rpRight - 2 - imageTag.getBoundingClientRect().left - imageMinWidth + "px";
          }
  
          break;
          case 'lyteTRCorner':
          th.style.height = rpHeight + (currentY - event.clientY) - 2 + "px";
          th.style.top = rpTop - (currentY - event.clientY) - imageTag.getBoundingClientRect().top + "px";
          th.style.width = rpWidth - (currentX - event.clientX) - 2 + "px";
          if(event.clientY <= imageTop){
            th.style.height = rpBottom - imageTop - 2 + "px";
            th.style.top = imageTop - imageTag.getBoundingClientRect().top + "px";
          }
          if(event.clientY >= rpBottom){
            th.style.height = "1px";
            th.style.top = rpBottom-3 - imageTag.getBoundingClientRect().top + "px";
          }
          if(event.clientX >= imageRight){
            th.style.width = imageRight - rpLeft + "px"
          }
          if(event.clientX <= rpLeft){
            th.style.width = "1px";
          }
  
          if((rpHeight + (currentY - event.clientY) - 2) <= imageMinHeight){
            th.style.height = imageMinHeight + "px";
            th.style.top = rpBottom - 2 - imageTag.getBoundingClientRect().top - imageMinHeight + "px";
          }
          if((rpWidth - (currentX - event.clientX)) <= imageMinWidth){
            th.style.width = imageMinWidth + "px";
          }
  
          break;
  
  
          case 'lyteBRCorner':
          th.style.width = rpWidth - (currentX - event.clientX) - 2 + "px";
          th.style.height = rpHeight - (currentY - event.clientY) - 2 + "px";
          if(event.clientY >= imageBottom){
            th.style.height = imageBottom - rpTop + "px";
          }
          if(event.clientY <= rpTop){
            th.style.height = '1px'
          }
          if(event.clientX >= imageRight){
            th.style.width = imageRight - rpLeft + "px"
          }
          if(event.clientX <= rpLeft){
            th.style.width = "1px";
          }
  
          if((rpHeight - (currentY - event.clientY)) <= imageMinHeight){
            th.style.height = imageMinHeight + "px";
          }
  
          if((rpWidth - (currentX - event.clientX)) <= imageMinWidth){
            th.style.width = imageMinWidth + "px";
          }
  
          break;
          case 'lyteBLCorner':
          th.style.width = rpWidth + (currentX - event.clientX) - 2 + "px";
          th.style.left = rpLeft - (currentX - event.clientX) - imageTag.getBoundingClientRect().left + "px";
          th.style.height = rpHeight - (currentY - event.clientY) + "px";
          if(event.clientX <= imageLeft){
            th.style.width = rpRight - imageLeft - 2 + "px";
            th.style.left = imageLeft - imageTag.getBoundingClientRect().left + "px";
          }
          if(event.clientX >= rpRight){
            th.style.width = "1px";
            th.style.left = rpRight-3 - imageTag.getBoundingClientRect().left + "px";
          }
  
          if(event.clientY >= imageBottom){
            th.style.height = imageBottom - rpTop + "px";
          }
          if(event.clientY <= rpTop){
            th.style.height = '1px'
          }
  
          if((rpHeight - (currentY - event.clientY)) <= imageMinHeight){
            th.style.height = imageMinHeight + "px";
          }
          if((rpWidth + (currentX - event.clientX) - 2) <= imageMinWidth){
            th.style.width = imageMinWidth + "px";
            th.style.left = rpRight - 2 - imageTag.getBoundingClientRect().left - imageMinWidth + "px";
          }
  
          break;
          case 'lyteTEdge':
          th.style.height = rpHeight + (currentY - event.clientY) - 2 + "px";
          th.style.top = rpTop - imageTag.getBoundingClientRect().top - (currentY - event.clientY) + "px";
  
          if(event.clientY <= imageTop){
            th.style.height = rpBottom - imageTop - 2 + "px";
            th.style.top = imageTop - imageTag.getBoundingClientRect().top + "px";
          }
          if(event.clientY >= rpBottom){
            th.style.height = "1px";
            th.style.top = rpBottom-3 - imageTag.getBoundingClientRect().top + "px";
          }
  
          if((rpHeight + (currentY - event.clientY) - 2) <= imageMinHeight){
            th.style.height = imageMinHeight + "px";
            th.style.top = rpBottom - 2 - imageTag.getBoundingClientRect().top - imageMinHeight + "px";
          }
  
          break;
          case 'lyteBEdge':
          th.style.height = rpHeight - (currentY - event.clientY) + "px";
          if(event.clientY >= imageBottom){
            th.style.height = imageBottom - rpTop + "px";
          }
          if(event.clientY <= rpTop){
            th.style.height = '1px'
          }
          if((rpHeight - (currentY - event.clientY)) <= imageMinHeight){
            th.style.height = imageMinHeight + "px";
          }
          break;
  
          case 'lyteREdge':
          th.style.width = rpWidth - (currentX - event.clientX) + "px";
          if(event.clientX >= imageRight){
            th.style.width = imageRight - rpLeft + "px"
          }
          if(event.clientX <= rpLeft){
            th.style.width = "1px";
          }
          if((rpWidth - (currentX - event.clientX)) <= imageMinWidth){
            th.style.width = imageMinWidth + "px";
          }
          break;
          case 'lyteLEdge':
  
          th.style.width = rpWidth + (currentX - event.clientX) - 2 + "px";
          th.style.left = rpLeft - (currentX - event.clientX) - imageTag.getBoundingClientRect().left + "px";
  
          if(event.clientX <= imageLeft){
            th.style.width = rpRight - imageLeft - 2 + "px";
            th.style.left = imageLeft - imageTag.getBoundingClientRect().left + "px";
          }
          if(event.clientX >= rpRight){
            th.style.width = "1px";
            th.style.left = rpRight-3 - imageTag.getBoundingClientRect().left + "px";
          }
  
          if((rpWidth + (currentX - event.clientX) - 2) <= imageMinWidth){
            th.style.width = imageMinWidth + "px";
            th.style.left = rpRight - 2 - imageTag.getBoundingClientRect().left - imageMinWidth + "px";
          }
  
          break;
  
        }
  
        $L(parentDiv).find('.lyteSelectorActiveBox')[0].style.backgroundPosition = (-($L(parentDiv).find('.lyteSelectorActiveBox')[0].getBoundingClientRect().left - imageTag.getBoundingClientRect().left)-1) + "px " + (-($L(parentDiv).find('.lyteSelectorActiveBox')[0].getBoundingClientRect().top - imageTag.getBoundingClientRect().top)-1) + "px"
  
        // window.addEventListener('mouseup' , removeReEve)
  
      }
  
      function removeReEve(){
        var curNode = window.event.target;
        if($L(window.event.target).hasClass('lyteSelectorHandles')){
          curNode = $L(window.event.target).closest('.lyteSelectionBox')[0]
        }
  
        if(selections.preventOverlap){
          deleteOverlapMove()
        }
        
        onResizeEnd(curNode)
        window.removeEventListener('mousemove' , resizeSelectionBox)
        window.removeEventListener('mouseup' , removeReEve)
        window.removeEventListener('mousedown' , parentDiv.mousedownFun);
      }
  
      function deleteOne(nodeToDelete){
  
        if(updateMaxCount){
          maxCount -= 1;
        }
  
  
        // if(event){
        //   event.preventDefault();
        // }
  
        onDeleteOne()
  
  
        if(nodeToDelete){
          window.delElem = $L(parentDiv).find(nodeToDelete)[0];
        } else {
          window.delElem = $L(parentDiv).find('.lyteSelectorActiveBox')[0];
        }
  
        if(!window.delElem){
          return
        }
  
        var index = $L(window.delElem).data().index;
        wrapperDiv.removeChild(window.delElem);
  
  
        var currentElemArr = $L(imageTagOriginal).data('classes');
        // Lyte.arrayUtils(currentElemArr , 'removeAt' , index , 1); 
        // var regex = /\d+/g
        // for (var i=index ; i<currentElemArr.length;i++){
        //   var curInd = parseInt(currentElemArr[i].match( regex )[0])
        //   var test = currentElemArr[i].replace( regex , curInd-1)
        //   $L('.'+currentElemArr[i]).addClass(test)
        //   $L('.'+currentElemArr[i]).removeClass(currentElemArr[i])
  
        //   Lyte.arrayUtils(currentElemArr , 'replaceAt' , i , test)
        // }
  
        // currentElemArr.splice( currentElemArr.indexOf(delElemClass) , 1 )
  
        if(currentElemArr.length <= 1){
  
          wrapperDiv.removeChild($L(parentDiv).find('.lyteSelectionFreezeLayer')[0]);
          selectionArray = [];
          parentDiv.removeChild(wrapperDiv)
          imageTagOriginal.style.display = "block";
  
        }
        var boxes = $L(parentDiv).find('.lyteSelectionBox')
        var remTotal = boxes.length;
        var newClasses = []
        $L(parentDiv).find('.lyteSelectionBox').attr('class' , '')
        $L(imageTagOriginal).data('classes' , [])
        for(var i=0;i<remTotal;i++){
          if(!$L(boxes[i]).attr(selections.classAttr)){
            $L(boxes[i]).addClass('lyteSelector'+(i+1)+' lyteSelectionBox '+selections.classList)  
          } else {
            $L(boxes[i]).addClass('lyteSelector'+(i+1)+' lyteSelectionBox '+selections.classList+' '+$L(boxes[i]).attr(selections.classAttr))
          }
          // $L(boxes[i]).addClass('lyteSelector'+(i+1)+' lyteSelectionBox '+selections.classList+' '+$L(boxes[i]).attr(selections.classAttr))
          newClasses.push('lyteSelector'+(i+1))
        }
        $L(imageTagOriginal).data('classes',newClasses)
  
      }
  
      function getSelectedData(){
  
        var returnData = {};
  
        returnData.imageNaturalWidth = imageTag.naturalWidth;
        returnData.imageNaturalHeight = imageTag.naturalHeight;
  
        returnData.imageWidth = imageTag.getBoundingClientRect().width;
        returnData.imageHeight = imageTag.getBoundingClientRect().height;
  
        if($L(parentDiv).find(imageTagOriginal).data('classes')){
          var totalBoxes = $L(parentDiv).find(imageTagOriginal).data('classes').length;
          var classesArr = $L(parentDiv).find(imageTagOriginal).data('classes');
          var imageSelections = [];
  
  
          for(var i=0;i<totalBoxes;i++){
  
            var dummy = {};
  
            var ratioChange = imageTag.naturalWidth / imageTag.getBoundingClientRect().width;
            dummy.creationIndex = i+1;
            dummy.width = $L(parentDiv).find('.'+classesArr[i])[0].getBoundingClientRect().width;
            dummy.height = $L(parentDiv).find('.'+classesArr[i])[0].getBoundingClientRect().height;
            dummy.left = $L(parentDiv).find('.'+classesArr[i])[0].getBoundingClientRect().left - imageTag.getBoundingClientRect().left;
            dummy.top = $L(parentDiv).find('.'+classesArr[i])[0].getBoundingClientRect().top - imageTag.getBoundingClientRect().top;
            dummy.naturalWidth = $L(parentDiv).find('.'+classesArr[i])[0].getBoundingClientRect().width * ratioChange;
            dummy.naturalHeight = $L(parentDiv).find('.'+classesArr[i])[0].getBoundingClientRect().height * ratioChange;
            dummy.naturalLeft = ( $L(parentDiv).find('.'+classesArr[i])[0].getBoundingClientRect().left - imageTag.getBoundingClientRect().left)*ratioChange;
            dummy.naturalTop = ($L(parentDiv).find('.'+classesArr[i])[0].getBoundingClientRect().top - imageTag.getBoundingClientRect().top)*ratioChange;
  
            imageSelections.push(dummy);
  
          }
  
          returnData.imageSelections = imageSelections;
        }
  
        return returnData;
  
  
      }
  
      selectionData.getData = function(){
  
        return getSelectedData()
  
      }
  
      selectionData.deleteSelection = function(arg){
        deleteOne(arg)
      }
  
      selectionData.deleteAll = function (){
  
        if(updateMaxCount){
          maxCount = 1;
        }
  
        onDeleteAll();
  
        var classArr = $L(imageTagOriginal).data().classes;
  
        for(var i=0;i<classArr.length;i++){
          wrapperDiv.removeChild( $L(parentDiv).find('.'+classArr[i])[0] )
        }
  
        wrapperDiv.removeChild($L(parentDiv).find('.lyteSelectionFreezeLayer')[0]);
        selectionArray = [];
        currentClass = '';
  
        parentDiv.removeChild(wrapperDiv)
        imageTagOriginal.style.display = "block";
  
      }
  
    function zoom(test){
      var transformVal = test;
      var scaleVal = 'scale('+test+')';
      var parentDivObj = $L(parentDiv);
      var selectionBox = parentDivObj.find('.lyteSelectionBox')[0];
      var freezeLayer = parentDivObj.find('.lyteSelectionFreezeLayer')[0];
    
      var wrapperBox = parentDivObj.find('.lyteSelectionWrapperBox')[0];
      var wrapperBoxParentNode = wrapperBox.parentNode;
      var wrapperBoxParentNodeGBCR = wrapperBoxParentNode.getBoundingClientRect();
      var wrapperBoxParentNodeComputedStyle = window.getComputedStyle(wrapperBoxParentNode);
      var wrapperBoxParentNodePaddingLeft = parseFloat(wrapperBoxParentNodeComputedStyle.paddingLeft);
      var wrapperBoxParentNodePaddingTop = parseFloat(wrapperBoxParentNodeComputedStyle.paddingTop);
      var HorizontalCenterOfWrapperBoxParentNode = wrapperBoxParentNodeGBCR.width / 2;
      var verticalCenterOfWrapperBoxParentNode = wrapperBoxParentNodeGBCR.height / 2;
      var selectorImage = parentDivObj.find('.lyteSelectorBackImage')[0];
      var imageGBCR = selectorImage.getBoundingClientRect();
      var imageLeftGapWithWrapperBoxParentNode = wrapperBoxParentNodeGBCR.left - imageGBCR.left;
      var imageTopGapWithWrapperBoxParentNode = wrapperBoxParentNodeGBCR.top - imageGBCR.top;
      var transformLeftOrigin = imageLeftGapWithWrapperBoxParentNode + HorizontalCenterOfWrapperBoxParentNode;
      var transformTopOrigin = imageTopGapWithWrapperBoxParentNode + verticalCenterOfWrapperBoxParentNode;
      var imageHeight = imageGBCR.height;
      var imageWidth = imageGBCR.width;
  
      var existingTransformVal = selectorImage.getAttribute('current-zoom');
      if(existingTransformVal == null) {
        existingTransformVal = 1;
      }
      existingTransformVal = parseFloat(existingTransformVal);
      transformLeftOrigin = transformLeftOrigin / existingTransformVal;
      transformTopOrigin = transformTopOrigin / existingTransformVal;
      var originalImageWidth = imageWidth / existingTransformVal;
      var originalImageHeight = imageHeight / existingTransformVal;
      selectorImage.style.transformOrigin = transformLeftOrigin +'px ' + transformTopOrigin + 'px';
      selectorImage.style.transform = scaleVal;
      selectorImage.setAttribute('current-zoom', transformVal);
  
      var newImageDim = selectorImage.getBoundingClientRect();
      var newImageHeight = newImageDim.height;
      var newImageWidth = newImageDim.width;
      var widthDifferenceFromOriginal = newImageWidth - originalImageWidth;
      var heightDifferenceFromOriginal = newImageHeight - originalImageHeight;
      
      var paddingLeft = (transformLeftOrigin / originalImageWidth) * widthDifferenceFromOriginal;
      var paddingRight = ((originalImageWidth - transformLeftOrigin) / originalImageWidth) * widthDifferenceFromOriginal;
      var paddingTop = (transformTopOrigin / originalImageHeight) * heightDifferenceFromOriginal;
      var paddingBottom = ((originalImageHeight - transformTopOrigin) / originalImageHeight) * heightDifferenceFromOriginal;
      if(widthDifferenceFromOriginal < 0) {
        widthDifferenceFromOriginal = 0;
      }
      if(heightDifferenceFromOriginal < 0) {
        heightDifferenceFromOriginal = 0;
      }
      if(paddingRight < 0) {
        paddingRight = 0;
      }
      if(paddingLeft < 0) {
        paddingLeft = 0;
      }
      if(paddingTop < 0) {
        paddingTop = 0;
      }
      if(paddingBottom < 0) {
        paddingBottom = 0;
      }
      if(selectionBox) {
        freezeLayer.style.transform = scaleVal;
        var selectionBoxes = $L(parentDiv).find('.lyteSelectionBox');
        var numberOfSelections = selectionBoxes.length;
        for(var i = 0; i < numberOfSelections; i++) {
          var selectorElement = selectionBoxes[i];
          var selectorGBCR = selectorElement.getBoundingClientRect();
          var selectorLeft = selectorGBCR.x - imageGBCR.x;
          var selectorTop = selectorGBCR.y - imageGBCR.y;
          var selectorLeftInOriginalImage = selectorLeft / existingTransformVal;
          var selectorTopInOriginalImage = selectorTop / existingTransformVal;
          var selectorLeftInNewImage = (selectorLeftInOriginalImage * transformVal);
          var selectorTopInNewImage = (selectorTopInOriginalImage * transformVal);
          var selectorNewLeftInSelectionBox = selectorLeftInNewImage;
          var selectorNewTopInSelectionBox =  selectorTopInNewImage;	
  
          var selectorCurrentWidth = parseFloat(selectorElement.style.width);
          var selectorCurrentHeight = parseFloat(selectorElement.style.height);
          var originalSelectorWidth = selectorCurrentWidth / existingTransformVal;
          var originalSelectorHeight = selectorCurrentHeight / existingTransformVal;
          selectorElement.style.width = (originalSelectorWidth * transformVal) + "px";
          selectorElement.style.height = (originalSelectorHeight * transformVal) + "px";
  
          selectorElement.style.backgroundSize = newImageDim.width + "px " + newImageDim.height +"px";
          selectorElement.style.left = selectorNewLeftInSelectionBox + "px";
          selectorElement.style.top = selectorNewTopInSelectionBox + "px";
          var selectorElementNewGBCR = selectorElement.getBoundingClientRect();
          var wrapperBoxGBCR = wrapperBox.getBoundingClientRect();
          selectorElement.style.backgroundPosition = -(selectorElementNewGBCR.left - wrapperBoxGBCR.left + 1)+ "px " + -(selectorElementNewGBCR.top - wrapperBoxGBCR.top + 1) + "px";
        }
      }
      wrapperBox.style.padding = paddingTop + 'px ' + paddingRight + 'px ' + paddingBottom + 'px ' + paddingLeft + 'px';
        wrapperBoxParentNode.scrollLeft = (transformLeftOrigin * transformVal) - ( wrapperBoxParentNodeGBCR.width / 2) + wrapperBoxParentNodePaddingLeft;
        wrapperBoxParentNode.scrollTop = (transformTopOrigin * transformVal) -  (wrapperBoxParentNodeGBCR.height / 2) + wrapperBoxParentNodePaddingTop;
    }
  
      $L(parentDiv).find(imageTagOriginal)[0].deleteSelection = function(arg){
        deleteOne(arg)
      }
  
      $L(parentDiv).find(imageTagOriginal).data('lyteSelector' , selectionData);
  
      $L(parentDiv).find(imageTagOriginal).data('zoom' , zoom);
  
    }
  
  }
} );
/**
 * Issues
 * block it for mobiles
 * Valid cases
 * ("alt+enter", "shift+enter", "b", "B", "meta+l", "meta+y", ' a b c ', 'Meta', "z+?", 'x z',  "c+m", "c +r", "c",
 * 'q w r t', "meta+i", "control + j", "$", "k+₹", "₹", "›", "f5", "meta+f8", "plus", "space", "Shift+ArrowDown",
 *  "/\\d/i", "/[a-z]{4}/i", ["meta+k", "control+m", "shift+backspace", "n"], ["meta+c", "meta+v", "meta+a"], "Control+F5")
 * Invalid Cases
 * ("meta+shift+plus", "Control+arrowleft", "alt+3", "alt+o", "alt+£", "shift+P", "shift+$", "Shift+1", "Shift+[", "shift+alt+o")
 * On keydown of any letter after meta will only fire the alphabet in small letter,no matter shift or capslock is used
*/

/**
 * Intializes the shortcut library
 * @param {object} window - window object
 * @param {document} document - document object
 */
(function (factory) {
  if (typeof define === "function" && define.amd) {
    define(["@zoho/lyte-dom"], factory);
  }
  else {
    factory($L);
  }
})(function ($L) {
  // Private Variables
  var _registeredKeys = {};
  var _registeredKeyShortcuts = {};
  var _timeoutID;
  var _allPressed = []
  var _allCodePressed = []
  var _shortcutCounter = {}
  var _keyShortcutCounter = {}
  var codeShortcutCounter = {}
  var _funcId
  var _clickId

  var _splittingKeys = new window.Map([
    [" ", "space"],
    [" ", "space"],
    ["+", "plus"]
  ]);
  var codeKeys = new window.Map([
    ["shiftleft", "shift"],
    ["shiftright", "shift"],
    ["metaleft", "meta"],
    ["metaright", "meta"],
    ["altleft", "alt"],
    ["altright", "alt"],
    ["controlleft", "control"],
    ["controlright", "control"]
  ]);

  var _specialKeys = {
    8: 'backspace',
    9: 'tab',
    13: 'enter',
    16: 'shift',
    17: 'control',
    18: 'alt',
    20: 'capslock',
    27: 'esc',
    32: 'space',
    33: 'pageup',
    34: 'pagedown',
    35: 'end',
    36: 'home',
    37: 'left',
    38: 'up',
    39: 'right',
    40: 'down',
    45: 'insert',
    46: 'delete',
    91: 'meta',
    92: 'meta', // windows key
    93: 'meta',
    224: 'meta'
  }

  var _otherSpecialKeys = {
    48: ')',
    49: '!',
    50: '@',
    51: '#',
    52: '$',
    53: '%',
    54: '^',
    55: '&',
    56: '*',
    57: '(',
    187: 'plus',
    188: '<',
    190: '>',
    191: '?',
    192: '~',
    219: '{',
    220: '|',
    221: '}',
    222: '"'
  }

  // Private Methods

  /**
   * Checks whether the two array are equal or not
   * @param {Object} arr1
   * @param {Object} arr2
   * @returns boolean
   */
  function isEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) { return false; }
    return arr1.every(function (element, index) {
      return element === arr2[index];
    });
  }

  /**
   * Checks if the current key is a modifier
   * @param {string} string - The string which contains the currently processed key
   */
  function _checkIfModifier(string) {
    string = string.toLowerCase()
    return string === "control" || string === "command" || string === "alt" || string === "shift" || string === "meta"
  }

  /**
   * Checks if the character is a function key
   * @param {string} character - The character that should be checked
   */
  function _checkIfFunctionKey(character) {
    character = character.toLowerCase()
    if (character.includes('f')) {
      for (var i = 1; i <= 12; i++) {
        if (character === ('f' + i)) {
          return true
        }
      }
    }
    return false
  }

  /**
   * Checks if there are any alphanumeric charcters
   * @param {Object} shortcutKeys
   */
  function checkAlphaNumeric(shortcutKeys) {
    function checkLength(element) {
      return element.trim().length > 1;
    }
    var keys = shortcutKeys.slice()
    return (keys.every(checkLength))
  }

  /**
   * Check if _splittingKeys are included in keys to be registered
   * We only allow special keys to be combined with alt and plus, using length of keys.
   * But since plus and space are added in words, they have to be prevented from registering shortcut.
   * @param {object} shortcutKeys Array of keys
   */
  function checkForSeperators(shortcutKeys) {
    function checkSplittingKeys(element) {
      var splittingKeys = Array.from(_splittingKeys.values())
      return splittingKeys.some(function (splittingKey) { return (splittingKey === element.trim().toLowerCase()) })
    }
    var keys = shortcutKeys.slice()
    return keys.some(checkSplittingKeys)
  }

  /**
   * Checks whether the shortcut is valid or not
   * @param {object} shortcutKeys
   */

  // Applies to all underscored identifier names
  function checkValid(shortcutKeys) {
    if (shortcutKeys.includes('+')) {
      shortcutKeys = shortcutKeys.split('+')
    }
    else if (shortcutKeys.includes(' ')) {
      shortcutKeys = shortcutKeys.split(' ')
    }
    else {
      shortcutKeys = [shortcutKeys]
    }

    var arrayLength = shortcutKeys.length;
    var element, i;
    for (i = 0; i < arrayLength; i++) {
      element = shortcutKeys[i].trim()
      if ("dead" === element.toLowerCase()) {
        return false;
      }
      if ("alt" === element.toLowerCase() || "shift" === element.toLowerCase()) {
        if (checkAlphaNumeric(shortcutKeys) && !checkForSeperators(shortcutKeys)) {
          return true;
        }
        else { return false; }
      }
    }
    return true
  }

  /**
   * Checks whether the keys in registerCode are in correct format
   * @param {string} shortcutKeys
   * @returns true if keys are properly added
   */
  function checkCodeKeys(shortcutKeys) {
    if (shortcutKeys.includes('+')) {
      shortcutKeys = shortcutKeys.split('+')
    }
    else if (shortcutKeys.includes(' ')) {
      shortcutKeys = shortcutKeys.split(' ')
    }
    else {
      shortcutKeys = [shortcutKeys]
    }

    var arrayLength = shortcutKeys.length;
    var element, i;
    for (i = 0; i < arrayLength; i++) {
      element = shortcutKeys[i].trim()
      if (element.length === 1) {
        return false;
      }
    }
    return true
  }

  /**
   * Checks if the shortcut to be registered is a valid shortcut
   * @param {string} character - The shortcut keys that should be checked
   */
  function removeWhiteSpace(shortcutKeys) {
    shortcutKeys = shortcutKeys.split('+');
    var arrayLength = shortcutKeys.length;
    for (let i = 0; i < arrayLength; i++) {
      shortcutKeys[i] = shortcutKeys[i].trim()
      // Case Insensitive
      shortcutKeys[i] = shortcutKeys[i].toLowerCase()
    }
    shortcutKeys = shortcutKeys.join("+");
    return (shortcutKeys);
  }

  /**
   * Split keys in modifiers and normal keys
   * @param {string} keys - The keys registered to shortcut
   */
  function segregateKeys(keys) {
    var keyArray = _splitArray(keys)
    var modifier = []
    for (var i = 0; i < keyArray.length; i++) {
      if (_checkIfModifier(keyArray[i])) {
        keyArray[i] = keyArray[i] === 'command' ? 'meta' : keyArray[i]
        if (keys.indexOf('+') != -1) {
          modifier.push(keyArray[i])
          keyArray.splice(i, 1)
          i--;
        }
      }
      else if (_checkIfFunctionKey(keyArray[i])) {
        keyArray[i] = keyArray[i].toLowerCase()
      }
    }
    var pressTogether
    if (keys.indexOf('+') !== -1) {
      keyArray = keyArray.join('+')
      pressTogether = true
    }
    else {
      keyArray = keyArray.join(' ')
      pressTogether = false
    }
    return {
      modifier: modifier,
      newKey: keyArray,
      pressTogether: pressTogether
    }
  }

  /**
   * Split keys and build an array
   * @param {string} keys - split between spaces or plus
   */
  function _splitArray(keys) {
    if (keys.indexOf('+') !== -1) {
      return keys.split('+')
    }
    else {
      return keys.split(' ')
    }
  }

  /**
   * @returns All the registered shortcuts
   */
  function getAllRegisteredShortcutKeys() {
    var allRegisteredShortcutKeys = Object.assign({}, _registeredKeys);
    Object.assign(allRegisteredShortcutKeys, _registeredKeyShortcuts)
    return allRegisteredShortcutKeys
  }

  /**
   *Check whether the shortcut is a regex method or not
   * @param {string} shortcutKey
   * @returns whether it is a REGEX shortcut or not
   */
  function isRegexKey(shortcutKey) {
    if (shortcutKey.indexOf('r:') !== -1) {
      return true;
    }
    else {
      return false;
    }
  }

  /**
   * remove special keys before checking for a cross match for REGEX
   */
  function removeSpecialKeysFromAllPressedKeys() {
    var _specialKeys = ['backspace', "plus", 'tab', 'enter', 'shift', 'control', 'alt', 'capslock', 'escape', 'space', 'pageup', 'pagedown', 'end', 'home', 'arrowleft', 'arrowup', 'arrowright', 'arrowdown', 'insert', 'delete', 'meta', "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "f10", "f11", "f12"]
    var pressedKeysWithoutSpecialKeys = _allPressed.filter(x => !_specialKeys.includes(x));
    return pressedKeysWithoutSpecialKeys
  }

  /**
   * Matches the input for regular expressions
   * @param {string} shortcutKey
   */
  function handleRegularExpressions(shortcutKey) {
    var pressedKeysWithoutSpecialKeys = removeSpecialKeysFromAllPressedKeys()
    var exp = shortcutKey.substring(2)
    var matches = exp.match(new RegExp('^/(.*?)/([gimy]*)$'))
    var regex = new RegExp(matches[1], matches[2])
    if (regex.test(pressedKeysWithoutSpecialKeys.join(''))) {
      _shortcutCounter[shortcutKey] = 1
      // return true
    }
    else {
      _shortcutCounter[shortcutKey] = 0
      // return false
    }
  }
  function getAllShortcutKeysWithCode() {
    var codeRegisteredKeys = {}
    for (var shortcutKey in _registeredKeyShortcuts) {
      var shortcutArray = []
      if (!isRegexKey(shortcutKey)) {
        for (var i = 0; i < _registeredKeyShortcuts[shortcutKey].length; i++) {
          var item = _registeredKeyShortcuts[shortcutKey][i]
          if (item.useCode) {
            shortcutArray.push(item)
          }
        }
        codeRegisteredKeys[shortcutKey] = shortcutArray
      }
    }
    return codeRegisteredKeys
  }
  function getAllShortcutKeysWithoutCode() {
    var codeRegisteredKeys = {}
    var allRegisteredShortcuts = getAllRegisteredShortcutKeys()
    for (var shortcutKey in allRegisteredShortcuts) {
      if (!isRegexKey(shortcutKey)) {
        var shortcutArray = []
        var flag = false
        for (var i = 0; i < allRegisteredShortcuts[shortcutKey].length; i++) {
          var item = allRegisteredShortcuts[shortcutKey][i]
          if (!(item.useCode)) {
            flag = true
            shortcutArray.push(item)
          }
        }
        if (flag) {
          codeRegisteredKeys[shortcutKey] = shortcutArray
        }
      }
      else {
        codeRegisteredKeys[shortcutKey] = allRegisteredShortcuts[shortcutKey]
      }
    }
    return codeRegisteredKeys
  }
  /**
   * Increase character pointer of all the registered keys if the match
   * @param {string} character - currently pressed character
   */
  function _increaseCharPointer(currentPressedCharacter) {
    var allRegisteredShortcutKeys = getAllRegisteredShortcutKeys();

    for (var shortcutKey in allRegisteredShortcutKeys) {
      if (isRegexKey(shortcutKey)) {
        handleRegularExpressions(shortcutKey)
        continue;
      }
      var keyArray = _splitArray(shortcutKey)
      var progress
      _shortcutCounter[shortcutKey] = progress = _shortcutCounter[shortcutKey] ? _shortcutCounter[shortcutKey] : 0
      var nextCharacterInShorcutKeySequence = (keyArray[progress] || "")
      if (currentPressedCharacter === nextCharacterInShorcutKeySequence) {
        _shortcutCounter[shortcutKey]++;
      }
      else {
        _shortcutCounter[shortcutKey] = 0
      }
    }
  }
  function increaseCharPointerCode(currentPressedCharacter) {
    var allShortcutKeys = getAllShortcutKeysWithCode();
    if (currentPressedCharacter !== "shift" && currentPressedCharacter !== "alt") {

      for (var shortcutKey in allShortcutKeys) {
        var keyArray = _splitArray(shortcutKey)
        var progress
        codeShortcutCounter[shortcutKey] = progress = codeShortcutCounter[shortcutKey] ? codeShortcutCounter[shortcutKey] : 0
        var nextCharacterInShorcutKeySequence = (keyArray[progress] || "")
        if (currentPressedCharacter === nextCharacterInShorcutKeySequence) {
          codeShortcutCounter[shortcutKey]++;
        }
        else {
          codeShortcutCounter[shortcutKey] = 0
        }
      }
    }
  }
  function increaseCharPointerKey(currentPressedCharacter) {
    var allRegisteredShortcutKeys = getAllShortcutKeysWithoutCode();
    if (currentPressedCharacter !== "shift" && currentPressedCharacter !== "alt") {
      for (var shortcutKey in allRegisteredShortcutKeys) {
        var keyArray = _splitArray(shortcutKey)
        var progress
        _keyShortcutCounter[shortcutKey] = progress = _keyShortcutCounter[shortcutKey] ? _keyShortcutCounter[shortcutKey] : 0
        var nextCharacterInShorcutKeySquence = (keyArray[progress] || "")
        if (nextCharacterInShorcutKeySquence.toLowerCase() === currentPressedCharacter.toLowerCase()) {
          _keyShortcutCounter[shortcutKey]++;
        }
        else {
          _keyShortcutCounter[shortcutKey] = 0
        }
      }
    }
  }
  // Checks if the active element is a input/select/textarea
  function _checkActiveElement() {
    var activeElement = document.activeElement
    var tagName = activeElement.tagName
    var classList = activeElement.classList
    var inputTypesAllowed = ['checkbox', 'radio', 'file', 'color', 'range']
    var unallowedClasses = ['lyteDummyEventContainer']
    if (((tagName === 'INPUT' && inputTypesAllowed.indexOf(activeElement.type) === -1)
      || activeElement.hasAttribute('contenteditable') || activeElement.getAttribute('contenteditable') === "true" || tagName === 'SELECT' || tagName === 'TEXTAREA')
      && !activeElement.classList.contains('lyte-shortcut')) {
      return true;
    }
    unallowedClasses.forEach(function (activeClass) {
      if (classList.contains(activeClass)) {
        return true
      }
    });
    return false
  }
  /**
   * Calls a the matched element which should be invoked.
   * @param {function} func - The callback that must be invoked
   * @param {number} wait - A wait period where a user can press a different key to invoke a different element
   * @param {object} event - The current keydown event
   */
  // return true - prevent default behaviour of the  shortcut
  // return false - not  prevent default behaviour of the  shortcut
  function _invokeFunction(func, wait, event, invokedKey, preventDefault) {
    if (wait) {
      _flushTimeout()
      if (preventDefault) {
        event.preventDefault()
      }

      _funcId = setTimeout(function () {
        var prevent
        if (preventDefault) {
          func.call(window, event, invokedKey)
        }
        else {
          prevent = func.call(window, event, invokedKey)
          prevent = prevent === false ? true : prevent
          if (prevent) {
            event.preventDefault()
          }
        }
        _shortcutCounter = {}
        _keyShortcutCounter = {}
        _allPressed = []

        _allCodePressed = []
        codeShortcutCounter = {}

      }, wait)

    }
    else {
      _flushTimeout()


      var prevent
      if (preventDefault) {
        event.preventDefault()
        func.call(window, event, invokedKey)
      }
      else {
        prevent = func.call(window, event, invokedKey)
        prevent = prevent === false ? true : prevent
        if (prevent) {
          event.preventDefault()
        }
      }
      _shortcutCounter = {}
      _keyShortcutCounter = {}
      _allPressed = []

      _allCodePressed = []
      codeShortcutCounter = {}
    }
  }
  // Get the parent dropdown
  function getDropdownFromItem(element) {
    while (element.tagName !== 'LYTE-DROP-BOX' && element.tagName !== 'BODY') {
      element = element.parentElement
    }

    if (!element || element.tagName == 'BODY') {
      return;
    }

    var drp = element.origindd;

    if (!drp) {
      while (element.tagName !== 'LYTE-DROPDOWN' && element.tagName !== 'BODY') {
        element = element.parentElement
      }
      drp = element;
    }
    var component = drp.component;
    return component;
  }

  function _isVisible(element) {
    var tagName = element.tagName
    var parent = element;
    switch (tagName) {
      case 'BUTTON':
      case 'LYTE-ACCORDION-ITEM':
      case 'LYTE-NAV-ITEM':
        return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
        break;
      case 'LYTE-DROP-ITEM':
        var dropdown = getDropdownFromItem(element);
        if (dropdown) {
          dropdown = dropdown.$node;
          var disabled = dropdown.ltProp('disabled');
          if (disabled) {
            return false
          }
          else {
            return !!(dropdown.offsetWidth || dropdown.offsetHeight || dropdown.getClientRects().length);
          }
        }
        else {
          return false;
        }
      case 'LYTE-MENU-ITEM':
        while (parent.tagName !== 'LYTE-MENU-BODY') {
          parent = parent.parentElement
        }
        var menu = parent.parent
        var query = menu.ltProp('query')
        var all = document.querySelectorAll(query)
        for (var i = 0; i < all.length; i++) {
          var isVisible = !!(all[i].offsetWidth || all[i].offsetHeight || all[i].getClientRects().length);
          if (isVisible) {
            return true
          }
        }
        return false
    }
  }

  /**
   * Triggers a click event on the element that is matched
   * @param {HTMLElement} element - The HTMLElement that should be clicked
   * @param {number} wait - A wait period where a user can press a different key to invoke a different element
   */
  function _invokeClick(element, wait, preventDefault) {
    element = element.tagName === 'LYTE-BUTTON' ? element.querySelector('button') : element;
    var isVisible = _isVisible(element)
    if (!isVisible) {
      return;
    }
    if (preventDefault) {
      return;
    }
    if (wait) {
      _flushTimeout()
      _clickId = setTimeout(function () {
        element.click()
        _shortcutCounter = {}
        _keyShortcutCounter = {}
        _allPressed = []

        _allCodePressed = []
        codeShortcutCounter = {}
      }, wait)
    }
    else {
      _flushTimeout()
      element.click()
      _shortcutCounter = {}
      _keyShortcutCounter = {}
      _allPressed = []

      _allCodePressed = []
      codeShortcutCounter = {}
    }
  }

  /**
   * Clears the timeout in both the invoke functions
   */
  function _flushTimeout() {
    clearTimeout(_funcId)
    clearTimeout(_clickId)
  }

  /**
   * Callbacks/elements that need to be invoked/clicked
   * @param {array} matchedElements - all the keys that have matched the current sequence of characters
   */
  function _invokeMatchedElements(matchedElements, event) {
    for (var i = 0; i < matchedElements.length; i++) {

      var excludeElements = matchedElements[i].excludeElements

      var validate = matchedElements[i].validate

      // Validate Function decides the invocation of shortcut
      var isValid = validate.call(window, event, invokedKey)
      if (!isValid) {
        return;
      }

      //ExcludeElements starts
      var activeElement = document.activeElement
      var tagName = activeElement.tagName.toLowerCase()
      if (excludeElements) {
      // if (excludeElements && excludeElements.length) {
        for (let i = 0; i < excludeElements.length; i++) {
          const element = excludeElements[i];
          if (element.startsWith('[') && element.endsWith(']')) {
            var selector = element.substring(1, element.indexOf('='));
            var value = element.substring(element.indexOf('=') + 2, element.length - 2);
            var attributeValue = activeElement.getAttribute(selector);
            if (attributeValue && attributeValue.includes(value)) {
              return;
            }
          }
          else if (tagName === element) {
            return;
          }
        }
        // if (excludeElements.length === 0) {
        //   // Execute shortcut everywhere
        // }
      }
      else {
        var shouldReject = _checkActiveElement();
        if (shouldReject) {
          return;
        }
      }
      //ExcludeElements ends

      var value = matchedElements[i].value
      var wait = matchedElements[i].wait
      var preventDefault = matchedElements[i].preventDefault
      var invokedKey = matchedElements[i]._invokedKey
      if (typeof value === 'function') {
        _invokeFunction(value, wait, event, invokedKey, preventDefault)
      }
      else {
        _invokeClick(value, wait, preventDefault)
      }
    }
  }

  /**
   * get all the modifiers that are currently pressed
   * @param {object} event - the keydown event
   */
  function _getModifiers(event) {
    var modifier = []
    if (event.altKey) {
      modifier.push('alt')
    }
    if (event.ctrlKey) {
      modifier.push('control')
    }
    if (event.shiftKey) {
      modifier.push('shift')
    }
    if (event.metaKey) {
      modifier.push('meta')
    }
    return modifier
  }
  function _getFilteredModifiers(event) {
    var modifier = []
    if (event.ctrlKey) {
      modifier.push('control')
    }
    if (event.metaKey) {
      modifier.push('meta')
    }
    return modifier
  }
  /**
   * removes the smaller shortcut from the matched shortcuts
   * @param {object} foundMatches dictonary have all the matchedShortcuts
   * @param {object} allValues Array of matched shortcut entries
   * @remove the smaller matched shortcuts
   */
  function removeSmallShortcuts(foundMatches, allValues) {
    var allMatchedKeys = Object.keys(foundMatches);
    allMatchedKeys.sort((a, b) => b.length - a.length);
    var largest = "";
    for (var i = 0; i < allMatchedKeys.length; i++) {
      var currentKey = allMatchedKeys[i];
      for (var j = i + 1; j < allMatchedKeys.length; j++) {
        if (currentKey.includes(allMatchedKeys[j])) {
          // If the current string is a substring of another string,
          // check if it is larger than the current largest string
          if (largest.length < currentKey.length) {
            largest = currentKey;
          }
        }
      }
    }

    if (largest) {
      allMatchedKeys.forEach(element => {
        if (largest !== element) {
          delete foundMatches[element];
        }
      });
      for (var i = 0; i < allValues.length; i++) {
        var element = allValues[i];

        if (largest !== element._invokedKey) {
          allValues.splice(i, 1);
        }
      }
    }
    return [foundMatches, allValues];
  }

  /**
   * get all the matching elements for the current sequence
   * @param {object} event - the keydown event
   */
  function _getMatchedElements(event) {
    var allValues = [], foundMatches = {};
    var allModifier = _getModifiers(event)
    var filteredModifiers = _getFilteredModifiers(event)

    // _invokedKey writes in the global object but it won't cause problems i guess
    var allRegisteredShortcutKeys = getAllShortcutKeysWithoutCode();
    for (var keys in _shortcutCounter) {
      if (keys.indexOf('r:') !== -1 && _shortcutCounter[keys] > 0) {
        var item = allRegisteredShortcutKeys[keys]
        item._invokedKey = keys
        allValues.push(item)
        continue
      }
      if (allRegisteredShortcutKeys[keys]) {
        for (var i = 0; i < allRegisteredShortcutKeys[keys].length; i++) {
          var item = allRegisteredShortcutKeys[keys][i]
          if (item.modifier.length <= 0) {
            if (item.pressTogether) {
              if (_keyShortcutCounter[keys] === _splitArray(keys).length && _allPressed.join("+").includes(keys)) {
                item._invokedKey = keys
                allValues.push(item)
                foundMatches[keys] = true;
              }
            }
            else {
              if (_splitArray(keys).length !== 1 && _keyShortcutCounter[keys] === _splitArray(keys).length && _allPressed.length === _splitArray(keys).length && _allPressed.join(" ").includes(keys)) {
                item._invokedKey = keys
                allValues.push(item)
                foundMatches[keys] = true;
              }

              else if (!event.metaKey && !event.ctrlKey && _splitArray(keys).length === 1 && _keyShortcutCounter[keys] === _splitArray(keys).length && _allPressed.join(" ").includes(keys)) {
                item._invokedKey = keys
                allValues.push(item)
                foundMatches[keys] = true;
              }
            }
          }
          else {
            if (item.pressTogether) {
              if (_shortcutCounter[keys] === _splitArray(keys).length && item.modifier.sort().join('+') === allModifier.sort().join('+') && _allPressed.join("+").includes(keys)) {
                item._invokedKey = item.modifier.sort().length !== 0 ? item.modifier.sort().join('+') + "+" + keys : keys
                allValues.push(item)
                foundMatches[keys] = true;
              }
              else if (_keyShortcutCounter[keys] === _splitArray(keys).length && item.modifier.sort().join('+') === filteredModifiers.sort().join('+') && _allPressed.join("+").includes(keys)) {
                item._invokedKey = item.modifier.sort().length !== 0 ? item.modifier.sort().join('+') + "+" + keys : keys
                allValues.push(item)
                foundMatches[keys] = true;
              }
            }
            else {
              if (_shortcutCounter[keys] === _splitArray(keys).length && _allPressed.join(" ").includes(keys)) {
                item._invokedKey = keys
                allValues.push(item)
                foundMatches[keys] = true;
              }
            }
          }
        }
      }
    }
    for (var key in foundMatches) {
      if (foundMatches[key]) {
        _shortcutCounter[key] = 0;
      }
    }
    [foundMatches, allValues] = removeSmallShortcuts(foundMatches, allValues)
    return allValues
  }
  function getMatchedElementsCode(event) {
    var allValues = [], foundMatches = {};
    var allModifier = _getModifiers(event)
    // _invokedKey writes in the global object but it won't cause problems i guess
    var allRegisteredShortcutKeys = getAllShortcutKeysWithCode();

    for (var keys in codeShortcutCounter) {
      if (allRegisteredShortcutKeys[keys]) {
        for (var i = 0; i < allRegisteredShortcutKeys[keys].length; i++) {
          var item = allRegisteredShortcutKeys[keys][i]
          if (item.modifier.length <= 0) {
            if (item.pressTogether) {
              if (codeShortcutCounter[keys] === _splitArray(keys).length && _allCodePressed.join("+").includes(keys)) {
                item._invokedKey = keys
                allValues.push(item)
                foundMatches[keys] = true;
              }
            }
            else {
              if (_splitArray(keys).length !== 1 && codeShortcutCounter[keys] === _splitArray(keys).length && _allCodePressed.length === _splitArray(keys).length && _allCodePressed.join(" ").includes(keys)) {
                item._invokedKey = keys
                allValues.push(item)
                foundMatches[keys] = true;
              }
              else if (!event.metaKey && !event.ctrlKey && _splitArray(keys).length === 1 && codeShortcutCounter[keys] === _splitArray(keys).length && _allCodePressed.join(" ").includes(keys)) {
                item._invokedKey = keys
                allValues.push(item)
                foundMatches[keys] = true;
              }
            }
          }
          else {
            if (item.pressTogether) {
              if (codeShortcutCounter[keys] === _splitArray(keys).length && item.modifier.sort().join('+') === allModifier.sort().join('+') && _allCodePressed.join("+").includes(keys)) {
                item._invokedKey = item.modifier.sort().length !== 0 ? item.modifier.sort().join('+') + "+" + keys : keys
                allValues.push(item)
                foundMatches[keys] = true;
              }
            }
            else {
              if (codeShortcutCounter[keys] === _splitArray(keys).length && _allCodePressed.join(" ").includes(keys)) {
                item._invokedKey = keys
                allValues.push(item)
                foundMatches[keys] = true;
              }
            }
          }
        }
      }
    }
    for (var key in foundMatches) {
      if (foundMatches[key]) {
        codeShortcutCounter[key] = 0;
      }
    }
    [foundMatches, allValues] = removeSmallShortcuts(foundMatches, allValues)

    return allValues
  }

  // A timeout that refreshes the current pressed keys when no more keys are pressed
  function _createGracePeriod() {
    clearTimeout(_timeoutID)
    _timeoutID = setTimeout(function () {
      _shortcutCounter = {}
      _keyShortcutCounter = {}
      _allPressed = []

      _allCodePressed = []
      codeShortcutCounter = {}
    }, 1000)
  }



  /**
   * The callback for the keydown event
   * @param {object} event - the keydown event
   */
  function _handleKeyPress(event) {
    // var shouldReject = _checkActiveElement();
    // if (shouldReject) {
    //   return;
    // }

    var codeAlpha = event.key;
    if (codeAlpha === undefined) {
      return;
    }
    if (codeAlpha.length >= 1) {
      codeAlpha = codeAlpha.toLowerCase()
    }



    var temp = codeAlpha.toLowerCase()
    //Special case for plus and space
    if (_splittingKeys.has(temp)) {
      codeAlpha = _splittingKeys.get(temp);
    }
    if (!(temp === "shift" || temp === "alt")) {
      _allPressed.push(codeAlpha)
    }

    var code = event.code;
    code = code.toLowerCase()
    if (codeKeys.has(code)) {
      code = codeKeys.get(code);
    }

    if (code !== "shift" && code !== "alt") {
      _allCodePressed.push(code)
    }
    increaseCharPointerCode(code)
    if (Object.keys(codeShortcutCounter).length) {
      var matchedElements = getMatchedElementsCode(event)
      _createGracePeriod()
      _invokeMatchedElements(matchedElements, event)
    }

    _increaseCharPointer(codeAlpha)
    increaseCharPointerKey(codeAlpha)
    var matchedElements = _getMatchedElements(event)
    _createGracePeriod()
    _invokeMatchedElements(matchedElements, event)
  }

  /**
   * Builds the registered keys from array
   * @param {array} keys - Array of keys
   * @param {function} callback - Function to be invoked for the keys
   */
  function _processObject(keys, callback, options) {
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]
      _processString(key, callback, options)
    }
  }

  /**
   * Builds the registered key from the string
   * @param {string} keys - String that represents the key
   * @param {function} callback - Function to be invoked for the key
   */
  function _processString(keys, callback, options) {
    var isValid;
    keys = removeWhiteSpace(keys)
    var useKey = options.useKey
    var useCode = options.useCode
    if (!useKey) {
      keys = userToBrowserKeys(keys)
    }
    if (useKey) {
      isValid = checkValid(keys)
    }
    else {
      isValid = true
    }
    if (useCode) {
      var checkCodeValid = checkCodeKeys(keys)
      if (checkCodeValid) {
        shortcut.pushKey({
          newKey: keys,
          oldKey: undefined,
          value: callback,
          options: options
        })
        return
      }
      else {
        console.error("Shortcut keys are in invalid format! Shortcut not added for", keys)
        return
      }
    }
    if (isValid && useKey) {
      shortcut.pushKey({
        newKey: keys,
        oldKey: undefined,
        value: callback,
        options: options
      })
    }
    else if (isValid && !useKey) {
      shortcut.push({
        newKey: keys,
        oldKey: undefined,
        value: callback,
        options: options
      })
    }
    else {
      console.error("Invalid Shortcut! Shortcut not added for", keys)
    }
  }

  /**
   * Adds the regex expression to the registeredKeys
   * @param {string} key - The regular expresssion
   * @param {function/HTMLElement} callback - The function or the HTMLElement that should be invoked
   * @param {object} options - Configuarion for this particular key
   */
  function _pushRegex(keys, callback, options, regKeys) {
    keys = 'r:' + keys
    var wait = options.wait ? options.wait : 0

    var preventDefault = options.preventDefault ? options.preventDefault : false
    var useCode = options.useCode ? options.useCode : false
    var useKey = options.useKey ? options.useKey : false
    var validate = options.validate ? options.validate : function () { return true; }
    var excludeElements = options.excludeElements ? options.excludeElements : undefined;


    var type = typeof callback
    regKeys[keys] = {
      type: type,
      value: callback,
      wait: wait,
      preventDefault: preventDefault,
      useCode: useCode,
      useKey: useKey,
      excludeElements: excludeElements,
      validate: validate
    }
  }

  /**
   * registers function keys and solves other cross browser issues
   */
  function _registerOtherKeys() {
    for (var i = 0; i <= 9; i++) {
      _specialKeys[i + 96] = i.toString()
    }
    for (var i = 1; i <= 12; i++) {
      _specialKeys[111 + i] = 'f' + i
    }
    var sniff = navigator.userAgent
    if (sniff.match('Firefox')) {
      _otherSpecialKeys[59] = ':'
      _otherSpecialKeys[173] = '_'
    }
    else {
      _otherSpecialKeys[186] = ':'
      _otherSpecialKeys[189] = '_'
    }
  }

  /**
   * Removing a single key and its functions
   * @param {string} keys - The key to remove
   */
  function _removeKey(keys, _regKeys) {
    var obj = segregateKeys(keys)
    var container = _regKeys[obj.newKey]
    if (!container) {
      return;
    }
    for (var i = 0; i < container.length; i++) {
      if (obj.pressTogether && container[i].modifier.sort().join(' ') === obj.modifier.sort().join(' ')) {
        _regKeys[obj.newKey].splice(i, 1)
        break;
      }
      else if (!obj.pressTogether) {
        _regKeys[obj.newKey].splice(i, 1)
        break;
      }
    }
  }

  /**
   * Replaces the substrings of keys to event.key
   * @param {string} keys
   * @returns the modified key containing "event.key" name
   */
  function userToBrowserKeys(keys) {
    //ctrl will be replaced by control
    if (keys.search("/ctrl/i")) {
      keys = keys.replaceAll("ctrl", "control")
    }
    //command will be replaced by meta
    if (keys.search("/command/i")) {
      keys = keys.replaceAll("command", "meta")
    }
    //command will be replaced by meta
    if (keys.search("/esc/i")) {
      keys = keys.replaceAll("esc", "escape")
    }
    //arrow keys will be replaced
    if (keys.search("/left/i")) {
      keys = keys.replaceAll("left", "arrowleft")
    }
    if (keys.search("/right/i")) {
      keys = keys.replaceAll("right", "arrowright")
    }
    if (keys.search("/up/i")) {
      keys = keys.replaceAll("up", "arrowup")
    }
    if (keys.search("/down/i")) {
      keys = keys.replaceAll("down", "arrowdown")
    }
    return keys;
  }

  /**
   * Removes the shortcut registered with oldKey
   * @param {object} entry
   */
  function removeFromCache(entry) {
    var oldkey = entry.oldKey
    if (oldkey) {
      shortcut.unregister(oldkey)
      shortcut.unregisterKey(oldkey)
    }
  }

  /**
   * Check whether a shortcut is registered in shortcut cache
   * @param {object} entry
   * @param {string} shortcutCache
   * @returns false if shortcut is not present in cache. the index if present
   */
  function isShortcutRegistered(entry, shortcutCache) {
    var returnedObject = segregateKeys(entry.newKey)
    var shortcutkey = returnedObject.newKey
    if (shortcutCache[shortcutkey] && shortcutCache[shortcutkey].length) {
      for (var i = 0; i < shortcutCache[shortcutkey].length; i++) {
        var item = shortcutCache[shortcutkey][i]
        if (item.pressTogether === returnedObject.pressTogether) {
          if (isEqual(item.modifier, returnedObject.modifier)) {
            return i;
            // console.error("The shortcut is already registered for ", processedKeys.newKey);
          }
          else {
            return false
          }
        } else {
          return false
        }
      }
    }
    else {
      return false
    }
  }

  /**
   * Replaces the shortcut in the cache
   * @param {object} entry
   * @param {string} shortcutCache
   * @param {integer} index the position at which the shortcut is present in the array
   */
  function replaceShortcut(entry, shortcutCache, index) {
    var value = entry.value
    var returnedObject = segregateKeys(entry.newKey)
    var wait
    var preventDefault
    var useCode
    var excludeElements
    var validate
    if (entry.options) {
      wait = entry.options.wait ? entry.options.wait : 0
      preventDefault = entry.options.preventDefault ? entry.options.preventDefault : false
      useCode = entry.options.useCode ? entry.options.useCode : false
      excludeElements = entry.options.excludeElements ? entry.options.excludeElements : undefined;
      validate = entry.options.validate ? entry.options.validate : function () { return true }
    }
    else {
      wait = 0
      preventDefault = false;
      useCode = false;
      excludeElements = undefined;
      validate = function () { return true };
    }
    var type = typeof value
    shortcutCache[returnedObject.newKey][index] = {
      type: type,
      value: value,
      modifier: returnedObject.modifier,
      pressTogether: returnedObject.pressTogether,
      wait: wait,
      useKey: entry.useKey,
      preventDefault: preventDefault,
      useCode: useCode,
      excludeElements: excludeElements,
      validate: validate
    }
  }

  /**
   * Add new shortcut to the shortcut cache
   */
  function addNewShortcut(entry, shortcutCache) {
    var value = entry.value
    var returnedObject = segregateKeys(entry.newKey)
    var wait
    var preventDefault
    var useCode
    var excludeElements
    var validate
    if (entry.options) {
      wait = entry.options.wait ? entry.options.wait : 0;
      preventDefault = entry.options.preventDefault ? entry.options.preventDefault : false;
      useCode = entry.options.useCode ? entry.options.useCode : false;
      excludeElements = entry.options.excludeElements ? entry.options.excludeElements : undefined;
      validate = entry.options.validate ? entry.options.validate : function () { return true; }
    }
    else {
      wait = 0
      preventDefault = false;
      useCode = false;
      excludeElements = undefined;
      validate = function () { return true }
    }
    var type = typeof value
    shortcutCache[returnedObject.newKey] = shortcutCache[returnedObject.newKey] || [];
    shortcutCache[returnedObject.newKey].push({
      type: type,
      value: value,
      modifier: returnedObject.modifier,
      pressTogether: returnedObject.pressTogether,
      wait: wait,
      useKey: entry.useKey,
      preventDefault: preventDefault,
      useCode: useCode,
      excludeElements: excludeElements,
      validate: validate
    })
  }

  /**
   * based on the presece of the shortcut in the cache, the shortcut is added to cache
   */
  function storeToCache(entry, shortcutCache) {
    var index = isShortcutRegistered(entry, shortcutCache)
    if (typeof (index) === "number") {
      replaceShortcut(entry, shortcutCache, index)
    }
    else {
      addNewShortcut(entry, shortcutCache)
    }
  }
  function checkExcludeElements(excludeElements, keys) {
    if (!Array.isArray(excludeElements)) {
      return false;
    }
    for (let i = 0; i < excludeElements.length; i++) {
      const element = excludeElements[i];
      if (element && (/[a-zA-Z]/.test(element.join))) {
        if (element && element.length <= 0) {
          return false;
        }
        else if (element === null || element === undefined || element === true) {
          return false;
        }
      }
      else {
        return false
      }
    }
    return true;
  }
  /**
   *Checks whether the shortcut to be registered are of suggested types
   * @param {} keys
   * @param {function} callback - function to be invoked
   * @param {object} options - the attributes of shortcut(wait, type)
   * @param {boolean} useKey - defines the function used among (register() & registerKey())
   */
  function registerShortcut(keys, callback, options) {
    var type = typeof keys
    if (type !== 'string' && type !== 'object') {
      console.error("Invalid Type");
      return;
    }
    if (Array.isArray(options.excludeElements)) {
      var excludeElements = options.excludeElements;
      var excludeElementsValid = checkExcludeElements(excludeElements, keys);
      if (!excludeElementsValid) {
        console.error("Invalid value for excludeElements. Shortcut not registered for ", keys, excludeElements);
        return;
      }
    }
    if (options.excludeElements && !(Array.isArray(options.excludeElements))) {
      console.error("Invalid value for excludeElements. Shortcut not registered for ", keys, options.excludeElements);
      return;
    }

    if (type === 'object') {
      _processObject(keys, callback, options)
    }
    else {
      _processString(keys, callback, options)
    }
  }

  // Constructor
  /**
   * Shortcut constructor
   * registers listeners
   */
  function shortcut(target) {
    _registerOtherKeys()
    target.addEventListener('keydown', _handleKeyPress)
  }

  // Public methods
  /**
   * Exposes the push function so that the custom elements register key presses
   */
  Object.defineProperty(shortcut, "push", {
    writable: false,
    value: function (entry) {
      removeFromCache(entry);
      // undefined or empty string cases or empty object
      if (!entry.newKey || entry.newKey === undefined || (typeof entry.newKey === "object" && Object.keys(entry.newKey).length === 0)) {
        // When UI components disconnect entry.oldKey will be having oldkey
        // If oldKey is not there, the warning has to be given
        if (!(entry.oldKey)) {
          console.error("Shortcut Not Registered: Trying to register shortcut for empty key combination.");
        }
        return;
      }
      entry.useKey = false;
      storeToCache(entry, _registeredKeys)
    }
  })
  Object.defineProperty(shortcut, "pushKey", {
    writable: false,
    value: function (entry) {
      removeFromCache(entry)
      // undefined or empty string cases or empty object
      if (!entry.newKey || entry.newKey === undefined || (typeof entry.newKey === "object" && Object.keys(entry.newKey).length === 0)) {
        // When UI components disconnect entry.oldKey will be having oldkey
        // If oldKey is not there, the warning has to be given
        if (!(entry.oldKey)) {
          console.error("Shortcut Not Registered: Trying to register shortcut for empty key combination.");
        }
        return;
      }
      if (entry.useKey === undefined) {
        entry.useKey = true
      }
      storeToCache(entry, _registeredKeyShortcuts)
    }
  })

  /**
   * Checks whether the shortcut is already registered for these keys.
   */
  Object.defineProperty(shortcut, "hasRegisteredShortcut", {
    writable: false,
    value: function (keys) {
      keys = removeWhiteSpace(keys)
      var processedKeys = segregateKeys(keys.trim())
      var allRegisteredShortcutKeys = getAllRegisteredShortcutKeys();
      if (Object.keys(allRegisteredShortcutKeys).length === 0) {
        return false;
      }
      for (var keys in allRegisteredShortcutKeys) {
        if ((keys === processedKeys.newKey)) {
          for (var i = 0; i < allRegisteredShortcutKeys[keys].length; i++) {
            var item = allRegisteredShortcutKeys[keys][i]
            if (item.pressTogether === processedKeys.pressTogether) {
              if (isEqual(item.modifier, processedKeys.modifier)) {
                return true;
                // console.error("The shortcut is already registered for ", processedKeys.newKey);
              }
              else {
                return false;
                // console.log("No shortcut is registered for ", processedKeys.newKey);
              }
            }
            else {
              return false;
              // console.log("No shortcut is registered for ", processedKeys.newKey);
            }
          }
        }
      }
    }
  })

  /**
   * Exposes the register function so that developers can register key pressess
   */
  Object.defineProperty(shortcut, "registerKey", {
    writable: false,
    value: function (keys, callback, options) {
      if (options) {
        if (options.type) {
          options.type = options.type.trim()
        }
      }
      else {
        options = {}
      }
      options.useCode = false;
      options.useKey = true;

      if (options && options.type === 'regex') {
        _pushRegex(keys, callback, options, _registeredKeyShortcuts)
      }
      registerShortcut(keys, callback, options)
    }
  })
  Object.defineProperty(shortcut, "registerCode", {
    writable: false,
    value: function (keys, callback, options) {
      if (options) {
        if (options.type) {
          options.type = options.type.trim()
        }
      }
      else {
        options = {}
      }
      options.useCode = true
      options.useKey = true;
      registerShortcut(keys, callback, options)
    }
  })
  Object.defineProperty(shortcut, "register", {
    writable: false,
    value: function (keys, callback, options) {
      if (options) {
        if (options.type === 'regex') {
          options.useCode = false;
          options.useKey = false;
          _pushRegex(keys, callback, options, _registeredKeys)
        }
      }
      else {
        options = {}
      }
      options.useCode = false;
      options.useKey = false;
      registerShortcut(keys, callback, options)
    }
  })

  /**
   * Exposes the unregister function so that developers can unregister already registered keys
   */
  Object.defineProperty(shortcut, "unregister", {
    writable: false,
    value: function (keys) {
      if (typeof keys === 'object') {
        for (var i = 0; i < keys.length; i++) {
          var _key = userToBrowserKeys(keys[i])
          _key = removeWhiteSpace(_key)
          _removeKey(_key, _registeredKeys);
        }
      }
      else {
        keys = removeWhiteSpace(keys)
        _removeKey(keys, _registeredKeys);
      }
    }
  })

  Object.defineProperty(shortcut, "unregisterKey", {
    writable: false,
    value: function (keys) {
      if (typeof keys === 'object') {
        for (var i = 0; i < keys.length; i++) {
          var _key = keys[i]
          _key = removeWhiteSpace(_key)
          _removeKey(_key, _registeredKeyShortcuts);
        }
      }
      else {
        keys = removeWhiteSpace(keys)
        _removeKey(keys, _registeredKeyShortcuts);
      }
    }
  })
  Object.defineProperty(shortcut, "unregisterCode", {
    writable: false,
    value: function (keys) {
      if (typeof keys === 'object') {
        for (var i = 0; i < keys.length; i++) {
          var _key = keys[i]
          _key = removeWhiteSpace(_key)
          _removeKey(_key, _registeredKeyShortcuts);
        }
      }
      else {
        keys = removeWhiteSpace(keys)
        _removeKey(keys, _registeredKeyShortcuts);
      }
    }
  })
  /**
   * Exposes the unregisterAll function so developers can unregister all keys at once
   */
  Object.defineProperty(shortcut, "unregisterAll", {
    writable: false,
    value: function () {
      for (var key in _registeredKeys) {
        delete _registeredKeys[key]
      }
      for (var key in _registeredKeyShortcuts) {
        delete _registeredKeyShortcuts[key]
      }
    }
  })

  // Intializing
  shortcut(document)
  window.shortcut = shortcut

});

( function( factory ) {
    if( typeof define === "function" && define.amd ) {
        define( [ "@zoho/lyte-dom" ], factory );
    }
    else {
        factory( $L );
    }
} )(function( $L ) {

	if( typeof $L != "undefined" ){
		$L.prototype.manageSortable = {
			
			keyPressed : false,
			keyValue : 0,
			countSortable : 0,
			init : false,
			prevSortable : false,
			mousedownTriggered : false,
			draggedEle : null,
			_ssData : {},
			measureQueue : [],
			mutateQueue : [],
			isEqual : function (value, other) {
				if(value.length != other.length){
					return false;
				}
				for(var i = 0 ; i < value.length ; i++){
					if(other.indexOf(value[i]) == -1){
						return false;
					}
				}
				// If nothing failed, return true
				return true;
			},

			convertToArrayOfItems : function(selector,context){
				if(typeof selector != "string" && selector.length > 0){
					return selector;
				}
				var selectorArray = selector.split(',');
				var retArray = [];
				selectorArray.forEach(function(item,indexVal){
					var items = $L(item.trim(),context);
					if(items.length){
						for(var i=0;i < items.length ;i++){
							if(retArray.indexOf(items[i]) == -1 && items[i].tagName != "TEMPLATE"){
								retArray.push(items[i]);
							}
						}
					}
					else{
						if(retArray.indexOf(items) == -1 && items.tagName != "TEMPLATE"){
							retArray.push(items);
						}
					}
				});
				return retArray;
			},

			destroy : function(element){

				if(!(element.classList.contains('sortable-parent'))){
					console.info("ALERT! - U have already destroyed its sortable behaviour.");
					return;
				}
				var childrens = Array.from(element.children).filter(function(node) { return node.tagName != 'TEMPLATE'});
				var sortableElemClass = element.getSortableClass();
				for(var i = 0; i<childrens.length; i++){
					childrens[i].classList.remove('sortable-element',sortableElemClass);
					if(childrens[i]._sortableChildData){
						childrens[i]._sortableChildData = null;
					}
				}
				if(element._mousedown){
					element.removeEventListener('mousedown',element.__mouseDownEvent);
					element.removeEventListener('touchstart',element.__mouseDownEvent, true);
					element._mousedown = false;
				}
				element.classList.remove('sortable-parent');
				// element._sortableParentData = null;
				if(element._sortableParentData.multiSortable) {
					element._sortableParentData.allSortableClass = null;
				}
				delete element._sortableParentData;
				delete element.getSortableClass;
			},

			cancel : function(element){
				if(!(element.classList.contains('sortable-parent'))){
					console.info("ALERT! - The element is not a sortable parent.");
					return;
				}
				var childrens = this.getChildElements(element) /*element.children*/;
				for(var i = childrens.length-1; i >= 0 ; i--){
					if(childrens[i]._pos != i){
						var elem = undefined;
						for(var j = i; j >= 0; j--){
							if(childrens[j]._pos == i){
								elem = childrens[j];
								break;
							}
						}
						if(elem){
							if(i == childrens.length-1){
								window._lyteUiUtils.appendChild(element,elem);
							}
							else{
								window._lyteUiUtils.insertBefore(childrens[i+1],elem);
							}
						}
						childrens = this.getChildElements(element);
					}
				}
			},

			getChildElements : function(parent){
				return Array.from(parent.children).filter(function(ele){ return ele.tagName != "TEMPLATE" });
			},

			disable : function(elements){
				for(var i = 0; i < elements.length; i++){
					var sortableElem = elements[i];
					if(!(sortableElem.classList.contains('sortable-element'))){
						console.info(sortableElem, " cannot be disabled as it is not a sortable element.");
					}
					else{
						var disabledData = {
												class : 'sortable-element',
												data : Object.assign({}, sortableElem._sortableChildData)
											};
						sortableElem.classList.add('sort-disabled-element');
						sortableElem.classList.remove('sortable-element', sortableElem._sortableChildData.sortableElemClass);
						sortableElem._disabledData = disabledData;
						sortableElem._sortableChildData = null;
					}
				}
			},

			enable : function(elements){
				for(var i = 0; i < elements.length; i++){
					var sortableElem = elements[i];
					if(!(sortableElem._disabledData || sortableElem.classList.contains('sort-disabled-element'))){
						console.info(sortableElem, " cannot be enabled as it is not a disabled sortable element.");
					}
					else{
						sortableElem._sortableChildData = Object.assign({}, sortableElem._disabledData.data);
						sortableElem.classList.remove('sort-disabled-element');
						sortableElem.classList.add('sortable-element', sortableElem._sortableChildData.sortableElemClass);
						delete sortableElem._disabledData;
					}
				}
			},

			alreadySortable : function(elements){
				for(var i = 0; i<elements.length; i++){
					if($L(elements[i]).hasClass('sortable-parent') && elements[i]._sortableParentData){
						return {found : true, class : elements[i]._sortableParentData.sortableElemClass}
					}
				}
				return {found : undefined};
			},

			isOver : function(event, data, fromDraggable){
				var manageSortable = $L.prototype.manageSortable;
				var clientX = event.clientX !== undefined ? event.clientX : event.touches[0].clientX;
				var clientY  = event.clientY !== undefined ? event.clientY : event.touches[0].clientY;
				if(fromDraggable){
					var prevOffset = manageSortable.prevSortable ? manageSortable.prevSortable.getBoundingClientRect() : null;
					if(prevOffset && (clientX < prevOffset.left || clientX > prevOffset.right || clientY < prevOffset.top || clientY > prevOffset.bottom)){
						if(manageSortable.prevSortable && manageSortable.prevSortable._sortableParentData && manageSortable.prevSortable._sortableParentData.onLeave){
							manageSortable.prevSortable._sortableParentData.onLeave(event,{element : data._element, sortable : manageSortable.prevSortable, placeholder : data._placeholder});
						}
						manageSortable.prevSortable = false;
					}
					else{

						var sortables = document.querySelectorAll(data.connectToSortable+".sortable-parent");
												if(sortables.length){
							for(var i = sortables.length-1; i >= 0; i--){
								var sortableOffset =  sortables[i].getBoundingClientRect();
								if(sortables[i]._sortableParentData.droppable && (clientX >= sortableOffset.left) && (clientX <= sortableOffset.right) && (clientY >= sortableOffset.top) && (clientY <= sortableOffset.bottom)){
									// return sortables[i];
									if(!manageSortable.prevSortable || (manageSortable.prevSortable && manageSortable.prevSortable != sortables[i])){
										manageSortable.prevSortable = sortables[i];

										if(manageSortable.prevSortable._sortableParentData && manageSortable.prevSortable._sortableParentData.onEnter){
											manageSortable.prevSortable._sortableParentData.onEnter(event,{element : data._element, sortable : manageSortable.prevSortable, placeholder : data._placeholder});
										}
									}
									break;
								}
							}
						}
					}
				}
				else{

					var prevOffset = manageSortable.prevSortable ? ( manageSortable.prevSortable.getBoundingClientRect() ) : null;
					if(prevOffset && (clientX < prevOffset.left || clientX > prevOffset.right || clientY < prevOffset.top || clientY > prevOffset.bottom)){
						// manageSortable.prevSortable.classList.remove('disableHover');
						if(manageSortable.prevSortable && manageSortable.prevSortable._sortableParentData && manageSortable.prevSortable._sortableParentData.onLeave){
							manageSortable.prevSortable._sortableParentData.onLeave(event,{element : data._div, sortable : manageSortable.prevSortable, placeholder : data._placeholder});
						}
						manageSortable.prevSortable = false;
					}
					else{

						var sortables = data.connectedWith.length ? data.connectedWith : [data._parentElem];
						if(sortables.length){
							for(var i = sortables.length-1; i >= 0; i--){
								

								var sortableOffset =   sortables[i].getBoundingClientRect();
								if(sortables[i]._sortableParentData.droppable && (clientX >= sortableOffset.left) && (clientX <= sortableOffset.right) && (clientY >= sortableOffset.top) && (clientY <= sortableOffset.bottom)){
									// return sortables[i];

									if(!manageSortable.prevSortable || (manageSortable.prevSortable && manageSortable.prevSortable != sortables[i])){
										manageSortable.prevSortable = sortables[i];
										// manageSortable.prevSortable.classList.add('disableHover');
										if(manageSortable.prevSortable._sortableParentData && manageSortable.prevSortable._sortableParentData.onEnter){
											manageSortable.prevSortable._sortableParentData.onEnter(event,{element : data._div, sortable : manageSortable.prevSortable, placeholder : data._placeholder});
										}
									}
									break;
								}
							}
						}
					}
				}
			},

			getSortableClasses : function(elements, previousObject) {
				var object = previousObject || {};
				elements.forEach(function(element){
					if( element && element._sortableParentData){
						var classNameForSortable = element._sortableParentData.sortableElemClass;
						if(!object.hasOwnProperty(classNameForSortable)) {
							object[classNameForSortable] = element;
						}
					}
				});
				return object;
			},

			enableDroppable : function(element) {
				if($L(element).hasClass('sortable-parent')) {
					element[0]._sortableParentData.droppable = true;
				}
			},

			disableDroppable : function(element) {
				if($L(element).hasClass('sortable-parent')) {
					element[0]._sortableParentData.droppable = false;
				}
			}
		};

		$L.prototype.sortable = function(object) {
			
			var manageSortable = $L.prototype.manageSortable;
			if(!manageSortable.init){
				if (!Element.prototype.matches) {
				    Element.prototype.matches =
				        Element.prototype.matchesSelector ||
				        Element.prototype.mozMatchesSelector ||
				        Element.prototype.msMatchesSelector ||
				        Element.prototype.oMatchesSelector ||
				        Element.prototype.webkitMatchesSelector ||
				        function(s) {
				            var matches = (this.document || this.ownerDocument).querySelectorAll(s),
				                i = matches.length - 1;
				            while (i >= 0 && matches.item(i) !== this){
				            	--i;
				            	//gets the index of the matched item
				            }
				            return i > -1;
				        };
				}
				if (!Array.from) {
				  Array.from = (function () {
				    var toStr = Object.prototype.toString;
				    var isCallable = function (fn) {
				      return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
				    };
				    var toInteger = function (value) {
				      var number = Number(value);
				      if (isNaN(number)) { return 0; }
				      if (number === 0 || !window.isFinite(number)) { return number; }
				      return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
				    };
				    var maxSafeInteger = Math.pow(2, 53) - 1;
				    var toLength = function (value) {
				      var len = toInteger(value);
				      return Math.min(Math.max(len, 0), maxSafeInteger);
				    };

				    // The length property of the from method is 1.
				    return function from(arrayLike/*, mapFn, thisArg */) {
				      // 1. Let C be the this value.
				      var C = this;

				      // 2. Let items be ToObject(arrayLike).
				      var items = Object(arrayLike);

				      // 3. ReturnIfAbrupt(items).
				      if (arrayLike == null) {
				        throw new TypeError('Array.from requires an array-like object - not null or undefined');
				      }

				      // 4. If mapfn is undefined, then let mapping be false.
				      var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
				      var T;
				      if (typeof mapFn !== 'undefined') {
				        // 5. else
				        // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.
				        if (!isCallable(mapFn)) {
				          throw new TypeError('Array.from: when provided, the second argument must be a function');
				        }

				        // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.
				        if (arguments.length > 2) {
				          T = arguments[2];
				        }
				      }

				      // 10. Let lenValue be Get(items, "length").
				      // 11. Let len be ToLength(lenValue).
				      var len = toLength(items.length);

				      // 13. If IsConstructor(C) is true, then
				      // 13. a. Let A be the result of calling the [[Construct]] internal method
				      // of C with an argument list containing the single item len.
				      // 14. a. Else, Let A be ArrayCreate(len).
				      var A = isCallable(C) ? Object(new C(len)) : new Array(len);

				      // 16. Let k be 0.
				      var k = 0;
				      // 17. Repeat, while k < len… (also steps a - h)
				      var kValue;
				      while (k < len) {
				        kValue = items[k];
				        if (mapFn) {
				          A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
				        } else {
				          A[k] = kValue;
				        }
				        k += 1;
				      }
				      // 18. Let putStatus be Put(A, "length", len, true).
				      A.length = len;
				      // 20. Return A.
				      return A;
				    };
				  }());
				}
				manageSortable.init = true;
			}

			if(typeof object === "string"){
				if(object === "destroy"){
					if(this.length > 1){
						var elemArray = this;
						for(var i = 0; i<elemArray.length; i++){
							manageSortable.destroy(elemArray[i]);
						}
					}
					else{
						manageSortable.destroy(this[0]);
					}
				}
				else if(object === "cancel"){
					if(this.length > 1){
						var elemArray = this;
						for(var i = 0; i<elemArray.length; i++){
							manageSortable.cancel(elemArray[i]);
						}
					}
					else{
						manageSortable.cancel(this[0]);
					}
				}
				else if(object === "disable"){
					manageSortable.disable(this);
				}
				else if(object === "enable"){
					manageSortable.enable(this);
				}
				else if(object === "disableDroppable"){
					manageSortable.disableDroppable(this);
				}
				else if(object === "enableDroppable"){
					manageSortable.enableDroppable(this);
				}
				return;
			}
			var data = object ? object : {};

			/* -------- BROWSER RELATED CHECKS -------- */
			var detectBrowser = function(){
				//Check if browser is IE11
			    if (window.navigator.userAgent.search("rv:11") >= 0) {
			        return "ie";
			    }
			    //Check if browser is Edge
			    if (window.navigator.userAgent.search("Edge") >= 0) {
			        return "edge";
			    }
			    //Check if browser is Chrome || Opera
			    else if (window.navigator.userAgent.search("Chrome") >= 0) {
			        return "chrome";
			    }
			    //Check if browser is Firefox
			    else if (window.navigator.userAgent.search("Firefox") >= 0) {
			        return "firefox";
			    }
			    //Check if browser is Safari
			    else if (window.navigator.userAgent.search("Safari") >= 0 && window.navigator.userAgent.search("Chrome") < 0) {
			        return "safari";
			    }
			};

			var getOS = function() {
				var userAgent = window.navigator.userAgent,
				    platform = window.navigator.platform,
				    macosPlatforms = ['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'],
				    windowsPlatforms = ['Win32', 'Win64', 'Windows', 'WinCE'],
				    iosPlatforms = ['iPhone', 'iPad', 'iPod'],
				    os = null;

				if (macosPlatforms.indexOf(platform) !== -1) {
				    os = 'Mac OS';
				} else if (iosPlatforms.indexOf(platform) !== -1) {
				    os = 'iOS';
				} else if (windowsPlatforms.indexOf(platform) !== -1) {
				    os = 'Windows';
				} else if (/Android/.test(userAgent)) {
				    os = 'Android';
				} else if (!os && /Linux/.test(platform)) {
				    os = 'Linux';
				}

				return os;
			};

			var isMobileOrTabletCheck = function() {
				var check = false;
				(function(a){
					if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) ||
						/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) {
						check = true;
					}
				})(window.navigator.userAgent||window.navigator.vendor||window.opera);
				return check;
			};

			if(this.length > 1){

				var elemArray = this;
				if(!data.changed){
					++manageSortable.countSortable;
					data.changed = true;
				}
				var check = manageSortable.alreadySortable(this);

				if(check.found){
					data.sortableElemClass = check.class;
				}
				for(var i = 0 ; i < elemArray.length ; i++){

					if(elemArray[i]._sortableParentData && data.isSameClass  ){
						if((elemArray[i]._sortableParentData.connectedWith.length !== $L(data.connectedWith,data.context).length)){
							data.connectedWith  = manageSortable.convertToArrayOfItems(data.connectedWith,data.context);
						}else {
							data.connectedWith = elemArray[i]._sortableParentData.connectedWith;
						}
					}
					$L(elemArray[i]).sortable(Object.assign({},data));


				};
				return;
			}


			var element = this.length == undefined ? this : this[0];


			if(element._sortableParentData){

				var _sortableData = element._sortableParentData;

				data._parentElem = data._parentElem == undefined ? _sortableData._parentElem : data._parentElem;

				//Data overriding
				data.containment = data.containment ? data.containment : _sortableData.containment;
				data.containmentBoundaries =  data.containmentBoundaries ?  data.containmentBoundaries : _sortableData.containmentBoundaries;
				data.connected = data.connectedWith ? manageSortable.isEqual(data.connectedWith, _sortableData.connectedWith) : _sortableData.connected;
				data.connectedWith = data.connectedWith ? data.connectedWith : _sortableData.connectedWith;
				data.orientation = data.orientation ? data.orientation : _sortableData.orientation;
				data.droppable = (data.droppable == undefined) ? _sortableData.droppable : data.droppable;
				data.draggable = (data.draggable == undefined) ? _sortableData.draggable : data.draggable;
				data.sortableElemClass = data.sortableElemClass ? data.sortableElemClass : _sortableData.sortableElemClass;
				data.selectedClass = data.selectedClass ? data.selectedClass : _sortableData.selectedClass;
				data.placeholder = data.placeholder ? data.placeholder : _sortableData.placeholder;
				data.disabled = data.disabled ? data.disabled : _sortableData.disabled;
				data.onReady = data.onReady ? data.onReady : _sortableData.onReady;
				data.onSelect = data.onSelect ? data.onSelect : _sortableData.onSelect;
				data.onDragStart = data.onDragStart ? data.onDragStart : _sortableData.onDragStart;
				data.onDrag = data.onDrag ? data.onDrag : _sortableData.onDrag;
				data.onPlaceholder = data.onPlaceholder ? data.onPlaceholder : _sortableData.onPlaceholder;
				data.onBeforeDrop = data.onBeforeDrop ? data.onBeforeDrop : _sortableData.onBeforeDrop;
				data.onDrop = data.onDrop ? data.onDrop : _sortableData.onDrop;
				data.onAfterDrop = data.onAfterDrop ? data.onAfterDrop : _sortableData.onAfterDrop;
				data.cancel = data.cancel == undefined ? _sortableData.cancel : data.cancel instanceof Array ? data.cancel : data.cancel.split(",") ;
				data.cancelRemove = (_sortableData.cancelRemove || data.cancelRemove == true) ? true : false ;
				data.tolerance = data.tolerance ? data.tolerance : _sortableData.tolerance;
				data.items = data.items == undefined ? _sortableData.items : data.items instanceof Array ? data.items : data.items.split(",");
				data.cursorAt = data.cursorAt == undefined ? _sortableData.cursorAt : data.cursorAt;
				data.restrict = data.restrict == undefined ? _sortableData.restrict : data.restrict instanceof Array ? data.restrict : data.restrict.split(",");
				data.scrollDivX = data.scrollDivX == undefined ? _sortableData.scrollDivX : typeof data.scrollDivX === "string" ? document.querySelector(data.scrollDivX) : data.scrollDivX;
				data.scrollDivY = data.scrollDivY == undefined ? _sortableData.scrollDivY : typeof data.scrollDivY === "string" ? document.querySelector(data.scrollDivY) : data.scrollDivY;
				data.scrollBoundaries = data.scrollBoundaries ? data.scrollBoundaries :_sortableData.scrollBoundaries;
				data.preventScrollY = data.preventScrollY == undefined ? _sortableData.preventScrollY : data.preventScrollY;
				data.omitRestricted = data.omitRestricted == undefined ? _sortableData.omitRestricted : data.omitRestricted;
				data.onEnter = data.onEnter ? data.onEnter : _sortableData.onEnter;
				data.onLeave = data.onLeave ? data.onLeave : _sortableData.onLeave;
				data.clone = data.clone ? data.clone : _sortableData.clone;
				data.preventDefault = data.preventDefault ? data.preventDefault : _sortableData.preventDefault;
				if( data.appendTo && data.appendTo.toLowerCase() == 'body'){
					data.appendTo = document.body;
				}
				data.appendTo = data.appendTo ? (data.appendTo != "parent" ? $L(data.appendTo)[0] : "parent") : _sortableData.appendTo;
				data.helper = data.helper ? data.helper : _sortableData.helper;
				data.preventDropAtEnd = data.preventDropAtEnd == undefined ? _sortableData.preventDropAtEnd : data.preventDropAtEnd;
				data.preventDropAtStart = data.preventDropAtStart == undefined ? _sortableData.preventDropAtStart : data.preventDropAtStart;
				data.onMultiSelectDrag = data.onMultiSelectDrag ? data.onMultiSelectDrag : _sortableData.onMultiSelectDrag;
				data.gridView = data.gridView ? data.gridView : _sortableData.gridView;
				data.multiSortable = data.multiSortable ? data.multiSortable : _sortableData.multiSortable;
				data.context = data.context ? data.context : _sortableData.context;
				data.isSameClass = data.isSameClass ? data.isSameClass : _sortableData.isSameClass;
				data.preventScroll = data.preventScroll ? data.preventScroll : _sortableData.preventScroll;
				data.threshold = data.threshold ? data.threshold : _sortableData.threshold;
				data.dblTouchEvent = data.dblTouchEvent ? data.dblTouchEvent : _sortableData.dblTouchEvent;
				data.placeholderAppendTo = data.placeholderAppendTo ? data.placeholderAppendTo : _sortableData.placeholderAppendTo;
				data.transitionEnabled = data.transitionEnabled ? data.transitionEnabled : _sortableData.transitionEnabled;
				data.transitionDuration = data.transitionDuration ? data.transitionDuration : _sortableData.transitionDuration;
				data.aria = data.aria ? data.aria : _sortableData.aria;

				if (data.multiSortable && data.connectedWith) {
					data.allSortableClass = _sortableData.allSortableClass ? _sortableData.allSortableClass : manageSortable.getSortableClasses(data.connectedWith, _sortableData.allSortableClass);
				}
				if(!($L(element).hasClass('sortable-parent'))){
					$L(element).addClass('sortable-parent','lyteSortableParent')
				}
				if(data.executeOnReady){
					data._parentElem.executedOnReady = false;
				}
				if(data.aria){
					data._parentElem.setAttribute('tabIndex',0);
				}
			}
			else{

				if(!data.connected && !data.changed){
					++manageSortable.countSortable;
					data.changed = true;
				}
				//Parent Element
				data._parentElem = element;
				$L(data._parentElem).addClass('sortable-parent','lyteSortableParent');

				//Data initialization
				data.containment = data.containment;
				data.containmentBoundaries = data.containmentBoundaries ?   data.containmentBoundaries : {top: 0 ,left:0 ,right:0 ,bottom : 0};
				data.connectedWith = data.connectedWith ? data.connectedWith : [];
				data.orientation = data.orientation ? data.orientation : "default";
				data.selectedClass = data.selectedClass ? data.selectedClass : "";
				data.droppable = (data.droppable == undefined) ? true : data.droppable;
				data.draggable = (data.draggable == undefined) ? true : data.draggable;
				data.sortableElemClass = data.sortableElemClass ? data.sortableElemClass : element.parentElement && element.parentElement._sortableParentData ? element.parentElement._sortableParentData.sortableElemClass : (data.orientation === "horizontal") ? "sortable-element-h"+manageSortable.countSortable : (data.orientation === "vertical") ? "sortable-element-v"+manageSortable.countSortable : "sortable-element-d"+manageSortable.countSortable;
				data.placeholder = data.placeholder ? data.placeholder : "lyteSortablePlaceholder";
				data.disabled = data.disabled ? data.disabled : "lyteSortableDisabledPlaceholder";
				data.cancel = data.cancel == undefined ? [] : data.cancel instanceof Array ? data.cancel : data.cancel.split(",");
				data.tolerance = data.tolerance ? data.tolerance : "intersect";
				data.items = data.items == undefined ? [] : data.items instanceof Array ? data.items : data.items.split(",");
				data.cursorAt = data.cursorAt;
				data.restrict = data.restrict == undefined ? [] : data.restrict instanceof Array ? data.restrict : data.restrict.split(",");
				data.scrollDivX = data.scrollDivX ? ( typeof data.scrollDivX === "string" ? document.querySelector(data.scrollDivX) : data.scrollDivX) : undefined;
				data.scrollDivY = data.scrollDivY ? ( typeof data.scrollDivY === "string" ? document.querySelector(data.scrollDivY) : data.scrollDivY) : undefined;
				data.scrollBoundaries = data.scrollBoundaries ? data.scrollBoundaries : {top: 0 , left: 0 ,right: 0, bottom: 0}; 
				data.omitRestricted = data.omitRestricted == undefined ? false : data.omitRestricted;
				data.clone = data.clone ? true : false;
				data.context = data.context ? data.context : document.body;
				data.preventDefault = data.preventDefault == undefined ? { "mousedown" : isMobileOrTabletCheck() ? false : true, "mousemove" : true } : data.preventDefault;
				if(data.appendTo && data.appendTo.toLowerCase() == 'body'){
					data.appendTo = document.body;
				}
				data.appendTo = data.appendTo && data.appendTo != "parent" ? $L(data.appendTo)[0] : "parent";
				data.preventDropAtEnd = data.preventDropAtEnd == undefined ? true : data.preventDropAtEnd;
				data.preventDropAtStart = data.preventDropAtStart == undefined ? true : data.preventDropAtStart;
				data.gridView = data.gridView ? true : false;
				data.isSameClass = data.isSameClass ? data.isSameClass : false;
				data.preventScrollY = data.preventScrollY ? data.preventScrollY : false;
				data.preventScroll = data.preventScroll ? data.preventScroll : false;
				data.threshold = data.threshold ? data.threshold : 0;
				data.dblTouchEvent = data.dblTouchEvent ? data.dblTouchEvent : false;
				data.placeholderAppendTo = data.placeholderAppendTo ? data.placeholderAppendTo : 'null';
				data.transitionEnabled = data.transitionEnabled ? data.transitionEnabled : false;
				data.transitionDuration = data.transitionDuration !== undefined ? data.transitionDuration : 500;
				data.aria = data.aria ? data.aria : false;
				if(data.aria){
					data._parentElem.setAttribute('tabIndex',0);
				}
			}


			var _offset = [0,0];
			var _initClientX;
			var _initClientY;
			var _isDown = false;
			var _isMoved = false;
			var _mousePosition;
			var _elemBelow;
			var _droppablePlace;
			var _marginTop = 0;
			var _marginLeft = 0;
			var _sortableElemClass;
			var _sortableElem;
			var _placeholder = "";
			var _div = "";
			var _scrollLeft = 0;
			var _scrollTop = 0;
			var _requestId1 = null;
			var _requestId2 = null;
			var _animationFrameFired1 = false;
			var _animationFrameFired2 = false;
			var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
			var cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame;
			var _maxScrollWidth = 0;
			var _maxScrollHeight = 0;
			var _prevMode = null;
			var prevTop = null;
			var _prevScrollDiv = null;
			var _prevData = null;
			if(data.containmentBoundaries){
				data.containmentBoundaries.top = data.containmentBoundaries.top ? data.containmentBoundaries.top : 0;
				data.containmentBoundaries.bottom = data.containmentBoundaries.bottom ? data.containmentBoundaries.bottom : 0;
				data.containmentBoundaries.left = data.containmentBoundaries.left ? data.containmentBoundaries.left : 0;
				data.containmentBoundaries.right = data.containmentBoundaries.right ? data.containmentBoundaries.right : 0;
			}
			if(data.scrollBoundaries){
				data.scrollBoundaries.top = data.scrollBoundaries.top ? data.scrollBoundaries.top : 0;
				data.scrollBoundaries.bottom = data.scrollBoundaries.bottom ? data.scrollBoundaries.bottom : 0;
				data.scrollBoundaries.left = data.scrollBoundaries.left ? data.scrollBoundaries.left : 0;
				data.scrollBoundaries.right = data.scrollBoundaries.right ? data.scrollBoundaries.right : 0;
			}
			var getSortableElem =  function(target){
				while(target){
					if($L(target).hasClass("sortable-element")){
						_sortableElem = target;
						break;
					}
					target = target.parentElement;
				}
				if(!target){
					_sortableElem = null;
					manageSortable.draggedEle = null;
				}
				return _sortableElem;
			}
			
			var createHelper = function(data){
				var helper = data.helper(_sortableElem);
				if(helper){
					helper._isHelper = true;
					helper.classList.add('sortable-helper');
					helper._sortableChildData = Object.assign({},_sortableElem._sortableChildData);
					helper.classList.add(_sortableElem.parentElement._sortableParentData.sortableElemClass);
					helper._origin = _sortableElem;
					manageSortable.draggedEle = helper;
					if(data.appendTo == "parent"){
						window._lyteUiUtils.appendChild(_sortableElem.parentElement, helper);
					}
					else{
						window._lyteUiUtils.appendChild($L(data.appendTo)[0], helper);
					}
					data = helper._sortableChildData;
					helper.style.visibility = "hidden";
				}
				return data;
			}
			var bindMouseEvents = function( event, data, divOffset ){
				if(event.type == "mousedown"){
					_offset = [
						data.cursorAt && data.cursorAt.left || event.clientX - divOffset.left,
						data.cursorAt && data.cursorAt.top || event.clientY - divOffset.top
					];
					document.addEventListener('mousemove',mouseMoveEvent);
					document.addEventListener('mouseup',mouseUpEvent);
					manageSortable.mousedownTriggered = true;
					if(getOS() === "Windows"){	//Added check to restrict initial triggering of mousemove in windows as soon as the event is added
						manageSortable.mouseMoveTriggered = true;
					}
				}
				else if(event.type == "touchstart"){
					_offset = [
						data.cursorAt && data.cursorAt.left || event.touches[0].clientX - divOffset.left,
						data.cursorAt && data.cursorAt.top || event.touches[0].clientY - divOffset.top
					];

					//Binding eventlistener for touch
					document.addEventListener('touchmove',data._parentElem.__mouseMoveEvent, {capture : true, passive : false});
					document.addEventListener('touchend',data._parentElem.__mouseUpEvent, true);
				}
			}
			var isSortable = function( _sortableElem, target ){
				return _sortableElem && checkForSortable(_sortableElem._sortableChildData || _sortableElem.parentElement._sortableParentData, target) && checkForItems(_sortableElem._sortableChildData || _sortableElem.parentElement._sortableParentData, target);
			}
			function findNextSortElem(sortableElems,data,count,event){
				var currentEle = sortableElems[data.focusIndex];
				var prevfocusIndex = data.focusIndex;
				data.focusIndex += count;
				var SortableElem = sortableElems[data.focusIndex];
				while(SortableElem && !isNotRestricted(data,SortableElem) && data.focusIndex >= 0){
					SortableElem = sortableElems[data.focusIndex + count];
					data.focusIndex += count;
				}
				if(SortableElem && SortableElem !== currentEle ){
					if(count > 0){
						window._lyteUiUtils.insertAfter(SortableElem,currentEle);
					}else{
						window._lyteUiUtils.insertBefore(SortableElem,currentEle);
					}
					data._div = currentEle;
					data._fromIndex = prevfocusIndex;
					data._toIndex = data.focusIndex;
					if(data.onDrop){
						onDrop(data,event)
					}
					data._div = null;
					data._fromIndex = null;
					data._toIndex = null;
					currentEle.focus();
				}else{
					data.focusIndex = prevfocusIndex;
				}
			}
			function findNextFocusElem(sortableElems,data,count){
				sortableElems[data.focusIndex].tabIndex = -1;
				data.focusIndex += count;
				if(data.focusIndex < 0 ){
					data.focusIndex = sortableElems.length - 1;
				}
				if(data.focusIndex >= sortableElems.length ){
					data.focusIndex = 0;
				}
				sortableElems[data.focusIndex].tabIndex = 0;
				sortableElems[data.focusIndex].focus();
			}
			function keyDownEvent( event ){
				var sortableClass = data.sortableElemClass;
				var targetElem = event.target;
				var sortableElems = data._parentElem.children;
				var isMetaPressed = getOS() == 'Mac OS' ? event.metaKey : event.ctrlKey;
				if(event.keyCode == 13 && targetElem.classList.contains('sortable-parent')){
					sortableElems[0].focus();
					data.focusIndex = 0;
					sortableElems[0].tabIndex = 0;
				}

				if(event.keyCode == 27){
					var closest_sortableElem = targetElem.closest('.'+sortableClass);
					var restrict = data.restrict;
					
					if(!closest_sortableElem && restrict.length){
						for(var index = 0; index < restrict.length; index++){
							closest_sortableElem = targetElem.closest(restrict[index]);
							if(closest_sortableElem){
								break;
							}
						}
					}
					if(closest_sortableElem){
						var prevIndex = sortableElems[data.focusIndex];
						if(prevIndex){
							sortableElems[0].tabIndex = -1;
						}
						var foucs_Index = Array.from(sortableElems).findIndex(function(elem){
							return elem == closest_sortableElem;
						});
						data.focusIndex = foucs_Index;
						closest_sortableElem.focus();
					}
				}
				var isNotRestrictElem = isNotRestricted(data,targetElem);
				if( (targetElem.classList.contains(sortableClass) || !isNotRestrictElem) ){
					if( (event.keyCode == 40 || event.keyCode == 39) ){
						if( isMetaPressed && isNotRestrictElem){
							findNextSortElem(sortableElems,data,1,event);
						}else{
							findNextFocusElem(sortableElems,data,1,event);
						}
						event.preventDefault();
					}else if( (event.keyCode == 38 ||  event.keyCode == 37)  ){
						if( isMetaPressed  && isNotRestrictElem){
							findNextSortElem(sortableElems,data,-1,event);					
						}else{	
							findNextFocusElem(sortableElems,data,-1,event);
						}
						event.preventDefault();
					}
					
				}
				
			}
		function mouseDownEvent( event ){
				//Disable right click on the sortable elements to avoid unwanted behaviour
				if(event.which == 3){
					return;
				}
				_initClientX = event.clientX
				_initClientY = event.clientY

				if(manageSortable.mousedownTriggered){
					manageSortable.mousedownTriggered = false;
					return;
				}
				var target = event.target;
				_sortableElem = getSortableElem(target);
				if( isSortable( _sortableElem, target ) ){
					manageSortable.draggedEle = _sortableElem;
					var data = _sortableElem._sortableChildData || _sortableElem.parentElement._sortableParentData;
					if(data.preventDefault.mousedown == undefined || data.preventDefault.mousedown){
						event.preventDefault();
					}
					if(_sortableElem.parentElement && !_sortableElem.classList.contains(_sortableElem.parentElement._sortableParentData.sortableElemClass)){
						_sortableElem.classList.add(_sortableElem.parentElement._sortableParentData.sortableElemClass)
					}
					if(typeof data.helper == "function"){
						data = createHelper(data);
					}
					_placeholder = getClone(manageSortable.draggedEle, data.clone);
					data._div = _div = manageSortable.draggedEle;
					var returnVal = true;
					data._source = getSource(data);
					data._fromIndex = getFromIndex(data);
					//Callback fired
					if(data.onSelect){
						returnVal = onSelect(data,event);
						data._oldInlineCss = _div.style.cssText;

					}
					if(returnVal){
						if(data.selectedClass){
							_sortableElem.classList.add(data.selectedClass);
						}
						
						_div.classList.add("sortable-element-selected");
						var sortableElemCS = window.getComputedStyle(_div/*_sortableElem*/);
						var divOffset = isHelper(_div) ? _div._origin.getBoundingClientRect() : _div.getBoundingClientRect();
						if(data.scrollDivX && window.getComputedStyle(data.scrollDivX).position == "relative"){
							data._isRelative = true;
						}
						else{
							data._isRelative = false;
						}

						if(sortableElemCS.marginTop){
							_marginTop = sortableElemCS.marginTop;
						}
						if(sortableElemCS.marginLeft){
							_marginLeft = sortableElemCS.marginLeft;
						}
						//Binding mousedown and mouseup event
						bindMouseEvents(event,data,divOffset);

						//Binding the values to the draggable element
						data._isDown = true;
						data._placeholder = _placeholder;
						data._offset = _offset;
						data._marginTop = _marginTop;
						data._marginLeft = _marginLeft;
						data._event = event;
						data._placedPlaceholder = false;

						if(!manageSortable.draggedEle._sortableChildData){
							manageSortable.draggedEle._sortableChildData = data;
						}
						_placeholder = null;
						_div = null;
						_sortableElem = null;
					}
					else{
						if(!data.cancelRemove){
							if(data.helper){
								manageSortable.draggedEle.remove();
							}
							manageSortable.draggedEle = null;
							_sortableElem = null;
						}
					}
				}
				else{
					_sortableElem = null;
				}
			}
			var isRelative = function( scrollDiv, _div ){
				return scrollDiv && (window.getComputedStyle(scrollDiv).position == "relative" || window.getComputedStyle(scrollDiv).position == "fixed" || window.getComputedStyle(scrollDiv).position == "absolute") && (!isHelper(_div) || (isHelper(_div) && scrollDiv.contains(_div)));
			}
			var createPlaceholder = function(  _placeholder, _div, width, height, data ){
				$L(_placeholder).attr('id','dummy');
				_placeholder.style.width = width + "px";
				_placeholder.style.height = height + "px";
				_div.classList.add('lyteSortableElem');
				_placeholder.style.padding = "0px";
				_placeholder.classList.add(data.placeholder);
				_lyteUiUtils.insertBefore(isHelper(_div) ? _div._origin : _div ,_placeholder);
				_placeholder._origin = isHelper(_div) ? _div._origin.parentElement : _div.parentElement;
			}
			var isElementTopinBetween = function( topVal, parentOffset, data, divOffset, _scrollTop ){
				return topVal + parentOffset.top >= (data.containmentDimensions.top + _scrollTop) && topVal+parentOffset.top <= (data.containmentDimensions.top + (data.containmentDimensions.height - divOffset.height) + _scrollTop);
			}
			var verticalContainment =  function( topVal, parentOffset, data, divOffset, _scrollTop, _div, limit ){
				if( isElementTopinBetween( topVal, parentOffset, data, divOffset, _scrollTop ) ){
					_div.style.top = topVal + 'px';
				}else{
					var offset = { "top" : topVal + parentOffset.top  , "bottom" : topVal + parentOffset.top };
					
					if( !checkElemContainment(limit, offset, 'top', data.containment ) ){
						_div.style.top = (limit.top - parentOffset.top - _scrollTop) + 'px';
					}
					else if( !checkElemContainment(limit,offset,'bottom',data.containment) ){
						_div.style.top = (limit.bottom - parentOffset.top ) + 'px';
					}
				}
			}
			var horizontalContainment = function( leftVal, parentOffset, data, divOffset, scrollLeftValue, _div, limit ){
				if( ( leftVal + parentOffset.left ) >= data.containmentDimensions.left && ( leftVal + parentOffset.left ) <= (data.containmentDimensions.left + (data.containmentDimensions.width - divOffset.width) + scrollLeftValue)){
					_div.style.left = leftVal + 'px';
				}
				else{

					if( ( leftVal + parentOffset.left ) < limit.left) {
						_div.style.left = (limit.left - parentOffset.left) + 'px';
					}
					else if( ( leftVal + parentOffset.left ) > limit.right) {
						_div.style.left = (limit.right - parentOffset.left) + 'px';
					}
				}
			}
			var mouseMoveEvent = function(event){

				if(getOS() === "Windows" && manageSortable.mouseMoveTriggered){	
					//Added check to restrict initial triggering of mousemove in windows as soon as the event is added
					manageSortable.mouseMoveTriggered = false;
					return;
				}

				if(event.type == "touchmove"){
					event.preventDefault();
				}
				if(_animationFrameFired1 && _requestId1){
					cancelAnimationFrame(_requestId1);
					_animationFrameFired1 = false;
					_requestId1 = null;
				}
				if(_animationFrameFired2 && _requestId2){
					cancelAnimationFrame(_requestId2);
					_animationFrameFired2 = false;
					_requestId2 = null;
				}

				if(manageSortable.draggedEle && manageSortable.draggedEle.classList.contains("sortable-element-selected") && manageSortable.draggedEle._sortableChildData._isDown){
					_sortableElem = manageSortable.draggedEle;
				}
				else{
					_sortableElem = null;
					return;
				}
				if(_sortableElem){
					var data = _sortableElem._sortableChildData;
					
					if(((Math.abs(_initClientX - event.clientX)) <= data.threshold) && ((Math.abs(_initClientY - event.clientY)) <= data.threshold)){
						return
					}

					if(data && data._isDown){
						if(data.preventDefault.mousemove == undefined || data.preventDefault.mousemove){
							event.preventDefault();
						}
						if(data.selectedClass){
							$L('.'+data.selectedClass,data._parentElem).removeClass(data.selectedClass)
						}
						if(typeof document.body.style.MozUserSelect!="undefined"){
							document.body.style.MozUserSelect = "none";
						}
						_div = data._div;
						_placeholder = data._placeholder;
						_offset = data._offset;
						_marginTop = data._marginTop;
						_marginLeft = data._marginLeft;
						_sortableElemClass = data.sortableElemClass;
						var divOffset = _sortableElem.getBoundingClientRect();
						var scrollLeftValue = 0;
						//Find scroll div
						var scrollDiv;
						
						if(data.scrollDivY){
							scrollDiv = data.scrollDivY;
						}
						else if(!data.preventScrollY){
							scrollDiv = data.orientation != "horizontal" && findScrollDiv(data._placedPlaceholder ? _placeholder : _div);
						}
						if(scrollDiv && (!_prevScrollDiv || (_prevScrollDiv && _prevScrollDiv != scrollDiv))){
							_maxScrollHeight = scrollDiv.scrollHeight - scrollDiv.offsetHeight;
							_prevScrollDiv = scrollDiv;
						}

						//Find scrollDiv is relative or contains any relative parent and store scrollTop
						var isRelativeY = false;
						if(isRelative( scrollDiv,_div)){
							isRelativeY = true;
							_scrollTop = scrollDiv.scrollTop;
						}
						else{
							_scrollTop = 0;
						}

						if(!data._placedPlaceholder){
							if(data.scrollDivX){
								_maxScrollWidth = data.scrollDivX.scrollWidth - data.scrollDivX.clientWidth;
							}
							else{
								_maxScrollWidth = 0;
							}
							data._maxScrollWidth = _maxScrollWidth;
							//onDragStart
							if(data.onDragStart){
								onDragStart(data, event);
							}
							divOffset = isHelper(_sortableElem) ? _sortableElem._origin.getBoundingClientRect() : _sortableElem.getBoundingClientRect();

							//set containment properties
							if(data.containment) {
								data.containmentDimensions = setContainment(data,_sortableElem,data.containmentBoundaries);
							}else {
								data.containmentDimensions = null;
							}

							var width = divOffset.width;
							var height = divOffset.height;
							var cellSpacing = 0;
							var parent = _sortableElem.offsetParent;

							if(data._isRelative && data.scrollDivX.contains(_div)){
								scrollLeftValue = data.scrollDivX.scrollLeft;
							}
							if(!window._lyteUiUtils.isNegativeScroll() && window._lyteUiUtils.getRTL() && detectBrowser() == "chrome" && data._isRelative && data.scrollDivX.contains(_div)){
								scrollLeftValue = data.scrollDivX.scrollLeft - data._maxScrollWidth;
							}
							if(parent.tagName.toLowerCase() == "table"){
								cellSpacing = parent.cellSpacing;
								if(cellSpacing == ""){
									cellSpacing = 2;
								}
							}

							while((parent.tagName.toLowerCase() == "table" || parent.tagName.toLowerCase() == "lyte-table-structure") && parent.style.position == ""){
								parent = parent.offsetParent;
							}
							var relativeParent = getRelativeParent(_div);

							if(relativeParent && parent != relativeParent){
								parent = relativeParent;
							}
							if(!height){
								height = _sortableElem.getBoundingClientRect().height;
							}
							var parentOffset = parent.getBoundingClientRect();

							if(!data.cancelRemove){
								_div.style.top = divOffset.top - (parentOffset.top + parseInt(cellSpacing) + parseInt(_marginTop)) + _scrollTop + 'px';
							}
							_div.style.left = divOffset.left - (parentOffset.left + parseInt(_marginLeft)) + scrollLeftValue + 'px';
							_div.style.boxSizing = "border-box";
							_div.style.zIndex = 3001;
							_div.style.width = width + "px";
							_div.style.height = height + "px";
							if(isHelper(_div)){
								_div.style.visibility = "";
							}

							if(_sortableElem.tagName.toLowerCase() == "tr" || _sortableElem.tagName.toLowerCase() == "lyte-tr"){
								fixWidth(_sortableElem);
							}
							
							//Create placeholder and append it to the DOM
							createPlaceholder( _placeholder, _div, width, height, data );
							callPlaceholder(data, _div.parentElement);

							//Insert the placeholder in the DOM and make the selected element's position absolute
							//Insert the placeholder in the DOM and make the selected element's position absolute
							window._lyteUiUtils.insertBefore(isHelper(_div) ? _div._origin : _div ,_placeholder);
							//Insert the placeholder in the DOM and make the selected element's position absolute                             
							window._lyteUiUtils.insertBefore(isHelper(_div) ? _div._origin : _div ,_placeholder);
							_div.style.position = "absolute";
							_div.classList.add('lyteSortableDisablePE');
							data._placedPlaceholder = true;
							data._div = _div;
							data._placeholder = _placeholder;
							data._prevTop = event.clientY ;
							data._prevLeft = event.clientX ;
							if(data.onDrag){
								onDrag(data,event);
							}
							manageSortable.isOver(event,data);
							data._isMoved = true;
							return;
						}
						var measure1 = $L.fastdom.measure(function(){
							manageSortable.measureQueue.shift();
							if(!_sortableElem){
								return;
							}
							if(data.containment){
								data.containmentDimensions = setContainment(data,_sortableElem,data.containmentBoundaries);
							}

							if(event.type == "mousemove"){
								_mousePosition = {
									x : event.clientX,
									y : event.clientY
								};
							}
							else if(event.type == "touchmove"){
								_mousePosition = {
									x : event.touches[0].clientX,
									y : event.touches[0].clientY
								};
							}

							var parent = _div.offsetParent;
							var relativeParent = getRelativeParent(_div);
							if(relativeParent && parent != relativeParent){
								parent = relativeParent;
							}

							var parentOffset = parent.getBoundingClientRect();
							var leftVal;
							var topVal;
							if(data._isRelative && data.scrollDivX.contains(_div)){
								scrollLeftValue = data.scrollDivX.scrollLeft;
							}
							if(!window._lyteUiUtils.isNegativeScroll() && window._lyteUiUtils.getRTL() && detectBrowser() == "chrome" && data._isRelative && data.scrollDivX.contains(_div)){
								scrollLeftValue = data.scrollDivX.scrollLeft - data._maxScrollWidth;
							}
							divOffset = _div.getBoundingClientRect();
							var scrollDivOffset = scrollDiv ? scrollDiv.getBoundingClientRect() : 0,
							droppableOffset,droppablePlace;

							//Animation Frame fired for vertical scrolling
							if(scrollDiv && (divOffset.left <= scrollDivOffset.right) && (divOffset.right >= scrollDivOffset.left)){
								_requestId1 = requestAnimationFrame(callForScrollY.bind(this,data,scrollDiv,scrollDivOffset,_maxScrollHeight,null,isRelativeY,_mousePosition,_offset,parentOffset));
								_animationFrameFired1 = true;
							}

							//Animation Frame fired for horizontal scrolling
							if(data.scrollDivX){
								scrollDivOffset = data.scrollDivX.getBoundingClientRect();
								if(divOffset.left <= scrollDivOffset.left || divOffset.right >= (scrollDivOffset.right - 3)){
									_requestId2 = requestAnimationFrame(callForScrollX.bind(this,data,scrollDivOffset,_mousePosition,_offset,parentOffset,data._isRelative));
									_animationFrameFired2 = true;
								}
							}

							var mutate1 = $L.fastdom.mutate(function(){
								manageSortable.mutateQueue.shift();
								if(!_sortableElem){
									return;
								}
								leftVal = _mousePosition.x - _offset[0] - parentOffset.left - parseInt(_marginLeft) + scrollLeftValue;
								topVal = _mousePosition.y - _offset[1] - parentOffset.top - parseInt(_marginTop) + _scrollTop;
								if(data.containment){
									var limit = {
											top : data.containmentDimensions.top + _scrollTop,
											bottom : (data.containmentDimensions.top + (data.containmentDimensions.height - divOffset.height) + _scrollTop),
											left : data.containmentDimensions.left,
											right : (data.containmentDimensions.left + (data.containmentDimensions.width - divOffset.width) + scrollLeftValue)
										};
									if(data.orientation == "vertical"){
										verticalContainment(topVal, parentOffset, data, divOffset, _scrollTop, _div, limit);
									}
									else{
										if (data.transitionEnabled) {
											_div.style.transition = 'left 0.1s ease';
											data._oldLeft = _div.getBoundingClientRect().left;
										}
										horizontalContainment(leftVal, parentOffset, data, divOffset, scrollLeftValue, _div, limit)
										verticalContainment(topVal, parentOffset, data, divOffset, _scrollTop, _div, limit);
									}
								}
								else{
									if(data.orientation == "vertical"){
										_div.style.top = topVal + 'px';
									}
									else if (data.orientation == 'horizontal') {
										if (data.transitionEnabled) {
											_div.style.transition = 'left 0.1s ease';
											data._oldLeft = _div.getBoundingClientRect().left;
										}
										_div.style.left = leftVal + 'px';
									}
									else {
										_div.style.left = leftVal + 'px';
										_div.style.top = topVal + 'px';
									}
								}

								divOffset = { left : parentOffset.left + (leftVal - scrollLeftValue), top : parentOffset.top + (topVal - _scrollTop), right : parentOffset.left + (leftVal - scrollLeftValue) + divOffset.width, bottom : parentOffset.top + (topVal - _scrollTop) + divOffset.height }; /*_div.getBoundingClientRect();*/

								if(data.onMultiSelectDrag){
									onMultiSelectDrag(data, event)
								}

								//Find the below element over which the sortable element is being dragged
								var measure2 = $L.fastdom.measure(function(){
									manageSortable.measureQueue.shift();
									if(!_sortableElem){
										return;
									}
									_elemBelow = document.elementFromPoint(_mousePosition.x,_mousePosition.y);
									if(data.multiSortable) {
										if(_elemBelow) {
											var sortableClasses = data.allSortableClass;
											for(var key in sortableClasses) {
												droppablePlace = $L(_elemBelow).closest('.'+key,sortableClasses[key])[0];
												if(droppablePlace) {
													break;
												}
											}
											if(!droppablePlace && $L(_elemBelow).hasClass('sortable-parent')){
												droppablePlace = _elemBelow;
											}
										}
										else {
											droppablePlace = null;
										}
									}
									else {
										droppablePlace = _elemBelow ? _elemBelow.closest('.'+_sortableElemClass) : null;
										if(_elemBelow && $L(_elemBelow).hasClass('sortable-parent')){
											droppablePlace = _elemBelow;
										}
										if(  droppablePlace && $L(droppablePlace).hasClass('sortable-parent') ){
											if(!droppablePlace._sortableParentData.droppable){
												droppablePlace = false;
											}												
										}else{
											if ( droppablePlace && droppablePlace.parentElement._sortableParentData && !droppablePlace.parentElement._sortableParentData.droppable){
												droppablePlace = false;
											}
										}
									}
									droppableOffset = droppablePlace ? droppablePlace.getBoundingClientRect() : {};
									if(!_elemBelow){
										return;
									}
									var mutate2 = $L.fastdom.mutate(function(){
										manageSortable.mutateQueue.shift();
										if(!_sortableElem){
											return;
										}
										if(droppablePlace && $L(droppablePlace).hasClass('sortable-parent') && droppablePlace.querySelectorAll('.'+_sortableElemClass).length === 0 && data.droppable && data.connectedWith.indexOf(droppablePlace) !== -1){
											window._lyteUiUtils.appendChild(droppablePlace,_placeholder);
											callPlaceholder(data, _elemBelow, droppablePlace);
										}
										var clientX = event.clientX !== undefined ? event.clientX :  event.touches[0].clientX;
										var clientY = event.clientY  !== undefined ? event.clientY : event.touches[0].clientY;
										if(droppablePlace && checkDroppable(droppablePlace,_sortableElem.parentElement,_sortableElem,data.connectedWith,data.containmentDimensions,_mousePosition)){

											if($L(_elemBelow).hasClass('sortable-parent') && checkParentDroppable(_elemBelow,_sortableElem.parentElement,_sortableElem,data.connectedWith,data.containmentDimensions,_mousePosition) && checkForIntersect(_elemBelow,_mousePosition) && checkForBetween(_elemBelow,_mousePosition,_sortableElem/*,isRelativeY,scrollDiv*/)){
												window._lyteUiUtils.appendChild(_elemBelow,_placeholder);
												callPlaceholder(data, _elemBelow, droppablePlace);
											}
											else {
												if (data.tolerance == "pointer") {
													if (data.orientation === "horizontal") {
														if (clientX < data._prevLeft) {
															var oldPosition = droppableOffset.x;
															window._lyteUiUtils.insertBefore(droppablePlace, _placeholder);

															if (data.transitionEnabled) {
																var droppablePlaceFinalRect = droppablePlace.getBoundingClientRect();
																var deltaX = droppablePlaceFinalRect.x - oldPosition;
																data._deltaX = deltaX;

																if (deltaX !== 0) {
																	if (data._timeoutId) {
																		clearTimeout(data._timeoutId);
																		data._droppablePlace.style.transition = 'none';
																		data._droppablePlace.style.transform = 'translateX(0px)';
																		data._droppablePlace.offsetHeight;
																	}

																	data._droppablePlace = droppablePlace;
																	data._placeholder = _placeholder;

																	droppablePlace.style.transform = `translateX(-${data._deltaX}px)`;
																	droppablePlace.offsetHeight;
																	droppablePlace.style.transition = 'transform ease';
																	droppablePlace.style.transitionDuration = data.transitionDuration + 'ms';
																	droppablePlace.style.transform = `translateX(0px)`;
																	data._timeoutId = setTimeout(() => {
																		droppablePlace.style.transition = '';
																		droppablePlace = null;
																	}, data.transitionDuration);
																}
															}
															callPlaceholder(data, _elemBelow, droppablePlace);
														}
														else if (clientX > data._prevLeft) {
															var oldPosition = droppableOffset.x;
															window._lyteUiUtils.insertAfter(droppablePlace, _placeholder);
															if (data.transitionEnabled) {
																var droppablePlaceFinalRect = droppablePlace.getBoundingClientRect();
																var deltaX = droppablePlaceFinalRect.x - oldPosition;
																data._deltaX = deltaX;
																if (deltaX !== 0) {
																	if (data._deltaX < 0) {
																		data._deltaX = -1 * data._deltaX;
																	}
																	if (data._timeoutId) {
																		clearTimeout(data._timeoutId);
																		data._droppablePlace.style.transition = 'none';
																		data._droppablePlace.style.transform = 'translateX(0px)';
																		data._droppablePlace.offsetHeight;
																	}

																	data._droppablePlace = droppablePlace;
																	data._placeholder = _placeholder;

																	droppablePlace.style.transform = `translateX(${data._deltaX}px)`;
																	droppablePlace.offsetHeight;
																	droppablePlace.style.transition = 'transform ease';
																	droppablePlace.style.transform = `translateX(0px)`;
																	droppablePlace.style.transitionDuration = data.transitionDuration + 'ms';
																	data._timeoutId = setTimeout(() => {
																		droppablePlace.style.transition = '';
																		droppablePlace = null;
																	}, data.transitionDuration);

																}
															}
															callPlaceholder(data, _elemBelow, droppablePlace);
														}
														data._prevLeft = clientX;
													}
													else{
														if(((data.gridView && (clientX < data._prevLeft)) || (clientY < data._prevTop)) && (droppablePlace.previousElementSibling != _placeholder )){	
															// console.log("calling for droppable ele insertBefore => ",droppablePlace.textContent);
															window._lyteUiUtils.insertBefore(droppablePlace,_placeholder);
															callPlaceholder(data, _elemBelow, droppablePlace);
														}
														else if(((data.gridView && (clientX > data._prevLeft)) || (clientY > data._prevTop)) && (droppablePlace.nextElementSibling != _placeholder )){
															// console.log("calling for droppable ele insertAfter => ",droppablePlace.textContent);
															window._lyteUiUtils.insertAfter(droppablePlace,_placeholder);															
															callPlaceholder(data, _elemBelow, droppablePlace);
														}
														data._prevTop = event.clientY;
													}
												}

												if (data.tolerance == "intersect") {
													data._newLeft = _div.getBoundingClientRect().left;
													if (data.orientation === "horizontal") {
														if (divOffset.left < (droppableOffset.left)) {
															if (data.transitionEnabled) {
																if ((data._newLeft - data._oldLeft) < 0) {
																	var currentPosition = droppableOffset.x;
																	window._lyteUiUtils.insertBefore(droppablePlace, _placeholder);
																	var newPosition = droppablePlace.getBoundingClientRect().x;
																	// Calculate the difference in positions
																	var deltaX = newPosition - currentPosition;
																	data._deltaX = deltaX;

																	if (deltaX !== 0) {
																		if (deltaX !== 0) {
																			if (data._timeoutId) {
																				clearTimeout(data._timeoutId);
																				data._droppablePlace.style.transition = 'none';
																				data._droppablePlace.style.transform = 'translateX(0px)';
																				data._droppablePlace.offsetHeight;
																			}

																			data._droppablePlace = droppablePlace;
																			data._placeholder = _placeholder;

																			droppablePlace.style.transform = `translateX(-${data._deltaX}px)`;
																			droppablePlace.offsetHeight;
																			droppablePlace.style.transition = 'transform ease';
																			droppablePlace.style.transitionDuration = data.transitionDuration + 'ms';
																			droppablePlace.style.transform = `translateX(0px)`;
																			data._timeoutId = setTimeout(() => {
																				droppablePlace.style.transition = '';
																				droppablePlace = null;
																			}, data.transitionDuration);
																		}
																	}
																}
																else {
																	window._lyteUiUtils.insertBefore(droppablePlace, _placeholder);
																}
															} else {
																window._lyteUiUtils.insertBefore(droppablePlace, _placeholder);
															}
															callPlaceholder(data, _elemBelow, droppablePlace);
														}
														else if (divOffset.right > (droppableOffset.right)) {
															if (data.transitionEnabled) {
																if ((data._newLeft - data._oldLeft) > 0) {
																	var currentPosition = droppableOffset.x;
																	window._lyteUiUtils.insertAfter(droppablePlace, _placeholder);
																	var newPosition = droppablePlace.getBoundingClientRect().x;

																	// Calculate the difference in positions
																	var deltaX = newPosition - currentPosition;
																	data._deltaX = deltaX;
																	if (deltaX !== 0) {
																		if (data._deltaX < 0) {
																			data._deltaX = -1 * data._deltaX;
																		}
																		if (data._timeoutId) {
																			clearTimeout(data._timeoutId);
																			data._droppablePlace.style.transition = 'none';
																			data._droppablePlace.style.transform = 'translateX(0px)';
																			data._droppablePlace.offsetHeight;
																		}

																		data._droppablePlace = droppablePlace;
																		data._placeholder = _placeholder;

																		droppablePlace.style.transform = `translateX(${data._deltaX}px)`;
																		droppablePlace.offsetHeight;
																		droppablePlace.style.transition = 'transform ease';
																		debugger
																		droppablePlace.style.transitionDuration = data.transitionDuration + 'ms';
																		droppablePlace.style.transform = `translateX(0px)`;
																		data._timeoutId = setTimeout(() => {
																			droppablePlace.style.transition = '';
																			droppablePlace = null;
																		}, data.transitionDuration);
																	}
																}
																else {
																	window._lyteUiUtils.insertAfter(droppablePlace, _placeholder);
																}
															}
															else {
																window._lyteUiUtils.insertAfter(droppablePlace, _placeholder);
															}
															callPlaceholder(data, _elemBelow, droppablePlace);
														}
													}
													else{
														if(((data.gridView && (divOffset.left < droppableOffset.left)) || (divOffset.top < droppableOffset.top)) && ( droppablePlace.previousElementSibling != _placeholder /*(_placeholder.nextElementSibling && _placeholder.nextElementSibling != droppablePlace) || (_placeholder.parentElement != droppablePlace.parentElement)*/)){
															// console.log("calling for droppable ele insertBefore => ",droppablePlace.textContent);
															window._lyteUiUtils.insertBefore(droppablePlace,_placeholder);
															callPlaceholder(data, _elemBelow, droppablePlace);
														}
														else if(((data.gridView && (divOffset.right > droppableOffset.right)) || (divOffset.bottom > droppableOffset.bottom)) && ( droppablePlace.nextElementSibling != _placeholder /*(_placeholder.previousElementSibling && _placeholder.previousElementSibling != droppablePlace) || (_placeholder.parentElement != droppablePlace.parentElement)*/)){
															// console.log("calling for droppable ele insertAfter => ",droppablePlace.textContent);
															window._lyteUiUtils.insertAfter(droppablePlace,_placeholder);
															callPlaceholder(data, _elemBelow, droppablePlace);
														}
													}
												}
											}
										}else{
											if(_elemBelow && !$L(_elemBelow).hasClass('sortable-parent') && !isNotRestricted(data,_elemBelow)){
												_elemBelow = _elemBelow.closest('.sortable-parent');
											}
											if(_elemBelow && ($L(_elemBelow).hasClass('sortable-parent')) && checkForIntersect(_elemBelow,_mousePosition) && checkParentDroppable(_elemBelow,_sortableElem.parentElement,_sortableElem,data.connectedWith,data.containmentDimensions,_mousePosition) && (!data.preventDropAtStart && !firstChildNotRestricted(data, _elemBelow) && iselemCanDropOnTop(data,_elemBelow,_sortableElem))){												
												window._lyteUiUtils.insertBefore(getChildren(data, _elemBelow)[0], _placeholder);
												callPlaceholder(data, _elemBelow, droppablePlace);
											}
											else if(_elemBelow && $L(_elemBelow).hasClass('sortable-parent') && checkParentDroppable(_elemBelow,_sortableElem.parentElement,_sortableElem,data.connectedWith,data.containmentDimensions,_mousePosition) && checkForIntersect(_elemBelow,_mousePosition) && checkForBetween(_elemBelow,_mousePosition,_sortableElem,isRelativeY,scrollDiv) && (!data.preventDropAtEnd || lastChildNotRestricted(data, _elemBelow))){
												window._lyteUiUtils.appendChild(_elemBelow,_placeholder);
												callPlaceholder(data, _elemBelow, droppablePlace);
											}
										} 
										data._belowElem = _elemBelow != null ? _elemBelow : data._belowElem;
										if(data.onDrag){
											onDrag(data,event);
										}
										manageSortable.isOver(event,data);
										data._isMoved = true;
										if(!data.transitionEnabled){
											droppablePlace = null;
										}
										_elemBelow = null;
									});
									manageSortable.mutateQueue.push(mutate2);
								});
								manageSortable.measureQueue.push(measure2);
							});
							manageSortable.mutateQueue.push(mutate1);
						});
						manageSortable.measureQueue.push(measure1);
					}
				}
			}
			
			var iselemCanDropOnTop =  function(data,_elemBelow,_sortableElem){
				var firstChild = getChildren(data, _elemBelow)[0];
				if(data.orientation == 'horizontal'){
					return ( firstChild && firstChild.getBoundingClientRect().left >= _sortableElem.getBoundingClientRect().left);
				}else if(data.orientation == 'vertical'){
					return ( firstChild && firstChild.getBoundingClientRect().top >= _sortableElem.getBoundingClientRect().top);
				}else{
					return firstChild && firstChild.getBoundingClientRect().top >= _sortableElem.getBoundingClientRect().top && firstChild.getBoundingClientRect().left >= _sortableElem.getBoundingClientRect().left;
				}
			}
			var mouseUpEvent = function(event){
				var target = event.target;
				if(_animationFrameFired1 && _requestId1){
					cancelAnimationFrame(_requestId1);
					_animationFrameFired1 = false;
					_requestId1 = null;
				}
				if(_animationFrameFired2 && _requestId2){
					cancelAnimationFrame(_requestId2);
					_animationFrameFired2 = false;
					_requestId2 = null;
				}
				if(manageSortable.measureQueue.length){
					while(manageSortable.measureQueue.length){
						$L.fastdom.clear(manageSortable.measureQueue.shift());
					}
				}
				if(manageSortable.mutateQueue.length){
					while(manageSortable.mutateQueue.length){
						$L.fastdom.clear(manageSortable.mutateQueue.shift());
					}
				}
				//UnBinding mousedown and mouseup event
				if(event.type == "mouseup"){
					document.removeEventListener('mousemove',mouseMoveEvent);
					document.removeEventListener('mouseup',mouseUpEvent);
				}
				if(event.type == "touchend"){
					document.removeEventListener('touchmove',mouseMoveEvent, {capture : true, passive : false});
					document.removeEventListener('touchend',mouseUpEvent, true);
				}

				if(manageSortable.prevSortable){
					manageSortable.prevSortable = false;
				}
				if(manageSortable.draggedEle && $L(manageSortable.draggedEle).hasClass("sortable-element-selected") && manageSortable.draggedEle._sortableChildData._isDown){
					_sortableElem = manageSortable.draggedEle;
					_sortableElem.classList.remove('lyteSortableDisablePE');
				}
				else{
					abnormalMC(event);
					_sortableElem = null;
					manageSortable.draggedEle = null;
					manageSortable.mousedownTriggered = false;
					return;
				}
				
				if(_sortableElem){
					var data = _sortableElem._sortableChildData;
					var prevParent = _sortableElem.parentElement;
					
					if(data._isDown){

						data._isDown = false;
						_div = data._div;
						_placeholder = document.querySelectorAll('#dummy').length == 1 ? document.querySelectorAll('#dummy')[0] : data._placeholder;
						var _placeholderParent = _placeholder.parentElement;

						if(data._isMoved){
							data._isMoved = false;
							data._toIndex = checkDroppedItemPosition(data, _placeholder  ,Array.from(_placeholderParent.children).filter(function(ele){ return ele.tagName != "TEMPLATE" && !($L(ele).hasClass('sortable-element-selected')) }));
							var returnVal = true;

							//Callback fired
							if(data.onBeforeDrop){
								returnVal = onBeforeDrop(data,event,_placeholder,_placeholderParent);
							}

							if($L(_placeholder).hasClass(data.disabled)){
								callRevertBack(data);
								manageSortable.draggedEle = null;
								manageSortable.mousedownTriggered = false;
								return;
							}

							if(!returnVal){
								callRevertBack(data);
								if(isHelper(_div)){
									_div.remove();
								}
								if(_div.preventScrollX){
									delete _div.preventScrollX;
								}
								manageSortable.draggedEle = null;
								manageSortable.mousedownTriggered = false;
								return;
							}

							var sibling = (findPreviousElem(_placeholder) ? findPreviousElem(_placeholder) : findNextElem(_placeholder));
							var elementData = sibling && sibling._sortableChildData ? Object.assign({}, sibling._sortableChildData) : Object.assign({}, _placeholder.parentElement._sortableParentData);
							if((data._fromIndex == data._toIndex) && (data._parentElem == _placeholderParent)){
								_placeholder.remove();
							}
							else{
								window._lyteUiUtils.replaceWith(_placeholder, _div);
							}
							
							removeStyle(_div);

							_placeholder = null;

							_div._sortableChildData = elementData;

							//Callback fired
							if(data.onDrop){
								onDrop(data,event);

							}
							if(isHelper(_div)){
								delete _div._origin;
							}
						}
						else{
							removeStyle(_div);
							if(isHelper(_div)){
								delete _div._origin;
								_div.remove();
							}
							if(_sortableElem.tagName.toLowerCase() == 'a'){
								window.location.href = _sortableElem.href;
							}
						}
						if(data._oldInlineCss){
							_div.style.cssText = data._oldInlineCss;
							data._oldInlineCss = null;
						}
						if(data.onAfterDrop){
							onAfterDrop(data,event);
						}
						data._div = null;
						data._placeholder = null;
						data._placedPlaceholder = false;
						data._returnElemBelow = null;
						data._belowElem = null;
						data._source = null;
						data._fromIndex = null;
					}
					if(data.selectedClass){
						$L('.'+data.selectedClass,data._parentElem).removeClass(data.selectedClass)
					}
					
					$L(_sortableElem).removeClass('sortable-element-selected');
					_offset = null;
					_isDown = null;
					_isMoved = null;
					_mousePosition = null;
					_elemBelow = null;
					_droppablePlace = null;
					_marginTop = null;
					_marginLeft = null;
					_sortableElemClass = null;
					_sortableElem = null;
					_placeholder = null;
					_div = null;
					_prevScrollDiv = null;
				}

				abnormalMC(event);

				manageSortable.draggedEle = null;
				manageSortable.mousedownTriggered = false;
			}

			var abnormalMC = function(event){
				//Check for abnormal mouse clicks
				var dummies = event.target.ownerDocument.querySelectorAll('.lyteSortablePlaceholder');
				for(var i = 0; i < dummies.length; i++){
					if(dummies[i]._callee){
						var elem = dummies[i]._callee;
						window._lyteUiUtils.replaceWith(dummies[i], elem);
						$L(elem).removeClass('sortable-element-selected');
						removeStyle(elem);
						if(isHelper(elem)){
							elem.remove();
						}
					}
					else{
						dummies[i].remove();
					}
				}
				var elements = event.target.ownerDocument.querySelectorAll('.sortable-element-selected');
				for(var i =0; i<elements.length; i++){
					$L(elements[i]).removeClass('sortable-element-selected');
					removeStyle(elements[i]);
					if(isHelper(elements[i])){
						elements[i].remove();
					}
				}
			};
			element.changeScrollBoundaries = function(scrollBoundaries){
				if(scrollBoundaries){
					scrollBoundaries.top = scrollBoundaries.top !== undefined ? scrollBoundaries.top : element._sortableParentData.scrollBoundaries.top;
					scrollBoundaries.bottom = scrollBoundaries.bottom  !== undefined? scrollBoundaries.bottom : element._sortableParentData.scrollBoundaries.bottom;
					scrollBoundaries.left = scrollBoundaries.left !== undefined ? scrollBoundaries.left : element._sortableParentData.scrollBoundaries.left;
					scrollBoundaries.right = scrollBoundaries.right !== undefined ? scrollBoundaries.right : element._sortableParentData.scrollBoundaries.right;
				}
				var drag_element = element.querySelector('.sortable-element-selected');
				if(drag_element){
					drag_element._sortableChildData.scrollBoundaries = scrollBoundaries; 
				}
				element._sortableParentData.scrollBoundaries = scrollBoundaries;
			}

			element.addToSortable = function(elem){
				elem._sortableChildData = element._sortableParentData;
				$L(elem).addClass("sortable-element "+element._sortableParentData.sortableElemClass);
			};

			element.getSortableClass = function(){
				return element._sortableParentData.sortableElemClass;
			};


			element.removeFromSortable = function(elem){
				delete elem._sortableChildData;
				$L(elem).removeClass("sortable-element "+element._sortableParentData.sortableElemClass);
			};
			element.addToConnectedWith = function(elem,elem_data){

				var connectedWith = element._sortableParentData.connectedWith ? element._sortableParentData.connectedWith : [];
				if(elem.length !== undefined){
					for(var elem_index = 0; elem_index < elem.length && connectedWith.indexOf(elem[elem_index]) === -1; elem_index++){
						connectedWith.push(elem[elem_index]);
					}
				}else{
					connectedWith.push(elem);
				}
				var index = connectedWith.indexOf(element);
				connectedWith.splice(index,1);
				connectedWith.push(element);
				element._sortableParentData.connectedWith = connectedWith;
				var drag_element = element.querySelector('.sortable-element-selected');
				var diff = 0;
				if( drag_element ){
					var scrollDivX = element._sortableParentData.scrollDivX;
					var child =  scrollDivX.children;
					diff=  drag_element.getBoundingClientRect().right - child[child.length - 1].getBoundingClientRect().right;
					diff = diff > 0 ? diff : 0;
					if(element._sortableParentData && scrollDivX){
						_maxScrollWidth = scrollDivX.scrollWidth - scrollDivX.clientWidth;
					}else{
						_maxScrollWidth = 0;
					}
					drag_element._sortableChildData.connectedWith = connectedWith;
					drag_element._sortableChildData._maxScrollWidth = _maxScrollWidth - diff;
					drag_element.parentElement._sortableParentData._maxScrollWidth = _maxScrollWidth - diff;
					element._sortableParentData._maxScrollWidth = _maxScrollWidth - diff;
				}

				var not_sortable = $L(elem).not('.sortable-parent');

				if(not_sortable.length){
					elem_data = elem_data ? elem_data : {};
					if(elem_data.isSameClass){
						elem_data.connectedWith = connectedWith;
						elem_data.connected = true;
					}
					elem_data.restrict = elem_data.restrict ? elem_data.restrict : data.restrict;
					elem_data.sortableElemClass = data.sortableElemClass;
					elem_data._parentElem = $L(elem)[0];

					$L(not_sortable).sortable(Object.assign({},elem_data));
				}
			};
			element.addScrollDivXY = function(scrollDivX,scrollDivY){
				var scrollDivX = scrollDivX ? (typeof scrollDivX == "string" ? document.querySelector(scrollDivX) : scrollDivX) : undefined;
				var scrollDivY = scrollDivY ? (typeof scrollDivY == "string" ? document.querySelector(scrollDivY) : scrollDivY) : undefined;
				if( scrollDivY && scrollDivY !== data.scrollDivY){
					data.scrollDivY = scrollDivY;
					element._sortableParentData.scrollDivY = data.scrollDivY;
				}
				if(scrollDivX && scrollDivX !== data.scrollDivX){
					data.scrollDivX = scrollDivX; 
					element._sortableParentData.scrollDivX = data.scrollDivX;
				}	
			}

			var callPlaceholder = function(data, _elemBelow, droppablePlace){
				if(!data.onPlaceholder || checkValidDroppable(data,_elemBelow || droppablePlace.parentElement)){
					if(_placeholder.classList.contains(data.disabled)){
						_placeholder.classList.remove(data.disabled);
					}
					_placeholder.classList.add(data.placeholder);
				}
				else{
					if(_placeholder.classList.contains(data.placeholder)){
						_placeholder.classList.remove(data.placeholder);
					}
					_placeholder.classList.add(data.disabled);
				}


				//Callback fired
				data._returnElemBelow = droppablePlace || _elemBelow;
			};

			var callForScrollX = function(data,parentOffset,_mousePosition,_offset,parent,isRelative){
				if(!data._div ){
					return;
				}
				// console.log("Scroll X getting called");

				var divOffset = data._div.getBoundingClientRect();


				_scrollLeft = data.scrollDivX.scrollLeft ;
				_maxScrollWidth = data._maxScrollWidth;
				if( !window._lyteUiUtils.getRTL() || (!window._lyteUiUtils.isNegativeScroll() && window._lyteUiUtils.getRTL() && detectBrowser() == "chrome" && !isRelative)){

					if((divOffset.right >= parentOffset.right + data.scrollBoundaries.right) && (_scrollLeft < _maxScrollWidth)){

						if((_maxScrollWidth - _scrollLeft ) >= 5 ){
								data.scrollDivX.scrollLeft += 5;

							if(isRelative && data.scrollDivX.contains(data._div) ){
								data._div.style.left = _mousePosition.x - _offset[0] - parent.left + 5 + _scrollLeft + "px";
							}

						}
						else{

							data.scrollDivX.scrollLeft += ( (_maxScrollWidth - _scrollLeft) % 5);
							if(isRelative && data.scrollDivX.contains(data._div) ){
								data._div.style.left = _mousePosition.x - _offset[0] - parent.left + ( (_maxScrollWidth - _scrollLeft) % 5) + _scrollLeft + "px";
							}
						}
					}
					else if((divOffset.left <= parentOffset.left - data.scrollBoundaries.left) && (_scrollLeft > 0)){
						if(isRelative && data.scrollDivX.contains(data._div) ){
							data._div.style.left = _mousePosition.x - _offset[0] - parent.left - ((_maxScrollWidth - _scrollLeft) > 5 ? 5 : (5 - (_maxScrollWidth - _scrollLeft))) + _scrollLeft + "px";
						}
						data.scrollDivX.scrollLeft -= 5;
					}
					else{
						cancelAnimationFrame(_requestId2);
						_animationFrameFired2 = false;
						_requestId2 = null;
						return;
					}
				}
				else{
					if(!_lyteUiUtils.isNegativeScroll() && detectBrowser() == "chrome" && isRelative){
						if((divOffset.right >= parentOffset.right + data.scrollBoundaries.right) && (_scrollLeft < _maxScrollWidth)){
							if((_maxScrollWidth - _scrollLeft) >= 5){
								data.scrollDivX.scrollLeft += 5;
								if(isRelative && data.scrollDivX.contains(data._div)){
									data._div.style.left = _mousePosition.x - _offset[0] - parent.left + 5 + (_scrollLeft - _maxScrollWidth) + "px";
								}
							}
							else{
								data.scrollDivX.scrollLeft += (5 - (_maxScrollWidth - _scrollLeft));
								if(isRelative && data.scrollDivX.contains(data._div)){
									data._div.style.left = _mousePosition.x - _offset[0] - parent.left + (5 - (_maxScrollWidth - _scrollLeft)) + _scrollLeft + "px";
								}
							}
						}
						else if((divOffset.left <= parentOffset.left - data.scrollBoundaries.left) && (_scrollLeft > 0)){
							if(isRelative && data.scrollDivX.contains(data._div)){
								data._div.style.left = _mousePosition.x - _offset[0] - parent.left - ((_maxScrollWidth - _scrollLeft) + 5) + "px";
							}
							data.scrollDivX.scrollLeft -= 5;
						}
						else{
							cancelAnimationFrame(_requestId2);
							_animationFrameFired2 = false;
							_requestId2 = null;
							return;
						}
					}
					else if((window._lyteUiUtils.isNegativeScroll() && detectBrowser() == "chrome") || detectBrowser() == "firefox" || detectBrowser() == "safari"){

						if((divOffset.right >= parentOffset.right + data.scrollBoundaries.right) && (_scrollLeft < 0)){
							if((_maxScrollWidth + _scrollLeft) >= 5){
								data.scrollDivX.scrollLeft += 5;
								if(isRelative && data.scrollDivX.contains(data._div)){
									data._div.style.left = _mousePosition.x - _offset[0] - parent.left + 5 + _scrollLeft + "px";
								}
							}
							else{
								data.scrollDivX.scrollLeft += (5 - (_maxScrollWidth + _scrollLeft));
								if(isRelative && data.scrollDivX.contains(data._div)){
									data._div.style.left = _mousePosition.x - _offset[0] - parent.left + (5 - (_maxScrollWidth + _scrollLeft)) + _scrollLeft + "px";
								}
							}
						}
						else if((divOffset.left <= parentOffset.left - data.scrollBoundaries.left) && (_scrollLeft > -(_maxScrollWidth))){
							if(isRelative && data.scrollDivX.contains(data._div)){
								data._div.style.left = _mousePosition.x - _offset[0] - parent.left + (_scrollLeft - 5) + "px";
							}
							data.scrollDivX.scrollLeft -= 5;
						}
						else{
							cancelAnimationFrame(_requestId2);
							_animationFrameFired2 = false;
							_requestId2 = null;
							return;
						}
					}
					else if(detectBrowser() == "ie" || detectBrowser() == "edge"){
						if((divOffset.right >= parentOffset.right) && (_scrollLeft > 0)){
							if(_scrollLeft >= 5){
								data.scrollDivX.scrollLeft -= 5;
							}
							else{
								data.scrollDivX.scrollLeft -= _scrollLeft;
							}
						}
						else if((divOffset.left <= parentOffset.left - data.scrollBoundaries.left) && (_scrollLeft < _maxScrollWidth)){
							if(isRelative && data.scrollDivX.contains(data._div)){
								data._div.style.left = _mousePosition.x - _offset[0] - parent.left + (-_scrollLeft) - 5 + "px";
							}
							data.scrollDivX.scrollLeft += 5;
						}
						else{
							cancelAnimationFrame(_requestId2);
							_animationFrameFired2 = false;
							_requestId2 = null;
							return;
						}
					}

				}

				_requestId2 = requestAnimationFrame(callForScrollX.bind(this,data,parentOffset,_mousePosition,_offset,parent,isRelative));
			};

			var callForScrollY = function(data,scrollDiv,parentOffset,_maxScrollHeight,topNBottom,isRelativeY,_mousePosition,_offset,parent){
				var _this = this;

				$L.fastdom.measure(function(){
					if(!data._div){
						return;
					}
					
					if(data.containment){
						data.containmentDimensions = setContainment(data,data._div,data.containmentBoundaries);
					}else{
						data.containmentDimensions = null;
					}
					// var scrollTop = scrollDiv.scrollTop;
					var isWindow = scrollDiv  === document.documentElement ? true : false;
					var scrollDivTop = (isWindow ? 0 : scrollDiv.getBoundingClientRect().top) - data.scrollBoundaries.top;
					var height = scrollDiv  !== document.documentElement ? scrollDiv.offsetHeight : scrollDiv.clientHeight;
					if( height <=  $L(data._div)[0].parentElement.offsetHeight && !isWindow){
						var lastchild = $L(data._div)[0].parentElement.querySelectorAll("."+data.sortableElemClass);
						lastchild = lastchild[lastchild.length - 1];
						var nolastchild = false;
					}else{
						var nolastchild = true;

					}
					_maxScrollHeight = scrollDiv.scrollHeight - height;
					$L.fastdom.mutate(function(){
						var divOffset = data._div.getBoundingClientRect();
						var scrollTop = scrollDiv.scrollTop;
						if(!data._div){
							return;
						}
						if( isElementReachedTop( data,divOffset,scrollDivTop) && (scrollTop > 0 ) && ( checkElemContainment(data.containmentDimensions,divOffset,'top')  || !isSortableInViewPort(data,scrollDiv,isWindow,height,'top') ) ){
							if(isRelativeY && scrollDiv.contains(data._div)){
								if(checkElemContainment(data.containmentDimensions,divOffset,'top',data.containment)){
									data._div.style.top = _mousePosition.y - _offset[1] - parent.top - (_maxScrollHeight - scrollTop >= 10 ? 10 : _maxScrollHeight - scrollTop) + scrollTop + "px";
								}else{
									data._div.style.top = data.containmentDimensions.top - parent.top - (_maxScrollHeight - scrollTop >= 10 ? 10 : _maxScrollHeight - scrollTop) + scrollTop + 'px';
								}
							}else if(scrollDiv === document.documentElement && checkElemContainment(data.containmentDimensions,divOffset,'top',data.containment) ){
								data._div.style.top = data._div.offsetTop - (_maxScrollHeight - scrollTop >= 10 ? 10 : _maxScrollHeight - scrollTop) + 'px';
							}
							scrollDiv.scrollTop -= 10;
						}
						else if( isElementReachedBottom( data, divOffset, scrollDivTop, height ) && (scrollTop < _maxScrollHeight) &&  ( checkElemContainment(data.containmentDimensions,divOffset,'bottom',data.containment) || !isSortableInViewPort(data,scrollDiv,isWindow,height,'bottom') )  && ( nolastchild || isReachedLastELem( data, height, lastchild, scrollDivTop ) )){
							if(_maxScrollHeight - scrollTop > 10){
								if(isRelativeY && scrollDiv.contains(data._div)){
									if(checkElemContainment(data.containmentDimensions,divOffset,'bottom',data.containment)){
										data._div.style.top =  data._div.offsetTop  + 10 + "px";
									}else{
										data._div.style.top =  data.containmentDimensions.bottom - data._div.offsetHeight - parent.top + (_maxScrollHeight - scrollTop >= 10 ? 10 : _maxScrollHeight ) + scrollTop +'px';
									}
								}else if(scrollDiv === document.documentElement &&  checkElemContainment(data.containmentDimensions,divOffset,'bottom',data.containment) ){
									data._div.style.top = data._div.offsetTop  + 10 + 'px';
								}
								scrollDiv.scrollTop += 10;
							}
							else{
								if(isRelativeY && scrollDiv.contains(data._div)){
									data._div.style.top = _mousePosition.y - _offset[1] - parent.top + _maxScrollHeight - scrollTop + scrollTop + "px";
								}else if(scrollDiv === document.documentElement){
									data._div.style.top = data._div.offsetTop  + _maxScrollHeight - scrollTop + 'px';
								}
								scrollDiv.scrollTop += (_maxScrollHeight - scrollTop);
							}
						}
						else{
							
							if(isWindow){
								if(( !isFirstOrLastELement(data, "first")) && ((data.containmentDimensions  && (data.containmentDimensions.top >= divOffset.top)) || (divOffset.top - parseInt(data._marginTop) <= scrollDivTop) &&  (scrollTop == 0) )){
									appendPlaceholderAt(data, "first");

								}else if(!isFirstOrLastELement(data, "last") && ((data.containmentDimensions  && (data.containmentDimensions.bottom <= divOffset.bottom)) || (scrollTop == _maxScrollHeight) && (divOffset.bottom >= (scrollDivTop + data.scrollBoundaries.top + height + data.scrollBoundaries.bottom - 3))) ){
									appendPlaceholderAt(data, "last");
								}
							}else{
								if((scrollTop == 0) && (divOffset.top - parseInt(data._marginTop) <= scrollDivTop ) && !isFirstOrLastELement(data, "first")){
									appendPlaceholderAt(data, "first");
								}
								else if((scrollTop >= _maxScrollHeight) && (divOffset.bottom >= (scrollDivTop + data.scrollBoundaries.top + height + data.scrollBoundaries.bottom - 3)) && !isFirstOrLastELement(data, "last")){
									appendPlaceholderAt(data, "last");

								}
							}

							// if(data.scrollEnd){
							// 	data.scrollEnd();
							// }
							cancelAnimationFrame(_requestId1);
							_animationFrameFired1 = false;
							_requestId1 = null;
							return;
						}
						
						_requestId1 = requestAnimationFrame(callForScrollY.bind(this,data,scrollDiv,parentOffset,_maxScrollHeight,topNBottom,isRelativeY,_mousePosition,_offset,parent));
					});
				});
				
			};
			var isReachedLastELem = function(data,height,lastchild,scrollDivTop){
				return lastchild.getBoundingClientRect().bottom > (scrollDivTop  + data.scrollBoundaries.top + data.scrollBoundaries.bottom + height)
			}
			var isElementReachedBottom = function(data,divOffset,scrollDivTop,height,side){
				return (divOffset.bottom >= (scrollDivTop + height + data.scrollBoundaries.top + data.scrollBoundaries.bottom - 3));
			}
			var isSortableInViewPort = function(data,scrollDiv,isWindow,height,side){
				if(data.containment){
					var top = (isWindow ? 0 : scrollDiv.getBoundingClientRect().top) - data.scrollBoundaries.top;
					var parentOffset = data._div.parentElement.getBoundingClientRect();
					if(side == 'top'){
						return parentOffset.top > top;
					}else{
						return parentOffset.bottom < (top + height + data.scrollBoundaries.top - data.scrollBoundaries.bottom);
					}
				}
			}
			var checkElemContainment = function( limit, divOffset, side, containment ){

				if(containment){
					if(side == 'top' ){
						return (limit.top < divOffset.top);	
					}else if (side == 'bottom'){
						return (limit.bottom > divOffset.bottom);
					}
				   
				}
				return true;
			}
			var isElementReachedTop = function(data,divOffset,scrollDivTop){
				return divOffset.top - parseInt(data._marginTop) <= scrollDivTop;
			}
			var isFirstOrLastELement = function(data, pos){
				var placeholder = data._placeholder,
					parent = placeholder.parentElement,
					children = getChildren(data,parent);
				if(pos === "first"){
					return children[0] == placeholder;
				}
				return children[children.length - 1] == placeholder;	//incase of last
			};

			var getChildren = function(data, parent){
				if(data && data.omitRestricted){
					return Array.from(parent.children).filter( function(ele) { return (ele.tagName != "TEMPLATE" && isNotRestricted(data,ele))} );
				}
				return Array.from(parent.children).filter( function(ele) { return ele.tagName != "TEMPLATE" } );
			};

			var appendPlaceholderAt = function(data, pos){
				var placeholder = data._placeholder,
					parent = placeholder._origin,
					children = getChildren(data,parent);
				if(data.gridView){
					return;
				}
				if(pos === "first"){
					for(var i = 0; i < children.length; i++){
						if(!data.preventDropAtStart || (isNotRestricted(data, children[i]) && !(children[i].classList.contains('sort-disabled-element')))){
							window._lyteUiUtils.insertBefore(children[i], placeholder);
							break;
						}
					}
				}
				else{
					for(var i = children.length - 1; i >= 0; i--){
						if(!data.preventDropAtEnd || (isNotRestricted(data, children[i]) && !(children[i].classList.contains('sort-disabled-element')))){
							window._lyteUiUtils.insertAfter(children[i], placeholder);
							break;
						}
					}
				}
			};

			var isNotRestricted = function(data,targetElem){
				for(var i = 0; i<data.restrict.length ; i++){
					if(targetElem.matches(data.restrict[i])){
						return false;
					}
				}
				return true;
			};

			var lastChildNotRestricted = function(data, parent){
				var children = getChildren(null, parent);
				return children.length ? isNotRestricted(data, children[children.length - 1]) : true;
			};
			var firstChildNotRestricted = function(data, parent){
				var children = getChildren(null, parent);
				return children.length ? isNotRestricted(data, children[0]) : true;
			}
			var checkForSortable = function(data,targetElem){
				if(!data.draggable){
					return false;
				}
				for(var i = 0; i<data.cancel.length ; i++){
					var elem = targetElem;
					while(elem.parentElement){
						if(elem.matches(data.cancel[i])){
							return false;
						}
						if($L(elem).hasClass('sortable-element')){
							break;
						}
						elem = elem.parentElement;
					}
				}
				return true;
			};

			var checkDroppedItemPosition = function(data, ele,siblings){
				if(data.omitRestricted){
					for(var y = 0; y<siblings.length; y++){
                        if(!isNotRestricted(data,siblings[y])){
                            siblings.splice(y,1);
                            --y;
                        }
                    }
				}
				for(var i = 0; i<siblings.length; i++){
					if(siblings[i].tagName != "TEMPLATE" && ele == siblings[i]){
						return i;
					}
				}
			};

			var getFromIndex = function(data){
				var element = isHelper(data._div) ? data._div._origin : data._div;
				if(data.omitRestricted){
					var siblings = Array.from(data._source.children).filter( function(ele) { return ele.tagName != "TEMPLATE" } );
					for(var y = 0; y<siblings.length; y++){
                        if(!isNotRestricted(data,siblings[y])){
                            siblings.splice(y,1);
                            --y;
                        }
                    }
                    return siblings.indexOf(element);
				}
				else{
					return Array.from(data._source.children).filter( function(ele) { return ele.tagName != "TEMPLATE" } ).indexOf(element);
				}
			}

			var getSource = function(data){
				var current = isHelper(data._div) ? data._div._origin : data._div;
				var parentElem = data._parentElem;
				if(current.classList.contains('sortable-parent') && current.parentElement.classList.contains('sortable-parent')){
					parentElem = current.parentElement;
				}
				return parentElem;
			}

			/*---------------Callbacks Start--------------*/
			var onReady = function(data){
				data.onReady(data._parentElem);
			}

			var onSelect = function(data,event){
				data._div.preventScrollX = function(prevScroll){
					data._div._sortableChildData.preventScroll = prevScroll;
					data._parentElem._sortableParentData.preventScroll = prevScroll;
				}
				var returnVal = data.onSelect(data._div, data._fromIndex, data._source,event);
				if(returnVal == undefined || returnVal == true){
					return true;
				}else{
					delete data._div.preventScrollX;
					return false;
				}
				//return ( returnVal == undefined) ? true : returnVal;
			}

			var onDragStart = function(data, event){
				data.onDragStart(data._div,data._source, event,data._div._origin);
			}

			var onDrag = function(data,event){
				var placeholder = document.querySelectorAll('#dummy').length == 1 ? document.querySelectorAll('#dummy')[0] : data._placeholder;
				data.onDrag(data._div,data._returnElemBelow,event,placeholder,data._belowElem);
			}

			var onBeforeDrop = function(data,event,placeholder){
				// var placeholder = document.querySelectorAll('#dummy').length == 1 ? document.querySelectorAll('#dummy')[0] : data._placeholder;
				var returnVal = data.onBeforeDrop(data._div,data._returnElemBelow,placeholder,data._fromIndex, data._toIndex /*checkDroppedItemPosition(data, placeholder,Array.from(placeholder.parentElement.children).filter(function(ele){ return ele.tagName != "TEMPLATE" && !($L(ele).hasClass('sortable-element-selected')) }))*/, data._source, placeholder ? placeholder.parentElement : null,event);
				return (returnVal == undefined) ? true : returnVal;
			}

			var onDrop = function(data,event){
				data.onDrop(data._div, data._div._sortableChildData._parentElem, data._returnElemBelow, data._fromIndex, data._toIndex /*checkDroppedItemPosition(data, data._div,Array.from(data._div._sortableChildData._parentElem.children).filter(function(ele){ return ele.tagName != "TEMPLATE" }))*/, data._source, event);
			}
			var onAfterDrop = function(data,event){
				data.onDrop(data._div, event);
			}

			var onMultiSelectDrag = function(data, event){
				var placeholder = document.querySelectorAll('#dummy').length == 1 ? document.querySelectorAll('#dummy')[0] : data._placeholder;
				data.onMultiSelectDrag(data._div,event,placeholder,placeholder.parentElement);
			}
			/*---------------Callbacks End--------------*/

			var checkValidDroppable = function(data,destination){
				if(destination.id && destination.id == "dummy"){
					destination = destination.parentElement;
				}
				else{
					while(destination){
						if($L(destination).hasClass('sortable-parent')){
							break;
						}
						destination = destination.parentElement;
					}
				}
				var placeholder = document.querySelectorAll('#dummy').length == 1 ? document.querySelectorAll('#dummy')[0] : data._placeholder;
				var returnVal = data.onPlaceholder(data._div,placeholder, data._parentElem, placeholder ? placeholder.parentElement : null);
				return (returnVal == undefined) ? true : returnVal;
			}


			//Bind events to the child elements that will be sortable
			var childrens = /*data._parentElem.children*/ getChildren(data, data._parentElem);
			
			if(data.dblTouchEvent){
				var prevClick = 0;
				
				data._parentElem.__mouseDownEvent = function(event) {
					if(event.type == 'mousedown'){
							mouseDownEvent(event);
					}else{
						var date = new Date();
					  var time = date.getTime();
					  var touches = event.touches;
					  var curtouchY = event.touches[0].clientY;
					  const time_between_taps = 200; 

					  if(touches.length == 1){
					  		if(checkForSortable(data._parentElem._sortableParentData,event.target)){
								  $L(	event.target  ).one('touchend',function(event){
								  		event.preventDefault();	  		
							  	})
								}
						  if (time - prevClick < time_between_taps &&  touches.length == 1 ) {
						  	prevClick = 0;
						  	event.preventDefault();
						  	mouseDownEvent(event);
						  	
						  }
						}
					  prevClick = time;
					}
				}
			}else{
				data._parentElem.__mouseDownEvent = mouseDownEvent;
			}
			data._parentElem.__mouseMoveEvent = mouseMoveEvent;
			data._parentElem.__mouseUpEvent = mouseUpEvent;
			data._parentElem.__keydownEvent = keyDownEvent;
			data._parentElem._sortableParentData = data;
			for(var i = 0 ; i < childrens.length ; i++){
				childrens[i]._pos = i;
				if(data.aria){
					$L(childrens[i]).attr('tabIndex',-1);
				}
				if(/*childrens[i].tagName != "TEMPLATE" &&*/ isNotRestricted(data,childrens[i]) && !(childrens[i].classList.contains('sortable-element-selected'))){
					childrens[i]._sortableChildData = data;
					$L(childrens[i]).addClass("sortable-element "+data.sortableElemClass);
				}
			}
			if(data.draggable && !data._parentElem._mousedown){
				if(data.aria){
					data._parentElem.addEventListener("keydown",data._parentElem.__keydownEvent);
				}
				data._parentElem.addEventListener("mousedown",data._parentElem.__mouseDownEvent);
				data._parentElem.addEventListener("touchstart",data._parentElem.__mouseDownEvent, true);
				data._parentElem._mousedown = true;
			}
			

			//Check whether the arrays are connected or not and has connectedWith
			if(!data.connected && data.connectedWith.length > 0){

				data.connectedWith = manageSortable.convertToArrayOfItems(data.connectedWith,data.context);
				data.connectedWith.forEach(function(id){

					var connectedWith = data.connectedWith.concat(),
					index = connectedWith.indexOf(id);
					connectedWith.splice(index,1);
					connectedWith.push(id);
					// connectedWith.push(data._parentElem);

					if(data.multiSortable && _sortableData &&  _sortableData.connectedWith) {
						data.connectedWith = _sortableData.connectedWith;
					}
					else {
						$L(id).sortable({
							_parentElem : $L(id)[0],
							connectedWith : connectedWith,
							connected : true,
							// droppable : data.droppable,
							// draggable : data.draggable,
							// placeholder : data.placeholder,
							// disabled : data.disabled,
							// orientation : data.orientation,
							// cancel : data.cancel,
							// items : data.items,
							// cursorAt : data.cursorAt,
							restrict : data.restrict,
							// scrollDivX : data.scrollDivX,
							// omitRestricted : data.omitRestricted,
							sortableElemClass : data.sortableElemClass,
							dblTouchEvent : data.dblTouchEvent
							// clone : data.clone
						});
					}
				});
			}

			if(data.onReady && !data._parentElem.executedOnReady){
				onReady(data);
				data._parentElem.executedOnReady = true;
			}

			var setContainment = function(data,sortableElem,containerdimensions){
				
				if(data.containment == "parent"){
					var dimensions = isHelper(sortableElem) ? sortableElem._origin.parentElement.getBoundingClientRect() : sortableElem.parentElement.getBoundingClientRect();
					return ({left : dimensions.left - containerdimensions.left,
							right : dimensions.right + containerdimensions.right,
							top : dimensions.top - containerdimensions.top,
							bottom : dimensions.bottom + containerdimensions.bottom,
							height : dimensions.height  + containerdimensions.top + containerdimensions.bottom,
							width : dimensions.width + containerdimensions.left + containerdimensions.right,
							offsetLeft : isHelper(sortableElem) ? sortableElem._origin.parentElement.offsetLeft - containerdimensions.left : sortableElem.parentElement.offsetLeft - containerdimensions.left,
							offsetTop : isHelper(sortableElem) ? sortableElem._origin.parentElement.offsetTop - containerdimensions.top : sortableElem.parentElement.offsetTop - containerdimensions.top});
				}
				else{
					var containment = $L(data.containment).length == undefined ? null : $L(data.containment)[0];
					var dimensions = containment.getBoundingClientRect();
					return ({left : dimensions.left - containerdimensions.left,
							right : dimensions.right + containerdimensions.right,
							top : dimensions.top - containerdimensions.top,
							bottom : dimensions.bottom + containerdimensions.bottom,
							height : dimensions.height + containerdimensions.top + containerdimensions.bottom,
							width : dimensions.width + containerdimensions.left + containerdimensions.right ,
							offsetLeft : containment.offsetLeft - containerdimensions.left, 
							offsetTop : containment.offsetTop - containerdimensions.top});
				}
			};

			/*----------------------- UTILITY FUNCTIONS FOR SORTABLE ---------------------*/

			var findScrollDiv = function(elem){
				var parent = elem.parentElement;
				while(elem.parentElement){
					elem = elem.parentElement;
					if((parent.scrollHeight > elem.clientHeight) && ((window.getComputedStyle(elem).overflowY != "hidden" && window.getComputedStyle(elem).overflow != "visible") || elem.matches('.lyteScrollBar')) /*!(elem.style.overflow && elem.style.overflow == 'hidden')*/){
						return elem;
					}
				}
				return null;
			};

			var fixWidth = function(element){
				var childrens = element.children,
				width = []
				for(var i = 0; i<childrens.length; i++){
					if(childrens[i].tagName.toLowerCase() == "td" || childrens[i].tagName.toLowerCase() == "lyte-td"){
						childrens[i].__prevWidth = childrens[i].style.width;
						width[ i ] = childrens[i].__prevWidth || ( childrens[i].getBoundingClientRect().width + 'px' ) ;
					}
				}
				for(var i = 0; i<childrens.length; i++){
					if(childrens[i].tagName.toLowerCase() == "td" || childrens[i].tagName.toLowerCase() == "lyte-td"){
						childrens[i].style.width = width[ i ];
					}
				}
			};

			var removefixedWidth = function(element){
				var childrens = element.children;
				for(var i = 0; i<childrens.length; i++){
					if(childrens[i].tagName.toLowerCase() == "td" || childrens[i].tagName.toLowerCase() == "lyte-td"){
						childrens[i].style.width = childrens[i].__prevWidth;
					}
				}
			};

			var calculateHeight = function(element) {
				var cs = getComputedStyle(element);

				var paddingY = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);

				var borderY = parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth);

				// Element height minus padding and border
				var elementHeight = element.offsetHeight - paddingY - borderY;
				return elementHeight;
			};

			var calculateWidth = function(element) {
				var cs = getComputedStyle(element);

				var paddingX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);

				var borderX = parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth);

				// Element width minus padding and border
				var elementWidth = element.offsetWidth - paddingX - borderX;
				return elementWidth;
			};

			var getRelativeParent = function(element){

				while(element.parentElement){
					element = element.parentElement;
					var cs = getComputedStyle(element);
					if(cs.position == "relative" || cs.position == "absolute" ){
						return element;
					}
				}
				return null;
			};

			//Checks whether the element can be dropped or not
			var checkDroppable = function(element,parentElem,sortableElem,connectedWith,containmentDimensions,mP){
				if(element.id != "dummy"){
					// var sortableParentId = sortableElem.parentElement.id;
					// var droppableParentId = element.parentElement.id;
					if(containmentDimensions){
						if(mP.x < containmentDimensions.left || mP.x > containmentDimensions.right || mP.y < containmentDimensions.top || mP.y > containmentDimensions.bottom){
							return false;
						}
					}
					if(sortableElem.parentElement == element.parentElement || element.parentElement == sortableElem._sortableChildData._parentElem){
						return true;
					}
					if(((connectedWith).indexOf(element.parentElement) != -1) && element._sortableChildData.droppable){
						return true;
					}
				}
				return false;
			};

			//Checks whwther the element can be dropped or not
			var checkParentDroppable = function(element,parentElem,sortableElem,connectedWith,containmentDimensions,mP){
				// var sortableParentId = sortableElem.parentElement.id;
				if(containmentDimensions){
					if(mP.x < containmentDimensions.left || mP.x > containmentDimensions.right || mP.y < containmentDimensions.top || mP.y > containmentDimensions.bottom){
						return false;
					}
				}
				if(sortableElem.parentElement == element || element == parentElem){
					return true;
				}
				if(((connectedWith).indexOf(element) != -1) && checkDroppableValue(element)){
					return true;
				}
				return false;
			};

			var checkDroppableValue = function(element){
				var childrens = element.children;
				var childElem;
				for(var v= 0; v<childrens.length; v++){
					if(childrens[v] != element.querySelector("#dummy") && childrens[v].tagName != "TEMPLATE" && $L(childrens[v]).hasClass('sortable-element')){
						childElem = childrens[v];
						break;
					}
				}
				return (childElem && childElem._sortableChildData ? childElem._sortableChildData.droppable : element._sortableParentData.droppable);
			};

			//Checks for appending the sortable elements at the end of the div
			var checkPossiblePosition = function(element,sortableElem){
				if(element.childElementCount > 0){
					var lastChild = element.lastElementChild;
					if(sortableElem.getBoundingClientRect().top > lastChild.getBoundingClientRect().bottom){
						return true
					}
				}
				else{
					return true;
				}
				return false;
			};

			var checkIfDroppable = function(parentElem,ele){
				if(ele.parentElement === parentElem && parentElem.childElementCount === 1 && (((ele.getBoundingClientRect().right > (parentElem.getBoundingClientRect().left + ele.getBoundingClientRect().width / 2)) &&
					(ele.getBoundingClientRect().right <= parentElem.getBoundingClientRect().right)) || ((ele.getBoundingClientRect().left < (parentElem.getBoundingClientRect().right - ele.getBoundingClientRect().width / 2)) &&
					(ele.getBoundingClientRect().left >= parentElem.getBoundingClientRect().left)))){
					return true;
				}
				return false;
			};

			var checkForIntersect = function(parentElem,mP){
				var cs = window.getComputedStyle(parentElem);
				var offset = parentElem.getBoundingClientRect();
				
				if(mP.x > (offset.left + parseFloat(cs.paddingLeft || 0)) && mP.x < (offset.right - parseFloat(cs.paddingRight || 0)) && mP.y > (offset.top + parseFloat(cs.paddingTop || 0)) && mP.y < (offset.bottom - parseFloat(cs.paddingBottom || 0))){
					return true;
				}
				return false;
			};

			var checkForBetween = function(parentElem,mP,div,isRelativeY,scrollDiv){
				var childrens = parentElem.children;
				var templateTags = 0;
				var childElem = [];
				for(var i = 0;i<childrens.length;i++){
					if(childrens[i].tagName != "TEMPLATE" && childrens[i].id != "dummy" && isNotRestricted(parentElem._sortableParentData,childrens[i])){
						childElem.push(childrens[i]);
					}
					else{
						templateTags++;
					}
				}
				if(templateTags == childrens.length){
					return true;
				}
				else if((childElem.length == 1 && childElem[childElem.length - 1] == div) || (childElem.length > 1 && childElem[childElem.length - 1] == div && div.getBoundingClientRect().top > (childElem[childElem.length - 2].getBoundingClientRect().bottom + (isRelativeY ? scrollDiv.scrollTop : 0)))){
					return true;
				}
				else if(div.getBoundingClientRect().top > (childElem[childElem.length - 1].getBoundingClientRect().bottom + (isRelativeY ? scrollDiv.scrollTop : 0))){
					return true;
				}
				return false;
			};

			var callRevertBack = function(data) {
				$L(data._div).removeClass("sortable-element-selected");
				removeStyle(data._div);
				data._placeholder.remove();
			};

			var removeStyle = function (element) {
				if (data.transitionEnabled) {
					element.style.transition = '';
				}
				element.style.position = '';
				element.style.top = '';
				element.style.left = '';
				element.style.width = '';
				element.style.height = '';
				// element.style.display = '';
				element.style.zIndex = '';
				element.style.boxSizing = '';
				$L(element).removeClass('lyteSortableElem');
				$L(element).removeClass('lyteSortableDisablePE');
				if(isHelper(element)){
					$L(element).removeClass('sortable-helper');
				}
				if(element.tagName.toLowerCase() == "tr" || element.tagName.toLowerCase() == "lyte-tr"){
					removefixedWidth(element);
				}
			};

			var findPreviousElem = function(elem){
				while(elem.previousElementSibling){
					elem = elem.previousElementSibling;
					if(elem.tagName != "TEMPLATE" && $L(elem).hasClass('sortable-element')){
						return elem;
					}
				}
				return null;
			};

			var findNextElem = function(elem){
				while(elem.nextElementSibling){
					elem = elem.nextElementSibling;
					if(elem.tagName != "TEMPLATE" && $L(elem).hasClass('sortable-element')){
						return elem;
					}
				}
				return null;
			};

			var checkForItems = function(data,targetElem){
				if(data.items.length > 0){
					for(var i = 0 ; i<data.items.length ; i++){
						var elements = document.querySelectorAll(data.items[i]);
						for(var j = 0; j<elements.length; j++){
							if(elements[j] == targetElem){
								return true;
							}
						}
					}
				}
				else{
					return true;
				}
				return false;
			};

			var getClone = function(elem,deepCopy){
				var clone;
				if(deepCopy){
					clone = elem.cloneNode(deepCopy);
					var cloneChildren = clone.children;
					var elemChildren = elem.children;
					for(var i = 0; i<cloneChildren.length; i++){
						var childOffset = elemChildren[i].getBoundingClientRect();
						// cloneChildren[i].innerHTML = "";
						cloneChildren[i].style.width = childOffset.width + "px";
						cloneChildren[i].style.height = childOffset.height + "px";
						// cloneChildren[i].style.boxSizing = "border-box";
						cloneChildren[i].classList.add('lyteSortableDummyTr');
					}
				}
				else{
					clone = elem.cloneNode();
					clone.innerHTML = "";
					clone.style.boxSizing = "border-box";
				}
				clone._callee = elem;
				clone.classList.remove('sortable-element-selected','sortableElem');
				if(isHelper(elem)){
					clone.style.visibility = "";
				}
				return clone;
			};

			var isHelper = function(elem){
				return (elem.classList.contains('sortable-helper') || elem._isHelper);
			};

			return this;

		}

	}

});

( function( factory ) {
  if( typeof define === "function" && define.amd ) {
      define( [ "@zoho/lyte-dom" ], factory );
  }
  else {
      factory( $L );
  }
} )(function( $L ){
  if($L){
    $L.prototype.lazyRender = function(arg){
      var _this = this[0];
      if(arg.direction === 'scrollTop'){

        if(arg && !arg.onEnd){
          arg.onEnd = function(){}
        }
        if(arg && !arg.startLoader){
          arg.startLoader = function(){}
        }
        if(arg && !arg.endLoader){
          arg.endLoader = function(){}
        }
        if(!arg.dataToRender){
          arg.dataToRender = []
        }

        if(arg.dataToRender.length < 1){
          for (var i = 0,j=arg.entireData.length-(arg.renderConfig.initialRenderCount); i < arg.renderConfig.initialRenderCount; i++) {
            Lyte.arrayUtils( arg.dataToRender , 'push' , arg.entireData[j+i]);
            _this.scrollTop = _this.scrollHeight;
          }
        }


        function scrollEndFunction(){
          if(_this.scrollTop <= 50 ){
            var animationConfig = arg.renderConfig.pushCount
            var initialConfigVal = 0;
  
            function pushData(){

  
              var arr = arg.entireData.slice((arg.entireData.length - (arg.dataToRender.length + arg.renderConfig.renderCount)) , (arg.entireData.length - arg.dataToRender.length))
  
              if(arg.renderConfig.loader !== 'undefined' && arg.renderConfig.loader === false){
                Lyte.objectUtils( arg.renderConfig , "add" , "loader" , true )
              }
              arg.startLoader()
  

              Lyte.arrayUtils( arg.dataToRender , 'insertAt' , 0 , arr);
  
              if(arg.renderConfig.loader !== 'undefined' && arg.renderConfig.loader === true){
                Lyte.objectUtils( arg.renderConfig , "add" , "loader" , false )
              }
              arg.endLoader()
  
              initialConfigVal+=arg.renderConfig.renderCount

              if(_this.scrollTop  == 0){
                _this.scrollTop = 5
              }
  
              if(initialConfigVal >= animationConfig){
                  arr = []
                  window.cancelAnimationFrame(pushData)
                  return
              }
  
            }
  
  
            if(arg.entireData.length <= arg.dataToRender.length){
              var res = arg.onEnd();
              if(res){
                res.then(function(){
                  window.requestAnimationFrame(pushData)
                })
              }
              if(arg.entireData.length > arg.dataToRender.length){
                  window.requestAnimationFrame(pushData)
              }
            } else {
              window.requestAnimationFrame(pushData)
            }
  
          }
  
        }
        $L(this).bindScroll(scrollEndFunction)


      } else {

        if(arg && !arg.onEnd){
          arg.onEnd = function(){}
        }
        if(arg && !arg.startLoader){
          arg.startLoader = function(){}
        }
        if(arg && !arg.endLoader){
          arg.endLoader = function(){}
        }
        if(!arg.dataToRender){
          arg.dataToRender = []
        }

        if(arg.dataToRender.length < 1){
          // initialRenderCount
          for (var i = 0; i < arg.renderConfig.initialRenderCount; i++) {
            Lyte.arrayUtils( arg.dataToRender , 'push' , arg.entireData[i]);
          }
        }
  
        function scrollEndFunction(){
          if(_this.offsetHeight+_this.scrollTop >= _this.scrollHeight){
            var animationConfig = arg.renderConfig.pushCount
            var initialConfigVal = 0;
  
            function pushData(){
  
              var arr = arg.entireData.slice(arg.dataToRender.length , arg.dataToRender.length+arg.renderConfig.renderCount)
  
              if(arg.renderConfig.loader !== 'undefined' && arg.renderConfig.loader === false){
                Lyte.objectUtils( arg.renderConfig , "add" , "loader" , true )
              }
              arg.startLoader()
  
              Lyte.arrayUtils( arg.dataToRender , 'push' , arr);
  
              if(arg.renderConfig.loader !== 'undefined' && arg.renderConfig.loader === true){
                Lyte.objectUtils( arg.renderConfig , "add" , "loader" , false )
              }
              arg.endLoader()
  
              initialConfigVal+=arg.renderConfig.renderCount
  
              if(initialConfigVal >= animationConfig){
                  arr = []
                  window.cancelAnimationFrame(pushData)
                  return
              }
  
            }
  
  
            if(arg.entireData.length <= arg.dataToRender.length){
              var res = arg.onEnd();
              if(res){
                res.then(function(){
                  window.requestAnimationFrame(pushData)
                })
              }
              if(arg.entireData.length >= arg.dataToRender.length){
                  window.requestAnimationFrame(pushData)
              }
            } else {
              window.requestAnimationFrame(pushData)
            }
  
          }
  
        }
        $L(this).bindScroll(scrollEndFunction)
        // this[0].addEventListener('scroll' , scrollEndFunction)

      }
    }
  }
}());

;( function( cb ){
	if( typeof define == "function" && define.amd ){
		define( [ "@zoho/lyte-dom" ], cb );
	} else {
		cb( window.$L );
	}
} )( function( $L ){
	if( $L ){

		var isSticky = {}, span = document.createElement( 'span' );
		span.style.position = "sticky";
		if( span.style.position == "sticky" ){
			isSticky.sticky = true;
		} else {
			span.style.position = "-webkit-sticky";
			if( span.style.position == "-webkit-sticky" ){
				isSticky.webkitsticky = true;
			} else {
				isSticky.sticky = false;
			}
		}
		span = undefined;

		function getPos( pos ) {
			if( window._lyteUiUtils.getRTL() ) {
				if( pos == "left" ){
					return 'right';
				} else if( pos == "right" ) {
					return "left";
				}

			} 
			return pos;
		}

		function globalScroll( evt ){
			var target = evt.target,
			__sticky = target._sticky;

			if( __sticky ){

				if( __sticky.position == "topbottom" ){
					return update_positions( Array.from( target.parentNode.querySelectorAll( ".lyteSticky " + __sticky.query ) ), target );
				}

				if( isSticky.sticky == false ){
					findScroll.call( target, __sticky.highlight, true )
				} else if( __sticky.highlight ) {
					findScroll.call( target, true );
				}
			}
		}

		function update_positions( elems, __this ){
			var bcr_arr = elems.map( function( item ){
				var parent = item.parentNode;

				return {
					item : item,
					height : item.offsetHeight,
					bcr : parent.getBoundingClientRect(),
					parent : parent
				};
			}),
			this_bcr = __this.getBoundingClientRect(),
			is_relative = /relative|absolute|sticky/i.test( window.getComputedStyle( __this ).position ),
			__top = this_bcr.top,
			__bottom = this_bcr.bottom,
			this_height = this_bcr.height,
			__len = elems.length,
			top_stick = 0,
			bottom_stick = 0,
			default_top = is_relative ? __this.scrollTop : 0,
			default_bottom = is_relative ? -default_top : 0,
			top_hidden = [],
			bottom_hidden = [],
			className = "lyteStickyActive",
			sticky_obj = __this._sticky,
			__maxCount = sticky_obj.maxCount || Infinity,
			__maxHeight = sticky_obj.minHeight || 100,
			count = 0,
			__addFn = sticky_obj.onAdd,
			__removeFn = sticky_obj.onRemove;

			bcr_arr.forEach( function( __cur, index ){

				if( count++ > __maxCount ){
					return;
				}

				var __bcr = __cur.bcr,
				cur_top = __bcr.top,
				top_limit = __top + top_stick,
				obj = {
					position : "",
					top : "",
					bottom : ""
				},
				node = __cur.item,
				height = __cur.height,
				__class = "remove",
				is_active = node.classList.contains( className );

				if( top_limit > cur_top ){
					if( !( ( this_height - __maxHeight ) < top_stick ) ){
						obj.position = "absolute";
						obj.top = ( default_top + top_stick ) + "px";
						top_stick += height;
						__class = "add"
					}
				}
				$L( node ).css( obj )[ __class + 'Class' ]( className );

				if( __class == "add" && !is_active ){
					__addFn && __addFn.call( __this, node );
				} else if( __class == "remove" && is_active ){
					__removeFn && __removeFn.call( __this, node );
				}
			});

			bcr_arr.reverse().forEach( function( __cur, index ){

				if( count++ > __maxCount ){
					return;
				}

				var __bcr = __cur.bcr,
				cur_bottom = __bcr.top,
				obj = {
					position : "absolute",
					top : ""
				},
				bottom_limit = __bottom - bottom_stick,
				node = __cur.item,
				height = __cur.height,
				is_active = node.classList.contains( className );

				if( bottom_limit < cur_bottom + ( node.style.position ? 0 : height ) ){

					if( ( this_height - __maxHeight ) < top_stick + bottom_stick ){
						return;
					}

					obj.bottom = ( default_bottom + bottom_stick ) + "px";
					bottom_stick += height;

					$L( node ).css( obj ).addClass( className );

					if( !is_active ){
						__addFn && __addFn.call( __this, node );
					}
				}
			});
		}

		function makeSticky( arg ){
			var elms = this.parentElement.querySelectorAll( ".lyteSticky " + arg.query ),
			__len = elms.length,
			__pos = arg.position,
			__sticky = isSticky.sticky ? "sticky" : ( isSticky.webkitsticky ?  "-webkit-sticky" : '' ),
			stick_all = arg.position == "topbottom";

			if( stick_all ){
				update_positions( Array.from( elms ), this );
			} else {
				for( var i = 0; i < __len; i++ ){
					var __cur = elms[ i ],
					sty = __cur.style, 
					parstyle = __cur.parentElement.style;

					__cur._sticky = { val : sty[ __pos ], position : sty.position, parPos : parstyle.position };
					if( isSticky.sticky != false ) {
						sty.position = __sticky;
						sty[ __pos ] = arg.offset + 'px';
					} else {
						parstyle.position = sty.position = "relative";
					}
				}
			}
		}

		function unbind( arg ){
			var elms = this.parentElement.querySelectorAll( ".lyteSticky " + arg.query ),
			position = arg.position;

			for( var i = 0; i < elms.length; i++ ){
				var __cur = elms[ i ],
				obj = __cur._sticky, 
				style = __cur.style, 
				parstyle = __cur.parentElement.style;

				if( obj ){
					__cur.classList.remove( 'lyteStickyActive' );
					style.position = obj.position;
					parstyle.position = obj.parPos;
					style[ position ] = obj.val;
					delete __cur._sticky;
				}
			}
		}

		function findScroll( highlight, prevent ){
			if( !this.offsetParent ) {
				return
			}
			var arg = this._sticky, offs = [], slft, stp, elms = this.parentElement.querySelectorAll( ".lyteSticky " + arg.query ),
			stp = this == document.body ? window.pageYOffset : this.scrollTop, slft = this == document.body ? window.pageXOffset : this.scrollLeft,
			pos = arg.position, vert = [ 'bottom', 'top' ].indexOf( pos ) != -1, 
			bcr = this.getBoundingClientRect(), wid = vert ? "height" : "width", ofset = arg.offset;
			if( ( !vert && arg._prevx != slft ) || ( vert && arg._prevy != stp ) ) {
				for( var i = 0; i < elms.length; i++ ) {
					offs[ i ] = {};
					offs[ i ].node = elms[ i ]; elms[ i ].parent = elms[ i ].parentElement;
					offs[ i ].curBcr = elms[ i ].getBoundingClientRect();
					offs[ i ].parBcr = elms[ i ].parentElement.getBoundingClientRect();
				}
				for( var i = 0; i < elms.length; i++ ) {
					var cEl = offs[ i ], pBcr = cEl.parBcr, curBcr = cEl.curBcr, node = cEl.node.style,
					fact = 1, val = 0, flag = false;
					if( [ 'bottom', 'right' ].indexOf( pos ) != -1 ) {
						fact *= -1;
					}
					if( fact > 0 ) {
						if( parseInt( pBcr[ pos ] ) <= parseInt( bcr[ pos ] ) && ( parseInt( pBcr[ pos ] + pBcr[ wid ] ) >= parseInt( bcr[ pos ] + ofset ) ) ){
							var min = bcr[ pos ] - ( pBcr[ pos ] )
						 	val = min + ofset;
							flag = true;
						}
					} else {
						if( parseInt( pBcr[ pos ] ) >= parseInt( bcr[ pos ] ) && ( parseInt( pBcr[ pos ] - pBcr[ wid ] ) < parseInt( bcr[ pos ] - ofset ) ) ){
							var min = pBcr[ pos ] - bcr[ pos ];
							val = min + ofset;
							flag = true;
						}
					}
					if( flag ) {
						if( prevent ){
							node[ pos ] = val + 'px';
						}
						arg.onAdd && !cEl.node.classList.contains( 'lyteStickyActive' ) && arg.onAdd.call( this, cEl.node );
						highlight && cEl.node.classList.add( 'lyteStickyActive' );
						if( stp == 0 ){
							arg.onRemove && cEl.node.classList.contains( 'lyteStickyActive' ) && arg.onRemove.call( this, cEl.node );
							cEl.node.classList.remove( 'lyteStickyActive' );
						}
					} else {
						arg.onRemove && cEl.node.classList.contains( 'lyteStickyActive' ) && arg.onRemove.call( this, cEl.node );
						highlight && cEl.node.classList.remove( 'lyteStickyActive' );
					}
				}
			}
			arg._prevx = slft; arg._prevY = stp;
		}

		$L.prototype.destroySticky = function(){
			$L( '.lyteSticky' ).removeSticky();
			window.removeEventListener( 'scroll', globalScroll, true )
			return this;
		}

		$L.prototype.removeSticky = function(){
			for( var i = 0; i < this.length; i++ ){
				var obj = this[ i ]._sticky;
				if( obj ) {
					clearTimeout( obj._stickytime ); clearTimeout( obj._init );
					clearTimeout( obj._genscroll );
					unbind.call( this[ i ], obj ); 
					this[ i ].classList.remove( 'lyteSticky' );
					delete this[ i ]._sticky; 
				}
			}
			return this;
		}

		$L.prototype.sticky = function( obj ){
			obj = obj || {};
			obj.position = getPos( obj.position ) || "top";
			obj.offset = obj.offset || 0;
			obj.query = obj.query || "*>*:first-child:not(template)";

			var __len = this.length;

			for( var i = 0; i < __len; i++ ){
				var __cur = this[ i ];

				if( __cur._sticky ){

					if( obj == "refresh" ){
						globalScroll( { target : __cur } );
						continue;
					}

					$L( __cur ).removeSticky();
				}
				__cur.classList.add( 'lyteSticky' );
				__cur._sticky = $L.extend( true, {}, obj );
				__cur._sticky._stickytime = setTimeout( makeSticky.bind( __cur ), 20, __cur._sticky )
				if( obj.position != "topbottom" ) {
					__cur._sticky._init = setTimeout( findScroll.bind( __cur, obj.highlight, isSticky.sticky == false ), 40 )
				}
			}
		 	return this;
		}
		
			window.addEventListener( 'scroll', globalScroll, true )
		// }
	}
} );
( function( factory ) {
    if( typeof define === "function" && define.amd ) {
        define( [ "@zoho/lyte-dom" ], factory );
    }
    else {
        factory( $L );
    }
} )( function( $L ) { 

	var wrapped = [];
	var $u = function(obj){
		if (obj instanceof $u) return obj;
    	if (!(this instanceof $u)) return new $u(obj);
		this.wrapped = obj;
	};
	var result = function(instance, obj) {
    	return instance._chain ? $u(obj).chain() : obj;
  	};
  	
  	$u.some = function( list , predicate ){

  		if(predicate  != null){
  			predicate = formatIteratee(predicate);
		}
  		if(!Array.isArray(list)){
  			for(var key in list){
  				var currentVal = list[key];
  				if(!predicate){
  					if(currentVal){
  						return true;
  					}
  				}else if(predicate(currentVal)){
  					return true;
  				}
  			}
  		}else{
  			var length = list.length;
			for (var index = 0 ; index < length ; index++){
  				var currentVal = list[ index ];
  				if(!predicate){
  					if(currentVal){
  						return true;
  					}
  				}else if(predicate(currentVal)){
  					return true;
  				}
  			}
		}
  		
  		return false;
  	}


  	$u.every = function( list , predicate ){
  		
  		if(predicate  != null){
  			predicate = formatIteratee(predicate);
		}
  		if(!Array.isArray(list)){
  			for(var key in list){
  				var currentVal = list[key];
  				if(!predicate){
  					if(!currentVal){
  						return false;
  					}
  				}else if(!predicate(currentVal)){
  					return false;
  				}
  			}
  		}else{
  			var length = list.length;
			for (var index = 0 ; index < length ; index++){
  				var currentVal = list[ index ];
  				if(!predicate){
  					if(!currentVal){
  						return false;
  					}
  				}else if(!predicate(currentVal)){
  					return false;
  				}
  			}
		}
  		
  		return true;

  	}

  	$u.contains = function( list , val ){
  		return includes( list , val );
  	}


	$u.mixin = function( object ){
		
		var keys = Object.keys( object );
		keys.forEach(function(key){
			var func_name = key;
			var func =$u[func_name]= object[ func_name ];
      		$u.prototype[ func_name ] = function() {
        		var args = [this.wrapped];
        		Array.prototype.push.apply(args,arguments);
        		return  result( this , func.apply($u, args) );
			}
		});
	}
	$u.prototype.value=function(){
		return this.wrapped;
	}
	$u.difference = function(){
		
			var length = arguments.length;
		
		var newArray=[];
		
		var array = arguments[0];
		for(var index=0 ,len = array.length; index < len ; index++){
			var val = array[ index ];
			var isContains = false;
			for(var i= 1 ; i < length && Array.isArray(arguments[i]) ; i++){
				if(arguments[i].indexOf(val) !== -1){
					isContains = true;
					break;
				}
			}
			if(!isContains){
				newArray.push(val);
			}	
		}
		return newArray;
		
		

	}
	var Form_array = function( arg ){
		var array =[];
		Array.prototype.push.apply(array,arg);
		return array;
	}
	$u.removeFromArray = function (array , removeitems){
		var newArray = [];
		
		for (var i = 0,length= array.length; i < length; i++) {
			var val = array[ i ];
			if(!includes(removeitems,val)){
				newArray.push(val);
			}
		}
		return newArray;
	}
	var includes = function( list , val ){
		list = list || [];
		if(Array.isArray(list)){
			return list.indexOf(val) >= 0 ? true : false;
		}else{
			return $u.some( list , function(item){ return item === val; })
		}
		
	}
	$u.groupBy = function( list , iteratee ){
			
		iteratee = formatIteratee(iteratee);
		return list.reduce(function( set , val) {
			var key = iteratee( val );
	   		(set[key] = Array.isArray(set[ key ]) ? set[key] : []);
	   		set[key].push(val);
	    	return set;
	  	},{});
	}
	$u.indexBy = function( list , iteratee ){
		iteratee = formatIteratee(iteratee);
		return list.reduce(function( set , val ){
			var key = iteratee(val);
			set[ key ] = val;
			return set;
		},{});
	}
	$u.chain = function(obj){
		
		var instance = $u(obj);
    	instance._chain = true;
    	
		return instance;
	}

	$u.findWhere = function( list , properties ){
		var keys = Object.keys(properties);
		var flag = true;
		var result = undefined;
		for ( val in list){
			val = list[val]
			for(var i = 0 ; i < keys.length ; i++){
				var key = keys[i];
				if(val[key] !== properties[key]){
					flag = false;
					break;
				}
			}
			if(flag){
				result = val;
				break
			}
			flag = true; 
		}
		return result;
	}
	$u.intersection = function(){
		
		var start = 1 , intersec = [];
		intersec= arguments[0] || [];
		
		var result = [];
		var length = arguments.length ;
		var flag = true;
		var argument = arguments;
		var that = $u;
		var result = intersec . filter(function (val) {
			
			for(var index = start ; index < length ; index++){
				var array = argument[index];
				var check = includes( array , val );
				if( !check && flag ){
					flag = false;
					break;
				}
			}
			if(flag){
				return true;
			}
			flag = true;
		});
		
		return result;
	}
	$u.defaults =function( obj ){
		var length = arguments.length ;
		var argument = {} ;
		argument = obj || {};
		if( argument ){
			for(var i = 1 ; i < length ; i++){
				for(var key in arguments[i]){
					if( !argument.hasOwnProperty(key) || argument[key] === undefined ){
						argument[key] = arguments[i][key];
					}
				}
			}
		}
		return argument;
	}
	$u.negate = function( func ){
		return function(){
			return !func.apply( this , arguments );
		}
	}
	$u.omit = function( object ){
		var omit ;
		var iteratee ;
		if(typeof arguments[1] != 'function'){
			var keys = [];
			keys = Form_array(arguments);
			keys.shift();
			iteratee = function(value , key){
				return !includes(keys,key);
			}
		}else{
			iteratee = $u.negate(arguments[1]);
		}	
		return $u.pick(arguments[0] , iteratee);
	}
	$u.pick_array = function ( obj , pick , key ){
		var that = $u;
		for(var index =0 ,length=key.length; index < length ; index++){
			var val = key[index];
			if( Array.isArray(val)){
				that.pick_array( obj , pick , val );
			}else if(obj.hasOwnProperty(val)){
				pick[val] = obj[val];
			}
		}
		
		return pick;
	}
	$u.pick =function ( obj ){
		var pick = {};
		var length = arguments.length;
		var iteratee;

		if(typeof(arguments[1]) != 'function'){
			for(var i = 1 ; i < length ; i++ ){
				var key = arguments[i];
				if( !Array.isArray(key) ){
					if(obj[key]){
						pick[key] = obj[key];
					}
				}else {
					pick = $u.pick_array( obj , pick , key );
				}
			}
		}else{
			iteratee = (arguments[1]);
			for( var key in obj ){
				if(iteratee( obj[key] , key , obj )){
					pick[key] = obj[key];
				}
			}
		}
		return pick;
	}
	$u.extend = function(obj){
		if(obj){
			var extendObj = function(keys,object){
				keys.forEach(function(key){
					obj[key] = object[key];
				});
			}
			for(var index = 1; index < arguments.length ; index++){
				var object = arguments[index];
				var keys = Object.getOwnPropertyNames(object);
				extendObj(keys, object);
			}
			return obj;
		}else{
			return undefined;
		}
	}
	
	$u.isString = function(obj){
		if(typeof obj == "string"){
			return true;
		}else if(typeof obj == "object"){
			var type = toString(obj);
			return  type === "[object String]";
		}else{
			return false;
		}
	}

	$u.isEmpty = function( list ){
		
		if(  Array.isArray( list )){
			if(list.length > 0){
				return false;
			}
		}else if( list && typeof list == 'object' ){
			if(Object.getOwnPropertyNames( list ).length > 0){
				return false;
			}
		}else if(list){
			return false;
		}
		return true;
	}
	$u.clone = function( object ){
		var type = typeof object;

	    if (! (type === 'function' || type === 'object' && !!object ))
		 	return object;
	    if(Array.isArray( object ) ){
	    	return object.slice() 
	    }else{
	    	window.newObj = {};
			for(var key in object){
				newObj[key] = object[key];
			}
			return newObj;
	    }
	}
	var isArrayLike =  function(obj){
    	return ( Array.isArray(obj) || 
        (!!obj &&
          typeof obj === "object" &&
          typeof (obj.length) === "number" && 
          (obj.length === 0 ||
             (obj.length > 0 && 
             (obj.length - 1) in obj)
          )
        ));
	}
	$u.map = function(list , iteratee ){
		
		iteratee = formatIteratee(iteratee);
		var arr = [];
		var keys = !isArrayLike(list) && Object.keys(list),
			length = (keys || list).length;
		for(var index = 0 ; index < length ; index++){
			var cur_key = keys ? keys[index] : index,
				value = iteratee(list[cur_key] , cur_key , list);
			if(value){
				arr.push( value );
			}
		}
		return arr;
			
		
	}
	var flatten = function(input ,depth,output){
		var output = output || [];
		if(!depth && depth !== 0){
			depth = Infinity;
		}else if(depth <= 0){
			return output.concat(input);
		}
		var index = output.length;
		for(var i = 0; i < input.length ; i++){
			var val= input[i];
			if(Array.isArray(val)){
				if(depth > 1){
					flatten(val,depth-1,output);
					index = output.length;
				}else{
					var j = 0 , length = val.length;
					while( j < length ){
						output[ index++ ] = val[ j++ ];
					}
				}	
			}else{
				output[ index++ ] = val;
			}
		}
		return output;
	}
	var toString = function( obj ){
		return ({}).toString.call(obj);
	}
	$u.union = function(){
				
		var length = arguments.length;
		var unionArray = arguments[ 0 ];
		if(toString(unionArray) === '[object Arguments]'){
			var result = [];
			for(var union_index = 0 ,len = unionArray.length ; union_index < len ; union_index++   ){
				result[union_index] = unionArray[union_index];
			}
			unionArray = result;
		}

		for(var index = 1 ; index < length ; index++ ){
			var array = arguments[ index ];
			for (var i =  0 , len = array.length; i < len ; i++) {
				var val = array[ i ];
				if(!includes(unionArray,val)){
					unionArray.push(val);
				}
			}
		}
		return unionArray;
		
	}
	$u.uniq = function(array , iteratee){

		var uniqArray = [];
		if(!array && !array.length){
			return [];
		}
		var seen = [] ;
		var index = -1;
		
		if(iteratee != null){
			var iteratee = formatIteratee(iteratee);
			
		}else{
			seen = uniqArray;
		}
		var length = array.length;
		loop:
		for( ++index ; index< length ; index++){
			var val = array[index];
			var iter_val = iteratee ? iteratee(val) : val;
			var seen_len = seen.length;
			while(seen_len--){
				if(seen[seen_len] === iter_val){
					continue loop;
				}
			}
			if(iteratee){
				seen.push(iter_val);
			}
			uniqArray.push(val);
		}
		
		return uniqArray;
	}
	$u.chunk = function(array,length){
		
		var chunkedArray = [],chunks = [];
		array.forEach(function(val){
			if(chunks.length < length){
				chunks.push(val);
			}
			if( (chunks.length == length && length != 0) ){
				chunkedArray.push(chunks);
				chunks = [];
			}
		});
		if(chunks.length){
			chunkedArray.push(chunks);
		}
		return chunkedArray;
	}
	$u.isEqual = function(object1,object2,NonEnumerable){
		
		NonEnumerable = NonEnumerable === false ? false : true;
		if(object1 === object2){ return true; }
		if(typeof object1 !== typeof object2) return false;
		if (object1 == null || object2 == null) return object1 === object2;
		var className = toString(object1);
		if(className ==='[object RegExp]' || className ==='[object String]') {
	       	return '' + object1 === '' + object2;
	    }else if(className === '[object Number]'){
	       	if (+object1 !== +object1) return +object2 !== +object1;
	      		return +object1 === 0 ? 1 / +object1 === 1 / object2 : +object1 === +object2;
	    }else if( className === '[object Date]' || className ==='[object Boolean]'){
	        return +object1 === +object2;
	    }else if(typeof(object1) == 'object' && typeof(object2) == 'object'){
			if(Array.isArray(object1) != Array.isArray(object2)){
				return false;
			}else if(Array.isArray(object1) && Array.isArray(object2)){
				return $u.checkArrayEquality(object1,object2,NonEnumerable);
			}else {
				return $u.checkObjectEquality(object1,object2,NonEnumerable);
			}
		}else if(typeof object1 != typeof object2 ){
			return false;
		}
		return true;
	}
	$u.checkArrayEquality = function(array1,array2,NonEnumerable){
		var flag = true;
		if(array1.length == array2.length){
			var len = array1.length;
			for( var i = 0 ; i < len ; i++ ){
				if(typeof(array1[i]) != typeof(array2[i])){
					return false;
				}
				else if(typeof(array1[i]) == 'object' ){
					flag = $u.isEqual(array1[i],array2[i],NonEnumerable);
				}
				else if(array1[i] !== array2[i]){
					return false;
				}
				if(flag == false){
					return flag;
				}
			}
		}
		else {
			return false;
		}
		return flag;
	}

	$u.checkObjectEquality = function( obj1 , obj2 ,NonEnumerable){
			
		if(NonEnumerable){
			var obj2_key = Object.getOwnPropertyNames(obj2);
			var keys = Object.getOwnPropertyNames(obj1);
		}else{
			var obj2_key = Object.keys(obj2);
			var keys = Object.keys(obj1);	
		}
		var  len = keys.length , flag = true;

		if(keys.length != obj2_key.length){
			return false;
		}
		for(var i =0 ; i < len ; i++){
			var key = keys[i];
			if(typeof(obj1[key]) != typeof(obj2[key]) ){
				return false;
			}
			else if(typeof(obj1[key]) == 'object'){
				flag = $u.isEqual(obj1[key] , obj2[key] , NonEnumerable);
			}
			else if( obj1[key] !== obj2[key] ){
				return false;
			}
			if(flag == false){
				return flag;
			}
		}
		
		return flag;
	}
	$u.invert = function(input){
		var keys = Object.keys(input);
		var newObj = {};
		keys.forEach(function(val){
			newObj[input[val]] = val;
		});
		return newObj;
	}
	$u.without = function(){
		
		var len = arguments.length , argument = [] ;
		for(var i = 1 ; i < len ; i++ ){
			argument.push(arguments[i]);
		}
		var first_arg = Form_array(arguments[0]);
		return $u.removeFromArray( first_arg || [] , argument);
	}
	$u.max = function(list,iteratee){

		list = list || [];
		var maxVal = list[0] , flag = false;
		iteratee = formatIteratee(iteratee);
		var iter_max = iteratee(maxVal);
		for(var index = 0;index < list.length ;index ++){
			var val = list[index];
			var iter_val = iteratee(val);
			if(  ( iter_val > iter_max ) || isNaN(iter_max) && !isNaN(iter_val) ){
				maxVal = val;
				iter_max = iteratee(maxVal);
				flag = true;
			}
		}
		if(!flag && isNaN(iter_max)){
			return -Infinity;
		}
		return maxVal;
	}
	$u.min = function(list,iteratee){
		list =list || [];
		var minVal = list[0] , flag = false;
		iteratee = formatIteratee(iteratee);
		var iter_min = iteratee(minVal);
		for(var index = 0; index < list.length ; index++){
			var val = list[index];
			var iter_val = iteratee(val);
			if(  ( iter_val < iter_min ) || isNaN(iter_min) && !isNaN(iter_val) ){
				minVal = val;
				iter_min = iteratee(minVal)
				flag = true;
			}
		}
		if(!flag && isNaN(iter_min)){
			return Infinity;
		}
		return minVal;
	}
	var partition = function( arr ,  low ,  high , iteratee ){ 
        var pivot = arr[high];  
        var i = (low-1); 
        for (var j=low; j<high; j++) 
        { 
            if (iteratee(arr[j] )< iteratee(pivot)) 
            { 
                i++; 
                var temp = arr[i]; 
                arr[i] = arr[j]; 
                arr[j] = temp; 
            } 
        } 
        var temp = arr[i+1]; 
        arr[i+1] = arr[high]; 
        arr[high] = temp; 
  
        return i+1; 
    } 
 
   	var sort = function( arr ,  low ,  high , iteratee ){ 
        if (low < high){ 
            var pi = partition( arr, low , high , iteratee ); 
            sort( arr , low , pi-1 , iteratee ); 
            sort( arr , pi+1 , high , iteratee ); 
        }
        return arr; 
    } 
	$u.sortBy = function(list,iteratee){
		iteratee = formatIteratee(iteratee);
		return sort( list , 0 , list.length-1 , iteratee );
	}
	var formatIteratee = function(iteratee){
		
		var type = typeof iteratee;
		if(iteratee == undefined || type == "function"){
			return iteratee||function(val){return val;};
		}else if(type  == "string" || type  == "number"){
			var key = iteratee ;
			iteratee = function(val){return val[key]};
		}else if(Array.isArray(iteratee)){
			var deep = iteratee;
			iteratee = function( val ){
				for(var index=0 ; index < deep.length && val != undefined ; index++){
					val = val[deep[index]];
				}
				return val;
			}
		}else {
			var compareobj = iteratee;
			iteratee = function( obj ){
				var keys =  Object.getOwnPropertyNames( compareobj );
				var key = keys[ 0 ]; 
				for(var i = 0 ; i < keys.length ;key = keys[ ++i ]){
					if( obj[ key ] !== compareobj[ key ] ){
						return false;
					}
				}
				return true;
			}
		}
		
		return iteratee;
	}
	$u.replace = function(accented){
		var str;
		/*var map = {
        	
        	'a' : 'ā|á|à|ã|â|À|Á|Ã|Â|Ā',
        	'c' : 'ç|Ç|ĉ|Ĉ|Ć|ć|Ĉ|ĉ|Ċ|ċ|Č|č',
        	'd' : 'Ḍ|Ḏ|ḍ|ḏ|Ď|ď|Đ|đ|Ḍ',
        	'e' : 'ē|é|è|ê|É|È|Ê|Ē',
        	'g' : 'Ĝ|ĝ|Ğ|ğ|Ġ|ġ|Ģ|ģ',
        	'h' : 'Ḥ|H̱|H̤|Ḫ|ḥ|ẖ|h̤|ḫ|Ĥ|ĥ|Ħ|ħ',
        	'i' : 'í|ì|î|ī|Í|Ì|Î|Ī',
        	'j' : 'ĵ|j̄|Ĵ|J̄',
        	'k' : 'ḵ|Ḵ',
        	'l' : 'l̥|ḻ|ḷ|L̥|Ḻ|Ḷ| l̥̄|  L̥̄',
        	'm' : 'ṃ|ṁ|m̐|m̆|Ṃ|Ṁ|M̐|M̆',
        	'n' : 'Ñ|Ṇ|Ṅ|Ṉ|N̆|ñ|ṇ|ṅ|ṉ|n̆',
        	'o' : 'ó|ò|ô|ö|õ|ō|Ö|Ō|Ó|Ò|Ô|Õ',
  			'r' : 'Ṛ|Ṟ|R̥| R̥̄|R̆|ṛ|ṟ|r̥|  r̥̄|r̆',
  			's' : 'Ś|Ṣ|Ṣ|S̤|S̱|§|ś|ṣ|s̤|s̱|§',
  			't' : 'ṭ|ṯ|Ṭ|Ṯ',
         	'u' : 'ú|ù|û|ü|ū|Ú|Ù|Û|Ü|Ū',
        	'y' : 'ý|ÿ|Ý',
        	'z' : 'ž|ż|ẓ|ẕ|ź|Ž|Ż|Ẓ|Ẕ|Ź',
        	'kh': 'k͟h|K͟H',
        	'ae' : 'Æ|æ'
		};
    	for (var pattern in map) {
        	accented = accented.replace( new RegExp( map[pattern] , 'gi'), pattern);
    	};*/
    	str = accented.normalize("NFKD").replace(/[\u0300-\u036f]/g, "");
    	//str = str.replace(/"Æ"/g,"AE");
    	return str;
	}
	$u.highlight = function( string , search , callback ){
		var Reg = new RegExp( search , "gi");
		callback = generatecallback( callback ); 
		string = string.replace(Reg,function(str,pos){
			var highlight = string.slice(pos,pos+search.length);
			return callback(highlight);
		});
		return string;
	}
	
	var generatecallback = function( callback ){

		if(typeof callback === "string" ){
			var tag_name = callback;
			callback = function(str){
				return "<"+tag_name+">" + str + "</" + tag_name + ">"; 
			}
		}
		callback = callback ||  function(str){
				return "<span>" + str + "</span>"; 
			};
		return callback;
	}
	$u.mixin($u);
	window.$u = $u;
})


( function( factory ) {
    if( typeof define === "function" && define.amd ) {
        define( [ "@zoho/lyte-dom" ], factory );
    }
    else {
        factory( $L );
    }
} )( function( $L ){
	if( $L ){
		function CanvasPool() {
			var canvases = [];
			return {
	    	
	        pop: function pop() {
	          if (this.length === 0) {
	            canvases.push(document.createElement('canvas'));
	          }
	    
	          return canvases.pop();
	        },
	        
	        get length() {
	          return canvases.length;
	        },

	        release: function release(canvas) {
	          var context = canvas.getContext('2d');
	          context.clearRect(0, 0, canvas.width, canvas.height);
	          canvases.push(canvas);
	        },

	        clear: function clear() {
	          canvases.splice(0, canvases.length);
	        },

	        get elements() {
	          return canvases;
	        }
	    
	      };
	    }
	    var shared = CanvasPool();
	    var canvasPool = (shared);

		function lyteWatermark(object, promise){
			var data = object ? object : {};
			var positions = ["atPos","lowerRight","upperRight","lowerLeft","upperLeft","center","custom"];
			var styles = ["image","text"];

			data.target = data.target;
			data.watermark = data.watermark;
			data.style = data.style && styles.indexOf(data.style) !== -1 ? data.style : "text";
			data.position = data.position && positions.indexOf(data.position) !== -1 ? data.position : "lowerRight";
			data.alpha = data.alpha && data.alpha >= 0 && data.alpha <= 1 ? data.alpha : 1;
			data.font = data.font ? data.font : "20px Josefin Slab";
			data.fillStyle = data.fillStyle ? data.fillStyle : "#fff";
			data.size = data.size;
			data.init = data.init ? data.init : function init() {};
			data.initialized = data.initialized;
			data.type = "image/png";
			data.encoderOptions = 0.92;
			if(data.position == "atPos"){
				data.posX = typeof data.posX === "function" ? data.posX : returnFnRef(data.posX);
				data.posY = typeof data.posY === "function" ? data.posY : returnFnRef(data.posY);
			}
			data.onLoad = data.onLoad;
			data.onComplete = data.onComplete;
			var promise = this.promise = promise !== undefined ? promise : null;
			
			this.promise || (promise = this.promise = loadImages(getImageArray(data), data.init));

			if(!data.initialized){
				data.initialized = true;
				if(data.position === "custom"){
					if(!data.onLoad){
						// console.error("For custom style you need to provide onLoad function to position the watermark");
						// this.promise = "ERROR ! onLoad not provided for custom position.";
						throw new Error("ERROR ! onLoad not provided for custom position.");
						// return ;
					}
					promise = this.promise = afterImageLoad(data.onLoad)
				}
				else if(data.style == "image"){
					if(data.position == "lowerRight"){
						promise = this.promise = afterImageLoad(lowerRight(data.alpha));
					}
					else if(data.position == "upperRight"){
						promise = this.promise = afterImageLoad(upperRight(data.alpha));
					}
					else if(data.position == "lowerLeft"){
						promise = this.promise = afterImageLoad(lowerLeft(data.alpha));
					}
					else if(data.position == "upperLeft"){
						promise = this.promise = afterImageLoad(upperLeft(data.alpha));
					}
					else if(data.position == "center"){
						promise = this.promise = afterImageLoad(center(data.alpha));
					}
					else if(data.position == "atPos"){
						promise = this.promise = afterImageLoad(atPos(data.posX, data.posY, data.alpha));
					}
				}
				else if(data.style == "text"){
					if(data.position == "lowerRight"){
						promise = this.promise = afterImageLoad(text_lowerRight(data.watermark, data.font, data.fillStyle, data.alpha, data.size));
					}
					else if(data.position == "upperRight"){
						promise = this.promise = afterImageLoad(text_upperRight(data.watermark, data.font, data.fillStyle, data.alpha, data.size));
					}
					else if(data.position == "lowerLeft"){
						promise = this.promise = afterImageLoad(text_lowerLeft(data.watermark, data.font, data.fillStyle, data.alpha, data.size));
					}
					else if(data.position == "upperLeft"){
						promise = this.promise = afterImageLoad(text_upperLeft(data.watermark, data.font, data.fillStyle, data.alpha, data.size));
					}
					else if(data.position == "center"){
						promise = this.promise = afterImageLoad(text_center(data.watermark, data.font, data.fillStyle, data.alpha, data.size));
					}
					else if(data.position == "atPos"){
						promise = this.promise = afterImageLoad(text_atPos(data.posX, data.posY, data.watermark, data.font, data.fillStyle, data.alpha));
					}
				}
				if(data.onComplete){
					promise = this.promise = addResolve();
				}
			}

			function afterImageLoad(draw) {
			    return dataUrl(draw).then(createImage);
			}

			function dataUrl(draw) {
			    var promise_obj = $L.watermark(data, promise).then(function (images) {
			        return mapToCanvas(images, canvasPool);
			    }).then(function (canvases) {
			        return addStyleToResult(draw, canvases);
			    }).then(function (result) {
			        return release(result, canvasPool, {
			          type: data.type,
			          encoderOptions: data.encoderOptions
			        });
			    });
			    return $L.watermark(data, promise_obj);
			}

			function identity(x) {
				return x;
			}

			function getTypeOf(obj) { 
				if (typeof window.Symbol === "function" && typeof window.Symbol.iterator === "symbol") { 
				    getTypeOf = function getTypeOf(obj) { return typeof obj; }; 
				} else { 
				    getTypeOf = function getTypeOf(obj) { 
					    return obj && 
					    typeof window.Symbol === "function" && 
					    obj.constructor === window.Symbol && 
					    obj !== window.Symbol.prototype ? "symbol" : typeof obj; 
				    }; 
				} return getTypeOf(obj); 
			}

			function getLoader(resource) {
				var type = getTypeOf(resource);
				if (type === 'string') {
    				return loadUrl;
				}
				if (resource instanceof window.Image) {
    				return identity;
				}
				// return loadFile;
			}

			function loadImages(imgArray, init) {
				var promises = [];

				for (var i = 0; i < imgArray.length; i++) {
				    var img = imgArray[i];
				    var loader = getLoader(img);
				    var promise = loader(img, init);
				    promises.push(promise);
				}

				return Promise.all(promises);
			}

			function loadUrl(url, init) {
				var img = new window.Image();
				typeof init === 'function' && init(img);
				return new Promise(function (resolve) {
				    img.onload = function () {
				    	return resolve(img);
				    };
				    img.src = url;
				});
			}

			function createImage(url, onload) {
				var img = new window.Image();

				if (typeof onload === 'function') {
    				img.onload = onload;
				}
				img.src = url;
				return img;
			}

			function mapToCanvas(images, pool) {
				return images.map(function (img) {
					var canvas = pool.pop();
					var ctx = canvas.getContext('2d');
					canvas.width = img.width;
					canvas.height = img.height;
					ctx.drawImage(img, 0, 0);
					return canvas;
				});
			}
			function canvasDataUrl(canvas, parameters) {
				var parameters = parameters || {
				    type: 'image/png',
				    encoderOptions: 0.92
				};
				return canvas.toDataURL(parameters.type, parameters.encoderOptions);
			}
			function addStyleToResult(draw, sources) {
				var canvas = draw.apply(null, sources);
				return {
				    canvas: canvas,
				    sources: sources
				};
			}

		    function release(result, pool, parameters) {
				var canvas = result.canvas,
			    	sources = result.sources;
				var dataURL = canvasDataUrl(canvas, parameters);
				sources.forEach(pool.release);
				return dataURL;
			}

			function atPos(xFn, yFn, alpha) {
				// alpha || (alpha = 1.0);
				return function (target, watermark) {
				    var context = target.getContext('2d');
				    context.save();
				    context.globalAlpha = alpha;
				    context.drawImage(watermark, xFn(target, watermark), yFn(target, watermark));
				    context.restore();
				    return target;
				};
			}
			function lowerRight(alpha) {
				return atPos(function (target, mark) {
				    return target.width - (mark.width + 10);
				}, function (target, mark) {
				    return target.height - (mark.height + 10);
				}, alpha);
			}
			function upperRight(alpha) {
				return atPos(function (target, mark) {
				    return target.width - (mark.width + 10);
				}, function (target, mark) {
				    return 10;
				}, alpha);
			}

			function lowerLeft(alpha) {
				return atPos(function (target, mark) {
				    return 10;
				}, function (target, mark) {
				    return target.height - (mark.height + 10);
				}, alpha);
			}

			function upperLeft(alpha) {
				return atPos(function (target, mark) {
				    return 10;
				}, function (target, mark) {
				    return 10;
				}, alpha);
			}

			function center(alpha) {
				return atPos(function (target, mark) {
				    return (target.width - mark.width) / 2;
				}, function (target, mark) {
				    return (target.height - mark.height) / 2;
				}, alpha);
			}

			function text_atPos(xFn, yFn, text, font, fillStyle, alpha) {
				return function (target) {
				    var context = target.getContext('2d');
				    context.save();
				    context.globalAlpha = alpha;
				    context.fillStyle = fillStyle;
				    context.font = font;
				    var metrics = context.measureText(text);
				    context.fillText(text, xFn(target, metrics, context), yFn(target, metrics, context));
				    context.restore();
				    return target;
				};
			}

			function text_lowerRight(text, font, fillStyle, alpha, size) {
				return text_atPos(function (target, metrics) {
				    return target.width - (metrics.width + 10);
				}, function (target) {
				    return size || target.height - 10;
				}, text, font, fillStyle, alpha);
			}

			function text_lowerLeft(text, font, fillStyle, alpha, size) {
				return text_atPos(function () {
				    return 10;
				}, function (target) {
				    return size || target.height - 10;
				}, text, font, fillStyle, alpha);
			}

			function text_upperRight(text, font, fillStyle, alpha, size) {
				return text_atPos(function (target, metrics) {
				    return target.width - (metrics.width + 10);
				}, function () {
				    return size || 20;
				}, text, font, fillStyle, alpha);
			}

			function text_upperLeft(text, font, fillStyle, alpha, size) {
				return text_atPos(function () {
				    return 10;
				}, function () {
				    return size || 20;
				}, text, font, fillStyle, alpha);
			}

			function text_center(text, font, fillStyle, alpha, size) {
				return text_atPos(function (target, metrics, ctx) {
				    ctx.textAlign = 'center';
				    return target.width / 2;
				}, function (target, metrics, ctx) {
				    ctx.textBaseline = 'middle';
				    return target.height / 2;
				}, text, font, fillStyle, alpha);
			}

			function returnFnRef(val) {
				return function(){
					return val || 40;
				}
			}

			function getImageArray(data){
				var images = Array.of(data.target);
				if(data.style == "image"){
					images.push(data.watermark);
				}
				return images;
			}

			function addResolve(){
				return $L.watermark(data, promise).then(data.onComplete);
			}
		}

		lyteWatermark.prototype = {
			load: function load(resources, init) {
		      var promise = this.then(function (resource) {
		        resources.target = resource;
		        resources.initialized = false;
		        return $L.watermark(resources);
		      });
		      resources.initialized = true;
		      return $L.watermark(resources, promise);
		    },

		    then: function then() {
		      for (var len = arguments.length, funcs = new Array(len), key = 0; key < len; key++) {
		        funcs[key] = arguments[key];
		      }

		      return this.promise.then.apply(this.promise, funcs);
		    }
		}

		$L.watermark = function(arg, promise){
			if(typeof arg === "string" && arg === "destroy"){
				return canvasPool.clear();
			}
			return new lyteWatermark(arg, promise);
		}

		$L.watermark.lyteWatermark = lyteWatermark;
	}
} )
