;( function( cb ){
	if( typeof define == "function" && define.amd ){
		  define( [ "@zoho/lyte-dom" ], cb );
	  } else {
		  cb( window.$L );
	  }
} )( function($L) {

	$L( document ).on( 'mousedown', function( event ) {

		var elm = event.target;

		while( elm && elm.tagName != 'HTML' ) {
			
			var ripple = elm.getAttribute( 'data-ripple' ), 
			target, width, color, position, targetElement,addclass,callBack;
			var obj = {};
			if( ripple != null && ripple != "false" ) {
				
				target = elm.getAttribute( 'data-ripple-target' ); 
				obj.width = elm.getAttribute( 'data-ripple-width' );
				obj.color = elm.getAttribute( 'data-ripple-color' );
				obj.position = elm.getAttribute( 'data-ripple-position' );
				obj.callBack = elm.getAttribute( 'data-ripple-callBack' );
				obj.addclass = elm.getAttribute( 'data-ripple-class' );
				obj.targetElement = target ? elm.querySelector( target ) : elm;
				obj.event = event;
				$L.ripple_effect(obj);				
				break;
			}
			else {
				elm = elm.parentNode;
			}
		}


	} );

	$L.ripple_effect = function( rippleobj ) {
		
		var rippleSpan = document.createElement( 'span' );
		var button = rippleobj.targetElement;
		if( button ) {
			
			var localX = rippleobj.event.clientX - button.getBoundingClientRect().left,
			localY =  rippleobj.event.clientY - button.getBoundingClientRect().top,
			radius = rippleobj.width || calcRadius( button.offsetWidth, button.offsetHeight, localX, localY ),
			diameter = radius * 2,
			x = localX - radius,
			y = localY - radius;
			if(rippleobj.addclass){
				rippleSpan.classList.add(rippleobj.addclass);	
			}
			
			rippleSpan.style.width = diameter + 'px';
			rippleSpan.style.height = diameter + 'px';
			
			if( rippleobj.color ) {
				rippleSpan.style.backgroundColor = rippleobj.color;
			}
			if(window.getComputedStyle(button).position !== 'absolute'){
				button.style.position = 'relative';
			}
			
			if( !rippleobj.position || rippleobj.position.toUpperCase() !== "CENTER" ) {
				
				button.style.overflow = 'hidden';
				/*button.style.position = 'relative';*/
				rippleSpan.style.left = x + 'px';
		    	rippleSpan.style.top =  y + 'px';
				rippleSpan.classList.add( "lyteRipple" );		    	
			}
			else {
				rippleSpan.style.top =  'calc(50% - '+ radius + 'px)';
		    	rippleSpan.style.left =  'calc(50% - '+ radius + 'px)';
		    	rippleSpan.classList.add( 'lyteRippleCenter' );

			}
			$L( rippleSpan ).one( 'animationend', { element: rippleSpan ,close : rippleobj.callBack,originElem: rippleobj.targetElement }, hideOnInteractionEnd );
			var hideRipple = hideOnRippleEnd.bind(this);
			$L( rippleobj.targetElement ).one( 'mouseup', { element: rippleSpan ,close : rippleobj.callBack, hideRipple: hideRipple,originElem: rippleobj.targetElement}, hideRipple );
			$L( rippleobj.targetElement ).one( 'mouseleave', { element: rippleSpan ,close : rippleobj.callBack ,hideRipple: hideRipple,originElem: rippleobj.targetElement}, hideRipple );

	        button.insertBefore( rippleSpan, button.childNodes[ 0 ]) ;
		}
	}


	var hideOnRippleEnd = function( event ) {
		var rippleSpan = event.data.element;
		
		rippleSpan.interactionEnd = true;
		if( rippleSpan.rippleEnd ) {
			
			removeRipple( rippleSpan, event.data.originElem, event.data.close);
		}

		removeEvents( event.currentTarget , event.data.hideRipple );
	}

	var removeEvents = function( button ,hideRipple) {

		$L( button ).off( 'mouseleave', hideRipple );
		$L( button ).off( 'mouseup', hideRipple );
	}

	var hideOnInteractionEnd = function( event ) {
		var rippleSpan = event.data.element;
		
		rippleSpan.rippleEnd = true;
		
		if( rippleSpan.interactionEnd ) {

			removeRipple( rippleSpan ,event.data.originElem,event.data.close);
		}
	}

	var removeRipple = function( span, originElem, close) {

		$L( span ).one( 'animationend', { element: span , originElem: originElem,callBack:close}, removeFromDom );
		span.classList.add( 'lyteRippleFadeOut' );
	}

	var removeFromDom = function( event ) {
		
		var span = event.data.element;
		// event.data.originElem.style.overflow = 'unset';
		span.remove();
		if(event.data.callBack){

			event.data.callBack();
		}
	}

	var calcRadius = function( width, height, localX, localY ) {
		return Math.max( Math.sqrt( localX ** 2 + localY ** 2 ), 
			Math.sqrt( ( width - localX ) ** 2 + ( height - localY ) ** 2 ),
			Math.sqrt( localX ** 2 + ( height - localY ) ** 2 ),
			Math.sqrt( localY ** 2 + ( width - localX ) ** 2 ) );
	}
	


} );