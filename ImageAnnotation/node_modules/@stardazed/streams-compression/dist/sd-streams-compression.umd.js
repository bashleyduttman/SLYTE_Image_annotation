(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@stardazed/zlib')) :
	typeof define === 'function' && define.amd ? define(['exports', '@stardazed/zlib'], factory) :
	(global = global || self, factory(global.sdStreamsCompression = {}, global.sdZlib));
}(this, (function (exports, zlib) { 'use strict';

	/*
	@stardazed/streams-compression - implementation of compression streams
	Part of Stardazed
	(c) 2019-Present by Arthur Langereis - @zenmumbler
	https://github.com/stardazed/sd-streams
	*/

	/*
	streams-compression/decompression-stream - transform stream expanding compressed data
	Part of Stardazed
	(c) 2019-Present by Arthur Langereis - @zenmumbler
	https://github.com/stardazed/sd-streams
	*/
	var decContext = Symbol("decContext");
	var decTransform = Symbol("decTransform");
	var DecompressionTransformer = /** @class */ (function () {
	    function DecompressionTransformer(inflater) {
	        this.inflater_ = inflater;
	    }
	    DecompressionTransformer.prototype.transform = function (chunk, controller) {
	        if (!(chunk instanceof ArrayBuffer || ArrayBuffer.isView(chunk))) {
	            throw new TypeError("Input data must be a BufferSource");
	        }
	        var buffers = this.inflater_.append(chunk);
	        for (var _i = 0, buffers_1 = buffers; _i < buffers_1.length; _i++) {
	            var buf = buffers_1[_i];
	            controller.enqueue(buf);
	        }
	    };
	    DecompressionTransformer.prototype.flush = function (_controller) {
	        var result = this.inflater_.finish();
	        if (!result.success) {
	            if (!result.complete) {
	                throw new Error("Unexpected EOF during decompression");
	            }
	            if (result.checksum === "mismatch") {
	                throw new Error("Data integrity check failed");
	            }
	            if (result.fileSize === "mismatch") {
	                throw new Error("Data size check failed");
	            }
	            throw new Error("Decompression error");
	        }
	    };
	    return DecompressionTransformer;
	}());
	var DecompressionStream = /** @class */ (function () {
	    function DecompressionStream(format) {
	        if (format !== "deflate" && format !== "gzip") {
	            throw new TypeError("format must be one of `deflate`, `gzip`");
	        }
	        this[decContext] = new zlib.Inflater();
	        this[decTransform] = new TransformStream(new DecompressionTransformer(this[decContext]));
	    }
	    Object.defineProperty(DecompressionStream.prototype, "readable", {
	        get: function () {
	            return this[decTransform].readable;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DecompressionStream.prototype, "writable", {
	        get: function () {
	            return this[decTransform].writable;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return DecompressionStream;
	}());

	/*
	streams-compression/compression-stream - transform stream compressing arbitrary data
	Part of Stardazed
	(c) 2019-Present by Arthur Langereis - @zenmumbler
	https://github.com/stardazed/sd-streams
	*/
	var comContext = Symbol("comContext");
	var comTransform = Symbol("comTransform");
	var CompressionTransformer = /** @class */ (function () {
	    function CompressionTransformer(deflater) {
	        this.deflater_ = deflater;
	    }
	    CompressionTransformer.prototype.transform = function (chunk, controller) {
	        if (!(chunk instanceof ArrayBuffer || ArrayBuffer.isView(chunk))) {
	            throw new TypeError("Input data must be a BufferSource");
	        }
	        var buffers = this.deflater_.append(chunk);
	        for (var _i = 0, buffers_1 = buffers; _i < buffers_1.length; _i++) {
	            var buf = buffers_1[_i];
	            controller.enqueue(buf);
	        }
	    };
	    CompressionTransformer.prototype.flush = function (controller) {
	        var buffers = this.deflater_.finish();
	        for (var _i = 0, buffers_2 = buffers; _i < buffers_2.length; _i++) {
	            var buf = buffers_2[_i];
	            controller.enqueue(buf);
	        }
	    };
	    return CompressionTransformer;
	}());
	var CompressionStream = /** @class */ (function () {
	    function CompressionStream(format) {
	        if (format !== "deflate" && format !== "gzip") {
	            throw new TypeError("format must be one of `deflate`, `gzip`");
	        }
	        this[comContext] = new zlib.Deflater({ format: format });
	        this[comTransform] = new TransformStream(new CompressionTransformer(this[comContext]));
	    }
	    Object.defineProperty(CompressionStream.prototype, "readable", {
	        get: function () {
	            return this[comTransform].readable;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(CompressionStream.prototype, "writable", {
	        get: function () {
	            return this[comTransform].writable;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return CompressionStream;
	}());

	exports.CompressionStream = CompressionStream;
	exports.DecompressionStream = DecompressionStream;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
