var path = require("path"),
    utils = require("@zoho/lyte-cli-utils"),
    replaceSpecialCharWithHTML = utils.stringManipulation.replaceSpecialCharWithHTML,
    minifyHTMLContent =  utils.commonCliUtils.minifyHTMLContent,
	expHandlers = require('@zoho/lyte-cli-utils/src/expHandlers'),
    traverse = require("@babel/traverse").default,
    childIf = false,
	parser = require("@babel/parser").parse;
module.exports = function(content,file) {
    let errorCount = [0];
    let returnObj = {
        content : {}
    };
    let getText = function(node) {
        return content.slice(node.start,node.end);
    }
    let checkForError = function(e) {
        let {errorMsg:  msg,node} = e
        let loc = node.loc;
        errorCount[file] = 1;
        returnObj.error = msg+" in the line number "+loc.start.line+":"+loc.start.column;
    }
    let output;
    try {
        let handleForEach =function(expressionObj){
           
            var item;
            var index;
            var expressionObjArgs = expressionObj.arguments;
            var argsZero = expressionObjArgs[0].params[0]
            var argsOne = expressionObjArgs[0].params[1]
            if(argsZero) {
                item = argsZero.name;
            }
            index = argsOne ? argsOne.name : "index";
            var options = {};
            var expObj;
            var key,value,objKey;
            var len = expressionObj.arguments.length,i;
            for(i = 1 ;i < len;i++) {
                expObj = expressionObjArgs[i].properties[0];
                
                if(expressionObjArgs[i].type == "ObjectExpression") {
                    key =  expObj.key;
                    value = expObj.value
                    objKey = key.value || key.name
                    options[objKey] = {};
                    options[objKey].value = value.value || value.name;
                    options[objKey].type =	value.type
                }	
            }
            var callee = expressionObj.callee;
            var propName = callee.property.name;
            if(propName == "forEach") { 
                output += '<template is="for" _jsp="true" items="{{';
            } else if(propName == "forIn") {
                output += '<template is="forIn" _jsp="true" object="{{';
            }
            var calleeObj = callee.object
            var calleeType = calleeObj.type;
            if(calleeType === "ArrayExpression") {
                checkForError({errorMsg : "Static Array to forEach",node : callee.object});
            }else if(calleeType === "LogicalExpression"){
                checkForError({errorMsg : "LogicalExpression to forEach",node : callee.object});
            }else if(calleeType === "BinaryExpression"){
                checkForError({errorMsg : "BinaryExpression to forEach",node : callee.object});
            } else if(calleeType === "ConditionalExpression") {
                checkForError({errorMsg : "ConditionalExpression to forEach",node : callee.object});
            } else {
                try {
                    returnFromFn = replaceSpecialCharWithHTML(getText(calleeObj));				
                    output += returnFromFn;
                } catch(e) {
                    checkForError({errorMsg : e.message,node : e.node});
                }
            }
            if(propName == "forEach") { 
                if(item) {
                    output += '}}" item="'+item+'" index="'+index+'" ';
                } else {
                    output += '}}" item="item" index="index" ';
                }									
            } else if(propName == "forIn") {				
                if(item && argsOne) {
                    output += '}}" value="'+item+'" key="'+index+'" ';
                } else if(item) {
                    output += '}}" value="'+item+'" key="key" ';
                } else {
                    output += '}}" value="value" key="key" ';
                }				
            }
            if(options) {
                var key;
                var optionsVal;					
                for(key in options) { 
                    let optKey = options[key];
                    optionsVal = optKey.value;
                    let type  = optKey.type;
                    if(type == "Identifier") {
                        output += key+'="{{'+ optionsVal.replace(/\"/g,'&quot;')+'}}" ';						
                    } else if(type == "Literal" || type == "StringLiteral") {
                        if(typeof optionsVal == "string") {
                            if(optionsVal == "true" || optionsVal == "false") {
                                output += key+"="+JSON.parse(optionsVal)+' ';
                            } else {
                                output += key+"='"+optionsVal.replace(/\"/g,'&quot;')+"' ";
                            }
                        } else {
                            output += key+"="+optionsVal+' ';
                        }
                    } else if(type == "BooleanLiteral") {
                        output += key+"="+optionsVal+' ';
                    } else if(type == "NumericLiteral") {
                        output += key+"="+optionsVal+' ';
                    }   
                }		
            }
            output+='>';
            handleBlockStatement(expressionObjArgs[0].body.body);
            output += "</template>";
        }
            
        let handleProgram = function(node){
            try  {
                var idname = node.id.name;
                handleFunctionDeclaration(node);				
                idname = idname.replace(/\$/g,'-');			
                if(!errorCount[file]) {											
                    returnObj.content[idname] = minifyHTMLContent(output);										
                } 	
                output = "";
            } catch(e) {
                output = "";
                checkForError({errorMsg : e.message,node :node});
            }
        }
        
        let handleFunctionDeclaration = function(node){
            // var params = node.params;
            // var body = node.body;
            handleBlockStatement(node.body.body);
        }

        let handleSwitchCase = function(node){
            var i,len = node.length;
            var test;
            var nodeVal;
            for(i=0;i<len;i++){
                nodeVal = node[i]
                test = nodeVal.test;
                if(!test){//default case handling
                    output += '<template default>';
                }else{
                    output += '<template case=' ;
                    handleSwitchCondition(test);
                    output += '>';
                }
                handleBlockStatement(nodeVal.consequent);
                output += "</template>"
            }
        }

        let handleSwitchCondition = function(node){
            try {
           
                var type = node.type;
                if(type === "Identifier" || type == "MemberExpression"){
                    returnFromFn = expHandlers.getValueBasedOnType(node,false);
                    output += '"{{' +returnFromFn+'}}"';		
                } else if(type == "Literal" || type =="StringLiteral") {
                    var val = expHandlers.getValueBasedOnType(node,false,true);
                    if(typeof val != "boolean" && typeof val != "number") {
                        output += val.replace(/^('|")$/g,'');
                    } else {
                        output += val;
                    }
                } else if(type == "NumericLiteral"){
                    output += expHandlers.getValueBasedOnType(node,false);
                } else if(type == "BooleanLiteral"){
                    output += expHandlers.getValueBasedOnType(node,false);
                } else {
                    output += '"{{'+replaceSpecialCharWithHTML(getText(node))+'}}"';
                }
            } catch(e) {
                checkForError({errorMsg : e.message,node :e.node});
            }
        }

        let handleIfStatement = function(node){
            debugger;
            if(childIf){
				output += '<template is="if" _jsp="true" lyte-elif="true" value="{{';
				childIf = false;
			}else{
				output += '<template is="if" _jsp="true" value="{{';
			}
            try {				
                output += replaceSpecialCharWithHTML(getText(node.test));			
            } catch(e) {
                checkForError({errorMsg : e.message,node :e.node});
            }
            output += '}}"><template case="true">';
            var consequent = node.consequent
            var conbody = consequent.body
            if(conbody) {
                handleBlockStatement(conbody);
            } else {
                checkForError({errorMsg : "If statement body should be written within an curly braces",node :consequent})
            }		
            output += "</template>";
            var alternate = node.alternate;
            
            if(alternate) {
                
                if(alternate.type == "BlockStatement") {
                    var altbody = alternate.body;
                    output += '<template case="false">';
                    handleBlockStatement(altbody);
                    output += '</template>';
                } else if(alternate.type == "IfStatement") {
                    childIf = true;
                    output += '<template case="false">';
                    handleIfStatement(alternate);
                    output += '</template>';
                } else if(alternate.type == "ExpressionStatement") {
                    checkForError({errorMsg : "Else statement body should be written within an curly braces",node : alternate})				
                }
            }
            output += '</template>';
        }

        let handleBlockStatement = function(node){
            //createHelperFn();
            var fnBody = node;
            var i,len = fnBody.length;
            var block;
            for(i=0;i<len;i++){
                block = fnBody[i];
                switch(block.type){
                    case "BreakStatement" :
                    case "ReturnStatement" :
                        output += '<template is="break"></template>';
                    break;
                    case "VariableDeclaration":
                        var k ; 
                        var declarations = block.declarations;
                        var decllen = declarations.length;
                        var variableBlock;
                        for(k=0;k<decllen;k++){
                            variableBlock = declarations[k];
                            output += variableBlock.init.value; //The value assigned to the variable is recieved as init.raw
                        }
                    break;
                    case "ExpressionStatement":
                        var expressionObj = block.expression;
                        var type = expressionObj.type ;
                        var expressionObjProperty;

                        if(type === "CallExpression"){
                            expressionObjProperty = expressionObj.callee.property 
                            if((expressionObjProperty.name == "forEach" || expressionObjProperty.name == "forIn")){
                            //take the arguments from argument array to determind item and index.
                                handleForEach(expressionObj);
                            }
                        } else if(type === "AssignmentExpression"){
                            output += expressionObj.right.value;
                        }
                    break;
                    case "ForStatement":
                        checkForError({errorMsg : "For is not allowed try => forEach instead",node :block});
                        //handleForStatement(block);
                    break;
                    case "IfStatement":
                        handleIfStatement(block);
                    break;
                    case "SwitchStatement":
                        var switchCnd = block.discriminant;
                        output += '<template is="switch" _jsp="true" value =';
                        handleSwitchCondition(switchCnd);
                        output += '>';
                        handleSwitchCase(block.cases);
                        output += "</template>";
                    break;
                }
            }
        }
        
        let node = parser(content,{
            ecmaVersion : 11,
            sourceType : "module",
            loc : true,
            comment : true,
            jsescOption : {
                'wrap': false
            },
            cloneInputAst: false
        })
        traverse(node,{
            "FunctionDeclaration": function(path) {
                let {node} = path;
                if(node.original) {
                    node = node.original;
                }
                output = '';
                handleProgram(node);
                path.skip();
            }
        })
        return returnObj;
    } catch(e) {
        errorCount[file] = 1;
        returnObj.error = e;
        return returnObj;
    }

   

}
	
