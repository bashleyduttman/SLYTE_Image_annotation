(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('@stardazed/streams-compression')) :
	typeof define === 'function' && define.amd ? define(['@stardazed/streams-compression'], factory) :
	(global.ZWAF = factory(global.streamsCompression));
}(this, (function (streamsCompression) { 'use strict';

/**
 * Polyfills
 */

/**
 * 
 * It's a wrapper over Object.defineProperty for setting  data descriptors for object .A data descriptor is a property that has a value, which sets isWritable,isConfigurable,isEnumerable for an object. By default all configuration values are false.
 * 
 * Below function will define Object.defineProperty if not defined.
 * Normal property addition through assignment(=) creates properties.
 * But it shows up during property enumeration (for...in loop or Object.keys method), whose values may be changed or deleted.
 * And it may even create some unusual behaviour. The Object.defineProperty method allows
 * three extra details(configurable, writable, and enumerable) to be set for the value.
 * By default all the value are true. Since defineProperty is not supported
 * below IE-9 we have implemented fall back to directly assign value to the object
 *
 * @param   {Object} obj
 * @param   {string} property
 * @param   {value}  value
 * @param   {boolean}  isOverrideDefaultValue
 * @param   {boolean}  isWritable
 * @param   {boolean}  isConfigurable
 * @param   {boolean}  isEnumerable
 * @returns {Object}
 */
/* eslint-disable-next-line max-params */
function defineProperty(obj, property, value, isOverrideDefaultValue, isWritable, isConfigurable, isEnumerable) {
  if (!isOverrideDefaultValue && property in obj) {
    return;
  }
  if (!Object.defineProperty || !function () {
    try {
      Object.defineProperty({}, 'x', {}); // No I18N
      return true;
    } catch (e) {
      return false;
    }
  }()) {
    obj[property] = value;
    return obj;
  }

  isWritable = isWritable === true;
  isConfigurable = isConfigurable === true;
  isEnumerable = isEnumerable === true;
  return Object.defineProperty(obj, property, {
    value: value,
    writable: isWritable,
    configurable: isConfigurable,
    enumerable: isEnumerable
  });
}

/**
 * Defining String.prototype.codePointAt if not defined already
 * This is not supported in IE 11 and below
 */

var codePointAt = String.prototype.codePointAt;
if (!codePointAt) {
  /* eslint-disable-next-line no-extend-native */
  codePointAt = function codePointAt(position) {
    if (this === null) {
      throw new TypeError(' ');
    }
    var string = String(this);
    var size = string.length;
    // `ToInteger`
    var index = position ? Number(position) : 0;
    if (window.isNan(index)) {
      // Better `isNaN`
      index = 0;
    }
    // Account for out-of-bounds indices:
    if (index < 0 || index >= size) {
      return undefined;
    }
    // Get the first code unit
    var first = string.charCodeAt(index);
    var second = void 0;
    if (
    // Check if it's the start of a surrogate pair
    first >= 0xd800 && first <= 0xdbff && // High surrogate
    size > index + 1 // There is a next code unit
    ) {
        second = string.charCodeAt(index + 1);
        if (second >= 0xdc00 && second <= 0xdfff) {
          // Low surrogate
          // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
          return (first - 0xd800) * 0x400 + second - 0xdc00 + 0x10000;
        }
      }
    return first;
  };
}

/**
 * Defining String.fromCodePoint if not defined already
 * Which is not supported in many browsers like IE ,Android ,Opera Mobile
 * */

var fromCodePoint = String.fromCodePoint;
if (!fromCodePoint) {
  var stringFromCharCode = String.fromCharCode;
  var floor = Math.floor;

  fromCodePoint = function fromCodePoint() {
    var MAX_SIZE = 0x4000;
    var codeUnits = [];

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var length = args.length;

    var highSurrogate = void 0;
    var lowSurrogate = void 0;
    var index = -1;
    if (!length) {
      return ''; // No I18N
    }
    var result = ''; // No I18N
    while (++index < length) {
      var codePoint = Number(args[index]);
      if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
      codePoint < 0 || // Not a valid Unicode code point
      codePoint > 0x10ffff || // Not a valid Unicode code point
      floor(codePoint) !== codePoint // Not an integer
      ) {
          throw new RangeError('Invalid code point: ' + codePoint); // No I18N
        }
      if (codePoint <= 0xffff) {
        // BMP code point
        codeUnits.push(codePoint);
      } else {
        // Astral code point; split in surrogate halves
        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        codePoint -= 0x10000;
        highSurrogate = (codePoint >> 10) + 0xd800;
        lowSurrogate = codePoint % 0x400 + 0xdc00;
        codeUnits.push(highSurrogate, lowSurrogate);
      }
      if (index + 1 === length || codeUnits.length > MAX_SIZE) {
        result += stringFromCharCode.apply(undefined, codeUnits);
        codeUnits.length = 0;
      }
    }
    return result;
  };
}

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Logger = function () {
  function Logger(level) {
    _classCallCheck(this, Logger);

    this.LEVELS = {
      NONE: -1,
      DEBUG: 0,
      INFO: 1,
      WARN: 2,
      ERROR: 3
    };
    if (level === this.LEVELS.NONE || level === this.LEVELS.DEBUG || level === this.LEVELS.INFO || level === this.LEVELS.WARN || level === this.LEVELS.ERROR) {
      this.level = level;
    } else {
      this.level = this.LEVELS.ERROR;
    }
  }

  _createClass(Logger, [{
    key: "debug",
    value: function debug() {
      var _window;

      if (!window || !window.console || this.level === this.LEVELS.NONE || this.level !== this.LEVELS.DEBUG) {
        return;
      }

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      (_window = window["con" + "sole"]).debug.apply(_window, args.concat([performance.now()])); // No I18N
    }
  }, {
    key: "info",
    value: function info() {
      var _window2;

      if (!window || !window.console || this.level === this.LEVELS.NONE || this.level > this.LEVELS.INFO) {
        return;
      }

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      (_window2 = window["con" + "sole"]).log.apply(_window2, args.concat([performance.now()])); // No I18N
    }
  }, {
    key: "warn",
    value: function warn() {
      var _window3;

      if (!window || !window.console || this.level === this.LEVELS.NONE || this.level > this.LEVELS.WARN) {
        return;
      }

      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      (_window3 = window["con" + "sole"]).warn.apply(_window3, args.concat([performance.now()])); // No I18N
    }
  }, {
    key: "error",
    value: function error() {
      var _window4;

      if (!window || !window.console || this.level === this.LEVELS.NONE || this.level > this.LEVELS.ERROR) {
        return;
      }

      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      (_window4 = window["con" + "sole"]).error.apply(_window4, args.concat([performance.now()])); // No I18N
    }
  }]);

  return Logger;
}();

/**
 * @author: Patrick-2626 & Vigneshwar-5036
 *
 * @wiki: https://intranet.wiki.zoho.com/security/client-side-security.html
 *
 * Reference
 *  1)https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/
 *  2)https://github.com/danielstjules/blankshield
 */

var ZWAF$2 = window && window.ZWAF ? window.ZWAF : { version: '7.0.0' };
var logger = new Logger();

if (!ZWAF$2.defineProperty) {
  ZWAF$2.defineProperty = defineProperty;
}

if (!ZWAF$2.logger) {
  ZWAF$2.logger = logger;
}

if (!ZWAF$2['7_0_0']) {
  ZWAF$2['7_0_0'] = {
    version: '7.0.0',
    defineProperty: defineProperty,
    logger: logger
  };
}

/**
 * Display a message in the browser developer console, warning any unwary user.
 *
 * Only a static message is displayed for now. Support for giving API to user to customize message maybe given in future
 * INFO: This warning is linked to a common source (Wikipedia page).
 * This is because our products maybe used for Whitelabel Deployment and we shouldn't display anything specific to Zoho there.
 * So we will maintain this to be common source.
 */

var called = false;
var Console = {
  log: function log() {
    if (!window || !window.console || !window.console.log || !window.navigator || !window.navigator.userAgent || called) {
      return;
    }
    var userAgent = window.navigator.userAgent;

    var browser = userAgent.match(/opera|chrome|safari|firefox|msie|trident(?=\/)/i);
    called = true;
    if (browser && browser[0].search(/trident|msie/i) < 0) {
      // Supported  browser
      window.console.log('%cSTOP!', // No I18N
      'color:red;font-size:xx-large;font-weight:bold;' // No I18N
      );
      window.console.log("%cThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\nSee https://en.wikipedia.org/wiki/Self-XSS for more details", // No I18N
      'font-size:large;' // No I18N
      );
      return;
    }
    // Not supported browser
    window.console.log("STOP!\nThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\nSee https://en.wikipedia.org/wiki/Self-XSS for more details" // No I18N
    );
  }
};

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Custom Functions for Sanitizer
 **/

function objectIterator(obj, func) {
  if (!(obj instanceof Object)) {
    return;
  }
  for (var each in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, each)) {
      func(each, obj[each]);
    }
  }
}

function concatArray(arr1, arr2) {
  var _Array$prototype$spli;

  (_Array$prototype$spli = Array.prototype.splice).call.apply(_Array$prototype$spli, [arr1, arr1.length, 0].concat(_toConsumableArray(arr2)));
}

function toMap(list, key) {
  if (!list || list.constructor === Object) {
    return list;
  }
  var res = {};
  for (var i = 0; i < list.length; i++) {
    var each = list[i];
    res[each[key]] = each;
  }
  return res;
}

function toLowerCaseValue(value) {
  if (value && value.constructor === String) {
    return value.toLowerCase();
  }
  if (value.constructor === Array) {
    for (var i = 0; i < value.length; i++) {
      value[i] = toLowerCaseValue(value[i]);
    }
  }
  return value;
}

function copy(from, to, isDeepCopy, blackList) {
  if (Array.isArray(from)) {
    for (var i = 0, len = from.length; i < len; i++) {
      copyKey(from, to, i, isDeepCopy);
    }
  } else {
    for (var key in from) {
      if (blackList && blackList.indexOf(key) !== -1) {
        continue;
      }
      copyKey(from, to, key, isDeepCopy);
    }
  }
  return to;
}

function copyKey(from, to, key, isDeepCopy) {
  if (!isDeepCopy) {
    to[key] = from[key];
    return;
  }
  var obj = from[key];
  if (Array.isArray(obj)) {
    if (!to[key]) {
      to[key] = [];
    }
    copy(obj, to[key], isDeepCopy);
  } else if (obj instanceof Object) {
    if (!to[key]) {
      to[key] = {};
    }
    copy(obj, to[key], isDeepCopy);
  } else {
    to[key] = obj;
  }
}

/**
 * Custom Functions for Encoder
 **/

/**
 * Array.indexOf function is not supported below IE-9 .
 * Since defineProperty is not supported below IE-9 and many service teams are using
 * property enumeration (for...in loop) for Arrays (which is not recommended), the Array.indexOf
 * function is stored in the local variable(ZWAF.util.arrayIndexOf) instead of assigning
 * it directly to Array.prototype. And later it is called using ZWAF.util.arrayIndexOf.call(params...)
 *
 * @param   {Number|String}      searchElement  Element to search for in the array
 * @param   {...otherArguments}  args           Other arguments for Array.indexOf
 *
 * @return  {Number}                    Index of the given element in the array
 */
function indexOfPolyfill(searchElement) {
  if (this === undefined || this === null) {
    throw new TypeError(' ');
  }

  var t = {};
  var len = t.length >>> 0;
  if (len === 0) {
    return -1;
  }

  var n = 0;
  if ((arguments.length <= 1 ? 0 : arguments.length - 1) > 0) {
    n = Number(arguments.length <= 2 ? undefined : arguments[2]);
    if (isNaN(n)) {
      n = 0;
    } else if (n !== 0 && n !== 1 / 0 && n !== -(1 / 0)) {
      n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
  }

  if (n >= len) {
    return -1;
  }

  var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);

  for (; k < len; k++) {
    if (k in t && t.charAt(k) === searchElement) {
      return k;
    }
  }
  return -1;
}

var arrayIndexOf = Array.prototype.indexOf ? Array.prototype.indexOf : indexOfPolyfill;

/**
 * Cookie handling functions
 **/

function setCookie(name, value) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  options = Object.assign({
    path: '/',
    SameSite: 'lax', // No I18N
    // Default max age is 100 days
    'max-age': 100 * 24 * 60 * 60 * 1000 // No I18N
  }, options);
  if (!encodeURIComponent) {
    return;
  }
  var cookieVal = encodeURIComponent(name) + '=' + encodeURIComponent(value);

  for (var optionKey in options) {
    cookieVal += '; ' + optionKey;
    var optionValue = options[optionKey];
    if (optionValue !== true) {
      cookieVal += '=' + optionValue;
    }
  }
  document.cookie = cookieVal;
}
function deleteCookie(name) {
  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '/';

  setCookie(name, '', {
    path: path,
    'max-age': -1 // No I18N
  });
}

function getCookie(name) {
  name = name + '=';
  var cookieList = document.cookie;
  var res = void 0;
  cookieList.split('; ').forEach(function (cookie) {
    if (res !== undefined) {
      return;
    }
    var cookieValue = void 0;
    try {
      if (decodeURIComponent) {
        cookieValue = decodeURIComponent(cookie);
      }
    } catch (e) {
      cookieValue = cookie;
      ZWAF && ZWAF.logger && ZWAF.logger.warn && ZWAF.logger.warn("Error while trying to decode Cookie value!");
    }
    if (cookieValue.indexOf(name) === 0) {
      res = cookieValue.substring(name.length);
    }
  });
  return res;
}

function hasCookie(name) {
  return !!getCookie(name);
}

function getFromLocalStorage(name) {
  if (!window || !window.localStorage || name === undefined || name === null) {
    return null;
  }
  return window.localStorage.getItem(name);
}

function deleteFromLocalStorage(name) {
  if (!window || !window.localStorage || name === undefined || name === null) {
    return null;
  }
  return window.localStorage.removeItem(name);
}

function setToLocalStorage(name, value) {
  if (!window || !window.localStorage || name === undefined || name === null) {
    return null;
  }
  return window.localStorage.setItem(name, value);
}

function hasInLocalStorage(name) {
  return !!getFromLocalStorage(name);
}

function extend(obj, mixin, isDeep, isDeepMixArray) {
  if (!mixin) {
    return obj;
  }
  var keys = Object.keys(mixin);
  if (!keys.length) {
    return obj;
  }
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      var v2 = mixin[key];
      if (obj[key] === undefined) {
        obj[key] = mixin[key];
      } else if (isDeep) {
        var v1 = obj[key];
        if (is(v1, Object) && is(v2, Object)) {
          extend(v1, v2, isDeep, isDeepMixArray);
        } else if (isDeepMixArray && is(v1, Array) && is(v2, Array)) {
          obj[key] = v1.concat(v2);
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return obj;
}

// Unused functions
//
// function setArray(arr1, arr2){
//   arr1.splice.apply(arr1,[0,arr1.length].concat(arr2));
// }
//
// function addObjsToSet(set, set2) {
//   for (let each in set2) {
//     if (set2.hasOwnProperty(each)) {
//       set[each] = true;
//     }
//   }
//   return set;
// };
//
// function removeFromSet(set, key) {
//   delete set[key];
//   return set;
// }
//
// /* Add all object keys to array */
// function addToArr(array, set) {
//   let property;
//   for (property in set) {
//     if (set.hasOwnProperty(property)) {
//       array.push(property);
//     }
//   }
//   return array;
// }
//
// /* Add flags to config */
// function addToConfig(set, array) {
//   let l = array.length;
//   while (l--) {
//     set[array[l]] = true;
//   }
//   return set;
// }

if (ZWAF$2.version === '7.0.0' && !ZWAF$2.Console) {
  ZWAF$2.defineProperty(ZWAF$2, 'Console', // No I18N
  Console, true, false, false, true);
}
if (!ZWAF$2['7_0_0'].Console) {
  ZWAF$2.defineProperty(ZWAF$2['7_0_0'], 'Console', // No I18N
  Console, true, false, false, true);
}

var COOKIE_NAMES = ['_zcsr_tmp', // No I18N
'com_chat_owner', // No I18N
'com_avcliq_owner', // No I18N
'wms.agent' // No I18N
];
var loggedInUser = COOKIE_NAMES.some(function (e) {
  return hasCookie(e);
});
if (loggedInUser) {
  ZWAF$2 && ZWAF$2['7_0_0'] && ZWAF$2['7_0_0'].Console && ZWAF$2['7_0_0'].Console.log();
}

/**
 * Identify specific browsers like Chromium-based Ulaa, Brave, Arc
 *
 * These browsers are usually not identifiable through User-Agent Request Header
 * This is because they sometimes prefer to be identified as their parent browser (like Chromium)
 * to ensure webpages work correctly. But it is necessary for us to get accurate stats on browsers
 *
 * Eg: To show users which browser they recently used to log in
 *
 * Browser-specific identification or "duck-typing" is done to identify the browser.
 * If it is not in the list of usually identifiable browsers,
 * then we place this detail in a cookie named "_zwaf_ua".
 * For now, only browser name is added. Based on further needs we can add more info
 * like specific browser version and device type.
 */
var UA_COOKIE_NAME = '_zwaf_ua'; // No I18N

var UAIdentification = {
  /**
   * Called by default when SecurityJS is loaded.
   *
   */
  init: function init() {
    deleteCookie(UA_COOKIE_NAME);

    // Reference:
    // https://github.com/brave/brave-browser/issues/10165#issuecomment-641128278
    // https://github.com/brave/brave-browser/issues/10165#issuecomment-644949774
    var isUlaa = !!window.ulaa;
    var isBrave = navigator && navigator.brave && typeof navigator.brave.isBrave === 'function'; // No I18N
    if (isUlaa) {
      setCookie(UA_COOKIE_NAME, 'Ulaa'); // No I18N
    } else if (isBrave) {
      setCookie(UA_COOKIE_NAME, 'Brave'); // No I18N
    } else {
      // Reference:
      // https://webmasters.stackexchange.com/a/142231
      // Should be done after 1 second timeout after page is loaded.
      window && window.addEventListener('load', // No I18N
      function () {
        window.setTimeout(function () {
          var isArc = window.getComputedStyle(window.document.documentElement).getPropertyValue('--arc-palette-background'); // No I18N
          if (isArc) {
            setCookie(UA_COOKIE_NAME, 'Arc'); // No I18N
          }
        }, 1000);
      });
    }
  },
  disable: function disable() {
    // If any one does not want this cookie to be set, they can call ZWAF.UAIdentification.disable()
    deleteCookie(UA_COOKIE_NAME);
  }
};

if (ZWAF$2.version === '7.0.0' && !ZWAF$2.UAIdentification) {
  ZWAF$2.defineProperty(ZWAF$2, 'UAIdentification', // No I18N
  UAIdentification, true, false, false, true);
}
if (!ZWAF$2['7_0_0'].UAIdentification) {
  ZWAF$2.defineProperty(ZWAF$2['7_0_0'], 'UAIdentification', // No I18N
  UAIdentification, true, false, false, true);
}

ZWAF$2 && ZWAF$2['7_0_0'] && ZWAF$2['7_0_0'].UAIdentification && ZWAF$2['7_0_0'].UAIdentification.init();

/** @format */

var APP_AGENT_CONF_PROMISE = null;
var CSRF_DETAILS_PROMISE = null;
var CSRF_PROP_NAME = "csrf"; // No I18N
var CSRF_PARAM_PROP_NAME = "param_name"; // No I18N
var CSRF_COOKIE_PROP_NAME = "cookie_name"; // No I18N
var WAF_APP_AGENT_CONFIG_URL = "/waf/appAgentConf"; // No I18N

/**
 * Load App Agent Conf, primarily used now for getting CSRF info
 * As of now, this call will not be made. We are only using this to get CSRF param and cookie names
 * which are currently set by user using setCSRF.
 * But it might be used for other purposes in the future, and we will mandate getting this info
 * through the /waf call. So keeping this implementation for now.
 *
 * Response will be like:
 *   {
 *     csrf: {
 *       param_name: "ac_p"
 *       cookie_name: "_ca"
 *     }
 *   }
 * @return {Promise<Response>}
 */
function loadAppAgentConf() {

  if (APP_AGENT_CONF_PROMISE) {
    return APP_AGENT_CONF_PROMISE;
  }
  APP_AGENT_CONF_PROMISE = fetch(WAF_APP_AGENT_CONFIG_URL).catch(function (error) {
    throw Error("Error while fetching App Agent Conf: " + error); // No I18N
  });
  return APP_AGENT_CONF_PROMISE;
}

/**
 * Usage is like this:
 *    ZWAF.configuration.setCSRF({
 *      paramName: "_ca",
 *      cookieName: "ac_p"
 *    })
 * @param config
 */
function setCSRF(config) {
  if (config.paramName && config.cookieName) {
    CSRF_DETAILS_PROMISE = Promise.resolve([config.paramName, config.cookieName]);
  }
}

function getCSRFDetails() {
  if (CSRF_DETAILS_PROMISE) {
    return CSRF_DETAILS_PROMISE;
  }
  CSRF_DETAILS_PROMISE = this.loadAppAgentConf().then(function (response) {
    return response.json().then(function (jsonResponse) {
      var csrfParamName = jsonResponse && jsonResponse[CSRF_PROP_NAME] && jsonResponse[CSRF_PROP_NAME][CSRF_PARAM_PROP_NAME];
      if (!csrfParamName) {
        throw Error("Invalid CSRF Param Name in Conf"); // No I18N
      }
      var csrfCookieName = jsonResponse && jsonResponse[CSRF_PROP_NAME] && jsonResponse[CSRF_PROP_NAME][CSRF_COOKIE_PROP_NAME];
      if (!csrfCookieName) {
        throw Error("Invalid CSRF Cookie Name in Conf"); // No I18N
      }
      return [csrfParamName, csrfCookieName];
    });
  });
  return CSRF_DETAILS_PROMISE;
}

function getCSRFName() {
  return getCSRFDetails().then(function (response) {
    return response[0];
  });
}

function getCSRFValue() {
  return getCSRFDetails().then(function (response) {
    return response[1];
  });
}

var configuration = {
  setCSRF: setCSRF,
  getCSRFName: getCSRFName,
  getCSRFValue: getCSRFValue,
  getCSRFDetails: getCSRFDetails,
  loadAppAgentConf: loadAppAgentConf
};

if (Object.freeze) {
  Object.freeze(configuration);
}

if (ZWAF$2.version === '7.0.0' && !ZWAF$2.configuration) {
  ZWAF$2.defineProperty(ZWAF$2, 'configuration', // No I18N
  configuration, true, false, false, true);
}
if (!ZWAF$2['7_0_0'].configuration) {
  ZWAF$2.defineProperty(ZWAF$2['7_0_0'], 'configuration', // No I18N
  configuration, true, false, false, true);
}

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

/**
 * RequestUtils
 * */
var RequestUtils = {};
function mergeArrayBuffersToUint8Array(buffers) {
  var totalLength = buffers.reduce(function (acc, buffer) {
    return acc + buffer.byteLength;
  }, 0);
  var mergedUint8Array = new Uint8Array(totalLength);
  var offset = 0;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = buffers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var buffer = _step.value;

      mergedUint8Array.set(new Uint8Array(buffer), offset);
      offset += buffer.byteLength;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return mergedUint8Array;
}

function generateBoundaryString() {
  var prefix = "----WafFormBoundary"; // No I18N
  var length = 15;
  var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'; // No I18N
  var result = prefix;
  for (var i = 0; i <= length; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result;
}

function formUint8ArrayPayload(parts) {
  var te = new TextEncoder();
  var resultArrayBuffers = parts.map(function (each) {
    if (typeof each === "string") {
      return te.encode(each).buffer;
    } else {
      return each;
    }
  });
  return mergeArrayBuffersToUint8Array(resultArrayBuffers);
}

RequestUtils.createMultipartFormData = function (formData) {
  return new Promise(function (resolve, reject) {
    var boundary = generateBoundaryString();
    var parts = [];

    // Convert entries to an array for sequential processing
    var entries = Array.from(formData.entries());

    // Function to process each entry sequentially
    var processEntry = function processEntry(index) {
      if (index >= entries.length) {
        parts.push("--" + boundary + "--");

        var result = {};
        result.data = formUint8ArrayPayload(parts);
        result.boundary = boundary;
        resolve(result);
        return;
      }

      var _entries$index = _slicedToArray(entries[index], 2),
          name = _entries$index[0],
          value = _entries$index[1];

      if (value instanceof Blob) {
        value.arrayBuffer().then(function (fileBinaryArrayBuffer) {
          parts.push("--" + boundary + "\r\n", "Content-Disposition: form-data; name=\"" + name + "\"; filename=\"" + value.name + "\"\r\n", // No I18N
          "Content-Type: " + value.type + "\r\n", "\r\n", // No I18N
          fileBinaryArrayBuffer, "\r\n" // No I18N
          );
          processEntry(index + 1); // Process next entry
        }).catch(reject);
      } else {
        parts.push("--" + boundary + "\r\n", "Content-Disposition: form-data; name=\"" + name + "\"\r\n", // No I18N
        "\r\n", // No I18N
        value, "\r\n" // No I18N
        );
        processEntry(index + 1); // Process next entry
      }
    };

    // Start processing entries
    processEntry(0);
  });
};

if (Object.freeze) {
  Object.freeze(RequestUtils);
}

if (ZWAF$2.version === '7.0.0' && !ZWAF$2.RequestUtils) {
  ZWAF$2.defineProperty(ZWAF$2, 'RequestUtils', // No I18N
  RequestUtils, true, false, false, true);
}
if (!ZWAF$2['7_0_0'].RequestUtils) {
  ZWAF$2.defineProperty(ZWAF$2['7_0_0'], 'RequestUtils', // No I18N
  RequestUtils, true, false, false, true);
}

var util = {
  arrayIndexOf: arrayIndexOf
};

if (Object.freeze) {
  Object.freeze(util);
}

if (ZWAF$2.version === '7.0.0' && !ZWAF$2.util) {
  ZWAF$2.defineProperty(ZWAF$2, 'util', // No I18N
  util, true, false, false, true);
}
if (!ZWAF$2['7_0_0'].util) {
  ZWAF$2.defineProperty(ZWAF$2['7_0_0'], 'util', // No I18N
  util, true, false, false, true);
}

/**
 * Encoder
 * */
var Encoder = {};

function toCharCodeArr(charArr) {
  var charCodeArr = [];
  for (var i = 0; i < charArr.length; i++) {
    charCodeArr.push(charArr[i].charCodeAt(0));
  }
  return charCodeArr;
}
var arrayIndexOf$1 = util.arrayIndexOf;

var IMMUNE = {
  HTML: toCharCodeArr([',', '.', '-', '_', ' ']), // No I18N
  HTMLATTR: toCharCodeArr([',', '.', '-', '_']), // No I18N
  CSS: toCharCodeArr([]),
  JAVASCRIPT: toCharCodeArr([',', '.', '_']) // No I18N
};

var characterToEntityMap = {};
var characterToEntityArray = '34=&quot|38=&amp|60=&lt|62=&gt|160=&nbsp|161=&iexcl|162=&cent|163=&pound|164=&curren|165=&yen|166=&brvbar|167=&sect|168=&uml|169=&copy|170=&ordf|171=&laquo|172=&not|173=&shy|174=&reg|175=&macr|176=&deg|177=&plusmn|178=&sup2|179=&sup3|180=&acute|181=&micro|182=&para|183=&middot|184=&cedil|185=&sup1|186=&ordm|187=&raquo|188=&frac14|189=&frac12|190=&frac34|191=&iquest|192=&Agrave|193=&Aacute|194=&Acirc|195=&Atilde|196=&Auml|197=&Aring|198=&AElig|199=&Ccedil|200=&Egrave|201=&Eacute|202=&Ecirc|203=&Euml|204=&Igrave|205=&Iacute|206=&Icirc|207=&Iuml|208=&ETH|209=&Ntilde|210=&Ograve|211=&Oacute|212=&Ocirc|213=&Otilde|214=&Ouml|215=&times|216=&Oslash|217=&Ugrave|218=&Uacute|219=&Ucirc|220=&Uuml|221=&Yacute|222=&THORN|223=&szlig|224=&agrave|225=&aacute|226=&acirc|227=&atilde|228=&auml|229=&aring|230=&aelig|231=&ccedil|232=&egrave|233=&eacute|234=&ecirc|235=&euml|236=&igrave|237=&iacute|238=&icirc|239=&iuml|240=&eth|241=&ntilde|242=&ograve|243=&oacute|244=&ocirc|245=&otilde|246=&ouml|247=&divide|248=&oslash|249=&ugrave|250=&uacute|251=&ucirc|252=&uuml|253=&yacute|254=&thorn|255=&yuml|338=&OElig|339=&oelig|352=&Scaron|353=&scaron|376=&Yuml|402=&fnof|710=&circ|732=&tilde|913=&Alpha|914=&Beta|915=&Gamma|916=&Delta|917=&Epsilon|918=&Zeta|919=&Eta|920=&Theta|921=&Iota|922=&Kappa|923=&Lambda|924=&Mu|925=&Nu|926=&Xi|927=&Omicron|928=&Pi|929=&Rho|931=&Sigma|932=&Tau|933=&Upsilon|934=&Phi|935=&Chi|936=&Psi|937=&Omega|945=&alpha|946=&beta|947=&gamma|948=&delta|949=&epsilon|950=&zeta|951=&eta|952=&theta|953=&iota|954=&kappa|955=&lambda|956=&mu|957=&nu|958=&xi|959=&omicron|960=&pi|961=&rho|962=&sigmaf|963=&sigma|964=&tau|965=&upsilon|966=&phi|967=&chi|968=&psi|969=&omega|977=&thetasym|978=&upsih|982=&piv|8194=&ensp|8195=&emsp|8201=&thinsp|8204=&zwnj|8205=&zwj|8206=&lrm|8207=&rlm|8211=&ndash|8212=&mdash|8216=&lsquo|8217=&rsquo|8218=&sbquo|8220=&ldquo|8221=&rdquo|8222=&bdquo|8224=&dagger|8225=&Dagger|8226=&bull|8230=&hellip|8240=&permil|8242=&prime|8243=&Prime|8249=&lsaquo|8250=&rsaquo|8254=&oline|8260=&frasl|8364=&euro|8465=&image|8472=&weierp|8476=&real|8482=&trade|8501=&alefsym|8592=&larr|8593=&uarr|8594=&rarr|8595=&darr|8596=&harr|8629=&crarr|8656=&lArr|8657=&uArr|8658=&rArr|8659=&dArr|8660=&hArr|8704=&forall|8706=&part|8707=&exist|8709=&empty|8711=&nabla|8712=&isin|8713=&notin|8715=&ni|8719=&prod|8721=&sum|8722=&minus|8727=&lowast|8730=&radic|8733=&prop|8734=&infin|8736=&ang|8743=&and|8744=&or|8745=&cap|8746=&cup|8747=&int|8756=&there4|8764=&sim|8773=&cong|8776=&asymp|8800=&ne|8801=&equiv|8804=&le|8805=&ge|8834=&sub|8835=&sup|8836=&nsub|8838=&sube|8839=&supe|8853=&oplus|8855=&otimes|8869=&perp|8901=&sdot|8968=&lceil|8969=&rceil|8970=&lfloor|8971=&rfloor|10216=&lang|10217=&rang|9674=&loz|9824=&spades|9827=&clubs|9829=&hearts|9830=&diams'; // No I18N
characterToEntityArray = characterToEntityArray.split('|'); // No I18N
for (var i = 0; i < characterToEntityArray.length; i++) {
  var eachEntry = characterToEntityArray[i].split('='); // No I18N
  characterToEntityMap[eachEntry[0]] = eachEntry[1];
}

var hex = [];
for (var c = 0; c < 0xff; c++) {
  if (c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c >= 0x61 && c <= 0x7a) {
    hex[c] = null;
  } else {
    hex[c] = c.toString(16);
  }
}

function getHexForNonAlphanumeric(c) {
  if (c < 256) {
    return hex[c];
  }
  return c.toString(16);
}

function encodeHTMLCharacter(immuneCharList, c) {
  if (arrayIndexOf$1.call(immuneCharList, c) !== -1) {
    return fromCodePoint(c);
  }
  var hex = getHexForNonAlphanumeric(c);
  if (hex === null) {
    return fromCodePoint(c);
  }

  // Returning space for non printable characters
  if (c <= 0x1f && c != 0x09 && c != 0x0a && c != 0x0d || c >= 0x7f && c <= 0x9f || c === 0x20) {
    return '&#x20;'; // No I18N
  }
  var entityName = characterToEntityMap[c];
  if (entityName !== undefined) {
    return entityName + ';'; // No I18N
  }
  return '&#x' + hex + ';'; // No I18N
}

function encodeJSCharacter(immuneCharList, c) {
  if (arrayIndexOf$1.call(immuneCharList, c) !== -1) {
    return String.fromCharCode(c);
  }
  var hex = getHexForNonAlphanumeric(c);
  if (hex === null) {
    return String.fromCharCode(c);
  }
  var tmp = c.toString(16);
  var pad = void 0;
  if (c < 256) {
    pad = '00'.substr(tmp.length); // No I18N
    return '\\x' + pad + tmp.toUpperCase(); // No I18N
  }
  pad = '0000'.substr(tmp.length); // No I18N
  return '\\u' + pad + tmp.toUpperCase(); // No I18N
}

function encodeCSSCharacter(immuneCharList, c) {
  if (arrayIndexOf$1.call(immuneCharList, c) !== -1) {
    return fromCodePoint(c);
  }

  var hex = getHexForNonAlphanumeric(c);
  if (hex === null) {
    return fromCodePoint(c);
  }
  return '\\' + hex + ' '; // No I18N
}

/**
 * Iterates over the characters in sInput and calls characterEncoder to encode them
 * Based on isHandleUnicodeChar value, iteration is done by either code unit or code point
 *
 * @param   {Array}     immuneCharList       List of immune characters to not encode
 * @param   {String}    sInput               String of characters to encode
 * @param   {Function}  characterEncoder     Function to encode each character
 * @param   {Boolean}   isHandleUnicodeChar  Determines iteration technique, either by code unit or code point
 *
 * @return  {String}                        Encoded sInput string
 */
function encode(immuneCharList, sInput, characterEncoder, isHandleUnicodeChar) {
  if (sInput === null || sInput === undefined || typeof sInput !== 'string') {
    // No I18N
    return sInput;
  }
  var out = '';
  for (var _i = 0; _i < sInput.length; _i++) {
    if (isHandleUnicodeChar) {
      var _c = codePointAt.call(sInput, _i);
      out += characterEncoder(immuneCharList, _c, isHandleUnicodeChar);
      if (_c > 0xffff) {
        _i++;
      }
    } else {
      out += characterEncoder(immuneCharList, sInput.charCodeAt(_i));
    }
  }
  return out;
}

/**
 * Encodes text which has to be rendered as element text i.e., as HTML.
 * Here input has to be iterated by code point
 *
 * @param   {String}  input  Text to be encoded
 *
 * @return  {String}         Encoded Text
 */
Encoder.encodeForHTML = function (input) {
  return encode(IMMUNE.HTML, input, encodeHTMLCharacter, true);
};

/**
 * Encodes text which has to be rendered as HTML attribute value (except JS attributes like onclick, onblur etc.)
 * Here input has to be iterated by code point
 *
 * @param   {String}  input  Text to be encoded
 *
 * @return  {String}         Encoded Text
 */
Encoder.encodeForHTMLAttribute = function (input) {
  return encode(IMMUNE.HTMLATTR, input, encodeHTMLCharacter, true);
};

/**
 * Encodes text which has to be rendered inside the script tag
 * or inside HTML attributes which are executed as JavaScript (like onclick, onblur etc.)
 * Here input has to be iterated by code unit
 *
 * @param   {String}  input  Text to be encoded
 *
 * @return  {String}         Encoded Text
 */
Encoder.encodeForJavaScript = function (input) {
  return encode(IMMUNE.JAVASCRIPT, input, encodeJSCharacter, false);
};

/**
 * Encodes text which has to be rendered as CSS property name or value
 * Here input has to be iterated by code unit
 *
 * @param   {String}  input  Text to be encoded
 *
 * @return  {String}         Encoded Text
 */
Encoder.encodeForCSS = function (input) {
  return encode(IMMUNE.CSS, input, encodeCSSCharacter, true);
};

if (Object.freeze) {
  Object.freeze(Encoder);
}

if (ZWAF$2.version === '7.0.0' && !ZWAF$2.Encoder) {
  ZWAF$2.defineProperty(ZWAF$2, 'Encoder', // No I18N
  Encoder, true, false, false, true);
}
if (!ZWAF$2['7_0_0'].Encoder) {
  ZWAF$2.defineProperty(ZWAF$2['7_0_0'], 'Encoder', // No I18N
  Encoder, true, false, false, true);
}

var _createClass$1 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** @format */
var defaultConfig = {
  algorithm: "RSA-OAEP", // No I18N
  key_hash: "SHA-256", // No I18N
  key_size: 2048,
  key_encoding: "Base64", // No I18N
  transmission_algorithm: "AES-GCM", // No I18N

  publicKeyFormat: "spki", // No I18N
  privateKeyFormat: "pkcs8", // No I18N
  transmission_key_length: 256,
  transmission_iv_length: 12,

  logLevel: 3
};

var PayloadEncryptAgent = function () {
  function PayloadEncryptAgent(config) {
    _classCallCheck$1(this, PayloadEncryptAgent);

    config = extend(config || {}, defaultConfig);
    this.KEY_USAGES = {
      ENCRYPT: "encrypt", // No I18N
      DECRYPT: "decrypt" // No I18N
    };
    this.asymmetricEncryptionAlgorithm = config.algorithm;
    this.asymmetricEncryptionHash = config.key_hash;
    this.asymmetricEncryptionKeySize = config.key_size;
    this.asymmetricPublicKeyFormat = config.publicKeyFormat;
    this.asymmetricPrivateKeyFormat = config.privateKeyFormat;

    this.symmetricKeyEncryptionAlgorithm = config.transmission_algorithm;
    this.symmetricKeyLength = config.transmission_key_length;
    this.symmetricKeyIVLength = config.transmission_iv_length;
    this.logger = new Logger(config.logLevel);
  }

  _createClass$1(PayloadEncryptAgent, [{
    key: "setLogLevel",
    value: function setLogLevel(level) {
      this.logger = new Logger(level);
    }

    /**
     * Convert a Base64 String to Uint8Array
     * Since we are only dealing with base64 characters (which are within ASCII range),
     * no need to use codePointAt instead of charCodeAt
     * @param {String} base64string
     * @returns {Uint8Array}
     */

  }, {
    key: "base64ToUint8Array",
    value: function base64ToUint8Array(base64string) {
      var binaryString = atob(base64string);
      var bytes = new Uint8Array(binaryString.length);
      for (var i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return bytes;
    }

    /**
     * Convert a Uint8Array to Base64 String
     * Since we are only dealing with base64 characters (which are within ASCII range),
     * no need to use fromCodePoint instead of fromCharCode
     * @param {Uint8Array} uint8array
     * @returns {String}
     */

  }, {
    key: "uint8ArrayToBase64",
    value: function uint8ArrayToBase64(uint8array) {
      var binaryString = "";
      for (var i = 0; i < uint8array.length; i++) {
        binaryString += String.fromCharCode(uint8array[i]);
      }
      return btoa(binaryString);
    }

    /**
     * Convert data to binary (ArrayBuffer format)
     * This would be called to normalize data to be encrypted,
     * which can be normal string information or binary data like files.
     *
     * @param {String|Uint8Array|ArrayBuffer} data
     * @return {ArrayBuffer}
     */

  }, {
    key: "convertToBinary",
    value: function convertToBinary(data) {
      if (data.constructor === ArrayBuffer) {
        return data;
      }
      if (typeof data === "string") {
        // No I18N
        var dataBytes = new TextEncoder().encode(data); // Convert the given string to Uint8Array
        return dataBytes.buffer;
      }
      if (data.constructor === Uint8Array) {
        return data.buffer;
      }
      throw new Error("Data cannot be converted to Binary!"); // No I18N
    }

    /**
     * Export binary data to binary (ArrayBuffer format)
     * This would be called to normalize data to be encrypted,
     * which can be normal string information or binary data like files.
     *
     * @param {Uint8Array | Uint8Array[] | ArrayBuffer | ArrayBuffer[]} data
     * @return {String | String[]}
     */

  }, {
    key: "exportBinary",
    value: function exportBinary(data) {
      var _this = this;

      if (data.constructor === Array) {
        return data.map(function (eachData) {
          return _this.exportBinary(eachData);
        });
      }
      if (data.constructor === ArrayBuffer) {
        return this.uint8ArrayToBase64(new Uint8Array(data));
      }
      if (data.constructor === Uint8Array) {
        return this.uint8ArrayToBase64(data);
      }
      throw new Error("Data is not in Binary format!"); // No I18N
    }

    /**
     * Normalize binary data to ArrayBuffer
     * This would be called to normalize encrypted data or any binary data.
     * If datatype is string, then we can assume it is base64 encoded binary data.
     *
     * @param {String|Uint8Array|ArrayBuffer} binaryData
     * @return {ArrayBuffer}
     */

  }, {
    key: "normalizeBinaryData",
    value: function normalizeBinaryData(binaryData) {
      if (binaryData.constructor === ArrayBuffer) {
        return binaryData;
      } else if (typeof binaryData === "string") {
        // No I18N
        var binaryDataArray = this.base64ToUint8Array(binaryData);
        return binaryDataArray.buffer;
      } else if (binaryData.constructor === Uint8Array) {
        return binaryData.buffer;
      }
      throw new Error("Data cannot be normalized to Binary!"); // No I18N
    }

    /**
     * Get the asymmetric algorithm details for importing the asymmetric key
     * @param algorithm
     * @param keySize
     * @returns {RsaHashedKeyGenParams}
     */

  }, {
    key: "getAsymmetricEncryptionAlgorithmForGeneration",
    value: function getAsymmetricEncryptionAlgorithmForGeneration(algorithm, keySize) {
      return {
        name: algorithm || this.asymmetricEncryptionAlgorithm,
        hash: this.asymmetricEncryptionHash,
        modulusLength: keySize || this.asymmetricEncryptionKeySize,
        publicExponent: new Uint8Array([0x01, 0x00, 0x01])
      };
    }

    /**
     * Get the asymmetric algorithm details for importing the asymmetric key
     * @return {RsaHashedImportParams}
     */

  }, {
    key: "getAsymmetricEncryptionAlgorithmForImport",
    value: function getAsymmetricEncryptionAlgorithmForImport() {
      return {
        name: this.asymmetricEncryptionAlgorithm,
        hash: this.asymmetricEncryptionHash
      };
    }

    /**
     * Get the asymmetric algorithm details for encrypting/decrypting using the asymmetric key
     * @return {RsaOaepParams}
     */

  }, {
    key: "getAsymmetricEncryptionAlgorithmForUsage",
    value: function getAsymmetricEncryptionAlgorithmForUsage() {
      return { name: this.asymmetricEncryptionAlgorithm };
    }

    /**
     * Get the symmetric algorithm details for generating a new symmetric key
     * @return {AesKeyGenParams}
     */

  }, {
    key: "getSymmetricEncryptionAlgorithmForGeneration",
    value: function getSymmetricEncryptionAlgorithmForGeneration() {
      return {
        name: this.symmetricKeyEncryptionAlgorithm,
        length: this.symmetricKeyLength
      };
    }

    /**
     * Get the symmetric algorithm details for importing the symmetric key
     * @return {AlgorithmIdentifier}
     */

  }, {
    key: "getSymmetricEncryptionAlgorithmForImport",
    value: function getSymmetricEncryptionAlgorithmForImport() {
      return {
        name: this.symmetricKeyEncryptionAlgorithm
      };
    }

    /**
     * Get the symmetric algorithm details for encrypting/decrypting using the symmetric key
     * @return {AesGcmParams}
     */

  }, {
    key: "getSymmetricEncryptionAlgorithmForUsage",
    value: function getSymmetricEncryptionAlgorithmForUsage(IVBytes) {
      return {
        name: this.symmetricKeyEncryptionAlgorithm,
        iv: IVBytes
      };
    }

    /**
     * Generate a new asymmetric key pair
     * @param algorithm
     * @param keySize
     * @returns {Promise<CryptoKeyPair>}
     */

  }, {
    key: "generateAsymmetricKeyPair",
    value: function generateAsymmetricKeyPair(algorithm, keySize) {
      return crypto.subtle.generateKey(this.getAsymmetricEncryptionAlgorithmForGeneration(algorithm, keySize), true, [this.KEY_USAGES.ENCRYPT, this.KEY_USAGES.DECRYPT]).catch(function (error) {
        throw new Error("Failed to generate symmetric key! Error: " + error); // No I18N
      });
    }

    /**
     * Import the Asymmetric PublicKey
     * @param {String|Uint8Array|ArrayBuffer|CryptoKey} publicKey
     * @returns {Promise<CryptoKey>}
     */

  }, {
    key: "importAsymmetricPublicKey",
    value: function importAsymmetricPublicKey(publicKey) {
      if (publicKey === null || publicKey.constructor === CryptoKey) {
        return Promise.resolve(publicKey);
      }
      var publicKeyBuffer = this.normalizeBinaryData(publicKey);
      var algorithm = this.getAsymmetricEncryptionAlgorithmForImport();
      return crypto.subtle.importKey(this.asymmetricPublicKeyFormat, publicKeyBuffer, algorithm, true, [this.KEY_USAGES.ENCRYPT]).catch(function (error) {
        throw new Error("Failed to import Asymmetric Public Key! Algorithm: " + JSON.stringify(algorithm) + " Error: " + error);
      });
    }

    /**
     * Import the Asymmetric PrivateKey
     * @param {String|Uint8Array|ArrayBuffer|CryptoKey} privateKey
     * @returns {Promise<CryptoKey>}
     */

  }, {
    key: "importAsymmetricPrivateKey",
    value: function importAsymmetricPrivateKey(privateKey) {
      if (privateKey === null || privateKey.constructor === CryptoKey) {
        return Promise.resolve(privateKey);
      }
      var privateKeyBuffer = this.normalizeBinaryData(privateKey);
      var algorithm = this.getAsymmetricEncryptionAlgorithmForImport();
      // Import the public key
      return crypto.subtle.importKey(this.asymmetricPrivateKeyFormat, privateKeyBuffer, algorithm, true, [this.KEY_USAGES.DECRYPT]).catch(function (error) {
        throw new Error("Failed to import asymmetric private key! Algorithm: " + JSON.stringify(algorithm) + " Error: " + error);
      });
    }

    /**
     * Export the asymmetric public key
     * @param {CryptoKey} key
     * @returns {Promise<ArrayBuffer>}
     */

  }, {
    key: "exportAsymmetricPublicKey",
    value: function exportAsymmetricPublicKey(key) {
      if (key === null) {
        return Promise.resolve(key);
      }
      return crypto.subtle.exportKey(this.asymmetricPublicKeyFormat, key).catch(function (error) {
        throw new Error("Failed to export asymmetric public key! Error: " + error); // No I18N
      });
    }

    /**
     * Export the asymmetric private key
     * @param {CryptoKey} key
     * @returns {Promise<ArrayBuffer>}
     */

  }, {
    key: "exportAsymmetricPrivateKey",
    value: function exportAsymmetricPrivateKey(key) {
      if (key === null) {
        return Promise.resolve(key);
      }
      return crypto.subtle.exportKey(this.asymmetricPrivateKeyFormat, key).catch(function (error) {
        throw new Error("Failed to export asymmetric private key! Error: " + error); // No I18N
      });
    }

    /**
     * Generate IV for Symmetric Key
     * @returns {Uint8Array}
     */

  }, {
    key: "generateIV",
    value: function generateIV() {
      return crypto.getRandomValues(new Uint8Array(this.symmetricKeyIVLength));
    }

    /**
     * Extract the IV bytes from the Symmetric Key Data
     * @param {Uint8Array} AESKeyArray
     * @return {Uint8Array}
     */

  }, {
    key: "extractIVBytes",
    value: function extractIVBytes(AESKeyArray) {
      return AESKeyArray.slice(AESKeyArray.length - this.symmetricKeyIVLength);
    }

    /**
     * Extract the key bytes from the Symmetric Key Data
     * @param {Uint8Array} AESKeyArray
     * @return {Uint8Array}
     */

  }, {
    key: "extractSymmetricKeyBytes",
    value: function extractSymmetricKeyBytes(AESKeyArray) {
      return AESKeyArray.slice(0, AESKeyArray.length - this.symmetricKeyIVLength);
    }

    /**
     * Generate a new symmetric key
     * @returns {Promise<CryptoKey>}
     */

  }, {
    key: "generateSymmetricKey",
    value: function generateSymmetricKey() {
      return crypto.subtle.generateKey(this.getSymmetricEncryptionAlgorithmForGeneration(), true, [this.KEY_USAGES.ENCRYPT, this.KEY_USAGES.DECRYPT]).catch(function (error) {
        throw new Error("Failed to generate symmetric key! Error: " + error); // No I18N
      });
    }

    /**
     * Generate a new symmetric key
     * @param {String|Uint8Array|ArrayBuffer|Object} [key]
     * @returns {Promise<{key:CryptoKey,iv:Uint8Array}>}
     */

  }, {
    key: "getSymmetricKey",
    value: function getSymmetricKey(key) {
      var _this2 = this;

      var symmetricKeyPromise = void 0;
      var IVBytes = void 0;
      if (!key || key.constructor !== Object && key.constructor !== String && key.constructor !== Uint8Array && key.constructor !== ArrayBuffer) {
        symmetricKeyPromise = this.generateSymmetricKey();
        IVBytes = this.generateIV();
        symmetricKeyPromise.then(function (generatedKey) {
          _this2.logger.debug("Symmetric key generated: ", generatedKey); // No I18N
        });
      } else if (key.constructor === Object && key.key && key.key.constructor === CryptoKey && key.iv && key.iv.constructor === Uint8Array) {
        // reuse that key
        symmetricKeyPromise = Promise.resolve(key.key);
        IVBytes = key.iv;
      } else {
        var symmetricKeyArray = new Uint8Array(this.normalizeBinaryData(key));
        var symmetricKeyBytes = this.extractSymmetricKeyBytes(symmetricKeyArray);
        IVBytes = this.extractIVBytes(symmetricKeyArray);
        this.logger.debug("IV Bytes extracted: ", IVBytes); // No I18N
        symmetricKeyPromise = this.importSymmetricKey(symmetricKeyBytes);
        symmetricKeyPromise.then(function (importedKey) {
          _this2.logger.debug("Symmetric key imported: ", importedKey); // No I18N
        });
      }
      if (symmetricKeyPromise) {
        return symmetricKeyPromise.then(function (symmetricKey) {
          return {
            key: symmetricKey,
            iv: IVBytes
          };
        });
      } else {
        this.logger.error("Failed to get symmetric key!", key); // No I18N
      }
    }

    /**
     * Import the symmetric key bytes as a usable CryptoKey
     * @param {Uint8Array} key
     * @return {Promise<CryptoKey>}
     */

  }, {
    key: "importSymmetricKey",
    value: function importSymmetricKey(key) {
      var _this3 = this;

      return crypto.subtle.importKey("raw", // No I18N
      key.buffer, this.getSymmetricEncryptionAlgorithmForImport(), true, [this.KEY_USAGES.ENCRYPT, this.KEY_USAGES.DECRYPT]).catch(function (error) {
        _this3.logger.debug("Encrypted symmetric key bytes: ", key); // No I18N
        throw new Error("Failed to import symmetric key! Error: " + error);
      });
    }

    /**
     * Export the symmetric key
     * @param {CryptoKey} key
     * @returns {Promise<ArrayBuffer>}
     */

  }, {
    key: "exportSymmetricKey",
    value: function exportSymmetricKey(key) {
      return crypto.subtle.exportKey("raw", key) // No I18N
      .catch(function (error) {
        throw new Error("Failed to export symmetric key! Error: " + error); // No I18N
      });
    }

    /**
     * Encrypt the symmetric key data with asymmetric public key
     * @param {Uint8Array} aesKeyIV
     * @param {CryptoKey} publicKey
     * @returns {Promise<ArrayBuffer>}
     */

  }, {
    key: "encryptWithPublicKey",
    value: function encryptWithPublicKey(aesKeyIV, publicKey) {
      var _this4 = this;

      // Import the public key
      return this.importAsymmetricPublicKey(publicKey).then(function (asymmetricKey) {
        _this4.logger.debug("Asymmetric key imported: ", asymmetricKey); // No I18N
        var asymmetricAlgorithm = _this4.getAsymmetricEncryptionAlgorithmForUsage();
        // Encrypt data using the public key
        return _this4._encrypt(aesKeyIV, asymmetricKey, asymmetricAlgorithm).catch(function (error) {
          throw new Error("Failed to encrypt the symmetric key with asymmetric public key! Error: " + // No I18N
          error);
        });
      });
    }

    /**
     * Decrypt the symmetric key data with asymmetric private key
     * @param {String} encryptedSymmetricKey
     * @param {CryptoKey} privateKey
     * @return {Promise<ArrayBuffer>}
     */

  }, {
    key: "decryptWithPrivateKey",
    value: function decryptWithPrivateKey(encryptedSymmetricKey, privateKey) {
      var _this5 = this;

      return this.importAsymmetricPrivateKey(privateKey).then(function (asymmetricKey) {
        _this5.logger.debug("Asymmetric key imported: ", asymmetricKey); // No I18N
        // Encrypt data using the public key
        var asymmetricAlgorithm = _this5.getAsymmetricEncryptionAlgorithmForUsage();
        return _this5._decrypt(encryptedSymmetricKey, asymmetricKey, asymmetricAlgorithm).catch(function (error) {
          _this5.logger.warn("Failed to decrypt the symmetric key with asymmetric private key! Encrypted symmetric key bytes: ", // No I18N
          encryptedSymmetricKey);
          throw new Error("Failed to decrypt the symmetric key with asymmetric private key! Error: " + // No I18N
          error);
        });
      });
    }

    /**
     * Merge the symmetric key and IV, so they can be exported together
     * @param keyBytes
     * @param IVBytes
     * @return {Uint8Array}
     */

  }, {
    key: "mergeSymmetricKeyAndIV",
    value: function mergeSymmetricKeyAndIV(keyBytes, IVBytes) {
      if (keyBytes.constructor === ArrayBuffer) {
        keyBytes = new Uint8Array(keyBytes);
      }
      var keyAndIV = new Uint8Array(keyBytes.length + IVBytes.length);
      keyAndIV.set(keyBytes);
      keyAndIV.set(IVBytes, keyBytes.length);
      return keyAndIV;
    }

    /**
     *
     * @param {ArrayBuffer} symmetricKeyData
     * @return {Promise<{key: CryptoKey, iv: Uint8Array}>}
     */

  }, {
    key: "importSymmetricKeyAndIV",
    value: function importSymmetricKeyAndIV(symmetricKeyData) {
      var _this6 = this;

      var symmetricKeyArray = new Uint8Array(symmetricKeyData);
      var symmetricKeyBytes = this.extractSymmetricKeyBytes(symmetricKeyArray);
      var decryptedIVBytes = this.extractIVBytes(symmetricKeyArray);
      this.logger.debug("IV Bytes extracted: ", decryptedIVBytes); // No I18N
      return this.importSymmetricKey(symmetricKeyBytes).then(function (importedSymmetricKey) {
        _this6.logger.debug("AES Key imported: ", importedSymmetricKey); // No I18N
        return {
          key: importedSymmetricKey,
          iv: decryptedIVBytes
        };
      });
    }

    /**
     *
     * @param {CryptoKey} symmetricKey
     * @param {Uint8Array} IVBytes
     * @return {Promise<Uint8Array>}
     */

  }, {
    key: "exportSymmetricKeyAndIV",
    value: function exportSymmetricKeyAndIV(symmetricKey, IVBytes) {
      var _this7 = this;

      return this.exportSymmetricKey(symmetricKey).then(function (symmetricKeyBytes) {
        var keyAndIV = _this7.mergeSymmetricKeyAndIV(symmetricKeyBytes, IVBytes);
        _this7.logger.debug("Symmetric key exported: ", keyAndIV); // No I18N
        return keyAndIV;
      });
    }

    /**
     *
     * @param {Uint8Array} keyAndIV
     * @param {CryptoKey} publicKey
     * @return {Promise<ArrayBuffer>}
     */

  }, {
    key: "encryptSymmetricKeyAndIV",
    value: function encryptSymmetricKeyAndIV(keyAndIV, publicKey) {
      var _this8 = this;

      // Encrypt the key with RSA Public Key
      return this.encryptWithPublicKey(keyAndIV, publicKey).then(function (encryptedSymmetricKey) {
        _this8.logger.debug("Symmetric key encrypted: ", encryptedSymmetricKey); // No I18N
        return encryptedSymmetricKey;
      });
    }

    /**
     *
     * @param {String} encryptedSymmetricKey
     * @param {CryptoKey} privateKey
     * @return {Promise<ArrayBuffer>}
     */

  }, {
    key: "decryptSymmetricKeyAndIV",
    value: function decryptSymmetricKeyAndIV(encryptedSymmetricKey, privateKey) {
      var _this9 = this;

      return this.decryptWithPrivateKey(encryptedSymmetricKey, privateKey).then(function (symmetricKeyData) {
        _this9.logger.debug("AES Key Data decrypted: "); // No I18N
        return symmetricKeyData;
      });
    }

    /**
     *
     * @param {String|Uint8Array|ArrayBuffer} data
     * @param {CryptoKey} key
     * @param {RsaOaepParams,AesGcmParams} algorithm
     * @return {Promise<ArrayBuffer>}
     */

  }, {
    key: "_encrypt",
    value: function _encrypt(data, key, algorithm) {
      var dataArrayBuffer = this.convertToBinary(data);
      return crypto.subtle.encrypt(algorithm, key, dataArrayBuffer);
    }

    /**
     *
     * @param {String|Uint8Array|ArrayBuffer} data
     * @param {CryptoKey} key
     * @param {RsaOaepParams,AesGcmParams} algorithm
     * @return {Promise<ArrayBuffer>}
     */

  }, {
    key: "_decrypt",
    value: function _decrypt(data, key, algorithm) {
      var dataArrayBuffer = this.normalizeBinaryData(data);
      return crypto.subtle.decrypt(algorithm, key, dataArrayBuffer);
    }

    /**
     * Encrypt the given payload using symmetric key encryption
     * @param {String|Uint8Array|ArrayBuffer} data
     * @param {String|Uint8Array|ArrayBuffer|Object} [symmetricKey]
     * @return {Promise<{key:Uint8Array, data: ArrayBuffer|ArrayBuffer[]}>}
     */

  }, {
    key: "encrypt",
    value: function encrypt(data, symmetricKey) {
      var _this10 = this;

      this.logger.debug("Encryption started: "); // No I18N
      return this.getSymmetricKey(symmetricKey).then(function (_ref) {
        var key = _ref.key,
            iv = _ref.iv;

        var symmetricKeyAlgorithm = _this10.getSymmetricEncryptionAlgorithmForUsage(iv);
        _this10.logger.debug("Symmetric Encryption Algorithm: ", // No I18N
        symmetricKeyAlgorithm);
        return _this10.exportSymmetricKeyAndIV(key, iv).then(function (keyAndIV) {
          var dataArray = Array.isArray(data) ? data : [data];
          var promiseArray = dataArray.map(function (eachData, index) {
            _this10.logger.debug("Started encrypting data in " + index + ": ", eachData);
            return _this10._encrypt(eachData, key, symmetricKeyAlgorithm).then(function (encryptedData) {
              _this10.logger.debug("Finished encrypting data in " + index + ": ", encryptedData);
              return encryptedData;
            }).catch(function (error) {
              throw new Error("Failed to encrypt the data using Symmetric Encryption: " + // No I18N
              error);
            });
          });
          return Promise.all(promiseArray).then(function (encryptedData) {
            _this10.logger.debug("Encryption finished: "); // No I18N
            return {
              key: keyAndIV,
              data: encryptedData.length === 1 ? encryptedData[0] : encryptedData
            };
          });
        });
      });
    }

    /**
     * Decrypt the given payload using the given encrypted symmetric key
     * @param {String|Uint8Array|ArrayBuffer|Array} encryptedData
     * @param {ArrayBuffer} symmetricKeyData
     * @return {Promise<ArrayBuffer|Array<ArrayBuffer>>}
     */

  }, {
    key: "decrypt",
    value: function decrypt(encryptedData, symmetricKeyData) {
      var _this11 = this;

      this.logger.debug("Decryption started: "); // No I18N
      return this.importSymmetricKeyAndIV(symmetricKeyData).then(function (_ref2) {
        var key = _ref2.key,
            iv = _ref2.iv;

        var symmetricKeyAlgorithm = _this11.getSymmetricEncryptionAlgorithmForUsage(iv);
        if (!Array.isArray(encryptedData)) {
          encryptedData = [encryptedData];
        }
        var promiseArray = encryptedData.map(function (eachData, index) {
          _this11.logger.debug("Started decrypting data in " + index + ": ", eachData);
          return _this11._decrypt(eachData, key, symmetricKeyAlgorithm).then(function (decryptedData) {
            _this11.logger.debug("Completed decrypting data in " + index + ": ", decryptedData);
            return decryptedData;
          }).catch(function (error) {
            throw new Error("Decryption error! Error: " + error); // No I18N
          });
        });
        return Promise.all(promiseArray).then(function (data) {
          _this11.logger.debug("Decryption finished: "); // No I18N
          return data.length === 1 ? data[0] : data;
        });
      });
    }
  }]);

  return PayloadEncryptAgent;
}();

var responseKeyPair = {
  privateKey: "MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCIDx6RJqiLUYUOLGBMW2VpmrPnGfnBfH7WWenVyKul0Y3se6LpXJdSf5YwrB7355tM/g3NCzvE2VqJfOAYbi69T3diOfWKtv0M0Xqx0djSr1xpSsO7sYxFAa86Teq/bSwrGBjLrUrTDHoNK3HMYt9u/IMLKGGeZC74KlxWG2kexQS7ADPaUvtt+sbm+4J00hbUZ+6LcCyb+w183zXMPVG5hFC03hyfzVeIDn+wIYP0SCuTIAZordcj+R1E4Nsbf8BgWEUKTJlxvDSSl5tfICV/Z09pZdoBbvru2Lch5lMAiQknskgO7GC0K2EkjEreYGr7k9/jU0i+reDj+aCaKMAhAgMBAAECggEAdZDC8994obGWDDIyH6iVz5OawiWC1zqxCpz03gKgtw6E2QPYOFcGdoXCjFoeBE4/tl6MJFIBmk3J2qVpqhKDFpe0685zKiKGM+5KW56dASf/7QdqbCO1tecHt5SeNDysfqw6uLwLvKO6TujsUxRYRrmwrhJ9j3S31T4dPVZAFhIas9yNCFtVVSoejrsZBTCoccHuOCRzlvYGawBHtRPLQjXfWNjdfcbK6aU7RH3ORagJG3wiJ+GUnlPwwCCxJJaX5E6lYoP/JQfm0S8NOsN57Sm0RpQ7XruU1jSsYPBaoxzu5y5jaOPiSvgndMWBT6Y51Q9TJgH2ef5VzNvhxq94AQKBgQDGCRazu4LhRrm0bY+Ci6T0aqoV18c7lB3K1eKYFUI+dYAJHSoyqKAKG0rV/PxqVzK+rKRLl9+HSIV+G1e2TL9h5oraQAp5p46eXFj+0Lk2y4Z1nVODBmniWMk87/agp7izVLps17mrEaXpA5SyIKo5Sp2mXD3RljcJ+0uUcwjJQQKBgQCv4hnirz7+wq064pU03nWUW9WZHS2OWiDbH+3cqvHMH8mhduQUdz7pasGpH1U0k8PmqWdZBlvWdcZvaQkKdJoPEixOmTrn/ulI8KQEVnOIa4W+fJLctMPBqNZBvQdozq/uX3t3yFmx3YOLyhgPH2ezKVP2yawsOnwAxO6XKQpe4QKBgH6kFUZ+5SWXCu7dGWcMUkKTa41oXdo10A+EU9GZ1rEGhwhNBE09FIsiBOtvSyPd+2+AC9jjmGh08hlA9wh3b/P1cFo9lfVSN5wBxk+9vpPR93yDTYJ+uXur95Tmh7sZRr43srgkBHHnaUfnqFF5HiJhGwvl9Qpwm2Xgs+aM4dOBAoGBAJfHKwVmq5sXjnwRSiccjiTf9vyxpD2C43WVISPbVNwM1mgC/CH5IY42dTan9lRv648iwy+dACWa7wn3fzjJlKTKzvdo3d+UJ+as2y1vGTYxa3INeIMDbyawt2x1Xm6AZmvzc83TVCvcd4drd8WdGVUPpgiC0pQ8SAQ17Zr+bJehAoGADTgia4vtIj14cSkoR0qjK28zkrm4CPmyaB3ds2f3k7C4rrT/Z5j0SmSuv2rj1GfLCg4NrtzNhDkIsW0nIZithu7cClZFM37ZHIevpgCK3h8AV9v1M9mwVxHx8oue2fHTbuW+xZbX6mYF9/QaXqmAbKd1jDriyrgOh0Xn6k/Xet8=", // No I18N
  publicKey: "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAiA8ekSaoi1GFDixgTFtlaZqz5xn5wXx+1lnp1cirpdGN7Hui6VyXUn+WMKwe9+ebTP4NzQs7xNlaiXzgGG4uvU93Yjn1irb9DNF6sdHY0q9caUrDu7GMRQGvOk3qv20sKxgYy61K0wx6DStxzGLfbvyDCyhhnmQu+CpcVhtpHsUEuwAz2lL7bfrG5vuCdNIW1Gfui3Asm/sNfN81zD1RuYRQtN4cn81XiA5/sCGD9EgrkyAGaK3XI/kdRODbG3/AYFhFCkyZcbw0kpebXyAlf2dPaWXaAW767ti3IeZTAIkJJ7JIDuxgtCthJIxK3mBq+5Pf41NIvq3g4/mgmijAIQIDAQAB", // No I18N
  algorithm: "RSA_2048" // No I18N
};

var requestKeyPair = {
  privateKey: "MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDVDVF6vdb0wKcdJY9G0Oe4X4slqAcZID4Zr1t6GHqTMDU/GTEjWsHgYC5c5vxg+WWP3I0tbLmu7e9Jkz+FIeVFKQz08DoxmPW9/SIvMOlKZzukmGo6r2mR/3OIyT9VICnvIEh2k9GlkiYdOIgOrNpwu+ZSCq6CzTc5YC3p+rpJAi8Fet7Ynan7uI/ysB99HsZnH450rCTMKB1AqBmIDtOgqZs0GqbRyau7BZkZV65jYecZQ0oOi3utkm+1L7U7EixEcZf+AB75TqwMdTIA4uwg3gktoOs8ZDsFgWQfkd10CK8nSs3w6onNqrfcKpiRTKF8qhBdONtPsElqR410572TAgMBAAECggEBAKyV0lhMqnGwEm/Q+kSSe/NmKlEB0WYwMT4bSE4awEi1d5y6qoyKO52oLEaDsxRXU0d7kT2n4q7q/bkrN/x/3brtqxpL88gzsXYLNYLm60SjZbRK51rMuAdV2OCIre4mVPHpw+mSivTF9GwdXFIPAhDqlYQGNSGuXbrzx53PxtHWIaP+nFU/LBMONatyq/h0iNj5HLByLLURgWkPWIiz4W5t4K12OndWAjGenR19DdbnVk5eHWwau1bSZCm750tV+qMemVUVCcSgiiQdzG51rUfvJfTFnyXq0W2qlEKmLFmWfKwrsbk+cE6ZMfE44FxYojywSoKZJ+p2cKRoP1ZGk2ECgYEA6g9hwuMeAW0WnfdnO7NrVSuPsRywRMscArJBA6wJgtnk4OCD1bh+y3obQXafOw5nEUytmOT8LJvCxfqfdL6TsNMglykU4c7ePsbmTo4558iykceI0zD/Dmsr6GncJlG/W9pJE/rXHLKcyVwGlkA141nt6thSRjz0SlK4XC0dEoMCgYEA6QXRH5rsQpBi77FXVHcP9R6GBjy19q5kCro44c8/90qZHwPVCpl50QW63/wNwuk/pnPVBYYV2Q+JVTdYK7xWVWaTlGYdd3ACxM8M/QNsd5vWDGRk2jQTFM7u6bNaxBKgBASDtNXtHK2HIKJCASTXYyQqILs5IlBnAa/iiewje7ECgYBYiCrtQWT3GyEj7RGiNlJR6+E1F+ngi4bzyiLnVapfUTXOjX2wWFG1e2FV2J2QA/meRIehPnPYF66Lnim0SeWpS6KXKpXYd5v+2NMCQa/LaVGJ7JRnda/z7zuzdF8uK1ubTay4nvfAxhqh22ouaOk5LqncW6h7ItEwT6umSfYmKwKBgQCI7QAbYD+gRZO9YSn92hCoao06sQYDtCnZG+A84DmoKE+dp/TRy6mHJ6TN5SB4/fKG7t2n50iDSdvbFTBcUskwWZwywWZjPpCB8WCidBaSmiHHGl8g0SS9P3OoI9ocCQ26DqUN5/7ysQ0MIgxC+9EM0r1mil1iSnicxyuI/BdFoQKBgQDQlKmcSjgft/2EhwN16Ck8+RWQluEG+nmoI/WB+LU56+TQzc3GGXQHjwDnrfX9vGgdBcI62Dk+S+d7HS8YY8XOAPugJ4/G1gABLjniG1N0GyeJmjjP2M+sLmljtxyLVwdz/PXVdT+7mnuwTt3TLEJUcI+EVL4D8oq6L7vwbcYzdQ==", // No I18N
  publicKey: "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1Q1Rer3W9MCnHSWPRtDnuF+LJagHGSA+Ga9behh6kzA1PxkxI1rB4GAuXOb8YPllj9yNLWy5ru3vSZM/hSHlRSkM9PA6MZj1vf0iLzDpSmc7pJhqOq9pkf9ziMk/VSAp7yBIdpPRpZImHTiIDqzacLvmUgqugs03OWAt6fq6SQIvBXre2J2p+7iP8rAffR7GZx+OdKwkzCgdQKgZiA7ToKmbNBqm0cmruwWZGVeuY2HnGUNKDot7rZJvtS+1OxIsRHGX/gAe+U6sDHUyAOLsIN4JLaDrPGQ7BYFkH5HddAivJ0rN8OqJzaq33CqYkUyhfKoQXTjbT7BJakeNdOe9kwIDAQAB", // No I18N
  algorithm: "RSA_2048" // No I18N
};

/** @format */

var SCOPES = {
  ORG: "org", // No I18N
  COMMON: "common" // No I18N
};
var constants = {
  WAF_ENCRYPTION_HANDSHAKE_URL: "/zwaf/encryption/handshake", // No I18N
  WAF_ENCRYPTION_KEY_HEADER: "Waf-Encryption-Key", // No I18N
  WAF_ENCRYPTION_ID_HEADER: "Waf-Encryption-Id", // No I18N
  WAF_CONTENT_ENCODING_HEADER: "Waf-Content-Encoding" // No I18N
};

function factory(baseConfig) {
  var encryptAgent = new PayloadEncryptAgent();
  var _initPromise = null;
  var _isInitialized = false;
  var _config = null;
  var _clientKeyPair = null;
  var _serverKeyPair = null;
  var _clientKeyExpiry = null;
  var _wafEncryptionId = null;
  var _forced = false;
  /**
   * Encrypt the given payload using AES-GCM. publicKeyData contains the keyID, followed by version and
   * publicKey.
   *
   * @param {String|Array<String>|Uint8Array|Array<Uint8Array>|ArrayBuffer|Array<ArrayBuffer>} data
   * @param {Object} keyIV
   * @param {CryptoKey} publicKey
   *
   * @return {Promise<Object>}
   */
  function _encrypt(data, keyIV, publicKey) {
    var encryptPromise = encryptAgent.encrypt(data, keyIV).then(function (_ref) {
      var key = _ref.key,
          data = _ref.data;

      return encryptAgent.encryptSymmetricKeyAndIV(key, publicKey).then(function (encryptedKeyData) {
        var exportedBinaryDataAndKey = encryptAgent.exportBinary([encryptedKeyData, data]);
        return {
          key: exportedBinaryDataAndKey[0],
          data: exportedBinaryDataAndKey[1]
        };
      });
    });
    return encryptPromise.then(function (result) {
      encryptAgent.logger.debug("Encryption complete: ", data); // No I18N
      return result;
    }).catch(function (error) {
      throw Error("Error while encrypting data: " + error); // No I18N
    });
  }

  /**
   * @param {String|Array} encryptedData
   * @param {String} encryptedAESKey
   * @param {CryptoKey} privateKey
   * @return {Promise<ArrayBuffer|Array<ArrayBuffer>>}
   */
  function _decrypt(encryptedData, encryptedAESKey, privateKey) {
    var decryptPromise = encryptAgent.decryptSymmetricKeyAndIV(encryptedAESKey, privateKey).then(function (key) {
      return encryptAgent.decrypt(encryptedData, key);
    });
    return decryptPromise.catch(function (error) {
      throw Error("Error while decrypting data: " + error); // No I18N
    });
  }

  /**
   * Returns a DecompressionStream.
   * In case of old Firefox browsers where it is not available, we use the alternate package
   * @return {DecompressionStream|{prototype: DecompressionStream, new(format: CompressionFormat): DecompressionStream}}
   */
  function getDecompressionStream() {
    if (DecompressionStream) {
      return DecompressionStream;
    }
    return streamsCompression.DecompressionStream;
  }

  /**
   * Used to decompress Gzipped content
   * Called after decryption is performed based on whether the "decompress" flag is enabled
   * Decompression is performed through a Decompression Stream and is read recursively until the stream is closed
   * @param compressedContent
   * @return {Promise<ArrayBuffer>}
   */
  function decompressGzipContent(compressedContent) {
    return new Promise(function (resolve, reject) {
      encryptAgent.logger.debug("Decompressing data"); // No I18N
      var gzipBlob = new Blob([compressedContent]);
      var decompressionStream = getDecompressionStream();
      var decompressionStreamInstance = new decompressionStream("gzip"); // No I18N
      var response = new Response(gzipBlob);
      var decompressedStream = response.body.pipeThrough(decompressionStreamInstance);
      var reader = decompressedStream.getReader();
      var result = [];

      function readDecompressedStream() {
        try {
          return reader.read().then(function (_ref2) {
            var done = _ref2.done,
                value = _ref2.value;

            // Check if there's data to read
            if (!done) {
              // Push the Uint8Array to the result array for merging after reading is complete
              encryptAgent.logger.debug("Partial decompressed content:", value); // No I18N
              result.push(value);
              // Continue reading recursively
              return readDecompressedStream();
            }
            encryptAgent.logger.debug("Decompression complete"); // No I18N
            resolve(result);
          });
        } catch (error) {
          reject("Error while decompressing data: " + error); // No I18N
        }
      }

      // Start reading the stream
      return readDecompressedStream();
    }).then(function (arrayOfReadChunks) {
      var totalLength = 0;
      for (var i = 0; i < arrayOfReadChunks.length; i++) {
        totalLength += arrayOfReadChunks[i].length;
      }
      var resultUint8Array = new Uint8Array(totalLength);
      var offset = 0;
      for (var _i = 0; _i < arrayOfReadChunks.length; _i++) {
        resultUint8Array.set(arrayOfReadChunks[_i], offset);
        offset += arrayOfReadChunks[_i].length;
      }
      return resultUint8Array.buffer;
    });
  }

  /**
   * The return value of the decrypt function can vary based on the flags set.
   * This function handles that in a single place.
   * It can return the binary data as an ArrayBuffer directly. It can perform decompression for gzipped content.
   * It can also convert the data back to string format, which is the default behaviour.
   * @param response
   * @param config
   * @return {Promise<string>|Promise<Awaited<unknown>>}
   */
  function handleDecryptionResponse(response, config) {
    var promise = Promise.resolve(response);
    if (config && config.decompress === true) {
      promise = decompressGzipContent(response);
    }
    if (config && config.returnBinary === true) {
      return promise;
    }
    try {
      return promise.then(function (value) {
        if (!Array.isArray(value)) {
          return new TextDecoder().decode(value);
        } else {
          return value.map(function (each) {
            return new TextDecoder().decode(each);
          });
        }
      });
    } catch (error) {
      encryptAgent.logger.error(error);
      encryptAgent.logger.debug(value);
      throw new Error("Failed to decode the decrypted content as string!"); // No I18N
    }
  }

  /**
   * Create a unique string to store the given property
   * This is scoped to ZWAF and the particular tag for which the encrypt agent is initialized
   * Default Tag value is domain. But Teams can customise this to include the org ID or similar value
   * @param name
   * @return {string}
   */
  function getStorageKeyName(name) {
    var localStoragePrefix = "_zwaf"; // No I18N
    var localStorageDelimiter = "__";
    return localStoragePrefix + localStorageDelimiter + _config.tag + localStorageDelimiter + name;
  }

  /**
   * Determine whether a handshake is needed based on the given factors
   *
   * @return {boolean}
   */
  function isHandshakeNeeded() {
    // Need to make handshake if any one of these checks fail
    var serverIDInLocalStorage = getFromLocalStorage(getStorageKeyName(_config.serverIDCookie));
    var serverIDInCookie = getCookie(_config.serverIDCookie);
    return !(
    // Check if clientKey is active
    hasInLocalStorage(getStorageKeyName(_config.clientKeyExpiry)) && isClientKeyActive() &&
    // Check if clientPrivateKey present in LocalStorage
    hasInLocalStorage(getStorageKeyName(_config.clientPrivateKey)) &&
    // Check if serverPublicKey present in LocalStorage
    hasInLocalStorage(getStorageKeyName(_config.serverPublicKey)) &&
    // Check if clientID present in LocalStorage
    // TODO: Is this check needed? Any scenario to check clientID cookie in LocalStorage
    hasInLocalStorage(getStorageKeyName(_config.clientIDCookie)) &&
    // Check if clientID present in Cookie
    hasCookie(_config.clientIDCookie) &&
    // Check if serverID present in LocalStorage
    serverIDInLocalStorage &&
    // Check if serverID present in Cookie
    serverIDInCookie &&
    // Check if serverID present in Cookie matches the serverID stored in LocalStorage
    // Because if server has changed the key, we need to know about it.
    serverIDInLocalStorage === serverIDInCookie);
  }

  /**
   * Export and share the Client Public key along with the key information like algorithm and size
   * @param clientPublicKey {ArrayBuffer}
   * @return {Promise<Object>}
   */
  function fetchDetailsFromServer(clientPublicKey) {
    var url = _config.handshakeURL;
    return configuration.getCSRFDetails().then(function (detail) {
      var csrfParamName = detail[0];
      var csrfValue = getCookie(detail[1]);
      var formData = new FormData();
      formData.append("scope", _config.scope); // No I18N
      formData.append("size", _config.keySize); // No I18N
      formData.append("algorithm", _config.algorithm); // No I18N
      formData.append("data", JSON.stringify({ "client-public-key": encryptAgent.exportBinary(clientPublicKey) })); // No I18N
      formData.append(csrfParamName, csrfValue);
      return fetch(url, {
        method: "POST", // No I18N
        headers: _config.handshakeHeaders || {},
        body: formData
      }).then(function (response) {
        return response.json();
      }).then(function (response) {
        var serverPublicKeyData = response[_config.serverPublicKey]; // Name of the server public key prop in the handshake response
        if (!serverPublicKeyData) {
          throw new Error("Failed to fetch Server Public Key!"); // No I18N
        }
        return response;
      });
    });
  }

  /**
   * To get client key pair
   * @return {Promise<boolean>}
   */
  function initializeClientKeyPair() {
    // TODO: We currently only maintain a single client key pair in memory since key size is fixed
    // Need to handle multiple key sizes which fetching existing key, etc. If such cases do exist.
    var clientKeyPairPromise = void 0;
    var storeClientKeyPair = false;
    //common scope, use hard-coded key pairs
    if (_config.scope === SCOPES.COMMON) {
      // If already loaded into memory, no need to import from LocalStorage again!
      if (_clientKeyPair) {
        clientKeyPairPromise = Promise.resolve(_clientKeyPair);
      } else {
        clientKeyPairPromise = importAsymmetricKeyPair(responseKeyPair);
      }
    }
    // generate new key pair
    else if (!isClientKeyActive() || _forced || isHandshakeNeeded()) {
        clientKeyPairPromise = encryptAgent.generateAsymmetricKeyPair(_config.algorithm, _config.keySize);
        storeClientKeyPair = true;
      }
      // load from localStorage
      else {
          // If already loaded into memory, no need to import from LocalStorage again!
          if (_clientKeyPair) {
            clientKeyPairPromise = Promise.resolve(_clientKeyPair);
          } else {
            var clientPublicKey = getFromLocalStorage(getStorageKeyName(_config.clientPublicKey));
            var clientPrivateKey = getFromLocalStorage(getStorageKeyName(_config.clientPrivateKey));
            var clientKeyPairFromLS = normalizeKeyPair(clientPublicKey, clientPrivateKey);

            clientKeyPairPromise = importAsymmetricKeyPair(clientKeyPairFromLS);
          }
        }
    //store in memory variable
    return clientKeyPairPromise.then(function (clientKeyPair) {
      _clientKeyPair = clientKeyPair;
      encryptAgent.logger.info("Client Key Pair stored in memory !"); // No I18N
      return storeClientKeyPair;
    });
  }

  /**
   * To get server key pair
   * @return {Promise<boolean>}
   */
  function initializeServerKeyPair(handshake) {
    // TODO: We currently only maintain a single client key pair in memory since key size is fixed
    // Need to handle multiple key sizes which fetching existing key, etc. If such cases do exist.
    var serverKeyPairPromise = void 0;
    var storeServerKeyPair = false;

    //common scope, use hard-coded key pairs
    if (_config.scope === SCOPES.COMMON) {
      // If already loaded into memory, no need to import from LocalStorage again!
      if (_serverKeyPair) {
        serverKeyPairPromise = Promise.resolve(_serverKeyPair);
      } else {
        serverKeyPairPromise = importAsymmetricKeyPair(requestKeyPair);
      }
    }
    //fetch from server
    else if (handshake) {
        storeServerKeyPair = true;
        serverKeyPairPromise = encryptAgent.exportAsymmetricPublicKey(_clientKeyPair.publicKey).then(function (exportedClientPublicKey) {
          _clientKeyExpiry = null;
          _wafEncryptionId = null;
          return fetchDetailsFromServer(exportedClientPublicKey).then(function (response) {
            _clientKeyExpiry = response[_config.clientKeyExpiry] || -1;
            _wafEncryptionId = response[_config.wafEncryptionId] || null;
            var serverPublicKey = response[_config.serverPublicKey];
            var serverPrivateKey = null;
            var serverKeyPair = normalizeKeyPair(serverPublicKey, serverPrivateKey);
            return importAsymmetricKeyPair(serverKeyPair);
          });
        });
      }
      //load from localStorage
      else {
          // If already loaded into memory, no need to import from LocalStorage again!
          if (_serverKeyPair) {
            serverKeyPairPromise = Promise.resolve(_serverKeyPair);
          } else {
            var serverPublicKey = getFromLocalStorage(getStorageKeyName(_config.serverPublicKey));
            var serverPrivateKey = null;
            var serverKeyPair = normalizeKeyPair(serverPublicKey, serverPrivateKey);
            serverKeyPairPromise = importAsymmetricKeyPair(serverKeyPair);
          }
        }
    //store in memory variable
    return serverKeyPairPromise.then(function (serverKeyPair) {
      _serverKeyPair = serverKeyPair;
      encryptAgent.logger.info("Server Key Pair stored in memory !"); // No I18N
      return storeServerKeyPair;
    });
  }

  /**
   * Import Asymmetric Key Pair
   * @param keyPair
   * @return {Promise<CryptoKeyPair>}
   */
  function importAsymmetricKeyPair(keyPair) {
    return encryptAgent.importAsymmetricPublicKey(keyPair.publicKey).then(function (importedPublicKey) {
      return encryptAgent.importAsymmetricPrivateKey(keyPair.privateKey).then(function (importedPrivateKey) {
        return normalizeKeyPair(importedPublicKey, importedPrivateKey);
      });
    });
  }

  /**
   * Normalize Key Pair
   * @param publicKey
   * @param privateKey
   * @return {{privateKey, publicKey}}
   */
  function normalizeKeyPair(publicKey, privateKey) {
    return {
      publicKey: publicKey,
      privateKey: privateKey
    };
  }

  /**
   * Trigger a handshake request based on the given config. Once it is called, it returns a client key pair
   * which can be the default hardcoded one, already created one from LocalStorage or create a new one.
   * The server public key is obtained through server call, along with the client id, server id and client key expiry.
   * @return {Promise<boolean>}
   */
  function initializeHandshake() {
    return initializeClientKeyPair().then(function (storeClientKeyPair) {
      return initializeServerKeyPair(storeClientKeyPair).then(function (storeServerKeyPair) {
        if (storeServerKeyPair || storeClientKeyPair) {
          // update localStorage if it's new from server
          return storeDetailsInLocalStorage().then(function (isDetailsStoredInLocalstorage) {
            return isDetailsStoredInLocalstorage;
          });
        }
        encryptAgent.logger.debug("Handshake not needed, ignoring this init call!"); // No I18N
        return true;
      });
    });
  }

  /**
   * Determine whether the existing private key from our LocalStorage is active
   * @return {boolean}
   */
  function isClientKeyActive() {
    // get Client key expiry from localStorage
    var clientKeyExpiry = getFromLocalStorage(getStorageKeyName(_config.clientKeyExpiry));
    // Client Expiry time in secs
    var clientExpiryTime = Number(clientKeyExpiry);
    // Check if its valid number
    if (!clientExpiryTime) {
      return false;
    }
    var clientExpiryUnixTime = clientExpiryTime * 1000; // Convert to milliseconds
    var currentUnixTime = Date.now(); // Current time in milliseconds
    // Check if expiry time is greater than current time
    return clientExpiryUnixTime > currentUnixTime;
  }

  /**
   * Handles and stores details like ClientKeyPair, ServerKeyPair and ClientKeyExpiry
   * LocalStorage would then contain,
   *      1. Server ID
   *      2. Server Public Key
   *
   *      4. Client ID
   *      3. Client Expiry Time
   *      5. Client Public Key
   *      6. Client Private Key
   *
   * @return {Promise<boolean>}
   */
  function storeDetailsInLocalStorage() {
    // TODO:
    //  If we are unable to store any of the details in LocalStorage (due to storage constraints, etc),
    //  we need to handle it without LocalStorage. No solution for now - discuss later
    var promiseArray = [];

    // Store Server ID
    try {
      var serverID = getCookie(_config.serverIDCookie);
      setToLocalStorage(getStorageKeyName(_config.serverIDCookie), serverID);
    } catch (e) {
      encryptAgent.logger.error("Failed to store Server ID in localStorage!"); // No I18N
    }

    // Store Server Public Key
    try {
      var serverPublicKeyPromise = encryptAgent.exportAsymmetricPublicKey(_serverKeyPair.publicKey).then(function (serverPublicKeyData) {
        setToLocalStorage(getStorageKeyName(_config.serverPublicKey), encryptAgent.exportBinary(serverPublicKeyData));
        return true;
      });
      promiseArray.push(serverPublicKeyPromise);
    } catch (e) {
      encryptAgent.logger.error("Failed to store Server Public Key in localStorage!"); // No I18N
    }

    // Store Client ID
    try {
      var clientID = getCookie(_config.clientIDCookie);
      setToLocalStorage(getStorageKeyName(_config.clientIDCookie), clientID);
    } catch (e) {
      encryptAgent.logger.error("Failed to store Client ID in localStorage!"); // No I18N
    }

    // Store Client Expiry Time
    var clientKeyExpiry = _clientKeyExpiry + Math.floor(Date.now() / 1000); // Current time in seconds + given expiry time
    try {
      setToLocalStorage(getStorageKeyName(_config.clientKeyExpiry), clientKeyExpiry);
    } catch (e) {
      encryptAgent.logger.error("Failed to store Client Expiry time in localStorage!"); // No I18N
    }

    // Store Waf Encryption ID
    try {
      if (_wafEncryptionId) {
        setToLocalStorage(getStorageKeyName(_config.wafEncryptionId), _wafEncryptionId);
      }
    } catch (e) {
      encryptAgent.logger.error("Failed to store Waf Encryption ID in localStorage!"); // No I18N
    }

    // Store Client Public Key
    try {
      var clientPublicKeyPromise = encryptAgent.exportAsymmetricPublicKey(_clientKeyPair.publicKey).then(function (clientPublicKeyData) {
        setToLocalStorage(getStorageKeyName(_config.clientPublicKey), encryptAgent.exportBinary(clientPublicKeyData));
        return true;
      });
      promiseArray.push(clientPublicKeyPromise);
    } catch (e) {
      encryptAgent.logger.error("Failed to store Client Public Key in localStorage!"); // No I18N
    }

    // Store Client Private Key
    try {
      var clientPrivateKeyPromise = encryptAgent.exportAsymmetricPrivateKey(_clientKeyPair.privateKey).then(function (clientPrivateKeyData) {
        setToLocalStorage(getStorageKeyName(_config.clientPrivateKey), encryptAgent.exportBinary(clientPrivateKeyData));
        return true;
      });
      promiseArray.push(clientPrivateKeyPromise);
    } catch (e) {
      encryptAgent.logger.error("Failed to store Client Private Key in localStorage!"); // No I18N
    }

    return Promise.all(promiseArray).then(function (res) {
      encryptAgent.logger.info("Key details stored in localStorage!"); // No I18N
      return true;
    });
  }

  /**
   * Delete the stored handshake details from LocalStorage
   * Maybe exposed to service team later
   */
  function deleteHandshakeDetails() {
    // LocalStorage entries to be deleted
    var localStorageEntriesToBeDeleted = [_config.serverIDCookie, _config.serverPublicKey, _config.clientIDCookie, _config.clientKeyExpiry, _config.clientPublicKey, _config.clientPrivateKey];
    var cookieEntriesToBeDeleted = [_config.serverIDCookie, _config.clientIDCookie];
    localStorageEntriesToBeDeleted.forEach(function (key) {
      var storageKeyName = getStorageKeyName(key);
      try {
        if (hasInLocalStorage(storageKeyName)) {
          deleteFromLocalStorage(storageKeyName);
        }
      } catch (e) {
        encryptAgent.logger.error("Failed to delete " + key + " from localStorage!"); // No I18N
      }
    });
    cookieEntriesToBeDeleted.forEach(function (key) {
      try {
        if (hasCookie(storageKeyName)) {
          deleteCookie(storageKeyName);
        }
      } catch (e) {
        encryptAgent.logger.error("Failed to delete " + key + " from localStorage!"); // No I18N
      }
    });

    return true;
  }

  /**
   * Used to get the Server Public Key from memory for Request Encryption
   *  When using hardcoded keys (common scope), we can return the Client Public Key for Response Encryption
   * @param [encryptAsServer]
   * @return {Promise<CryptoKey>}
   */
  function getPublicKey(encryptAsServer) {
    if (!_isInitialized) {
      throw new Error("ZWAF Encryption Agent not initialized yet!"); // No I18N
    }
    var publicKey = encryptAsServer ? _clientKeyPair.publicKey : _serverKeyPair.publicKey;
    return Promise.resolve(publicKey);
  }

  /**
   * Used to get the Client Private Key from memory for Response Decryption
   *  When using hardcoded keys (common scope), we can return the Server Private Key for Request Decryption
   * @param [decryptAsServer]
   * @return {Promise<CryptoKey>}
   */
  function getPrivateKey(decryptAsServer) {
    if (!_isInitialized) {
      throw new Error("ZWAF Encryption Agent not initialized yet!"); // No I18N
    }
    var privateKey = _config.scope === SCOPES.COMMON && decryptAsServer ? _serverKeyPair.privateKey : _clientKeyPair.privateKey;
    return Promise.resolve(privateKey);
  }

  function encrypt(data, keyIV) {
    return getPendingHandshakePromise().then(function (handshakeAndStoreCompleted) {
      return getPublicKey().then(function (publicKey) {
        return _encrypt(data, keyIV, publicKey);
      });
    });
  }

  function encryptAsServer(data, keyIV) {
    return getPendingHandshakePromise().then(function (handshakeAndStoreCompleted) {
      return getPublicKey(true).then(function (publicKey) {
        return _encrypt(data, keyIV, publicKey);
      });
    });
  }

  function decrypt(data, encryptedAESKey, config) {
    return getPrivateKey().then(function (privateKey) {
      return _decrypt(data, encryptedAESKey, privateKey).then(function (decryptedBinaryContent) {
        return handleDecryptionResponse(decryptedBinaryContent, config);
      });
    });
  }

  function decryptAsServer(data, encryptedAESKey, config) {
    return getPrivateKey(true).then(function (privateKey) {
      return _decrypt(data, encryptedAESKey, privateKey).then(function (decryptedBinaryContent) {
        return handleDecryptionResponse(decryptedBinaryContent, config);
      });
    });
  }

  /**
   * Entry function to be called to initialize encryption details
   * Must be called first before using encrypt/decrypt functions
   * User can customize the tag(domain), handshake URL, algorithm, key size, scope, etc.
   * Returns whether handshake was performed or not
   * @param config
   * @return {Promise<boolean>}
   */
  function init(config) {
    _config = extend(config || {}, baseConfig);
    if (_isInitialized) {
      encryptAgent.logger.warn("Already initialized! Is this call really necessary?"); // No I18N
    }
    if (_initPromise) {
      encryptAgent.logger.debug("Init in progress so returning the same promise!"); // No I18N
      return _initPromise;
    }
    _initPromise = initializeHandshake().then(function (didHandshakeOccur) {
      _isInitialized = didHandshakeOccur;
      _initPromise = null;
      return _isInitialized;
    });
    return _initPromise;
  }

  /**
   * To be used as a fallback to force a handshake request. This bypasses existing checks and is not recommended.
   * ONLY USE THIS IF YOU ARE SURE ABOUT IT!
   * @param config
   * @return {Promise<boolean>}
   */
  function reInit(config) {
    _forced = true;
    _config = extend(config || {}, baseConfig);
    encryptAgent.logger.warn("Using forced handshake!"); // No I18N
    deleteHandshakeDetails();
    _initPromise = initializeHandshake().then(function (didHandshakeOccur) {
      _isInitialized = didHandshakeOccur;
      _initPromise = null;
      _forced = false;
      return _isInitialized;
    });
    return _initPromise;
  }

  /**
   * To get any pending handshake / store details promise while invoking user-exposed functions
   * @return {Promise<boolean>}
   */

  function getPendingHandshakePromise() {
    if (!_isInitialized && !_initPromise) {
      throw new Error("ZWAF Encryption Agent not initialized yet!"); // No I18N
    }
    if (_initPromise) {
      encryptAgent.logger.debug("Handshake in progress so returning the same promise!"); // No I18N
      return _initPromise;
    }
    _initPromise = initializeHandshake().then(function (didHandshakeOccur) {
      _isInitialized = didHandshakeOccur;
      _initPromise = null;
      return _isInitialized;
    });
    return _initPromise;
  }

  /**
   * Get a new encrypted Symmetric key
   * @return {Promise<string>}
   */
  function getKey() {
    return getReusableKey().then(function (symmetricKeyAndIv) {
      // Returning encrypted key depends on server public key received from handshake
      // so wait for handshake / store to complete and encrypt the symmetric key
      return getPendingHandshakePromise().then(function (handshakeAndStoreCompleted) {
        return encryptAgent.exportSymmetricKeyAndIV(symmetricKeyAndIv.key, symmetricKeyAndIv.iv).then(function (exportedSymmetricKey) {
          return getPublicKey().then(function (publicKey) {
            return encryptAgent.encryptSymmetricKeyAndIV(exportedSymmetricKey, publicKey).then(function (encryptedKeyData) {
              return encryptAgent.exportBinary(encryptedKeyData);
            });
          });
        });
      });
    });
  }

  /**
   * Get a new Symmetric key and iv that can be reused multiple times.
   * This will be useful when trying to encrypt queryString and body separately
   * @return {Promise<{key: CryptoKey, iv: Uint8Array}>}
   */
  function getReusableKey() {
    return encryptAgent.getSymmetricKey();
  }

  /**
   * Customise the logging level. By default, only errors are logged.
   * We can set the level to DEBUG and call encrypt/decrypt and revert back to the original level
   * Log levels can be found in ZWAF.logger.LEVELS
   * Eg:
   *    ZWAF.Encryption.setLogLevel(ZWAF.logger.LEVELS.DEBUG);
   *    ZWAF.Encryption.encrypt("data");
   *    ZWAF.Encryption.setLogLevel();
   * @param level
   */
  function setLogLevel(level) {
    encryptAgent.setLogLevel(level);
  }

  /**
   * Function to expose the PayloadEncryptAgent instance used internally
   * @return {PayloadEncryptAgent}
   */
  function getEncryptAgent() {
    return encryptAgent;
  }

  function getWafEncryptionId() {
    if (!_isInitialized && !_initPromise) {
      throw new Error("ZWAF Encryption Agent not initialized yet!"); // No I18N
    }
    if (_initPromise) {
      encryptAgent.logger.debug("Handshake in progress. Please call after Handshake is complete!"); // No I18N
      return null;
    }
    // get Waf Encryption Id from localStorage
    return getFromLocalStorage(getStorageKeyName(_config.wafEncryptionId));
  }

  /**
   * Constructor for Encryption. Can be used to create fresh instances of Encryption
   * @return {Object}
   */
  var Encryption = function Encryption(config) {
    config = extend(config || {}, defaultConf);
    return factory(config);
  };

  Encryption.SCOPES = SCOPES;
  Encryption.constants = constants;
  Encryption.encrypt = encrypt;
  Encryption.decrypt = decrypt;
  Encryption.encryptAsServer = encryptAsServer;
  Encryption.decryptAsServer = decryptAsServer;
  Encryption.init = init;
  Encryption.reInit = reInit;
  Encryption.deleteHandshakeDetails = deleteHandshakeDetails;
  Encryption.getKey = getKey;
  Encryption.getReusableKey = getReusableKey;
  Encryption.setLogLevel = setLogLevel;
  Encryption.getEncryptAgent = getEncryptAgent;
  Encryption.getWafEncryptionId = getWafEncryptionId;

  // TODO: To be deprecated soon as the asymmetric keys shouldn't be accessed by service teams!
  Encryption.getPublicKey = getPublicKey;
  Encryption.getPrivateKey = getPrivateKey;

  return Encryption;
}

var defaultConf = {
  clientIDCookie: "_zwaf_enc_clientid", // No I18N
  serverIDCookie: "_zwaf_enc_serverid", // No I18N
  serverPublicKey: "server-public-key", // No I18N
  clientKeyExpiry: "client-id-expiry", // No I18N
  clientPublicKey: "client-public-key", // No I18N
  clientPrivateKey: "client-private-key", // No I18N
  wafEncryptionId: "waf-encryption-id", // No I18N

  algorithm: "RSA-OAEP", // No I18N
  keySize: 2048,

  scope: SCOPES.COMMON,
  handshakeURL: constants.WAF_ENCRYPTION_HANDSHAKE_URL,
  // Default tag value is domain
  // Domain is taken from window.location, not from document.domain. Because it's deprecated
  // Ref: https://developer.mozilla.org/en-US/docs/Web/API/Document/domain
  tag: window && window.location && window.location.hostname || "null" // No I18N
};

var Encryption = factory(defaultConf);

if (Object.freeze) {
  Object.freeze(Encryption);
}

if (ZWAF$2.version === '7.0.0' && !ZWAF$2.Encryption) {
  ZWAF$2.defineProperty(ZWAF$2, 'Encryption', // No I18N
  Encryption, true, false, false, true);
}
if (!ZWAF$2['7_0_0'].Encryption) {
  ZWAF$2.defineProperty(ZWAF$2['7_0_0'], 'Encryption', // No I18N
  Encryption, true, false, false, true);
}

function _toConsumableArray$3(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var hasOwnProperty = Object.hasOwnProperty;
var setPrototypeOf = Object.setPrototypeOf;
var isFrozen = Object.isFrozen;
var getPrototypeOf = Object.getPrototypeOf;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var freeze$1 = Object.freeze;
var seal = Object.seal;
var create = Object.create; // eslint-disable-line import/no-mutable-exports

var _ref = typeof Reflect !== 'undefined' && Reflect;
var apply = _ref.apply;
var construct = _ref.construct; // No I18N

if (!apply) {
  apply = function apply(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}

if (!freeze$1) {
  freeze$1 = function freeze(x) {
    return x;
  };
}

if (!seal) {
  seal = function seal(x) {
    return x;
  };
}

if (!construct) {
  construct = function construct(Func, args) {
    return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray$3(args))))();
  };
}

var arrayForEach = unapply(Array.prototype.forEach);
var arrayPop = unapply(Array.prototype.pop);
var arrayPush = unapply(Array.prototype.push);
var stringToLowerCase = unapply(String.prototype.toLowerCase);
var stringToString = unapply(String.prototype.toString);
var stringMatch = unapply(String.prototype.match);
var stringReplace = unapply(String.prototype.replace);
var stringIndexOf = unapply(String.prototype.indexOf);
var stringTrim = unapply(String.prototype.trim);

var regExpTest = unapply(RegExp.prototype.test);

var typeErrorCreate = unconstruct(TypeError);

function numberIsNaN(x) {
  // eslint-disable-next-line unicorn/prefer-number-properties
  return typeof x === 'number' && isNaN(x);
}

function unapply(func) {
  return function (thisArg) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return apply(func, thisArg, args);
  };
}

function unconstruct(func) {
  return function () {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return construct(func, args);
  };
}

/* Add properties to a lookup table */
function addToSet(set, array, transformCaseFunc) {
  transformCaseFunc = transformCaseFunc || stringToLowerCase;
  if (setPrototypeOf) {
    // Make 'in' and truthy checks like Boolean(set.constructor) // No I18N
    // independent of any properties defined on Object.prototype.
    // Prevent prototype setters from intercepting set as a this value.
    setPrototypeOf(set, null);
  }

  var l = array.length;
  while (l--) {
    var element = array[l];
    if (typeof element === 'string') {
      // No I18N
      var lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        // Config presets (e.g. tags.js, attrs.js) are immutable.
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }

        element = lcElement;
      }
    }

    set[element] = true;
  }

  return set;
}

/* Shallow clone an object */
function clone(object) {
  var newObject = create(null);

  var property = void 0;
  for (property in object) {
    if (apply(hasOwnProperty, object, [property]) === true) {
      newObject[property] = object[property];
    }
  }

  return newObject;
}

/* IE10 doesn't support __lookupGetter__ so lets' // No I18N
 * simulate it. It also automatically checks
 * if the prop is function or getter and behaves
 * accordingly. */
function lookupGetter(object, prop) {
  while (object !== null) {
    var desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }

      if (typeof desc.value === 'function') {
        // No I18N
        return unapply(desc.value);
      }
    }

    object = getPrototypeOf(object);
  }

  function fallbackValue(element) {
    // console.warn('fallback value for', element); // No I18N
    return null;
  }

  return fallbackValue;
}

var html = freeze$1(['a', // No I18N
'abbr', // No I18N
'acronym', // No I18N
'address', // No I18N
'area', // No I18N
'article', // No I18N
'aside', // No I18N
'audio', // No I18N
'b', // No I18N
'bdi', // No I18N
'bdo', // No I18N
'big', // No I18N
'blink', // No I18N
'blockquote', // No I18N
'body', // No I18N
'br', // No I18N
'button', // No I18N
'canvas', // No I18N
'caption', // No I18N
'center', // No I18N
'cite', // No I18N
'code', // No I18N
'col', // No I18N
'colgroup', // No I18N
'content', // No I18N
'data', // No I18N
'datalist', // No I18N
'dd', // No I18N
'decorator', // No I18N
'del', // No I18N
'details', // No I18N
'dfn', // No I18N
'dialog', // No I18N
'dir', // No I18N
'div', // No I18N
'dl', // No I18N
'dt', // No I18N
'element', // No I18N
'em', // No I18N
'fieldset', // No I18N
'figcaption', // No I18N
'figure', // No I18N
'font', // No I18N
'footer', // No I18N
'form', // No I18N
'h1', // No I18N
'h2', // No I18N
'h3', // No I18N
'h4', // No I18N
'h5', // No I18N
'h6', // No I18N
'head', // No I18N
'header', // No I18N
'hgroup', // No I18N
'hr', // No I18N
'html', // No I18N
'i', // No I18N
'img', // No I18N
'input', // No I18N
'ins', // No I18N
'kbd', // No I18N
'label', // No I18N
'legend', // No I18N
'li', // No I18N
'main', // No I18N
'map', // No I18N
'mark', // No I18N
'marquee', // No I18N
'menu', // No I18N
'menuitem', // No I18N
'meter', // No I18N
'nav', // No I18N
'nobr', // No I18N
'ol', // No I18N
'optgroup', // No I18N
'option', // No I18N
'output', // No I18N
'p', // No I18N
'picture', // No I18N
'pre', // No I18N
'progress', // No I18N
'q', // No I18N
'rp', // No I18N
'rt', // No I18N
'ruby', // No I18N
's', // No I18N
'samp', // No I18N
'section', // No I18N
'select', // No I18N
'shadow', // No I18N
'small', // No I18N
'source', // No I18N
'spacer', // No I18N
'span', // No I18N
'strike', // No I18N
'strong', // No I18N
'style', // No I18N
'sub', // No I18N
'summary', // No I18N
'sup', // No I18N
'table', // No I18N
'tbody', // No I18N
'td', // No I18N
'template', // No I18N
'textarea', // No I18N
'tfoot', // No I18N
'th', // No I18N
'thead', // No I18N
'time', // No I18N
'tr', // No I18N
'track', // No I18N
'tt', // No I18N
'u', // No I18N
'ul', // No I18N
'var', // No I18N
'video', // No I18N
'wbr' // No I18N
]);

// SVG
var svg = freeze$1(['svg', // No I18N
'a', // No I18N
'altglyph', // No I18N
'altglyphdef', // No I18N
'altglyphitem', // No I18N
'animatecolor', // No I18N
'animatemotion', // No I18N
'animatetransform', // No I18N
'circle', // No I18N
'clippath', // No I18N
'defs', // No I18N
'desc', // No I18N
'ellipse', // No I18N
'filter', // No I18N
'font', // No I18N
'g', // No I18N
'glyph', // No I18N
'glyphref', // No I18N
'hkern', // No I18N
'image', // No I18N
'line', // No I18N
'lineargradient', // No I18N
'marker', // No I18N
'mask', // No I18N
'metadata', // No I18N
'mpath', // No I18N
'path', // No I18N
'pattern', // No I18N
'polygon', // No I18N
'polyline', // No I18N
'radialgradient', // No I18N
'rect', // No I18N
'stop', // No I18N
'style', // No I18N
'switch', // No I18N
'symbol', // No I18N
'text', // No I18N
'textpath', // No I18N
'title', // No I18N
'tref', // No I18N
'tspan', // No I18N
'view', // No I18N
'vkern' // No I18N
]);

var svgFilters = freeze$1(['feBlend', // No I18N
'feColorMatrix', // No I18N
'feComponentTransfer', // No I18N
'feComposite', // No I18N
'feConvolveMatrix', // No I18N
'feDiffuseLighting', // No I18N
'feDisplacementMap', // No I18N
'feDistantLight', // No I18N
'feFlood', // No I18N
'feFuncA', // No I18N
'feFuncB', // No I18N
'feFuncG', // No I18N
'feFuncR', // No I18N
'feGaussianBlur', // No I18N
'feImage', // No I18N
'feMerge', // No I18N
'feMergeNode', // No I18N
'feMorphology', // No I18N
'feOffset', // No I18N
'fePointLight', // No I18N
'feSpecularLighting', // No I18N
'feSpotLight', // No I18N
'feTile', // No I18N
'feTurbulence' // No I18N
]);

// List of SVG elements that are disallowed by default.
// We still need to know them so that we can do namespace
// checks properly in case one wants to add them to
// allow-list.
var svgDisallowed = freeze$1(['animate', // No I18N
'color-profile', // No I18N
'cursor', // No I18N
'discard', // No I18N
'fedropshadow', // No I18N
'font-face', // No I18N
'font-face-format', // No I18N
'font-face-name', // No I18N
'font-face-src', // No I18N
'font-face-uri', // No I18N
'foreignobject', // No I18N
'hatch', // No I18N
'hatchpath', // No I18N
'mesh', // No I18N
'meshgradient', // No I18N
'meshpatch', // No I18N
'meshrow', // No I18N
'missing-glyph', // No I18N
'script', // No I18N
'set', // No I18N
'solidcolor', // No I18N
'unknown', // No I18N
'use' // No I18N
]);

var mathMl = freeze$1(['math', // No I18N
'menclose', // No I18N
'merror', // No I18N
'mfenced', // No I18N
'mfrac', // No I18N
'mglyph', // No I18N
'mi', // No I18N
'mlabeledtr', // No I18N
'mmultiscripts', // No I18N
'mn', // No I18N
'mo', // No I18N
'mover', // No I18N
'mpadded', // No I18N
'mphantom', // No I18N
'mroot', // No I18N
'mrow', // No I18N
'ms', // No I18N
'mspace', // No I18N
'msqrt', // No I18N
'mstyle', // No I18N
'msub', // No I18N
'msup', // No I18N
'msubsup', // No I18N
'mtable', // No I18N
'mtd', // No I18N
'mtext', // No I18N
'mtr', // No I18N
'munder', // No I18N
'munderover' // No I18N
]);

// Similarly to SVG, we want to know all MathML elements,
// even those that we disallow by default.
var mathMlDisallowed = freeze$1(['maction', // No I18N
'maligngroup', // No I18N
'malignmark', // No I18N
'mlongdiv', // No I18N
'mscarries', // No I18N
'mscarry', // No I18N
'msgroup', // No I18N
'mstack', // No I18N
'msline', // No I18N
'msrow', // No I18N
'semantics', // No I18N
'annotation', // No I18N
'annotation-xml', // No I18N
'mprescripts', // No I18N
'none' // No I18N
]);

var text = freeze$1(['#text']); // No I18N

var html$1 = freeze$1(['accept', // No I18N
'action', // No I18N
'align', // No I18N
'alt', // No I18N
'autocapitalize', // No I18N
'autocomplete', // No I18N
'autopictureinpicture', // No I18N
'autoplay', // No I18N
'background', // No I18N
'bgcolor', // No I18N
'border', // No I18N
'capture', // No I18N
'cellpadding', // No I18N
'cellspacing', // No I18N
'checked', // No I18N
'cite', // No I18N
'class', // No I18N
'clear', // No I18N
'color', // No I18N
'cols', // No I18N
'colspan', // No I18N
'controls', // No I18N
'controlslist', // No I18N
'coords', // No I18N
'crossorigin', // No I18N
'datetime', // No I18N
'decoding', // No I18N
'default', // No I18N
'dir', // No I18N
'disabled', // No I18N
'disablepictureinpicture', // No I18N
'disableremoteplayback', // No I18N
'download', // No I18N
'draggable', // No I18N
'enctype', // No I18N
'enterkeyhint', // No I18N
'face', // No I18N
'for', // No I18N
'headers', // No I18N
'height', // No I18N
'hidden', // No I18N
'high', // No I18N
'href', // No I18N
'hreflang', // No I18N
'id', // No I18N
'inputmode', // No I18N
'integrity', // No I18N
'ismap', // No I18N
'kind', // No I18N
'label', // No I18N
'lang', // No I18N
'list', // No I18N
'loading', // No I18N
'loop', // No I18N
'low', // No I18N
'max', // No I18N
'maxlength', // No I18N
'media', // No I18N
'method', // No I18N
'min', // No I18N
'minlength', // No I18N
'multiple', // No I18N
'muted', // No I18N
'name', // No I18N
'nonce', // No I18N
'noshade', // No I18N
'novalidate', // No I18N
'nowrap', // No I18N
'open', // No I18N
'optimum', // No I18N
'pattern', // No I18N
'placeholder', // No I18N
'playsinline', // No I18N
'poster', // No I18N
'preload', // No I18N
'pubdate', // No I18N
'radiogroup', // No I18N
'readonly', // No I18N
'rel', // No I18N
'required', // No I18N
'rev', // No I18N
'reversed', // No I18N
'role', // No I18N
'rows', // No I18N
'rowspan', // No I18N
'spellcheck', // No I18N
'scope', // No I18N
'selected', // No I18N
'shape', // No I18N
'size', // No I18N
'sizes', // No I18N
'span', // No I18N
'srclang', // No I18N
'start', // No I18N
'src', // No I18N
'srcset', // No I18N
'step', // No I18N
'style', // No I18N
'summary', // No I18N
'tabindex', // No I18N
'title', // No I18N
'translate', // No I18N
'type', // No I18N
'usemap', // No I18N
'valign', // No I18N
'value', // No I18N
'width', // No I18N
'xmlns', // No I18N
'slot' // No I18N
]);

var svg$1 = freeze$1(['accent-height', // No I18N
'accumulate', // No I18N
'additive', // No I18N
'alignment-baseline', // No I18N
'ascent', // No I18N
'attributename', // No I18N
'attributetype', // No I18N
'azimuth', // No I18N
'basefrequency', // No I18N
'baseline-shift', // No I18N
'begin', // No I18N
'bias', // No I18N
'by', // No I18N
'class', // No I18N
'clip', // No I18N
'clippathunits', // No I18N
'clip-path', // No I18N
'clip-rule', // No I18N
'color', // No I18N
'color-interpolation', // No I18N
'color-interpolation-filters', // No I18N
'color-profile', // No I18N
'color-rendering', // No I18N
'cx', // No I18N
'cy', // No I18N
'd', // No I18N
'dx', // No I18N
'dy', // No I18N
'diffuseconstant', // No I18N
'direction', // No I18N
'display', // No I18N
'divisor', // No I18N
'dur', // No I18N
'edgemode', // No I18N
'elevation', // No I18N
'end', // No I18N
'fill', // No I18N
'fill-opacity', // No I18N
'fill-rule', // No I18N
'filter', // No I18N
'filterunits', // No I18N
'flood-color', // No I18N
'flood-opacity', // No I18N
'font-family', // No I18N
'font-size', // No I18N
'font-size-adjust', // No I18N
'font-stretch', // No I18N
'font-style', // No I18N
'font-variant', // No I18N
'font-weight', // No I18N
'fx', // No I18N
'fy', // No I18N
'g1', // No I18N
'g2', // No I18N
'glyph-name', // No I18N
'glyphref', // No I18N
'gradientunits', // No I18N
'gradienttransform', // No I18N
'height', // No I18N
'href', // No I18N
'id', // No I18N
'image-rendering', // No I18N
'in', // No I18N
'in2', // No I18N
'k', // No I18N
'k1', // No I18N
'k2', // No I18N
'k3', // No I18N
'k4', // No I18N
'kerning', // No I18N
'keypoints', // No I18N
'keysplines', // No I18N
'keytimes', // No I18N
'lang', // No I18N
'lengthadjust', // No I18N
'letter-spacing', // No I18N
'kernelmatrix', // No I18N
'kernelunitlength', // No I18N
'lighting-color', // No I18N
'local', // No I18N
'marker-end', // No I18N
'marker-mid', // No I18N
'marker-start', // No I18N
'markerheight', // No I18N
'markerunits', // No I18N
'markerwidth', // No I18N
'maskcontentunits', // No I18N
'maskunits', // No I18N
'max', // No I18N
'mask', // No I18N
'media', // No I18N
'method', // No I18N
'mode', // No I18N
'min', // No I18N
'name', // No I18N
'numoctaves', // No I18N
'offset', // No I18N
'operator', // No I18N
'opacity', // No I18N
'order', // No I18N
'orient', // No I18N
'orientation', // No I18N
'origin', // No I18N
'overflow', // No I18N
'paint-order', // No I18N
'path', // No I18N
'pathlength', // No I18N
'patterncontentunits', // No I18N
'patterntransform', // No I18N
'patternunits', // No I18N
'points', // No I18N
'preservealpha', // No I18N
'preserveaspectratio', // No I18N
'primitiveunits', // No I18N
'r', // No I18N
'rx', // No I18N
'ry', // No I18N
'radius', // No I18N
'refx', // No I18N
'refy', // No I18N
'repeatcount', // No I18N
'repeatdur', // No I18N
'restart', // No I18N
'result', // No I18N
'rotate', // No I18N
'scale', // No I18N
'seed', // No I18N
'shape-rendering', // No I18N
'specularconstant', // No I18N
'specularexponent', // No I18N
'spreadmethod', // No I18N
'startoffset', // No I18N
'stddeviation', // No I18N
'stitchtiles', // No I18N
'stop-color', // No I18N
'stop-opacity', // No I18N
'stroke-dasharray', // No I18N
'stroke-dashoffset', // No I18N
'stroke-linecap', // No I18N
'stroke-linejoin', // No I18N
'stroke-miterlimit', // No I18N
'stroke-opacity', // No I18N
'stroke', // No I18N
'stroke-width', // No I18N
'style', // No I18N
'surfacescale', // No I18N
'systemlanguage', // No I18N
'tabindex', // No I18N
'targetx', // No I18N
'targety', // No I18N
'transform', // No I18N
'transform-origin', // No I18N
'text-anchor', // No I18N
'text-decoration', // No I18N
'text-rendering', // No I18N
'textlength', // No I18N
'type', // No I18N
'u1', // No I18N
'u2', // No I18N
'unicode', // No I18N
'values', // No I18N
'viewbox', // No I18N
'visibility', // No I18N
'version', // No I18N
'vert-adv-y', // No I18N
'vert-origin-x', // No I18N
'vert-origin-y', // No I18N
'width', // No I18N
'word-spacing', // No I18N
'wrap', // No I18N
'writing-mode', // No I18N
'xchannelselector', // No I18N
'ychannelselector', // No I18N
'x', // No I18N
'x1', // No I18N
'x2', // No I18N
'xmlns', // No I18N
'y', // No I18N
'y1', // No I18N
'y2', // No I18N
'z', // No I18N
'zoomandpan' // No I18N
]);

var mathMl$1 = freeze$1(['accent', // No I18N
'accentunder', // No I18N
'align', // No I18N
'bevelled', // No I18N
'close', // No I18N
'columnsalign', // No I18N
'columnlines', // No I18N
'columnspan', // No I18N
'denomalign', // No I18N
'depth', // No I18N
'dir', // No I18N
'display', // No I18N
'displaystyle', // No I18N
'encoding', // No I18N
'fence', // No I18N
'frame', // No I18N
'height', // No I18N
'href', // No I18N
'id', // No I18N
'largeop', // No I18N
'length', // No I18N
'linethickness', // No I18N
'lspace', // No I18N
'lquote', // No I18N
'mathbackground', // No I18N
'mathcolor', // No I18N
'mathsize', // No I18N
'mathvariant', // No I18N
'maxsize', // No I18N
'minsize', // No I18N
'movablelimits', // No I18N
'notation', // No I18N
'numalign', // No I18N
'open', // No I18N
'rowalign', // No I18N
'rowlines', // No I18N
'rowspacing', // No I18N
'rowspan', // No I18N
'rspace', // No I18N
'rquote', // No I18N
'scriptlevel', // No I18N
'scriptminsize', // No I18N
'scriptsizemultiplier', // No I18N
'selection', // No I18N
'separator', // No I18N
'separators', // No I18N
'stretchy', // No I18N
'subscriptshift', // No I18N
'supscriptshift', // No I18N
'symmetric', // No I18N
'voffset', // No I18N
'width', // No I18N
'xmlns' // No I18N
]);

var xml = freeze$1(['xlink:href', // No I18N
'xml:id', // No I18N
'xlink:title', // No I18N
'xml:space', // No I18N
'xmlns:xlink' // No I18N
]);

// eslint-disable-next-line unicorn/better-regex
var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
var TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape
var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
);
var DOCTYPE_NAME = seal(/^html$/i);
var CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray$2(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var getGlobal = function getGlobal() {
  return typeof window === 'undefined' ? null : window;
}; // No I18N

/**
 * Creates a no-op policy for internal use only.
 * Don't export this function outside this module!
 * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
 * @param {Document} document The document object (to determine policy name suffix)
 * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
 * are not supported).
 */
var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
  if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || // No I18N
  typeof trustedTypes.createPolicy !== 'function' // No I18N
  ) {
      return null;
    }

  // Allow the callers to control the unique policy name
  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
  // Policy creation with duplicate names throws in Trusted Types.
  var suffix = null;
  var ATTR_NAME = 'data-tt-policy-suffix'; // No I18N
  if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
    suffix = document.currentScript.getAttribute(ATTR_NAME);
  }

  var policyName = 'dompurify' + (suffix ? '#' + suffix : ''); // No I18N

  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML: function createHTML(html$$1) {
        return html$$1;
      },
      createScriptURL: function createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_) {
    // Policy creation failed (most likely another DOMPurify script has
    // already run). Skip creating the policy, as this will only cause errors
    // if TT are enforced.
    // Comment #09
    // console.warn(
    //   'TrustedTypes policy ' + policyName + ' could not be created.' // No I18N
    // );
    return null;
  }
};

function createDOMPurify() {
  var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

  var DOMPurify = function DOMPurify(root) {
    return createDOMPurify(root);
  };

  /**
   * Version label, exposed for easier checks
   * if DOMPurify is up to date or not
   */
  DOMPurify.version = '2.5.4'; // Comment #00 // No I18N

  /**
   * Array of elements that DOMPurify removed during sanitation.
   * Empty if nothing was removed.
   */
  DOMPurify.removed = [];

  if (!window || !window.document || window.document.nodeType !== 9) {
    // Not running in a browser, provide a factory function
    // so that you can pass your own Window
    DOMPurify.isSupported = false;

    return DOMPurify;
  }

  var originalDocument = window.document;

  var document = window.document;
  var DocumentFragment = window.DocumentFragment,
      HTMLTemplateElement = window.HTMLTemplateElement,
      Node = window.Node,
      Element = window.Element,
      NodeFilter = window.NodeFilter,
      _window$NamedNodeMap = window.NamedNodeMap,
      NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
      HTMLFormElement = window.HTMLFormElement,
      DOMParser = window.DOMParser,
      trustedTypes = window.trustedTypes;


  var ElementPrototype = Element.prototype;

  var cloneNode = lookupGetter(ElementPrototype, 'cloneNode'); // No I18N
  var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling'); // No I18N
  var getChildNodes = lookupGetter(ElementPrototype, 'childNodes'); // No I18N
  var getParentNode = lookupGetter(ElementPrototype, 'parentNode'); // No I18N

  // As per issue #47, the web-components registry is inherited by a
  // new document created via createHTMLDocument. As per the spec
  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
  // a new empty registry is used when creating a template contents owner
  // document, so we use that as our parent document to ensure nothing
  // is inherited.
  if (typeof HTMLTemplateElement === 'function') {
    // No I18N
    var template = document.createElement('template'); // No I18N
    if (template.content && template.content.ownerDocument) {
      document = template.content.ownerDocument;
    }
  }

  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
  var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';

  var _document = document,
      implementation = _document.implementation,
      createNodeIterator = _document.createNodeIterator,
      createDocumentFragment = _document.createDocumentFragment,
      getElementsByTagName = _document.getElementsByTagName;
  var importNode = originalDocument.importNode;


  var documentMode = {};
  try {
    documentMode = clone(document).documentMode ? document.documentMode : {};
  } catch (_) {}

  var hooks = {};

  /**
   * Expose whether this browser supports running the full DOMPurify.
   */
  DOMPurify.isSupported = typeof getParentNode === 'function' && // No I18N
  implementation && implementation.createHTMLDocument !== undefined && documentMode !== 9;

  var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,
      ERB_EXPR$$1 = ERB_EXPR,
      TMPLIT_EXPR$$1 = TMPLIT_EXPR,
      DATA_ATTR$$1 = DATA_ATTR,
      ARIA_ATTR$$1 = ARIA_ATTR,
      IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,
      ATTR_WHITESPACE$$1 = ATTR_WHITESPACE,
      CUSTOM_ELEMENT$$1 = CUSTOM_ELEMENT;
  var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;

  /**
   * We consider the elements and attributes below to be safe. Ideally
   * don't add any new ones but feel free to remove unwanted ones.
   */

  /* allowed element names */

  var ALLOWED_TAGS = null;
  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$2(html), _toConsumableArray$2(svg), _toConsumableArray$2(svgFilters), _toConsumableArray$2(mathMl), _toConsumableArray$2(text)));
  var DONT_TRIM = true; // Comment #03

  /* Allowed attribute names */
  var ALLOWED_ATTR = null;
  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$2(html$1), _toConsumableArray$2(svg$1), _toConsumableArray$2(mathMl$1), _toConsumableArray$2(xml)));

  /*
   * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.
   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
   */
  var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));

  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
  var FORBID_TAGS = null;

  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
  var FORBID_ATTR = null;

  /* Decide if ARIA attributes are okay */
  var ALLOW_ARIA_ATTR = true;

  /* Decide if custom data attributes are okay */
  var ALLOW_DATA_ATTR = true;

  /* Decide if unknown protocols are okay */
  var ALLOW_UNKNOWN_PROTOCOLS = false;

  /* Decide if self-closing tags in attributes are allowed.
   * Usually removed due to a mXSS issue in jQuery 3.0 */
  var ALLOW_SELF_CLOSE_IN_ATTR = true;

  /* Output should be safe for common template engines.
   * This means, DOMPurify removes data attributes, mustaches and ERB
   */
  var SAFE_FOR_TEMPLATES = false;

  /* Output should be safe even for XML used within HTML and alike.
   * This means, DOMPurify removes comments when containing risky content.
   */
  var SAFE_FOR_XML = true;

  /* Decide if document with <html>... should be returned */
  var WHOLE_DOCUMENT = false;

  /* Track whether config is already set on this instance of DOMPurify. */
  var SET_CONFIG = false;

  /* Decide if all elements (e.g. style, script) must be children of
   * document.body. By default, browsers might move them to document.head */
  var FORCE_BODY = false;

  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
   * string (or a TrustedHTML object if Trusted Types are supported).
   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
   */
  var RETURN_DOM = false;

  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
   * string  (or a TrustedHTML object if Trusted Types are supported) */
  var RETURN_DOM_FRAGMENT = false;

  /* Try to return a Trusted Type object instead of a string, return a string in
   * case Trusted Types are not supported  */
  var RETURN_TRUSTED_TYPE = false;

  /* Output should be free from DOM clobbering attacks?
   * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
   */
  var SANITIZE_DOM = true;

  /* Achieve full DOM Clobbering protection by isolating the namespace of named
   * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
   *
   * HTML/DOM spec rules that enable DOM Clobbering:
   *   - Named Access on Window (7.3.3)
   *   - DOM Tree Accessors (3.1.5)
   *   - Form Element Parent-Child Relations (4.10.3)
   *   - Iframe srcdoc / Nested WindowProxies (4.8.5)
   *   - HTMLCollection (4.2.10.2)
   *
   * Namespace isolation is implemented by prefixing `id` and `name` attributes
   * with a constant string, i.e., `user-content-`
   */
  var SANITIZE_NAMED_PROPS = false;
  var SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';

  /* Keep element content when removing element? */
  var KEEP_CONTENT = true;

  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
   * of importing it into a new Document and returning a sanitized copy */
  var IN_PLACE = false;

  /* Allow usage of profiles like html, svg and mathMl */
  var USE_PROFILES = {};

  /* Tags to ignore content of when KEEP_CONTENT is true */
  var FORBID_CONTENTS = null;
  var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', // No I18N
  'audio', // No I18N
  'colgroup', // No I18N
  'desc', // No I18N
  'foreignobject', // No I18N
  'head', // No I18N
  'iframe', // No I18N
  'math', // No I18N
  'mi', // No I18N
  'mn', // No I18N
  'mo', // No I18N
  'ms', // No I18N
  'mtext', // No I18N
  'noembed', // No I18N
  'noframes', // No I18N
  'noscript', // No I18N
  'plaintext', // No I18N
  'script', // No I18N
  'style', // No I18N
  'svg', // No I18N
  'template', // No I18N
  'thead', // No I18N
  'title', // No I18N
  'video', // No I18N
  'xmp' // No I18N
  ]);

  /* Tags that are safe for data: URIs */
  var DATA_URI_TAGS = null;
  var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', // No I18N
  'video', // No I18N
  'img', // No I18N
  'source', // No I18N
  'image', // No I18N
  'track' // No I18N
  ]);

  /* Attributes safe for values like "javascript:" */ // No I18N
  var URI_SAFE_ATTRIBUTES = null;
  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', // No I18N
  'class', // No I18N
  'for', // No I18N
  'id', // No I18N
  'label', // No I18N
  'name', // No I18N
  'pattern', // No I18N
  'placeholder', // No I18N
  'role', // No I18N
  'summary', // No I18N
  'title', // No I18N
  'value', // No I18N
  'style', // No I18N
  'xmlns' // No I18N
  ]);

  var MATHML_NAMESPACE = 'ht' + 'tp://www.w3.org/1998/Math/MathML'; // No I18N
  var SVG_NAMESPACE = 'ht' + 'tp://www.w3.org/2000/svg'; // No I18N
  var HTML_NAMESPACE = 'ht' + 'tp://www.w3.org/1999/xhtml'; // No I18N
  /* Document namespace */
  var NAMESPACE = HTML_NAMESPACE;
  var IS_EMPTY_INPUT = false;

  /* Allowed XHTML+XML namespaces */
  var ALLOWED_NAMESPACES = null;
  var DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);

  /* Parsing of strict XHTML documents */
  var PARSER_MEDIA_TYPE = void 0;
  var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
  var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
  var transformCaseFunc = void 0;

  /* Keep a reference to config to pass to hooks */
  var CONFIG = null;

  /* Specify the maximum element nesting depth to prevent mXSS */
  var MAX_NESTING_DEPTH = 255;

  /* Ideally, do not touch anything below this line */
  /* ______________________________________________ */

  var formElement = document.createElement('form'); // No I18N

  var isRegexOrFunction = function isRegexOrFunction(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };

  /**
   * _parseConfig
   *
   * @param  {Object} cfg optional config literal
   */
  // eslint-disable-next-line complexity
  var _parseConfig = function _parseConfig(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }

    /* Shield configuration object from tampering */
    if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {
      // No I18N
      cfg = {};
    }

    /* Shield configuration object from prototype pollution */
    cfg = clone(cfg);

    PARSER_MEDIA_TYPE =
    // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;

    // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
    transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;

    /* Set configuration parameters */
    ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg // No I18N
    ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg // No I18N
    ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    ALLOWED_NAMESPACES = 'ALLOWED_NAMESPACES' in cfg // No I18N
    ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
    URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg // No I18N
    ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), // eslint-disable-line indent
    cfg.ADD_URI_SAFE_ATTR, // eslint-disable-line indent
    transformCaseFunc // eslint-disable-line indent
    ) // eslint-disable-line indent
    : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg // No I18N
    ? addToSet(clone(DEFAULT_DATA_URI_TAGS), // eslint-disable-line indent
    cfg.ADD_DATA_URI_TAGS, // eslint-disable-line indent
    transformCaseFunc // eslint-disable-line indent
    ) // eslint-disable-line indent
    : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {}; // No I18N
    FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {}; // No I18N
    USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
    SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
    RETURN_DOM = cfg.RETURN_DOM || false; // Default false
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
    DONT_TRIM = cfg.DONT_TRIM !== false; // Default true // Comment #03
    FORCE_BODY = cfg.FORCE_BODY || false; // Default false
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
    IN_PLACE = cfg.IN_PLACE || false; // Default false
    IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }

    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }

    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }

    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }

    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }

    /* Parse profile info */
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$2(text)));
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html);
        addToSet(ALLOWED_ATTR, html$1);
      }

      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg);
        addToSet(ALLOWED_ATTR, svg$1);
        addToSet(ALLOWED_ATTR, xml);
      }

      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg$1);
        addToSet(ALLOWED_ATTR, xml);
      }

      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl);
        addToSet(ALLOWED_ATTR, mathMl$1);
        addToSet(ALLOWED_ATTR, xml);
      }
    }

    /* Merge configuration parameters */
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }

      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }

    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }

      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }

    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }

    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }

      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }

    /* Add #text in case KEEP_CONTENT is set to true */
    if (KEEP_CONTENT) {
      ALLOWED_TAGS['#text'] = true; // No I18N
    }

    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']); // No I18N
    }

    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ['tbody']); // No I18N
      delete FORBID_TAGS.tbody;
    }

    // Prevent further manipulation of configuration.
    // Not available in IE8, Safari 5, etc.
    if (freeze$1) {
      freeze$1(cfg);
    }

    CONFIG = cfg;
  };

  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', // No I18N
  'mo', // No I18N
  'mn', // No I18N
  'ms', // No I18N
  'mtext' // No I18N
  ]);

  var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', // No I18N
  'annotation-xml' // No I18N
  ]);

  // Certain elements are allowed in both SVG and HTML
  // namespace. We need to specify them explicitly
  // so that they don't get erroneously deleted from
  // HTML namespace.
  var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', // No I18N
  'style', // No I18N
  'font', // No I18N
  'a', // No I18N
  'script' // No I18N
  ]);

  /* Keep track of all possible SVG and MathML tags
   * so that we can perform the namespace checks
   * correctly. */
  var ALL_SVG_TAGS = addToSet({}, svg);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);

  var ALL_MATHML_TAGS = addToSet({}, mathMl);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);

  /**
   *
   *
   * @param  {Element} element a DOM element whose namespace is being checked
   * @returns {boolean} Return false if the element has a
   *  namespace that a spec-compliant parser would never
   *  return. Return true otherwise.
   */
  var _checkValidNamespace = function _checkValidNamespace(element) {
    var parent = getParentNode(element);

    // In JSDOM, if we're inside shadow DOM, then parentNode
    // can be null. We just simulate parent in this case.
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: NAMESPACE,
        tagName: 'template' // No I18N
      };
    }

    var tagName = stringToLowerCase(element.tagName);
    var parentTagName = stringToLowerCase(parent.tagName);

    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
      return false;
    }

    if (element.namespaceURI === SVG_NAMESPACE) {
      // The only way to switch from HTML namespace to SVG
      // is via <svg>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'svg'; // No I18N
      }

      // The only way to switch from MathML to SVG is via`
      // svg if parent is either <annotation-xml> or MathML
      // text integration points.
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === 'svg' && ( // No I18N
        parentTagName === 'annotation-xml' || // No I18N
        MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }

      // We only allow elements that are defined in SVG
      // spec. All others are disallowed in SVG namespace.
      return Boolean(ALL_SVG_TAGS[tagName]);
    }

    if (element.namespaceURI === MATHML_NAMESPACE) {
      // The only way to switch from HTML namespace to MathML
      // is via <math>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'math'; // No I18N
      }

      // The only way to switch from SVG to MathML is via
      // <math> and HTML integration points
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName]; // No I18N
      }

      // We only allow elements that are defined in MathML
      // spec. All others are disallowed in MathML namespace.
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }

    if (element.namespaceURI === HTML_NAMESPACE) {
      // The only way to switch from SVG to HTML is via
      // HTML integration points, and from MathML to HTML
      // is via MathML text integration points
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }

      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }

      // We disallow tags that are specific for MathML
      // or SVG and should never appear in HTML namespace
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }

    // For XHTML and XML documents that support custom namespaces
    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {
      return true;
    }

    // The code should never reach this place (this means
    // that the element somehow got namespace that is not
    // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).
    // Return false just in case.
    return false;
  };

  /**
   * _forceRemove
   *
   * @param  {Node} node a DOM node
   */
  var _forceRemove = function _forceRemove(node) {
    arrayPush(DOMPurify.removed, { element: node });
    try {
      // eslint-disable-next-line unicorn/prefer-dom-node-remove
      node.parentNode.removeChild(node);
    } catch (_) {
      try {
        node.outerHTML = emptyHTML;
      } catch (_) {
        node.remove();
      }
    }
  };

  /**
   * _removeAttribute
   *
   * @param  {String} name an Attribute name
   * @param  {Node} node a DOM node
   */
  var _removeAttribute = function _removeAttribute(name, node) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node.getAttributeNode(name),
        from: node
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node
      });
    }

    node.removeAttribute(name);

    // We void attribute values for unremovable "is"" attributes // No I18N
    if (name === 'is' && !ALLOWED_ATTR[name]) {
      // No I18N
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node);
        } catch (_) {}
      } else {
        try {
          node.setAttribute(name, '');
        } catch (_) {}
      }
    }
  };

  /**
   * _initDocument
   *
   * @param  {String} dirty a string of dirty markup
   * @return {Document} a DOM, filled with the dirty markup
   */
  var _initDocument = function _initDocument(dirty) {
    /* Create a HTML document */
    var doc = void 0;
    var leadingWhitespace = void 0;

    if (FORCE_BODY) {
      dirty = '<remove></remove>' + dirty; // No I18N
    } else {
      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
      var matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }

    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {
      // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
    }

    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    /*
     * Use the DOMParser API by default, fallback later if needs be
     * DOMParser not work for svg when has multiple root element.
     */
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_) {}
    }

    /* Use createHTMLDocument in case DOMParser is not available */
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, 'template', null); // No I18N
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
      } catch (_) {
        // Syntax error if dirtyPayload is invalid xml
      }
    }

    var body = doc.body || doc.documentElement;

    if (dirty && leadingWhitespace) {
      body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }

    /* Work on whole document or just its body */
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body' // No I18N
      )[0];
    }

    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };

  /**
   * _createIterator
   *
   * @param  {Document} root document/fragment to create iterator for
   * @return {Iterator} iterator instance
   */
  var _createIterator = function _createIterator(root) {
    return createNodeIterator.call(root.ownerDocument || root, root,
    // eslint-disable-next-line no-bitwise
    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null, false);
  };

  /**
   * _isClobbered
   *
   * @param  {Node} elm element to check for clobbering attacks
   * @return {Boolean} true if clobbered, false if safe
   */
  var _isClobbered = function _isClobbered(elm) {
    return elm instanceof HTMLFormElement && (typeof elm.__depth !== 'undefined' && typeof elm.__depth !== 'number' || typeof elm.__removalCount !== 'undefined' && typeof elm.__removalCount !== 'number' || typeof elm.nodeName !== 'string' || // No I18N
    typeof elm.textContent !== 'string' || // No I18N
    typeof elm.removeChild !== 'function' || // No I18N
    !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || // No I18N
    typeof elm.setAttribute !== 'function' || // No I18N
    typeof elm.namespaceURI !== 'string' || // No I18N
    typeof elm.insertBefore !== 'function' || // No I18N
    typeof elm.hasChildNodes !== 'function') // No I18N
    ;
  };

  /**
   * _isNode
   *
   * @param  {Node} obj object to check whether it's a DOM node
   * @return {Boolean} true is object is a DOM node
   */
  var _isNode = function _isNode(object) {
    return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' // No I18N
    ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && // No I18N
    typeof object.nodeType === 'number' && // No I18N
    typeof object.nodeName === 'string'; // No I18N
  };

  /**
   * _executeHook
   * Execute user configurable hooks
   *
   * @param  {String} entryPoint  Name of the hook's entry point
   * @param  {Node} currentNode node to work on with the hook
   * @param  {Object} data additional hook parameters
   */
  var _executeHook = function _executeHook(entryPoint, currentNode, data) {
    if (!hooks[entryPoint]) {
      return;
    }

    arrayForEach(hooks[entryPoint], function (hook) {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  };

  /**
   * _sanitizeElements
   *
   * @protect nodeName
   * @protect textContent
   * @protect removeChild
   *
   * @param   {Node} currentNode to check for permission to exist
   * @return  {Boolean} true if node was killed, false if left alive
   */
  var _sanitizeElements = function _sanitizeElements(currentNode) {
    var content = void 0;

    /* Execute a hook if present */
    _executeHook('beforeSanitizeElements', currentNode, null); // No I18N

    /* Check if element is clobbered or can clobber */
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Check if tagname contains Unicode */
    if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Now let's check the element's type and name */ // No I18N
    var tagName = transformCaseFunc(currentNode.nodeName);

    /* Execute a hook if present */
    _executeHook('uponSanitizeElement', currentNode, { // No I18N
      tagName: tagName,
      allowedTags: ALLOWED_TAGS
    });

    /* Detect mXSS attempts abusing namespace confusion */
    if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Mitigate a problem with templates inside select */
    if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Remove any ocurrence of processing instructions */
    if (currentNode.nodeType === 7) {
      _forceRemove(currentNode);
      return true;
    }

    /* Remove any kind of possibly harmful comments */
    if (SAFE_FOR_XML && currentNode.nodeType === 8 && regExpTest(/<[/\w]/g, currentNode.data)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Remove element if anything forbids its presence */
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      /* Check if we have a custom element to handle */
      if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;
      }

      /* Keep content except for bad-listed elements */
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        var parentNode = getParentNode(currentNode) || currentNode.parentNode;
        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

        if (childNodes && parentNode) {
          var childCount = childNodes.length;

          for (var i = childCount - 1; i >= 0; --i) {
            var childClone = cloneNode(childNodes[i], true);
            childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
            parentNode.insertBefore(childClone, getNextSibling(currentNode));
          }
        }
      }

      _forceRemove(currentNode);
      return true;
    }

    /* Check whether element has a valid namespace */
    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Make sure that older browsers don't get fallback-tag mXSS */
    if ((tagName === 'noscript' || // No I18N
    tagName === 'noembed' || // No I18N
    tagName === 'noframes') && // No I18N
    regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Sanitize element content to be template-safe */
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      /* Get the element's text content */
      content = currentNode.textContent;
      content = stringReplace(content, MUSTACHE_EXPR$$1, ' '); // No I18N
      content = stringReplace(content, ERB_EXPR$$1, ' '); // No I18N
      content = stringReplace(content, TMPLIT_EXPR$$1, ' '); // No I18N
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
        currentNode.textContent = content;
      }
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeElements', currentNode, null); // No I18N

    return false;
  };

  /**
   * _isValidAttribute
   *
   * @param  {string} lcTag Lowercase tag name of containing element.
   * @param  {string} lcName Lowercase attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid, otherwise false.
   */
  // eslint-disable-next-line complexity
  var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
    /* Make sure attribute cannot clobber */
    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && ( // No I18N
    value in document || value in formElement || value === '__depth' || // No I18N
    value === '__removalCount') // No I18N
    ) {
        return false;
      }

    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) {
      // This attribute is safe
       // Comment #08
    } else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) {
      // This attribute is safe
      /* Otherwise, check the name is permitted */
       // Comment #08
    } else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
      // First condition does a very basic check if a) it's basically a valid custom element tagname AND
      // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
      // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
      _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) ||
      // Alternative, second condition checks if it's an `is`-attribute, AND
      // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
      lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) {
        // If user has supplied a regexp or function in CUSTOM_ELEMENT_HANDLING.tagNameCheck, we need to also allow derived custom elements using the same tagName test.
        // Additionally, we need to allow attributes passing the CUSTOM_ELEMENT_HANDLING.attributeNameCheck user has configured, as custom elements can define these at their own discretion.
         // Comment #08
      } else {
        return false;
      }
      /* Check value is safe. First, is attr inert? If so, is safe */
    } else if (URI_SAFE_ATTRIBUTES[lcName]) {
      // This attribute is safe
      /* Check no script, data or unknown possibly unsafe URI
        unless we know URI values are safe for that attribute */
       // Comment #08
    } else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) {
      // This attribute is safe
      /* Keep image data URIs alive if src/xlink:href is allowed */
      /* Further prevent gadget XSS for dynamically built script tags */
       // Comment #08
    } else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && // No I18N
    lcTag !== 'script' && // No I18N
    stringIndexOf(value, 'data:') === 0 && // No I18N
    DATA_URI_TAGS[lcTag]) {
      // This attribute is safe
      /* Allow unknown protocols: This provides support for links that
        are handled by protocol handlers which may be unknown ahead of
        time, e.g. fb:, spotify: */
       // Comment #08
    } else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) {
      // This attribute is safe
      /* Check for binary attributes */
      // eslint-disable-next-line no-negated-condition
       // Comment #08
    } else if (value) {
      return false;
    } else {
      // Binary attributes are safe at this point
      /* Anything else, presume unsafe, do not add it back */
       // Comment #08
    }

    return true;
  };

  /**
   * _basicCustomElementCheck
   * checks if at least one dash is included in tagName, and it's not the first char
   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
   * @param {string} tagName name of the tag of the node to sanitize
   */
  var _basicCustomElementTest = function _basicCustomElementTest(tagName) {
    return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT$$1);
  };

  /**
   * _sanitizeAttributes
   *
   * @protect attributes
   * @protect nodeName
   * @protect removeAttribute
   * @protect setAttribute
   *
   * @param  {Node} currentNode to sanitize
   * @return {Boolean} Returns true if the entire element needs to be removed, otherwise false. // Comment #04
   */
  var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
    var attr = void 0;
    var value = void 0;
    var lcName = void 0;
    var l = void 0;
    /* Execute a hook if present */
    _executeHook('beforeSanitizeAttributes', currentNode, null); // No I18N

    var attributes = currentNode.attributes;

    /* Check if we have attributes; if not we might have a text node */

    if (!attributes) {
      return false; // Comment #04
    }

    var hookEvent = {
      attrName: '',
      attrValue: '',
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR,
      nodeName: currentNode.nodeName.toLowerCase() // Comment #04
    };
    l = attributes.length;

    /* Go backwards over all attributes; safely remove bad ones */
    while (l--) {
      attr = attributes[l];
      var _attr = attr,
          name = _attr.name,
          namespaceURI = _attr.namespaceURI;

      value = name === 'value' ? attr.value : stringTrim(attr.value);
      if (DONT_TRIM) {
        value = attr.value;
      } // Comment #03
      lcName = transformCaseFunc(name);

      /* Execute a hook if present */
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.keepElement = true; // Comment #04
      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
      _executeHook('uponSanitizeAttribute', currentNode, hookEvent); // No I18N
      if (!hookEvent.keepElement) {
        return true;
      } // Comment #04
      value = hookEvent.attrValue;
      /* Did the hooks approve of the attribute? */
      if (hookEvent.forceKeepAttr) {
        continue;
      }

      /* Remove attribute */
      _removeAttribute(name, currentNode);

      /* Did the hooks approve of the attribute? */
      if (!hookEvent.keepAttr) {
        continue;
      }

      /* Work around a security issue in jQuery 3.0 */
      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }

      /* Work around a security issue with comments inside attributes */
      if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }

      /* Sanitize attribute content to be template-safe */
      if (SAFE_FOR_TEMPLATES) {
        value = stringReplace(value, MUSTACHE_EXPR$$1, ' '); // No I18N
        value = stringReplace(value, ERB_EXPR$$1, ' '); // No I18N
        value = stringReplace(value, TMPLIT_EXPR$$1, ' '); // No I18N
      }

      /* Is `value` valid for this attribute? */
      var lcTag = currentNode.nodeName.toLowerCase();
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }

      /* Full DOM Clobbering protection via namespace isolation,
       * Prefix id and name attributes with `user-content-`
       */
      if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
        // Remove the attribute with this value
        _removeAttribute(name, currentNode);

        // Prefix the value and later re-create the attribute with the sanitized value
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }

      /* Handle attributes that require Trusted Types */
      if (trustedTypesPolicy && (typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) === 'object' && typeof trustedTypes.getAttributeType === 'function') {
        if (namespaceURI) {
          /* Namespaces are not yet supported, see https://bugs.chromium.org/p/chromium/issues/detail?id=1305293 */
        } else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case 'TrustedHTML':
              {
                value = trustedTypesPolicy.createHTML(value);
                break;
              }

            case 'TrustedScriptURL':
              {
                value = trustedTypesPolicy.createScriptURL(value);
                break;
              }

            default:
              {
                break;
              }
          }
        }
      }

      /* Handle invalid data-* attribute set by try-catching it */
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */ // No I18N
          currentNode.setAttribute(name, value);
        }

        if (_isClobbered(currentNode)) {
          _forceRemove(currentNode);
        } else {
          arrayPop(DOMPurify.removed);
        }
      } catch (_) {}
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeAttributes', currentNode, null); // No I18N
    return false; // Comment #04
  };

  /**
   * _sanitizeShadowDOM
   *
   * @param  {DocumentFragment} fragment to iterate over recursively
   */
  var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
    var shadowNode = void 0;
    var shadowIterator = _createIterator(fragment);

    /* Execute a hook if present */
    _executeHook('beforeSanitizeShadowDOM', fragment, null); // No I18N

    while (shadowNode = shadowIterator.nextNode()) {
      /* Execute a hook if present */
      _executeHook('uponSanitizeShadowNode', shadowNode, null); // No I18N

      /* Sanitize tags and elements */
      if (_sanitizeElements(shadowNode)) {
        continue;
      }

      var parentNode = getParentNode(shadowNode);

      /* Set the nesting depth of an element */
      if (shadowNode.nodeType === 1) {
        if (parentNode && parentNode.__depth) {
          /*
            We want the depth of the node in the original tree, which can
            change when it's removed from its parent.
          */
          shadowNode.__depth = (shadowNode.__removalCount || 0) + parentNode.__depth + 1;
        } else {
          shadowNode.__depth = 1;
        }
      }

      /*
       * Remove an element if nested too deeply to avoid mXSS
       * or if the __depth might have been tampered with
       */
      if (shadowNode.__depth >= MAX_NESTING_DEPTH || numberIsNaN(shadowNode.__depth)) {
        _forceRemove(shadowNode);
      }

      /* Deep shadow DOM detected */
      if (shadowNode.content instanceof DocumentFragment) {
        shadowNode.content.__depth = shadowNode.__depth;
        _sanitizeShadowDOM(shadowNode.content);
      }

      /* Check attributes, sanitize if necessary */
      if (_sanitizeAttributes(shadowNode)) {
        _forceRemove(shadowNode);
      } // Comment #04
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeShadowDOM', fragment, null); // No I18N
  };

  /**
   * Sanitize
   * Public method providing core sanitation functionality
   *
   * @param {String|Node} dirty string or DOM node
   * @param {Object} configuration object
   */
  // eslint-disable-next-line complexity
  DOMPurify.sanitize = function (dirty) {
    var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var body = void 0;
    var importedNode = void 0;
    var currentNode = void 0;
    var oldNode = void 0;
    var returnNode = void 0;
    /* Make sure we have a string to sanitize.
      DO NOT return early, as this will return the wrong type if
      the user has requested a DOM object rather than a string */
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = '<!-->'; // No I18N
    }

    /* Stringify, in case dirty is an object */
    if (typeof dirty !== 'string' && !_isNode(dirty)) {
      // No I18N
      if (typeof dirty.toString === 'function') {
        // No I18N
        dirty = dirty.toString();
        if (typeof dirty !== 'string') {
          // No I18N
          throw typeErrorCreate('dirty is not a string, aborting'); // No I18N
        }
      } else {
        throw typeErrorCreate('toString is not a function'); // No I18N
      }
    }

    /* Check we can run. Otherwise fall back or ignore */
    if (!DOMPurify.isSupported) {
      if (_typeof(window.toStaticHTML) === 'object' || // No I18N
      typeof window.toStaticHTML === 'function' // No I18N
      ) {
          if (typeof dirty === 'string') {
            // No I18N
            return window.toStaticHTML(dirty);
          }

          if (_isNode(dirty)) {
            return window.toStaticHTML(dirty.outerHTML);
          }
        }

      return dirty;
    }

    /* Assign config vars */
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }

    /* Clean up removed elements */
    DOMPurify.removed = [];

    /* Check if dirty is correctly typed for IN_PLACE */
    if (typeof dirty === 'string') {
      // No I18N
      IN_PLACE = false;
    }

    if (IN_PLACE) {
      /* Do some early pre-sanitization to avoid unsafe root nodes */
      if (dirty.nodeName) {
        var tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
        }
      }
    } else if (dirty instanceof Node) {
      /* If dirty is a DOM element, append to an empty document to avoid
         elements being stripped by the parser */
      body = _initDocument('<!---->'); // No I18N
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
        // No I18N
        /* Node is already a body, use as is */
        body = importedNode;
      } else if (importedNode.nodeName === 'HTML') {
        // No I18N
        body = importedNode;
      } else {
        // eslint-disable-next-line unicorn/prefer-dom-node-append
        body.appendChild(importedNode);
      }
    } else {
      /* Exit directly if we have nothing to do */
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
      // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf('<') === -1 // No I18N
      ) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }

      /* Initialize the document to work on */
      body = _initDocument(dirty);

      /* Check we have a DOM node from the data */
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
      }
    }

    /* Remove first element node (ours) if FORCE_BODY is set */
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }

    /* Get node iterator */
    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);

    /* Now start iterating over the created document */
    while (currentNode = nodeIterator.nextNode()) {
      /* Fix IE's strange behavior with manipulated textNodes #89 */
      if (currentNode.nodeType === 3 && currentNode === oldNode) {
        continue;
      }

      /* Sanitize tags and elements */
      if (_sanitizeElements(currentNode)) {
        continue;
      }

      var parentNode = getParentNode(currentNode);

      /* Set the nesting depth of an element */
      if (currentNode.nodeType === 1) {
        if (parentNode && parentNode.__depth) {
          /*
            We want the depth of the node in the original tree, which can
            change when it's removed from its parent.
          */
          currentNode.__depth = (currentNode.__removalCount || 0) + parentNode.__depth + 1;
        } else {
          currentNode.__depth = 1;
        }
      }

      /*
       * Remove an element if nested too deeply to avoid mXSS
       * or if the __depth might have been tampered with
       */
      if (currentNode.__depth >= MAX_NESTING_DEPTH || numberIsNaN(currentNode.__depth)) {
        _forceRemove(currentNode);
      }

      /* Shadow DOM detected, sanitize it */
      if (currentNode.content instanceof DocumentFragment) {
        currentNode.content.__depth = currentNode.__depth;
        _sanitizeShadowDOM(currentNode.content);
      }

      /* Check attributes, sanitize if necessary */
      if (_sanitizeAttributes(currentNode)) {
        _forceRemove(currentNode);continue;
      } // Comment #04

      oldNode = currentNode;
    }

    oldNode = null;

    /* If we sanitized `dirty` in-place, return it. */
    if (IN_PLACE) {
      return dirty;
    }

    /* Return sanitized string or DOM */
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);

        while (body.firstChild) {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }

      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmod) {
        /*
          AdoptNode() is not used because internal state is not reset
          (e.g. the past names map of a HTMLFormElement), this is safe
          in theory but we would rather not risk another attack vector.
          The state that is cloned by importNode() is explicitly defined
          by the specs.
        */
        returnNode = importNode.call(originalDocument, returnNode, true);
      }

      return returnNode;
    }

    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;

    /* Serialize doctype if allowed */
    if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
    }

    /* Sanitize final string template-safe */
    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' '); // No I18N
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' '); // No I18N
      serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR$$1, ' '); // No I18N
    }

    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };

  /**
   * Public method to set the configuration once
   * setConfig
   *
   * @param {Object} cfg configuration object
   */
  DOMPurify.setConfig = function (cfg) {
    _parseConfig(cfg);
    SET_CONFIG = true;
  };

  /**
   * Public method to remove the configuration
   * clearConfig
   *
   */
  DOMPurify.clearConfig = function () {
    CONFIG = null;
    SET_CONFIG = false;
  };

  /**
   * Public method to check if an attribute value is valid.
   * Uses last set config, if any. Otherwise, uses config defaults.
   * isValidAttribute
   *
   * @param  {string} tag Tag name of containing element.
   * @param  {string} attr Attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
   */
  DOMPurify.isValidAttribute = function (tag, attr, value) {
    /* Initialize shared config vars if necessary. */
    if (!CONFIG) {
      _parseConfig({});
    }

    var lcTag = stringToLowerCase(tag);
    var lcName = stringToLowerCase(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };

  /**
   * AddHook
   * Public method to add DOMPurify hooks
   *
   * @param {String} entryPoint entry point for the hook to add
   * @param {Function} hookFunction function to execute
   */
  DOMPurify.addHook = function (entryPoint, hookFunction) {
    if (typeof hookFunction !== 'function') {
      // No I18N
      return;
    }

    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };

  /**
   * RemoveHook
   * Public method to remove a DOMPurify hook at a given entryPoint
   * (pops it from the stack of hooks if more are present)
   *
   * @param {String} entryPoint entry point for the hook to remove
   * @return {Function} removed(popped) hook
   */
  DOMPurify.removeHook = function (entryPoint) {
    if (hooks[entryPoint]) {
      return arrayPop(hooks[entryPoint]);
    }
  };

  /**
   * RemoveHooks
   * Public method to remove all DOMPurify hooks at a given entryPoint
   *
   * @param  {String} entryPoint entry point for the hooks to remove
   */
  DOMPurify.removeHooks = function (entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };

  /**
   * RemoveAllHooks
   * Public method to remove all DOMPurify hooks
   *
   */
  DOMPurify.removeAllHooks = function () {
    hooks = {};
  };

  return DOMPurify;
}

var createDOMPurify$1 = createDOMPurify();

/*
  Comment #00:
  Changing Version of DOMPurify

  Comment #03:
  Preserve the spaces in attribute values based on DONT_TRIM flag in config

  Comment #04:
  Added support to remove an Element based on attribute validation rule if ACTION = Remove Element

  Comment #08:
  Prevent empty block code-check issues

  Comment #09:
  Prevent console warning
 */

var seal$1 = Object.seal || function (x) {
  return x;
};

var REPLACEMENT_REGEX = seal$1(/\$\{[A-Z._]+?\}/i); // Specify Replacement detection regex for Attribute validation which replaces existing value

function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var freeze = Object.freeze;

/**
 * Factory Function to create new instances of HTMLPurifier
 *
 * @param   {Object}  config     Configuration to create the sanitizer instance
 * @param   {Object}  DOMPurify  DOMPurify instance which we use to create our Sanitizer Instance
 *
 * @return  {Object}             A fresh copy of HTMLPurifier.
 */

function factory$1(config, DOMPurify) {
  var GLOBAL_TAGS_ = 'GLOBAL_TAGS'; // No I18N
  var GLOBAL_ATTR_ = 'GLOBAL_ATTR'; // No I18N
  var GLOBAL_ATTRIBUTES_ = 'GLOBAL_ATTRIBUTES'; // No I18N // Comment #001
  var FORBID_TAGS_ = 'FORBID_TAGS'; // No I18N
  var FORBID_ATTR_ = 'FORBID_ATTR'; // No I18N
  var TAG_RULES_ = 'TAG_RULES'; // No I18N
  var STYLE_RULES_ = 'STYLE_RULES'; // No I18N
  var GLOBAL_ATTR_RULES_ = 'GLOBAL_ATTR_RULES'; // No I18N
  var GLOBAL_APPEND_ATTR_ = 'GLOBAL_APPEND_ATTR'; // No I18N
  var ADD_DATA_URI_TAGS_ = 'ADD_DATA_URI_TAGS'; // No I18N
  var ADD_URI_SAFE_ATTR_ = 'ADD_URI_SAFE_ATTR'; // No I18N

  var EXTENDS_ = 'EXTENDS'; // No I18N
  var REMOVE_ONEVENTS_ = 'REMOVE_ONEVENTS'; // No I18N

  var defaultForbiddenTags = ['script']; // No I18N
  var defaultForbiddenAttr = [];

  var runtimeConfigFlags = ['ALLOW_ARIA_ATTR', // No I18N
  'ALLOW_DATA_ATTR', // No I18N
  'ALLOW_UNKNOWN_PROTOCOLS', // No I18N
  'SAFE_FOR_TEMPLATES', // No I18N
  'WHOLE_DOCUMENT', // No I18N
  'RETURN_DOM', // No I18N
  'RETURN_DOM_FRAGMENT', // No I18N
  'IN_PLACE', // No I18N
  'DONT_TRIM', // No I18N
  'FORCE_BODY', // No I18N
  'SANITIZE_DOM', // No I18N
  'KEEP_CONTENT', // No I18N
  'ALLOWED_URI_REGEXP'];

  var nonExtendableConfigFlags = [];
  concatArray(nonExtendableConfigFlags, runtimeConfigFlags);
  concatArray(nonExtendableConfigFlags, [EXTENDS_, REMOVE_ONEVENTS_, 'ALLOWED_STYLE' // No I18N
  ]);

  var defaultTagRules = {
    iframe: {
      ATTR_RULES: {
        sandbox: {
          FALLBACK_VALUE: 'allow-popups allow-forms allow-scripts allow-same-origin', // No I18N
          CONDITIONS: [{
            NOT_CONTAINS: ['allow-top-navigation', // No I18N
            'allow-popups-to-escape-sandbox' // No I18N
            ]
          }]
        }
      },
      APPEND_ATTR: {
        sandbox: {
          APPEND_ATTR_VALUE: 'allow-popups allow-forms allow-scripts allow-same-origin' // No I18N
        }
      }
    },
    embed: {
      ATTR_RULES: {
        type: {
          CONDITIONS: [{
            EQUAL: 'application/pdf', // No I18N
            FALLBACK_VALUE: 'application/pdf' // No I18N
          }]
        }
      },
      APPEND_ATTR: {
        type: {
          APPEND_ATTR_VALUE: 'application/pdf' // No I18N
        },
        typemustmatch: {
          APPEND_ATTR_VALUE: 'true' // No I18N
        }
      }
    },
    object: {
      ATTR_RULES: {
        type: {
          CONDITIONS: [{
            EQUAL: 'application/pdf', // No I18N
            FALLBACK_VALUE: 'application/pdf' // No I18N
          }]
        }
      },
      APPEND_ATTR: {
        type: {
          APPEND_ATTR_VALUE: 'application/pdf' // No I18N
        },
        typemustmatch: {
          APPEND_ATTR_VALUE: 'true' // No I18N
        }
      }
    }
  };

  var altered = void 0;
  var tagRuleMap = void 0;
  var appendAttrMap = void 0;
  var GLOBAL_TAGS = config.GLOBAL_TAGS,
      GLOBAL_ATTR = config.GLOBAL_ATTR,
      FORBID_TAGS = config.FORBID_TAGS,
      FORBID_ATTR = config.FORBID_ATTR,
      TAG_RULES = config.TAG_RULES,
      STYLE_RULES = config.STYLE_RULES,
      GLOBAL_ATTR_RULES = config.GLOBAL_ATTR_RULES,
      GLOBAL_APPEND_ATTR = config.GLOBAL_APPEND_ATTR,
      TAG_SPECIFIC_ATTRS = config.TAG_SPECIFIC_ATTRS;
  var FORBID_PROPS = STYLE_RULES.FORBID_PROPS,
      FORBID_CSSRULES = STYLE_RULES.FORBID_CSSRULES,
      UNSAFE_PROP_RULES = STYLE_RULES.UNSAFE_PROP_RULES;


  var isStyleRulesPresent = FORBID_PROPS && FORBID_PROPS.length !== 0 || FORBID_CSSRULES && FORBID_CSSRULES.length !== 0;
  if (!isStyleRulesPresent) {
    objectIterator(UNSAFE_PROP_RULES, function () {
      isStyleRulesPresent = true;
    });
  }

  /**
   * Validate the Configuration given by the user when creating a new sanitizer instance. This attaches any missing, but required, flags/params.
   *
   * @param   {Object}  userConfig  User-given configuration object
   *
   * @return  {Object}              Valid/Complete configuration object
   */
  // eslint-disable-next-line complexity
  function validateUserConfig(userConfig) {
    if (!userConfig || userConfig.constructor !== Object) {
      // If no user configuration object is supplied, create a configuration with the default values
      userConfig = {};
      copy(config, userConfig, true);
      return userConfig;
    }
    /*
     * We tried to encode template content using the below 4 lines.
     * But it lead to double encoding issue because the value is inserted
     * using textContent but it is returned using innerHTML/outerHTML
     *
     * We do not have a solution to this issue as of now, so dropping support for this
     *
     * CODE:
     * value = value.replace(/\{\{/g,'&#x7b;&#x7b;'); // No I18N
     * value = value.replace(/\}\}/g,'&#x7d;&#x7d;'); // No I18N
     * value = value.replace(/<%/g,'&lt;&#x25;'); // No I18N
     * value = value.replace(/%>/g,'&#x25;&gt;'); // No I18N
     *
     */

    // Extending any configurations that may have been missed out
    if (!userConfig[TAG_RULES_]) {
      userConfig[TAG_RULES_] = {};
    }
    if (!userConfig[GLOBAL_ATTR_RULES_]) {
      userConfig[GLOBAL_ATTR_RULES_] = {};
    }
    if (!userConfig[GLOBAL_APPEND_ATTR_]) {
      userConfig[GLOBAL_APPEND_ATTR_] = {};
    }
    if (!userConfig[ADD_DATA_URI_TAGS_]) {
      userConfig[ADD_DATA_URI_TAGS_] = [];
    }
    if (!userConfig[ADD_URI_SAFE_ATTR_]) {
      userConfig[ADD_URI_SAFE_ATTR_] = [];
    }
    if (!userConfig[GLOBAL_TAGS_]) {
      userConfig[GLOBAL_TAGS_] = [];
    }
    if (!userConfig[GLOBAL_ATTR_]) {
      userConfig[GLOBAL_ATTR_] = [];
    }
    if (!userConfig[GLOBAL_ATTRIBUTES_]) {
      // Comment #001
      userConfig[GLOBAL_ATTRIBUTES_] = []; // Comment #001
    } // Comment #001
    if (!userConfig[FORBID_TAGS_]) {
      userConfig[FORBID_TAGS_] = [];
    }
    if (!userConfig[FORBID_ATTR_]) {
      userConfig[FORBID_ATTR_] = [];
    }
    if (!userConfig[STYLE_RULES_]) {
      userConfig[STYLE_RULES_] = {};
    }
    if (!userConfig[STYLE_RULES_].FORBID_CSSRULES) {
      userConfig[STYLE_RULES_].FORBID_CSSRULES = [];
    }
    if (!userConfig[STYLE_RULES_].FORBID_PROPS) {
      userConfig[STYLE_RULES_].FORBID_PROPS = [];
    }
    if (!userConfig[STYLE_RULES_].UNSAFE_PROP_RULES) {
      userConfig[STYLE_RULES_].UNSAFE_PROP_RULES = {};
    }

    // If we are extending from a parent, we need to reform the list of tag specific attributes. 
    userConfig.TAG_SPECIFIC_ATTRS = {};

    for (var i = 0; i < nonExtendableConfigFlags.length; i++) {
      var eachFlag = nonExtendableConfigFlags[i];
      if (userConfig[eachFlag] === undefined) {
        userConfig[eachFlag] = config[eachFlag];
      }
    }

    userConfig[TAG_RULES_] = toMap(userConfig[TAG_RULES_], 'NAME'); // No I18N
    userConfig[GLOBAL_ATTR_RULES_] = toMap(userConfig[GLOBAL_ATTR_RULES_], 'ATTR_NAME' // No I18N
    );
    userConfig[GLOBAL_APPEND_ATTR_] = toMap(userConfig[GLOBAL_APPEND_ATTR_], 'APPEND_ATTR_NAME' // No I18N
    );

    var _userConfig = userConfig,
        NEW_TAG_RULES = _userConfig.TAG_RULES,
        NEW_TAG_SPECIFIC_ATTRS = _userConfig.TAG_SPECIFIC_ATTRS,
        NEW_STYLE_RULES = _userConfig.STYLE_RULES,
        NEW_GLOBAL_ATTR = _userConfig.GLOBAL_ATTR,
        NEW_GLOBAL_ATTRIBUTES = _userConfig.GLOBAL_ATTRIBUTES,
        NEW_GLOBAL_ATTR_RULES = _userConfig.GLOBAL_ATTR_RULES,
        NEW_GLOBAL_APPEND_ATTR = _userConfig.GLOBAL_APPEND_ATTR,
        EXTENDS = _userConfig.EXTENDS;
    var NEW_FORBID_CSSRULES = NEW_STYLE_RULES.FORBID_CSSRULES,
        NEW_FORBID_PROPS = NEW_STYLE_RULES.FORBID_PROPS,
        NEW_UNSAFE_PROP_RULES = NEW_STYLE_RULES.UNSAFE_PROP_RULES;


    objectIterator(NEW_GLOBAL_APPEND_ATTR, function (key, value) {
      normalizeCase(value);
    });
    objectIterator(NEW_GLOBAL_ATTR_RULES, function (key, value) {
      normalizeCase(value);
    });

    var _loop = function _loop(_i) {
      var eachExtendConfig = EXTENDS[_i];
      switch (eachExtendConfig) {
        case GLOBAL_ATTR_:
          {
            var tempGlobalAttr = [];
            concatArray(tempGlobalAttr, GLOBAL_ATTR);
            objectIterator(TAG_SPECIFIC_ATTRS, function (attrName) {
              var index = tempGlobalAttr.indexOf(attrName);
              if (index > -1) {
                tempGlobalAttr.splice(index, 1);
              }
            });
            concatArray(NEW_GLOBAL_ATTR, NEW_GLOBAL_ATTRIBUTES); // Comment #001
            concatArray(NEW_GLOBAL_ATTR, tempGlobalAttr);
            break;
          }
        case GLOBAL_TAGS_:
        case FORBID_TAGS_:
        case FORBID_ATTR_:
        case ADD_DATA_URI_TAGS_:
        case ADD_URI_SAFE_ATTR_:
          concatArray(userConfig[eachExtendConfig], config[eachExtendConfig]);
          break;
        case TAG_RULES_:
          extendTagRules(NEW_TAG_RULES, TAG_RULES);
          break;
        case GLOBAL_APPEND_ATTR_:
        case GLOBAL_ATTR_RULES_:
          objectIterator(config[eachExtendConfig], function (attrName) {
            if (userConfig[eachExtendConfig][attrName]) {
              return;
            }
            userConfig[eachExtendConfig][attrName] = {};
            copy(config[eachExtendConfig][attrName], userConfig[eachExtendConfig][attrName], true);
          });
          break;
        // case GLOBAL_ATTR_RULES_:
        //   objectIterator(GLOBAL_ATTR_RULES, attrName => {
        //     if (NEW_GLOBAL_ATTR_RULES[attrName]) {
        //       return;
        //     }
        //     NEW_GLOBAL_ATTR_RULES[attrName] = {};
        //     copy(
        //       GLOBAL_ATTR_RULES[attrName],
        //       NEW_GLOBAL_ATTR_RULES[attrName],
        //       true
        //     );
        //   });
        //   break;
        // case GLOBAL_APPEND_ATTR_:
        //   objectIterator(GLOBAL_APPEND_ATTR, attrName => {
        //     if (NEW_GLOBAL_APPEND_ATTR[attrName]) {
        //       return;
        //     }
        //     NEW_GLOBAL_APPEND_ATTR[attrName] = {};
        //     copy(
        //       GLOBAL_APPEND_ATTR[attrName],
        //       NEW_GLOBAL_APPEND_ATTR[attrName],
        //       true
        //     );
        //   });
        //   break;
        case STYLE_RULES_:
          NEW_FORBID_PROPS.push.apply(NEW_FORBID_PROPS, _toConsumableArray$1(FORBID_PROPS));
          NEW_FORBID_CSSRULES.push.apply(NEW_FORBID_CSSRULES, _toConsumableArray$1(FORBID_CSSRULES));
          objectIterator(UNSAFE_PROP_RULES, function (propName) {
            if (NEW_UNSAFE_PROP_RULES[propName]) {
              return;
            }
            NEW_UNSAFE_PROP_RULES[propName] = {};
            copy(UNSAFE_PROP_RULES[propName], NEW_UNSAFE_PROP_RULES[propName], true);
          });
          break;
        default:
          break;
      }
    };

    for (var _i = 0; _i < EXTENDS.length; _i++) {
      _loop(_i);
    }

    // This is to add all attributes in GLOBAL_ATTR_RULES to NEW_GLOBAL_ATTR list if not already present.
    objectIterator(NEW_GLOBAL_ATTR_RULES, function (attrName) {
      if (NEW_GLOBAL_ATTR.indexOf(attrName) !== -1) {
        return;
      }
      NEW_GLOBAL_ATTR.push(attrName);
      // This is to note attribute which are given in GLOBAL_ATTR_RULES but not added in GLOBAL_ATTR
      // They need to be specifically noted down and removed before extending to another sanitizer instance
      if (!NEW_TAG_SPECIFIC_ATTRS[attrName] || NEW_TAG_SPECIFIC_ATTRS[attrName].constructor !== Array) {
        NEW_TAG_SPECIFIC_ATTRS[attrName] = [];
      }
      if (NEW_TAG_SPECIFIC_ATTRS[attrName].indexOf('*') === -1) {
        // No I18N
        NEW_TAG_SPECIFIC_ATTRS[attrName].push('*'); // No I18N
      }
    });

    objectIterator(NEW_TAG_RULES, function (tagName, tagRule) {
      tagName = toLowerCaseValue(tagName);

      if (!tagRule.APPEND_ATTR) {
        tagRule.APPEND_ATTR = {};
      }
      tagRule.APPEND_ATTR = toMap(tagRule.APPEND_ATTR, 'APPEND_ATTR_NAME'); // No I18N
      objectIterator(tagRule.APPEND_ATTR, function (key, value) {
        normalizeCase(value);
      });

      if (!tagRule.ATTR_RULES) {
        tagRule.ATTR_RULES = {};
      }
      tagRule.ATTR_RULES = toMap(tagRule.ATTR_RULES, 'ATTR_NAME'); // No I18N
      // The below loop is to add all attributes in Tag Rules to NEW_GLOBAL_ATTR list and a attribute-specific tag list
      objectIterator(tagRule.ATTR_RULES, function (attrName, attrRule) {
        normalizeCase(attrRule);
        attrName = toLowerCaseValue(attrName);
        if (NEW_GLOBAL_ATTR.indexOf(attrName) === -1 || NEW_TAG_SPECIFIC_ATTRS[attrName] && NEW_TAG_SPECIFIC_ATTRS[attrName].length > 0) {
          if (NEW_GLOBAL_ATTR.indexOf(attrName) === -1) {
            NEW_GLOBAL_ATTR.push(attrName);
          }
          if (!NEW_TAG_SPECIFIC_ATTRS[attrName] || NEW_TAG_SPECIFIC_ATTRS[attrName].constructor !== Array) {
            NEW_TAG_SPECIFIC_ATTRS[attrName] = [];
          }
          if (NEW_TAG_SPECIFIC_ATTRS[attrName].indexOf(tagName) === -1) {
            NEW_TAG_SPECIFIC_ATTRS[attrName].push(tagName);
          }
        }
      });
    });

    // Comment #002
    delete userConfig.USE_PROFILES;

    return userConfig;
  }

  /**
   * Parse any additional configurations passed while calling HTMLPurifier.sanitize
   * Merges the base configuration and runtime configuration
   *
   * @param   {Object}  runtimeConfig  User-given configuration at HTMLPurifier.sanitize
   *
   * @return  {Object}                 Valid/Complete configuration object
   */
  function parseConfig(runtimeConfig) {
    if (!runtimeConfig || runtimeConfig.constructor !== Object) {
      return config;
    }
    var customConfig = {};
    objectIterator(config, function (each, value) {
      if (each in runtimeConfig && runtimeConfigFlags.indexOf(each) !== -1 && (runtimeConfig[each] === true || runtimeConfig[each] === false || runtimeConfig[each] && runtimeConfig[each].constructor === RegExp)) {
        customConfig[each] = runtimeConfig[each];
        return;
      }
      customConfig[each] = value;
    });
    if (customConfig.SAFE_FOR_TEMPLATES) {
      customConfig.ALLOW_DATA_ATTR = false;
    }
    if (customConfig.RETURN_DOM_FRAGMENT) {
      customConfig.RETURN_DOM = true;
    }
    if (customConfig.KEEP_CONTENT) {
      customConfig.GLOBAL_TAGS.push('#text'); // No I18N
    }
    // Remove ADD_TAGS and ADD_ATTR from the runtime config
    // We are just making sure it's not passed to DOMPurify by deleting it explicitly.
    if (customConfig.ADD_TAGS) {
      delete customConfig.ADD_TAGS;
    }
    if (customConfig.ADD_ATTR) {
      delete customConfig.ADD_ATTR;
    }
    return customConfig;
  }

  /**
   * Sets all the necessary DOMPurify Hooks based on the sanitizer configuration
   */
  function setDOMPurifyHooks() {
    var ALLOWED_STYLE = config.ALLOWED_STYLE;

    // Clears any existing Hooks

    DOMPurify.removeAllHooks();
    altered = false;

    // Hooks for Style Validation
    // Default stance is to not allow any styles
    if (FORBID_TAGS.indexOf('style') === -1) {
      // No I18N
      FORBID_TAGS.push('style'); // No I18N
    }
    if (FORBID_ATTR.indexOf('style') === -1) {
      // No I18N
      FORBID_ATTR.push('style'); // No I18N
    }
    if (ALLOWED_STYLE === 'INLINE' || ALLOWED_STYLE === 'ALL') {
      // No I18N
      // Remove 'style' from FORBID_ATTR array and add it to GLOBAL_ATTR 
      // if (FORBID_ATTR.indexOf('style') !== -1) { // No I18N
      FORBID_ATTR.splice(FORBID_ATTR.indexOf('style'), 1); // No I18N
      // }
      if (GLOBAL_ATTR.indexOf('style') === -1) {
        // No I18N
        GLOBAL_ATTR.push('style'); // No I18N
      }
      if (isStyleRulesPresent) {
        // Hook to enforce CSS attribute sanitization
        DOMPurify.addHook('uponSanitizeAttribute', function (node, hookEvent) {
          // No I18N
          if (hookEvent.attrName !== 'style') {
            // No I18N
            return;
          }
          // Hack fix for baseURI + CSS problems in Chrome
          if (!node.ownerDocument.baseURI) {
            var _window = window,
                document = _window.document;

            var base = document.createElement('base'); // No I18N
            base.href = document.baseURI;
            node.ownerDocument.head.appendChild(base);
          }
          // Check all style attribute values and validate them
          // if (node.hasAttribute('style')) {  
          altered = false;
          validateStyles(node.style);

          var output = node.style.cssText;
          if (output.length === 0) {
            hookEvent.keepAttr = false;
            return;
          }
          hookEvent.attrValue = altered ? output : node.getAttribute('style'); // No I18N
        });
      }
    }
    if (ALLOWED_STYLE === 'INTERNAL' || ALLOWED_STYLE === 'ALL') {
      // No I18N
      // Remove 'style' from FORBID_TAGS array and add it to GLOBAL_TAGS 
      FORBID_TAGS.splice(FORBID_TAGS.indexOf('style'), 1); // No I18N
      if (GLOBAL_TAGS.indexOf('style') === -1) {
        // No I18N
        GLOBAL_TAGS.push('style'); // No I18N
      }
      if (isStyleRulesPresent) {
        // Hook to enforce CSS Element sanitization
        DOMPurify.addHook('uponSanitizeElement', function (node, data) {
          // No I18N
          if (data.tagName !== 'style' || node.sheet === null) {
            // No I18N
            return;
          }
          var styleSheet = node.sheet.cssRules;
          altered = false;
          validateStyleSheet(styleSheet, node.sheet);
          if (!altered) {
            return;
          }
          var output = [];
          copyValidatedStyleSheet(output, styleSheet);
          node.textContent = output.join('\n'); // No I18N
        });
      }
    }

    // Hook to set 'GLOBAL_ATTR_RULES' rules 
    if (GLOBAL_ATTR_RULES || TAG_RULES) {
      tagRuleMap = {};
      // First, copy all ATTR_RULES from default rules.
      objectIterator(defaultTagRules, function (nodeName, tagRule) {
        tagRuleMap[nodeName] = {};
        objectIterator(tagRule.ATTR_RULES, function (attrName, attrRule) {
          return tagRuleMap[nodeName][attrName] = attrRule;
        });
      });

      // Second, overwrite any ATTR_RULE if a rule is present for the same attribute in GLOBAL_ATTR_RULES
      objectIterator(tagRuleMap, function (nodeName, tagRule) {
        objectIterator(GLOBAL_ATTR_RULES, function (attrName, attrRule) {
          return tagRuleMap[nodeName][attrName] = attrRule;
        });
      });

      // Third, TAG_RULES have the highest precedence and they will overwrite any existing ATTR_RULE
      objectIterator(TAG_RULES, function (nodeName, tagRule) {
        if (!tagRuleMap[nodeName]) {
          tagRuleMap[nodeName] = {};
        }
        objectIterator(tagRule.ATTR_RULES, function (attrName, attrRule) {
          return tagRuleMap[nodeName][attrName] = attrRule;
        });
      });

      DOMPurify.addHook('uponSanitizeAttribute', function (node, hookEvent) {
        // No I18N
        var attrRule = tagRuleMap[hookEvent.nodeName] && tagRuleMap[hookEvent.nodeName][hookEvent.attrName] || GLOBAL_ATTR_RULES && GLOBAL_ATTR_RULES[hookEvent.attrName];

        if (!attrRule) {
          return;
        }

        var _validateAttributeRul = validateAttributeRule(node, attrRule, hookEvent.attrName),
            isValid = _validateAttributeRul.isValid,
            rule = _validateAttributeRul.rule;

        if (rule && rule.FORCE_KEEP_ATTR) {
          hookEvent.forceKeepAttr = true;
        }
        // The value of isValid will be a boolean by this point
        if (!isValid) {
          handleFailedAttributeValidation(node, rule, hookEvent);
        }
      });
    }

    // Hook to set 'GLOBAL_APPEND_ATTR' rules  
    if (GLOBAL_APPEND_ATTR || TAG_RULES) {
      appendAttrMap = {};
      // The order or precedence is as below:
      // 
      // Tag Rule > Global Rule for Element > Default Rule for Element
      // 
      // If there is a validation rule in the tag rule for this attribute, we choose it. 
      // Else if there is a global validation rule for this attribute, we choose it. 
      // Finally, we check if there is a default rule for this attribute and choose it.

      // First, copy all APPEND_RULES from default rules.
      objectIterator(defaultTagRules, function (nodeName, tagRule) {
        appendAttrMap[nodeName] = {};
        objectIterator(tagRule.APPEND_ATTR, function (attrName, attrRule) {
          return appendAttrMap[nodeName][attrName] = attrRule;
        });
      });

      // Second, overwrite any APPEND_RULE if a rule is present for the same attribute in GLOBAL_APPEND_ATTR
      objectIterator(appendAttrMap, function (nodeName, tagRule) {
        objectIterator(GLOBAL_ATTR_RULES, function (attrName, attrRule) {
          return appendAttrMap[nodeName][attrName] = attrRule;
        });
      });

      // Third, TAG_RULES have the highest precedence and they will overwrite any existing APPEND_RULE
      objectIterator(TAG_RULES, function (nodeName, tagRule) {
        if (!appendAttrMap[nodeName]) {
          appendAttrMap[nodeName] = {};
        }
        objectIterator(tagRule.APPEND_ATTR, function (attrName, attrRule) {
          return appendAttrMap[nodeName][attrName] = attrRule;
        });
      });

      DOMPurify.addHook('afterSanitizeAttributes', function (node) {
        // No I18N
        var name = node.nodeName.toLowerCase();
        var appendConfig = {};

        objectIterator(GLOBAL_APPEND_ATTR, function (attrName, appendAttrRule) {
          return appendConfig[attrName] = appendAttrRule;
        });
        objectIterator(appendAttrMap[name], function (attrName, appendAttrRule) {
          return appendConfig[attrName] = appendAttrRule;
        });

        appendAttributes(node, appendConfig);
      });
    }

    // Hook to remove all 'on' events 
    if (config[REMOVE_ONEVENTS_]) {
      DOMPurify.addHook('uponSanitizeAttribute', function (node, hookEvent) {
        // No I18N
        if (hookEvent.attrName.indexOf('on') === 0) {
          // No I18N
          hookEvent.keepAttr = false;
        }
      });
    }

    // Hook to remove tag-specific attributes which occur in tags other than those mentioned
    if (TAG_SPECIFIC_ATTRS) {
      DOMPurify.addHook('uponSanitizeAttribute', function (node, hookEvent) {
        // No I18N
        if (TAG_SPECIFIC_ATTRS[hookEvent.attrName] && TAG_SPECIFIC_ATTRS[hookEvent.attrName].indexOf(hookEvent.nodeName) === -1 && TAG_SPECIFIC_ATTRS[hookEvent.attrName].indexOf('*') === -1 // No I18N
        ) {
            hookEvent.keepAttr = false;
          }
      });
    }
  }

  /**
   * Core attribute validation logic
   * All condition must be satisfied to return true (AND condition)
   *
   * @param   {Object}   node               Node which has the attribute
   * @param   {[type]}   attrName           Name of attribute to validate
   * @param   {Object}   condition          Condition to validate the attribute
   *
   * @return  {Boolean}               Given condition is valid or not
   */
  function validateAttribute(node, attrName, condition) {
    var mandatory = condition.IS_MANDATORY !== false;

    if (attrName && !node.hasAttribute(attrName.toLowerCase())) {
      // Forbidden has a higher priority than mandatory check
      return condition.IS_FORBIDDEN || !mandatory;
    }
    if (condition.IS_FORBIDDEN) {
      return false;
    }

    var value = node.getAttribute(attrName.toLowerCase());
    if (value === undefined || value === null) {
      value = '';
    }
    return isValidAttributeValue(value, condition, attrName);
  }

  function isValidAttributeValue(value, condition, name) {
    if (value.constructor === String) {
      var caseSensitive = condition.CASE_SENSITIVE || false;
      if (!caseSensitive) {
        value = value.toLowerCase();
      }
      if (!condition.DONT_TRIM) {
        value = value.trim();
      }

      if (condition.MAX_LENGTH && value.length > condition.MAX_LENGTH) {
        return false;
      }
      if (condition.MIN_LENGTH && value.length < condition.MIN_LENGTH) {
        return false;
      }
      if (condition.REGEX && condition.REGEX.constructor === RegExp && value.search(condition.REGEX) === -1) {
        return false;
      }
      if (condition.REGEX && condition.REGEX.constructor === String) {
        var regex = new RegExp(condition.REGEX);
        if (value.search(condition.REGEX) === -1) {
          return false;
        }
      }
      if (condition.REGEX && condition.REGEX.constructor === Array) {
        for (var i = 0; i < condition.REGEX.length; i++) {
          if (value.search(condition.REGEX[i]) === -1) {
            return false;
          }
        }
      }

      if (condition.VALIDATOR && condition.VALIDATOR.HANDLER) {
        if (!condition.VALIDATOR.HANDLER(value, condition.VALIDATOR.CONFIG, name)) {
          return false;
        }
      }

      if (condition.STARTS_WITH !== undefined && value.indexOf(condition.STARTS_WITH) !== 0) {
        return false;
      }
      if (condition.ENDS_WITH !== undefined && value.lastIndexOf(condition.ENDS_WITH) !== value.length - condition.ENDS_WITH.length) {
        return false;
      }
      if (condition.CONTAINS && condition.CONTAINS.constructor === String && value.indexOf(condition.CONTAINS) === -1) {
        return false;
      }
      if (condition.CONTAINS && condition.CONTAINS.constructor === Array) {
        for (var _i2 = 0; _i2 < condition.CONTAINS.length; _i2++) {
          if (value.indexOf(condition.CONTAINS[_i2]) === -1) {
            return false;
          }
        }
      }
      if (condition.NOT_CONTAINS && condition.NOT_CONTAINS.constructor === String && value.indexOf(condition.NOT_CONTAINS) > -1) {
        return false;
      }
      if (condition.NOT_CONTAINS && condition.NOT_CONTAINS.constructor === Array) {
        for (var _i3 = 0; _i3 < condition.NOT_CONTAINS.length; _i3++) {
          if (value.indexOf(condition.NOT_CONTAINS[_i3]) > -1) {
            return false;
          }
        }
      }
      // eslint-disable-next-line eqeqeq
      if (condition.EQUAL !== undefined && value != condition.EQUAL) {
        // === check is avoided as condition value might also be number
        return false;
      }
      // eslint-disable-next-line eqeqeq
      if (condition.NOT_EQUAL !== undefined && value == condition.NOT_EQUAL) {
        // === check is avoided as condition value might also be number
        return false;
      }
    }
    if (condition.LIST && condition.LIST.indexOf(value) === -1) {
      return false;
    }
    if (condition.TYPE === 'INTEGER' || condition.TYPE === 'FLOAT') {
      // No I18N
      var tempValue = void 0;
      try {
        tempValue = condition.TYPE === 'INTEGER' // No I18N
        ? window.parseInt(value, 10) : window.parseFloat(value);
      } catch (e) {
        return false;
      }
      if (window.isNaN(tempValue)) {
        return false;
      }
      if (condition.GREATER_THAN !== undefined && tempValue <= condition.GREATER_THAN) {
        return false;
      }
      if (condition.GREATER_THAN_OR_EQUAL !== undefined && tempValue < condition.GREATER_THAN_OR_EQUAL) {
        return false;
      }
      if (condition.LESSER_THAN !== undefined && tempValue >= condition.LESSER_THAN) {
        return false;
      }
      if (condition.LESSER_THAN_OR_EQUAL !== undefined && tempValue > condition.LESSER_THAN_OR_EQUAL) {
        return false;
      }
      if (condition.EQUAL !== undefined && tempValue !== condition.EQUAL) {
        return false;
      }
      if (condition.NOT_EQUAL !== undefined && tempValue === condition.NOT_EQUAL) {
        return false;
      }
    }
    return true;
  }

  /**
   * Append an attribute to the DOM Element Node based on the given conditions
   * This is called through DOMPurify Hooks whenever append attribute rules are found
   * (like GLOBAL_APPEND_ATTR and TAG_RULES)
   *
   * @param   {Node}    node              DOM Element Node
   * @param   {Object}  appendConfig      Conditions to validate before adding the attribute
   */
  function appendAttributes(node, appendConfig) {
    objectIterator(appendConfig, function (attrName, attrRule) {
      if (node.hasAttribute(attrName.toLowerCase())) {
        return;
      }
      if (!attrRule.SIBLING_CONDITIONS || attrRule.SIBLING_CONDITIONS.length == 0) {
        node.setAttribute(attrName, attrRule.APPEND_ATTR_VALUE);
        return;
      }
      for (var i = 0; i < attrRule.SIBLING_CONDITIONS.length; i++) {
        var _validateAttributeRul2 = validateAttributeRule(node, attrRule.SIBLING_CONDITIONS[i]),
            isValid = _validateAttributeRul2.isValid,
            rule = _validateAttributeRul2.rule;

        if (!isValid) {
          continue;
        }
        var value = rule.APPEND_ATTR_VALUE !== undefined ? rule.APPEND_ATTR_VALUE : attrRule.APPEND_ATTR_VALUE;
        node.setAttribute(attrName, value);
        return;
      }
    });
  }

  /**
   * Validate an attribute in a given node based on validation conditions
   * This is called through DOMPurify Hooks whenever attribute validation rules are found
   * (like GLOBAL_ATTR_RULES and TAG_RULES)
   *
   * @param   {Node}    node            DOM Element Node
   * @param   {Object}  rule        Conditions to validate the given node and attribute
   * @param   {Object}  attrName        Name of attribute to validate
   *
   * @return  {Object}                  Returns 2 keys:
   *                                    1.isValid: True if attribute is valid. Else returns false.
   *                                    2.rule: The final rule it matched with
   */
  function validateAttributeRule(node, rule, attrName) {
    var isValid = true;
    if (!rule || !rule.CONDITIONS || rule.CONDITIONS.length === 0) {
      return { isValid: isValid, rule: rule };
    }
    attrName = rule.ATTR_NAME || attrName;

    for (var i = 0; i < rule.CONDITIONS.length; i++) {
      var eachCondition = rule.CONDITIONS[i];
      isValid = validateAttribute(node, attrName, eachCondition);
      if (eachCondition.NEGATION) {
        isValid = !isValid;
      }
      if (!isValid) {
        continue;
      }
      if (eachCondition.NEXT) {
        return validateAttributeRule(node, eachCondition.NEXT, attrName);
      }
      break;
    }
    return { isValid: isValid, rule: rule };
  }

  function handleFailedAttributeValidation(node, attrRule, hookEvent) {
    if (attrRule.ACTION === "REMOVE_ELEMENT") {
      hookEvent.keepElement = false;
      return;
    }
    // Default Action will be 'REMOVE_ATTRIBUTE' if no FALLBACK_VALUE is specified. 
    if (attrRule.FALLBACK_VALUE === undefined) {
      hookEvent.keepAttr = false;
      return;
    }
    var valueToSet = attrRule.FALLBACK_VALUE;
    var matched = REPLACEMENT_REGEX.exec(attrRule.FALLBACK_VALUE);
    if (matched) {
      var value = node.getAttribute(attrRule.ATTR_NAME);
      switch (matched[0]) {
        // eslint-disable-next-line no-template-curly-in-string
        case '${ZWAF.URL_COMPONENT}':
          // No I18N
          value = window.encodeURIComponent(value);
          break;
        // eslint-disable-next-line no-template-curly-in-string
        case '${ZWAF.REPLACE}':
          // No I18N
          // Simply replace the pattern with the actual attribute value
          // value = value;
          break;

        default:
          break;
      }
      valueToSet = attrRule.FALLBACK_VALUE.replace(matched[0], value);
    }
    if (IS_SCRIPT_OR_DATA.test(valueToSet.replace(ATTR_WHITESPACE, ''))) {
      // Remove as the value contains a possible XSS
      hookEvent.keepAttr = false;
    } else {
      hookEvent.attrValue = valueToSet;
    }
    return;
  }

  /**
   * Validate the given stylesheet
   * This is called from the DOMPurify Hook to sanitize styles
   *
   * @param   {CSSStyleSheet}  cssStyleSheet  CSS Stylesheet to validate
   */
  function validateStyleSheet(cssRules, cssStyleSheet) {
    for (var index = cssRules.length - 1; index >= 0; index--) {
      var rule = cssRules[index];
      if (FORBID_CSSRULES.length > 0 && FORBID_CSSRULES.indexOf(rule.type) > -1) {
        // Remove this rule
        cssStyleSheet.deleteRule(index);
        altered = true;
        continue;
      }
      // The cssRules.type determines whether it is a Media Query, KeyFrames Query, Regular CSS Query
      // https://developer.mozilla.org/en-US/docs/Web/API/CSSRule
      // 
      // TODO: Validation for @import CSS Rule Type? (type = 3)
      if (rule.type === 1 && rule.selectorText || rule.type === 8 && rule.keyText) {
        if (rule.style) {
          validateStyles(rule.style);
        }
      } else if ((rule.type === 4 || rule.type === 7 || rule.type === 12) && rule.cssRules) {
        validateStyleSheet(rule.cssRules, rule);
      }
    }
  }

  /**
   * Validate individual style properties from the CSS StyleSheet
   * This is called from the DOMPurify Hook to sanitize styles
   *
   * @param   {CSSStyleDeclaration}  styles  List of style property values
   */
  // TODO: Have to analyse adding SIBLING_CONDITIONS for Style validation 
  function validateStyles(styles) {
    // Validate regular CSS properties
    objectIterator(styles, function (property, value) {
      if (!value || value.constructor !== String) {
        return;
      }
      if (FORBID_PROPS.length > 0 && FORBID_PROPS.indexOf(property) > -1) {
        styles[property] = '';
        altered = true;
      }
      // Add UNSAFE_PROP_RULES validation here
      if (!UNSAFE_PROP_RULES[property]) {
        return;
      }
      var propRule = UNSAFE_PROP_RULES[property];
      for (var i = 0; i < propRule.CONDITIONS.length; i++) {
        if (isValidAttributeValue(value, propRule.CONDITIONS[i], property)) {
          // It has matched any one of the unsafe property rules. Need to remove or replace
          styles[property] = propRule.FALLBACK_VALUE === undefined ? '' : propRule.FALLBACK_VALUE;
          altered = true;
          return;
        }
      }
    });
  }

  /**
   * Copy the validated stylesheet content to replace the original stylesheet
   *
   * @param   {Array}         output         Array of safe stylesheet rules
   * @param   {CSSRuleList}   cssStyleSheet  Stylesheet with validated CSS rules
   */
  function copyValidatedStyleSheet(output, cssStyleSheet) {
    for (var index = cssStyleSheet.length - 1; index >= 0; index--) {
      // CSSRule type 8 is not checked below, as it will always come under CSSRule type 7
      // i.e , keyframe Rule will always be inside keyframes Rule
      if (cssStyleSheet[index].type === 1 || cssStyleSheet[index].type === 3 || cssStyleSheet[index].type === 4 || cssStyleSheet[index].type === 7 || cssStyleSheet[index].type === 12) {
        output.push(cssStyleSheet[index].cssText);
      }
    }
  }

  /**
   * Extend the configuration of a parent tag rule, to a child tag rule
   * Called when HTMLSanitizer is configured to extend the TAG_RULES of the base instance
   *
   * @param   {Object}  child   Child tag rule configuration
   * @param   {Object}  parent  Parent tag rule configuration
   */
  function extendTagRules(child, parent) {
    if (!parent || parent.constructor !== Object) {
      return;
    }
    objectIterator(parent, function (eachTag, eachTagRule) {
      if (!(eachTag in child)) {
        child[eachTag] = eachTagRule;
        return;
      }
      if (child[eachTag].APPEND_ATTR === undefined) {
        child[eachTag].APPEND_ATTR = eachTagRule.APPEND_ATTR;
      }
      if (child[eachTag].ATTR_RULES === undefined) {
        child[eachTag].ATTR_RULES = eachTagRule.ATTR_RULES;
      }
    });
  }

  // Helper functions to normalize the given sanitizer configuration
  /**
   * Normalizes uppercase and lowercase values in the configuration
   *
   * @param   {Object|Array}  config  Configuration object whose values should be normalized
   */
  function normalizeCase(config) {
    if (!config) {
      return;
    }
    if (config.CONDITIONS && config.CONDITIONS.length > 0) {
      // objectIterator(config, (key, value) => {
      config.CONDITIONS = normalizeCaseForConditions(config.CONDITIONS);
      // });
    }
    if (config.SIBLING_CONDITIONS && config.SIBLING_CONDITIONS.length > 0) {
      for (var i = 0; i < config.SIBLING_CONDITIONS.length; i++) {
        normalizeCase(config.SIBLING_CONDITIONS[i]);
      }
    }
  }

  function normalizeCaseForConditions(conditions) {
    if (!conditions) {
      return conditions;
    }
    for (var j = 0; j < conditions.length; j++) {
      conditions[j] = normalizeCaseForKey(conditions[j]);
    }
    return conditions;
  }
  /**
   * Normalizes uppercase and lowercase values of the given flags only.
   * Return unchanged if it is case sensitive.
   *
   * @param   {Object}  config  configuration object
   *
   * @return  {Object}          Case-normalized configuration object
   */
  function normalizeCaseForKey(config) {
    if (!config || config && config.CASE_SENSITIVE) {
      return config;
    }
    var flags = ['STARTS_WITH', // No I18N
    'ENDS_WITH', // No I18N
    'CONTAINS', // No I18N
    'EQUAL', // No I18N
    'NOT_EQUAL', // No I18N
    'LIST' // No I18N
    ];

    for (var i = 0; i < flags.length; i++) {
      var eachFlag = flags[i];
      if (!config[eachFlag]) {
        continue;
      }
      config[eachFlag] = toLowerCaseValue(config[eachFlag]);
    }
    if (config.NEXT) {
      normalizeCase(config.NEXT);
    }
    return config;
  }

  /**
   * Constructor for HTMLPurifier. Can be used to create fresh instances of HTMLPurifier
   *
   * @param  {Object}  conf   Configuration object
   *
   * @return {Object}         new HTMLPurifier instance
   */
  var HTMLPurifier = function HTMLPurifier(userConfig) {
    userConfig = validateUserConfig(userConfig);
    // eslint-disable-next-line new-cap
    return factory$1(userConfig, DOMPurify(window));
  };

  /**
   * Public method providing core sanitation functionality
   *
   * @param   {String|Node}   dirty   String or DOM node to sanitize
   * @param   {Object}        runtimeConfig     configuration object
   *
   * @return  {String|Node}           Sanitized safe content
   */
  HTMLPurifier.sanitize = function (dirty, runtimeConfig) {
    var _HTMLPurifier$removed;

    var customConfig = parseConfig(runtimeConfig);
    var result = DOMPurify.sanitize(dirty, customConfig);
    (_HTMLPurifier$removed = HTMLPurifier.removed).splice.apply(_HTMLPurifier$removed, [0, HTMLPurifier.removed.length].concat(_toConsumableArray$1(DOMPurify.removed)));
    return result;
  };

  concatArray(FORBID_TAGS, defaultForbiddenTags);
  concatArray(FORBID_ATTR, defaultForbiddenAttr);

  setDOMPurifyHooks();

  config.ALLOWED_TAGS = GLOBAL_TAGS;
  config.ALLOWED_ATTR = GLOBAL_ATTR;
  config.GLOBAL_ATTRIBUTES = GLOBAL_ATTR;

  if (config && !config.REUSE_CONFIG && freeze) {
    freeze(config);
  }

  HTMLPurifier.isSupported = DOMPurify.isSupported;
  HTMLPurifier.version = DOMPurify.version;
  HTMLPurifier.removed = [];

  return HTMLPurifier;
}

/// ///////////////////////////////////////////////////////
// Setting Base Configuration for HTMLPurifier Instance //
/// ///////////////////////////////////////////////////////

var config = {};

// Comment #002
// USE_PROFILES = false;

// No need to configure this as it will only increase size,
//  and we will anyway be using the default value of DOMPurify only
// config.ALLOW_ARIA_ATTR = true;
// config.ALLOW_DATA_ATTR = true;
// config.ALLOW_UNKNOWN_PROTOCOLS = false;
// config.ALLOW_SELF_CLOSE_IN_ATTR = true;
// config.SAFE_FOR_TEMPLATES = false;
// config.SAFE_FOR_XML = true;
// config.WHOLE_DOCUMENT = false;
// config.RETURN_DOM = false;
// config.RETURN_DOM_FRAGMENT = false;
// config.RETURN_TRUSTED_TYPE = false;
// config.DONT_TRIM = true;
config.FORCE_BODY = true;
// config.SANITIZE_DOM = true;
// config.SANITIZE_NAMED_PROPS = false;
// config.KEEP_CONTENT = true;
// config.IN_PLACE = false;
config.ALLOWED_URI_REGEXP = false;
// config.NAMESPACE = HTML_NAMESPACE;
// config.CUSTOM_ELEMENT_HANDLING = {};
// config.ALLOWED_NAMESPACES = [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE];
config.REUSE_CONFIG = false;

config.REMOVE_ONEVENTS = true;
config.EXTENDS = ['GLOBAL_TAGS', // No I18N
'GLOBAL_ATTR', // No I18N
'FORBID_TAGS', // No I18N
'FORBID_ATTR', // No I18N
'TAG_RULES', // No I18N
'GLOBAL_ATTR_RULES', // No I18N
'GLOBAL_APPEND_ATTR', // No I18N
'ADD_DATA_URI_TAGS', // No I18N
'ADD_URI_SAFE_ATTR' // No I18N
];
config.ALLOWED_STYLE = 'NONE'; // Values can be either 'INLINE', 'INTERNAL', 'ALL', 'NONE' // No I18N
config.STYLE_RULES = {
  FORBID_PROPS: [],
  FORBID_CSSRULES: [],
  UNSAFE_PROP_RULES: {
    // Same as attribute validation rule, but as blacklist
    //
    // {
    //   "NAME": "position",  
    //   "EQUALS": "absolute",  
    //   "DEFAULT_VALUE": "relative"  
    // }
  }
};

config.GLOBAL_TAGS = 'a|abbr|acronym|address|area|article|aside|audio|b|bdi|bdo|big|blink|blockquote|body|br|button|canvas|caption|center|cite|code|col|colgroup|content|data|datalist|dd|decorator|del|details|dfn|dir|div|dl|dt|element|em|fieldset|figcaption|figure|font|footer|form|h1|h2|h3|h4|h5|h6|head|header|hgroup|hr|html|i|img|input|ins|kbd|label|legend|li|main|map|mark|marquee|menu|menuitem|meter|nav|nobr|ol|optgroup|option|output|p|pre|progress|q|rp|rt|ruby|s|samp|section|select|shadow|small|source|spacer|span|strike|strong|sub|summary|sup|table|tbody|td|template|textarea|tfoot|th|thead|time|title|tr|track|tt|u|ul|var|video|wbr|#text'.split( // No I18N
'|' // No I18N
);
config.GLOBAL_ATTR = 'accept|action|align|alt|autocomplete|background|bgcolor|border|cellpadding|cellspacing|checked|cite|class|clear|color|cols|colspan|coords|datetime|default|dir|disabled|download|enctype|face|for|headers|height|hidden|high|href|hreflang|id|ismap|label|lang|list|loop|low|max|maxlength|media|method|min|multiple|name|noshade|novalidate|nowrap|open|optimum|pattern|placeholder|poster|preload|pubdate|radiogroup|readonly|rel|required|rev|reversed|role|rows|rowspan|spellcheck|scope|selected|shape|size|span|srclang|start|src|step|summary|tabindex|title|target|type|usemap|valign|value|width|xmlns|sandbox'.split( // No I18N
'|' // No I18N
);
config.FORBID_TAGS = []; // Add any forbidden tags here
config.FORBID_ATTR = []; // Add any forbidden attrs here
config.GLOBAL_ATTR_RULES = {};
config.GLOBAL_APPEND_ATTR = {};
config.ADD_DATA_URI_TAGS = [];
config.ADD_URI_SAFE_ATTR = [];
config.TAG_RULES = {
  a: {
    APPEND_ATTR: {
      rel: {
        ATTR_NAME: 'rel', // No I18N
        APPEND_ATTR_VALUE: 'noopener noreferrer', // No I18N
        SIBLING_CONDITIONS: [{
          ATTR_NAME: 'target', // No I18N
          CONDITIONS: [{
            IS_MANDATORY: 'true', // No I18N
            CONTAINS: '_blank' // No I18N
          }]
        }]
      }
    }
  }
};
config.TAG_SPECIFIC_ATTRS = {}; // HTMLPurifier will automatically add tag-specific attributes here
// {
//   'href' : ['a', 'div'] 
// }

var HTMLPurifier = factory$1(config, createDOMPurify$1);

if (freeze) {
  freeze(HTMLPurifier);
}

delete window.DOMPurify; //We are deleting the base DOMPurify Instance



/**
 *  Comment #001
 *  Temporary workaround for Lyte team. We can remove this after they migrate to GLOBAL_ATTR from GLOBAL_ATTRIBUTES
 */

/**
 *  Comment #002
 *  Deleting Profiles as it won't be used
 */

if (ZWAF$2.version === '7.0.0' && !ZWAF$2.HTMLPurifier) {
  ZWAF$2.defineProperty(ZWAF$2, 'HTMLPurifier', // No I18N
  HTMLPurifier, true, false, false, true);
}
if (!ZWAF$2['7_0_0'].HTMLPurifier) {
  ZWAF$2.defineProperty(ZWAF$2['7_0_0'], 'HTMLPurifier', // No I18N
  HTMLPurifier, true, false, false, true);
}

/**
 * SecureRedirector
 *
 * Reference
 *  1)https://github.com/danielstjules/blankshield
 */

/* eslint-disable prefer-rest-params */

var winNav = window.navigator;
var oldIE = winNav.userAgent.indexOf('MSIE') !== -1;
var isChromium = window.chrome;
var vendorName = winNav.vendor;
var isOpera = typeof window.opr !== "undefined"; // No I18N
var isIEedge = winNav.userAgent.indexOf("Edge") > -1;
var isChrome = isChromium !== null && typeof isChromium !== "undefined" && // No I18N
vendorName === "Google Inc." && // No I18N
isOpera === false && isIEedge === false;
var isChromeAbove72 = false;
if (isChrome) {
  // is Google Chrome
  isChromeAbove72 = true;
  try {
    var match = navigator.userAgent.match(/Chrome\/(\d+)/);
    var version = match && parseInt(match[1]);
    if (!isNaN(version)) {
      isChromeAbove72 = version > 71;
    }
  } catch (e) {
    isChromeAbove72 = true;
  }
}

var _window = window;
var open = _window.open;

var jsVulnCharMap = {
  "'": '\\x27', // No I18N
  '"': '\\x22', // No I18N
  '`': '\\x60', // No I18N
  '\n': '\\x0A', // No I18N
  '\r': '\\x0D', // No I18N
  '<': '\\x3C', // No I18N
  '>': '\\x3E', // No I18N
  ')': '\\x29' // No I18N
};

/**
 * Checks if the given target is safe
 *
 * @param   {String}  target  target value for window.open
 *
 * @return  {Boolean}         Return true if target value is safe
 */
function safeTarget(target) {
  return target === '_top' || target === '_self' || target === '_parent'; // No I18N
}

/**
 * Replaces vulnerable characters in the given string
 * with safe characters from the given character map
 *
 * @param   {String}  str      The string with vulnerable characters
 * @param   {Map}     charMap  Map of vulnerable characters as keys with safe characters as values
 *
 * @return  {String}           Safe string without vulnerable characters
 */
function replaceVulnChars(str, charMap) {
  if (!charMap || !str) {
    return str;
  }
  var newStr = '';
  for (var i = 0; i < str.length; i++) {
    if (Object.prototype.hasOwnProperty.call(charMap, str[i])) {
      newStr += charMap[str[i]];
    } else {
      newStr += str[i];
    }
  }
  return newStr;
}

/**
 * It iterates over all the child elements and sets click listener for the
 * elements where reverse tabnabbing based phishing attacks are possible
 *
 * @param   {Element}  target  Element to add event listener
 *
 * @return  {undefined}        Doesn't return
 */
function checkAndAddListener(target) {
  if (target.nodeType !== 1) {
    return;
  }
  var elementName = target.nodeName;
  if (elementName == 'A' || // No I18N
  elementName == 'a' || // No I18N
  !isChrome && (elementName == 'MATH' || // No I18N
  elementName == 'math' // No I18N
  )) {
    target.setAttribute("rel", "noopener noreferrer"); // No I18N
    if (!isChromeAbove72) {
      addEventListener(target, 'click', clickListener); // No I18N
    }
  }
  if (!target.childNodes) {
    return;
  }
  var childElement = target.childNodes;
  for (var i = 0; i < childElement.length; i++) {
    var each = childElement[i];
    if (each.nodeType === 1) {
      checkAndAddListener(each);
    }
  }
}

/**
 * It sets listener for an element to capture the new element insertion, using either MutationObserver or element.addEventListener based on the browser support
 *
 * @param   {Element}    element   Element to add event listener
 * @param   {Function}   callback  Function to call on event
 *
 * @return  {undefined}            Doesn't return
 */
function elementInsertionListener(element, callback) {
  var MutationObserver = window.MutationObserver || window.WebKitMutationObserver;
  var eventListenerSupported = window.addEventListener;
  if (MutationObserver) {
    var obs = new MutationObserver(function (mutations) {
      for (var i = 0; i < mutations.length; i++) {
        var addedNodesSize = mutations[i].addedNodes.length;
        if (addedNodesSize) {
          var addedList = mutations[i].addedNodes;
          for (var j = 0; j < addedNodesSize; j++) {
            callback(addedList[j]);
          }
        }
      }
    });
    obs.observe(element, {
      childList: true,
      subtree: true
    });
  } else if (eventListenerSupported) {
    element.addEventListener('DOMNodeInserted', // No I18N
    function (e) {
      callback(e.target);
    }, false);
  }
}

/**
 * An event listener that can be attached to a click event to protect against
 * reverse tabnabbing. It retrieves the target anchors href, and if the link
 * was intended to open in a new tab or window, the browser's default
 * behavior is canceled. Instead, the destination url is opened using
 * "window.open" from an injected iframe, and the iframe is removed. Except
 * for IE < 11, which uses "window.open" followed by setting the child
 * window's opener to null.
 *
 * @param   {Event}  e              a click event
 *
 * @return  {undefined|Boolean}     Returns false if the link is correctly opened. Else returns nothing.
 */
function clickListener() {
  var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.event;

  // Use global event object for IE8 and below to get target
  // Won't work for IE8 and below for cases when e.srcElement
  // refers not to the anchor, but to the element inside it e.g. an image
  var target = e.currentTarget || e.srcElement;

  // Ignore anchors without an href
  var href = target.getAttribute('href');
  if (!href) {
    href = target.getAttribute('xlink:href');
    if (!href) {
      return;
    }
  }

  // Ignore anchors without an unsafe target or modifier key
  var usedModifier = e.ctrlKey || e.shiftKey || e.metaKey;
  var targetName = target.getAttribute('target');
  var target2 = target.getAttribute('xlink:show');
  if (!usedModifier && (!targetName || safeTarget(targetName)) && !target2) {
    return;
  }
  SecureRedirector.open(href);

  // IE8 and below don't support preventDefault
  if (e.preventDefault) {
    e.preventDefault();
  } else {
    e.returnValue = false;
  }
  return false;
}

/**
 * A cross-browser addEventListener function that adds a listener for the
 * supplied event type to the specified target.
 *
 * @param  {Element}    target     Element to add event listener
 * @param  {String}     type       Type of event
 * @param  {Function}   listener   Listener function to add
 *
 * @return  {undefined|Boolean}     Returns false if the link is correctly opened. Else returns nothing.
 */
function addEventListener(target, type, listener) {
  // Modern browsers
  if (target.addEventListener) {
    return target.addEventListener(type, listener, false);
  }

  // Older browsers
  var onType = 'on' + type; // No I18N
  if (target.attachEvent) {
    target.attachEvent(onType, listener);
  } else if (target[onType]) {
    var prevListener = target[onType];
    target[onType] = function () {
      listener();
      prevListener();
    };
  } else {
    target[onType] = listener;
  }
}

/**
 * Opens the provided url by injecting a hidden iframe that calls
 * window.open(), then removes the iframe from the DOM.
 *
 * @param   {String}  url                URL to open
 * @param   {String}  strWindowName      String specifying the name of the browsing context
 * @param   {String}  strWindowFeatures  String containing a comma-separated list of window features like size and position
 *
 * @return  {Window}                     Reference of the newly opened page
 */
function iframeOpen(url, strWindowName, strWindowFeatures) {
  var iframe = window.document.createElement('iframe');
  iframe.style.display = 'none';
  window.document.body.appendChild(iframe);
  var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;

  var openArgs = '"' + window.encodeURI(url) + '"'; // No I18N
  if (strWindowName) {
    openArgs += ', "' + replaceVulnChars(strWindowName, jsVulnCharMap) + '"'; // No I18N
  }
  if (strWindowFeatures) {
    openArgs += ', "' + replaceVulnChars(strWindowFeatures, jsVulnCharMap) + '"'; // No I18N
  }
  var script = iframeDoc.createElement('script');
  script.type = 'text/javascript';
  script.text = "window.parent = null; window.top = null; window.frameElement = null; var child = window.open(" + openArgs + "); try{ child.opener = null; }catch(e){}";
  iframeDoc.body.appendChild(script);
  var newWin = iframe.contentWindow.child;

  window.document.body.removeChild(iframe);
  return newWin;
}

/**
 * Accepts an element or array of elements which contains elements vulnerable to reverse tabnabbing based
 * phishing attacks and secures them by adding an event listener to help mitigate an attack.
 * It will also monitor the changes(if monitor flag set to true) in the element and
 * adds listeners to the newly added vulnerable elements.
 *
 * @param   {HTMLElement|HTMLElement[]}   target   Element or array of elements to listen for clicks and redirect securely
 * @param   {Boolean}                     monitor  If set to true, monitors the element to add listeners for any newly added children.
 *
 * @return  {undefined}           Doesn't return
 */
function SecureRedirector(target) {
  var monitor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  // For performance, any supplied object with a length attribute is assumed to be an array of elements.
  if (typeof target.length === 'undefined') {
    checkAndAddListener(target);
    if (monitor) {
      elementInsertionListener(target, SecureRedirector);
    }
  } else if (typeof target !== 'string' && !(target instanceof String)) {
    // No I18N
    for (var i = 0; i < target.length; i++) {
      checkAndAddListener(target[i]);
      if (monitor) {
        elementInsertionListener(target, SecureRedirector);
      }
    }
  }
}

/**
 * Accepts the same arguments as window.open. If the strWindowName is not
 * equal to one of the safe targets (_top, _self or _parent), then it opens
 * the destination url using "window.open" from an injected iframe, then
 * removes the iframe. This behavior applies to all browsers except IE < 11,
 * which use "window.open" followed by setting the child window's opener to
 * null. If the strWindowName is set to some other value, the url is simply
 * opened with window.open().
 *
 * @param   {String}  strUrl             URL to open
 * @param   {String}  strWindowName      String specifying the name of the browsing context
 * @param   {String}  strWindowFeatures  String containing a comma-separated list of window features like size and position
 *
 * @return  {Window}                     Reference of the newly opened page
 */
SecureRedirector.open = function (strUrl, strWindowName, strWindowFeatures) {
  if (safeTarget(strWindowName)) {
    return open.apply(window, arguments);
  }
  if (!oldIE && !isChromeAbove72) {
    return iframeOpen(strUrl, strWindowName, strWindowFeatures);
  }
  // Replace child.opener for old IE to avoid appendChild errors
  // We do it for all to avoid having to sniff for specific versions
  // 
  // 
  // The below line is commented because child reference was being returned as null. (Zoho Backstage Issue)
  // arguments[2]='noopener,noreferrer'+(arguments[2] && ','+arguments[2]||'');// No I18N
  var child = open.apply(window, arguments);
  child.opener = null;
  return child;
};

/**
 * Patches window.open() to use blankshield.open() for new window/tab targets.
 */
SecureRedirector.patch = function () {
  window.open = function () {
    return SecureRedirector.open.apply(this, arguments);
  };
};

if (Object.freeze) {
  Object.freeze(SecureRedirector);
}

if (ZWAF$2.version === '7.0.0' && !ZWAF$2.SecureRedirector) {
  ZWAF$2.defineProperty(ZWAF$2, 'SecureRedirector', // No I18N
  SecureRedirector, true, false, false, true);
}
if (!ZWAF$2['7_0_0'].SecureRedirector) {
  ZWAF$2.defineProperty(ZWAF$2['7_0_0'], 'SecureRedirector', // No I18N
  SecureRedirector, true, false, false, true);
}

var TextFilter = {};

// Function to Filter the given XML String
TextFilter.filterXML = function (xmlString) {
  var xmlStringBuilder = '';
  for (var i = 0, xmlStringLength = xmlString.length; i < xmlStringLength; i++) {
    var codePoint = codePointAt.call(xmlString, i);
    var xmlChar = xmlString.charAt(i);
    if (codePoint === 0x9 || codePoint === 0xa || codePoint === 0xd || codePoint >= 0x20 && codePoint <= 0xd7ff || codePoint >= 0xe000 && codePoint <= 0xfffd || codePoint >= 0x10000 && codePoint <= 0x10ffff) {
      xmlStringBuilder += xmlChar;
    }
    if (codePoint > 0xffff) {
      i++;
    }
  }
  return xmlStringBuilder;
};

if (Object.freeze) {
  Object.freeze(TextFilter);
}

if (ZWAF$2.version === '7.0.0' && !ZWAF$2.TextFilter) {
  ZWAF$2.defineProperty(ZWAF$2, 'TextFilter', // No I18N
  TextFilter, true, false, false, true);
}
if (!ZWAF$2['7_0_0'].TextFilter) {
  ZWAF$2.defineProperty(ZWAF$2['7_0_0'], 'TextFilter', // No I18N
  TextFilter, true, false, false, true);
}

function _toConsumableArray$4(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/** Highest positive signed 32-bit float value */
var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D' // No I18N

/** Regular expressions */
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
var errors = {
  'overflow': 'Overflow: input needs wider integers to process', // No I18N
  'not-basic': 'Illegal input >= 0x80 (not a basic code point)', // No I18N
  'invalid-input': 'Invalid input' // No I18N
};

/** Convenience shortcuts */
var baseMinusTMin = base - tMin;
var floor$1 = Math.floor;
var stringFromCharCode$1 = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error(type) {
  throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, fn) {
  var result = [];
  var length = array.length;
  while (length--) {
    result[length] = fn(array[length]);
  }
  return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
  var parts = string.split('@');
  var result = '';
  if (parts.length > 1) {
    // In email addresses, only the domain name should be punycoded. Leave
    // the local part (i.e. everything up to `@`) intact.
    result = parts[0] + '@';
    string = parts[1];
  }
  // Avoid `split(regex)` for IE8 compatibility. See #17.
  string = string.replace(regexSeparators, '\x2E');
  var labels = string.split('.');
  var encoded = map(labels, fn).join('.');
  return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
  var output = [];
  var counter = 0;
  var length = string.length;
  while (counter < length) {
    var value = string.charCodeAt(counter++);
    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      // It's a high surrogate, and there is a next character.
      var extra = string.charCodeAt(counter++);
      if ((extra & 0xFC00) == 0xDC00) {
        // Low surrogate.
        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        // It's an unmatched surrogate; only append this code unit, in case the
        // next code unit is the high surrogate of a surrogate pair.
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
var ucs2encode = function ucs2encode(array) {
  return fromCodePoint.apply(undefined, _toConsumableArray$4(array));
};

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
var basicToDigit = function basicToDigit(codePoint) {
  if (codePoint - 0x30 < 0x0A) {
    return codePoint - 0x16;
  }
  if (codePoint - 0x41 < 0x1A) {
    return codePoint - 0x41;
  }
  if (codePoint - 0x61 < 0x1A) {
    return codePoint - 0x61;
  }
  return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
var digitToBasic = function digitToBasic(digit, flag) {
  //  0..25 map to ASCII a..z or A..Z
  // 26..35 map to ASCII 0..9
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
var adapt = function adapt(delta, numPoints, firstTime) {
  var k = 0;
  delta = firstTime ? floor$1(delta / damp) : delta >> 1;
  delta += floor$1(delta / numPoints);
  for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor$1(delta / baseMinusTMin);
  }
  return floor$1(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
var decode = function decode(input) {
  // Don't use UCS-2.
  var output = [];
  var inputLength = input.length;
  var i = 0;
  var n = initialN;
  var bias = initialBias;

  // Handle the basic code points: let `basic` be the number of input code
  // points before the last delimiter, or `0` if there is none, then copy
  // the first basic code points to the output.

  var basic = input.lastIndexOf(delimiter);
  if (basic < 0) {
    basic = 0;
  }

  for (var j = 0; j < basic; ++j) {
    // if it's not a basic code point
    if (input.charCodeAt(j) >= 0x80) {
      error('not-basic'); // No I18N
    }
    output.push(input.charCodeAt(j));
  }

  // Main decoding loop: start just after the last delimiter if any basic code
  // points were copied; start at the beginning otherwise.

  for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

    // `index` is the index of the next character to be consumed.
    // Decode a generalized variable-length integer into `delta`,
    // which gets added to `i`. The overflow checking is easier
    // if we increase `i` as we go, then subtract off its starting
    // value at the end to obtain `delta`.
    var oldi = i;
    for (var w = 1, k = base;; /* no condition */k += base) {

      if (index >= inputLength) {
        error('invalid-input'); // No I18N
      }

      var digit = basicToDigit(input.charCodeAt(index++));

      if (digit >= base || digit > floor$1((maxInt - i) / w)) {
        error('overflow'); // No I18N
      }

      i += digit * w;
      var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

      if (digit < t) {
        break;
      }

      var baseMinusT = base - t;
      if (w > floor$1(maxInt / baseMinusT)) {
        error('overflow'); // No I18N
      }

      w *= baseMinusT;
    }

    var out = output.length + 1;
    bias = adapt(i - oldi, out, oldi == 0);

    // `i` was supposed to wrap around from `out` to `0`,
    // incrementing `n` each time, so we'll fix that now:
    if (floor$1(i / out) > maxInt - n) {
      error('overflow'); // No I18N
    }

    n += floor$1(i / out);
    i %= out;

    // Insert `n` at position `i` of the output.
    output.splice(i++, 0, n);
  }

  return fromCodePoint.apply(undefined, output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
var encode$1 = function encode(input) {
  var output = [];

  // Convert the input in UCS-2 to an array of Unicode code points.
  input = ucs2decode(input);

  // Cache the length.
  var inputLength = input.length;

  // Initialize the state.
  var n = initialN;
  var delta = 0;
  var bias = initialBias;

  // Handle the basic code points.
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var currentValue = _step.value;

      if (currentValue < 0x80) {
        output.push(stringFromCharCode$1(currentValue));
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var basicLength = output.length;
  var handledCPCount = basicLength;

  // `handledCPCount` is the number of code points that have been handled;
  // `basicLength` is the number of basic code points.

  // Finish the basic string with a delimiter unless it's empty.
  if (basicLength) {
    output.push(delimiter);
  }

  // Main encoding loop:
  while (handledCPCount < inputLength) {

    // All non-basic code points < n have been handled already. Find the next
    // larger one:
    var m = maxInt;
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _currentValue = _step2.value;

        if (_currentValue >= n && _currentValue < m) {
          m = _currentValue;
        }
      }

      // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
      // but guard against overflow.
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    var handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor$1((maxInt - delta) / handledCPCountPlusOne)) {
      error('overflow'); // No I18N
    }

    delta += (m - n) * handledCPCountPlusOne;
    n = m;

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var _currentValue2 = _step3.value;

        if (_currentValue2 < n && ++delta > maxInt) {
          error('overflow'); // No I18N
        }
        if (_currentValue2 == n) {
          // Represent delta as a generalized variable-length integer.
          var q = delta;
          for (var k = base;; /* no condition */k += base) {
            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (q < t) {
              break;
            }
            var qMinusT = q - t;
            var baseMinusT = base - t;
            output.push(stringFromCharCode$1(digitToBasic(t + qMinusT % baseMinusT, 0)));
            q = floor$1(qMinusT / baseMinusT);
          }

          output.push(stringFromCharCode$1(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    ++delta;
    ++n;
  }
  return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
var toUnicode = function toUnicode(input) {
  return mapDomain(input, function (string) {
    return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
  });
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
var toASCII = function toASCII(input) {
  return mapDomain(input, function (string) {
    return regexNonASCII.test(string) ? 'xn--' + encode$1(string) // No I18N
    : string;
  });
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
var punycode = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  'version': '2.1.0', // No I18N
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  'ucs2': { // No I18N
    'decode': ucs2decode, // No I18N
    'encode': ucs2encode // No I18N
  },
  'decode': decode, // No I18N
  'encode': encode$1, // No I18N
  'toASCII': toASCII, // No I18N
  'toUnicode': toUnicode // No I18N
};

/**
 * URLValidator
 * */

var constants$1 = {
  unsafeProtocolRegex: /^(?:\w+script|data)$/i,
  sanitizeAction: {
    ENCODE: 'ENCODE', // No I18N
    REMOVE: 'REMOVE' // No I18N
  },
  allowedProtocols: ['https', 'http'] // No I18N
};

/**
 * Create a new URLValidator instance and pass as argument
 * @type {Object}
 */
var URLValidator = {
  punycode: punycode
};

function checkProtocol(allowedProtocols, protocol) {
  if (allowedProtocols) {
    for (var i = 0; i < allowedProtocols.length; i++) {
      var eachProtocol = allowedProtocols[i];
      if (eachProtocol.constructor === RegExp && eachProtocol.test(protocol) || eachProtocol.constructor === String && eachProtocol === protocol) {
        return true;
      }
    }
    return false;
  }
  if (constants$1.unsafeProtocolRegex.test(protocol)) {
    // Matches our default unsafe protocol regex so protocol is not safe, return false
    return false;
  }
  return true;
}

function checkDomain(allowedDomains, domain) {
  if (!allowedDomains) {
    return true;
  }
  var punycodedDomain = URLValidator.punycode.toASCII(domain); // We need both punycoded and non-punycoded domain values
  var nonPunycodedDomain = URLValidator.punycode.toUnicode(domain); // To check the allowedDomains list for ease of use
  for (var i = 0; i < allowedDomains.length; i++) {
    var eachDomain = allowedDomains[i];
    // Check both punycoded and non-punycoded domain values
    if (eachDomain.constructor === String && (eachDomain === punycodedDomain || eachDomain === nonPunycodedDomain) || eachDomain.constructor === RegExp && (eachDomain.test(punycodedDomain) || eachDomain.test(nonPunycodedDomain))) {
      return true;
    }
  }
  return false;
}
/**
 * Sanitizes the given URL and returns a safe URL/Object based on the given
 * configuration. By default, it resolves a partial URL to a complete URL,
 * punycodes non-ASCII domain names by default, allows only http/https protocols.
 *
 * @param  {String}  userURL  URL to Sanitize
 * @param  {Object}  config   Custom Config for URL Sanitization
 * @return {String/Object}    Sanitized URL
 */
URLValidator.sanitize = function (userURL) {
  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!userURL) {
    //  No User URL, return empty
    return '';
  }

  var ALLOWED_PROTOCOLS = config.ALLOWED_PROTOCOLS || constants$1.allowedProtocols;
  var ALLOWED_DOMAINS = config.ALLOWED_DOMAINS || false;
  var PUNYCODE = config.PUNYCODE !== false;
  var ACTION = config.ACTION || constants$1.sanitizeAction.ENCODE;
  var RETURN_OBJECT = config.RETURN_OBJECT || false;
  var KEEP_ORIGINAL = config.KEEP_ORIGINAL || false;
  var VALIDATE_ONLY = config.VALIDATE_ONLY || false;

  /*
  ////////////////////////////
  //  Original Method Start //
  ////////////////////////////
  
  //  URL is set through innerHTML and not through href property of anchor tag.
  //  This is because if a partial URL is set and got through the href property,
  //  it will only be returned as the original partial value. But setting
  //  through innerHTML and getting through href property will return
  //  the fully resolved URL.
  //
  //  Example - While in sites.zoho.com,
  //
  //  1) USING HREF PROPERTY:
  //      anchorTag.href = "/pages/page/1";
  //      return anchorTag.href;
  //
  //  This will return "/pages/page/1" in some old browsers
  //
  //  2) USING INNERHTML:
  //      divTag.innerHTML = "<a href='/pages/page/1'>Link</a>";
  //      return divTag.childNodes[0].href;
  //
  //  This will return "https://sites.zoho.com/pages/page/1" in all browsers
   //  Also, encodeURI will encode all double quotes(") but not single quotes(').
  //  So the href attribute in the innerHTML should be enclosed with double quotes
  //  to prevent the URL from breaking out of the href attribute value.
   let tempContainer = document.createElement('div');
  tempContainer.innerHTML = '<a href="' + encodeURI(userURL) + '">a</a>';
  anchorTag = tempContainer.childNodes[0];
   //////////////////////////
  //  Original Method End //
  //////////////////////////
  */

  /// ////////////////////////////////////////////////
  //  New Method Start (Method #3)                 //
  //  Tested in all browsers. See here for results //
  /// ////////////////////////////////////////////////

  var a = window.document.createElement('a');
  a.href = userURL;
  var anchorTag = a.cloneNode(false);

  /// //////////////////////////////
  //  New Method End (Method #3) //
  /// //////////////////////////////

  var protocol = anchorTag.protocol.slice(0, -1); // This is to remove the trailing colon ':' which is returned when getting the protocol
  var domain = anchorTag.host;
  var pathname = anchorTag.pathname,
      port = anchorTag.port,
      hash = anchorTag.hash;

  var resolvedURL = anchorTag.href;

  //  Return in non-ASCII characters only if explicitly mentioned in config.
  //  Otherwise, return punycoded value by default
  domain = PUNYCODE ? URLValidator.punycode.toASCII(domain) : URLValidator.punycode.toUnicode(domain);
  resolvedURL = PUNYCODE ? URLValidator.punycode.toASCII(resolvedURL) : URLValidator.punycode.toUnicode(resolvedURL);

  var isDomainSafe = checkDomain(ALLOWED_DOMAINS, domain);
  var isProtocolSafe = checkProtocol(ALLOWED_PROTOCOLS, protocol);

  if (VALIDATE_ONLY && (!isDomainSafe || !isProtocolSafe)) {
    return false;
  }
  if (!isDomainSafe) {
    return '';
  }
  if (!isProtocolSafe) {
    if (ACTION === constants$1.sanitizeAction.ENCODE) {
      return resolvedURL.replace(/:/, '%3A');
    }
    return '';
  }
  if (VALIDATE_ONLY) {
    return true;
  }
  if (RETURN_OBJECT) {
    return {
      PROTOCOL: protocol,
      DOMAIN: domain,
      PORT: port,
      PATH: pathname,
      HASH: hash,
      RESOLVED_URL: resolvedURL,
      ORIGINAL_URL: userURL
    };
  }
  if (KEEP_ORIGINAL) {
    return userURL;
  }
  return resolvedURL;
};

/**
 * Validates the given URL and returns if it is safe or not.
 * Only returns boolean values.
 *
 * @param   {String}  userURL  URL to Sanitize
 * @param   {Object}  config   Custom Config for URL Sanitization
 *
 * @return  {Boolean}          True if the URL is safe, false if it is unsafe.
 */
URLValidator.validate = function (userURL) {
  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!userURL) {
    //  No User URL, return false
    return false;
  }
  config.VALIDATE_ONLY = true;
  return URLValidator.sanitize(userURL, config);
};

if (Object.freeze) {
  Object.freeze(URLValidator);
}

if (ZWAF$2.version === '7.0.0' && !ZWAF$2.URLValidator) {
  ZWAF$2.defineProperty(ZWAF$2, 'URLValidator', // No I18N
  URLValidator, true, false, false, true);
}
if (!ZWAF$2['7_0_0'].URLValidator) {
  ZWAF$2.defineProperty(ZWAF$2['7_0_0'], 'URLValidator', // No I18N
  URLValidator, true, false, false, true);
}

return ZWAF$2;

})));
