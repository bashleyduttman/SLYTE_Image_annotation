(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.ZWAF = factory());
}(this, (function () { 'use strict';

/**
 * Polyfills
 */

/**
 * 
 * It's a wrapper over Object.defineProperty for setting  data descriptors for object .A data descriptor is a property that has a value, which sets isWritable,isConfigurable,isEnumerable for an object. By default all configuration values are false.
 * 
 * Below function will define Object.defineProperty if not defined.
 * Normal property addition through assignment(=) creates properties.
 * But it shows up during property enumeration (for...in loop or Object.keys method), whose values may be changed or deleted.
 * And it may even create some unusual behaviour. The Object.defineProperty method allows
 * three extra details(configurable, writable, and enumerable) to be set for the value.
 * By default all the value are true. Since defineProperty is not supported
 * below IE-9 we have implemented fall back to directly assign value to the object
 *
 * @param   {Object} obj
 * @param   {string} property
 * @param   {value}  value
 * @param   {boolean}  isOverrideDefaultValue
 * @param   {boolean}  isWritable
 * @param   {boolean}  isConfigurable
 * @param   {boolean}  isEnumerable
 * @returns {Object}
 */
/* eslint-disable-next-line max-params */
function defineProperty(obj, property, value, isOverrideDefaultValue, isWritable, isConfigurable, isEnumerable) {
  if (!isOverrideDefaultValue && property in obj) {
    return;
  }
  if (!Object.defineProperty || !function () {
    try {
      Object.defineProperty({}, 'x', {}); // No I18N
      return true;
    } catch (e) {
      return false;
    }
  }()) {
    obj[property] = value;
    return obj;
  }

  isWritable = isWritable === true;
  isConfigurable = isConfigurable === true;
  isEnumerable = isEnumerable === true;
  return Object.defineProperty(obj, property, {
    value: value,
    writable: isWritable,
    configurable: isConfigurable,
    enumerable: isEnumerable
  });
}

/**
 * Defining String.prototype.codePointAt if not defined already
 * This is not supported in IE 11 and below
 */


/**
 * Defining String.fromCodePoint if not defined already
 * Which is not supported in many browsers like IE ,Android ,Opera Mobile
 * */

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Logger = function () {
  function Logger(level) {
    _classCallCheck(this, Logger);

    this.LEVELS = {
      NONE: -1,
      DEBUG: 0,
      INFO: 1,
      WARN: 2,
      ERROR: 3
    };
    if (level === this.LEVELS.NONE || level === this.LEVELS.DEBUG || level === this.LEVELS.INFO || level === this.LEVELS.WARN || level === this.LEVELS.ERROR) {
      this.level = level;
    } else {
      this.level = this.LEVELS.ERROR;
    }
  }

  _createClass(Logger, [{
    key: "debug",
    value: function debug() {
      var _window;

      if (!window || !window.console || this.level === this.LEVELS.NONE || this.level !== this.LEVELS.DEBUG) {
        return;
      }

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      (_window = window["con" + "sole"]).debug.apply(_window, args.concat([performance.now()])); // No I18N
    }
  }, {
    key: "info",
    value: function info() {
      var _window2;

      if (!window || !window.console || this.level === this.LEVELS.NONE || this.level > this.LEVELS.INFO) {
        return;
      }

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      (_window2 = window["con" + "sole"]).log.apply(_window2, args.concat([performance.now()])); // No I18N
    }
  }, {
    key: "warn",
    value: function warn() {
      var _window3;

      if (!window || !window.console || this.level === this.LEVELS.NONE || this.level > this.LEVELS.WARN) {
        return;
      }

      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      (_window3 = window["con" + "sole"]).warn.apply(_window3, args.concat([performance.now()])); // No I18N
    }
  }, {
    key: "error",
    value: function error() {
      var _window4;

      if (!window || !window.console || this.level === this.LEVELS.NONE || this.level > this.LEVELS.ERROR) {
        return;
      }

      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      (_window4 = window["con" + "sole"]).error.apply(_window4, args.concat([performance.now()])); // No I18N
    }
  }]);

  return Logger;
}();

/**
 * @author: Patrick-2626 & Vigneshwar-5036
 *
 * @wiki: https://intranet.wiki.zoho.com/security/client-side-security.html
 *
 * Reference
 *  1)https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/
 *  2)https://github.com/danielstjules/blankshield
 */

var ZWAF$2 = window && window.ZWAF ? window.ZWAF : { version: '7.0.0' };
var logger = new Logger();

if (!ZWAF$2.defineProperty) {
  ZWAF$2.defineProperty = defineProperty;
}

if (!ZWAF$2.logger) {
  ZWAF$2.logger = logger;
}

if (!ZWAF$2['7_0_0']) {
  ZWAF$2['7_0_0'] = {
    version: '7.0.0',
    defineProperty: defineProperty,
    logger: logger
  };
}

/**
 * Display a message in the browser developer console, warning any unwary user.
 *
 * Only a static message is displayed for now. Support for giving API to user to customize message maybe given in future
 * INFO: This warning is linked to a common source (Wikipedia page).
 * This is because our products maybe used for Whitelabel Deployment and we shouldn't display anything specific to Zoho there.
 * So we will maintain this to be common source.
 */

var called = false;
var Console = {
  log: function log() {
    if (!window || !window.console || !window.console.log || !window.navigator || !window.navigator.userAgent || called) {
      return;
    }
    var userAgent = window.navigator.userAgent;

    var browser = userAgent.match(/opera|chrome|safari|firefox|msie|trident(?=\/)/i);
    called = true;
    if (browser && browser[0].search(/trident|msie/i) < 0) {
      // Supported  browser
      window.console.log('%cSTOP!', // No I18N
      'color:red;font-size:xx-large;font-weight:bold;' // No I18N
      );
      window.console.log("%cThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\nSee https://en.wikipedia.org/wiki/Self-XSS for more details", // No I18N
      'font-size:large;' // No I18N
      );
      return;
    }
    // Not supported browser
    window.console.log("STOP!\nThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\nSee https://en.wikipedia.org/wiki/Self-XSS for more details" // No I18N
    );
  }
};

/**
 * Custom Functions for Sanitizer
 **/















/**
 * Cookie handling functions
 **/

function setCookie(name, value) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  options = Object.assign({
    path: '/',
    SameSite: 'lax', // No I18N
    // Default max age is 100 days
    'max-age': 100 * 24 * 60 * 60 * 1000 // No I18N
  }, options);
  if (!encodeURIComponent) {
    return;
  }
  var cookieVal = encodeURIComponent(name) + '=' + encodeURIComponent(value);

  for (var optionKey in options) {
    cookieVal += '; ' + optionKey;
    var optionValue = options[optionKey];
    if (optionValue !== true) {
      cookieVal += '=' + optionValue;
    }
  }
  document.cookie = cookieVal;
}
function deleteCookie(name) {
  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '/';

  setCookie(name, '', {
    path: path,
    'max-age': -1 // No I18N
  });
}

function getCookie(name) {
  name = name + '=';
  var cookieList = document.cookie;
  var res = void 0;
  cookieList.split('; ').forEach(function (cookie) {
    if (res !== undefined) {
      return;
    }
    var cookieValue = void 0;
    try {
      if (decodeURIComponent) {
        cookieValue = decodeURIComponent(cookie);
      }
    } catch (e) {
      cookieValue = cookie;
      ZWAF && ZWAF.logger && ZWAF.logger.warn && ZWAF.logger.warn("Error while trying to decode Cookie value!");
    }
    if (cookieValue.indexOf(name) === 0) {
      res = cookieValue.substring(name.length);
    }
  });
  return res;
}

function hasCookie(name) {
  return !!getCookie(name);
}











// Unused functions
//
// function setArray(arr1, arr2){
//   arr1.splice.apply(arr1,[0,arr1.length].concat(arr2));
// }
//
// function addObjsToSet(set, set2) {
//   for (let each in set2) {
//     if (set2.hasOwnProperty(each)) {
//       set[each] = true;
//     }
//   }
//   return set;
// };
//
// function removeFromSet(set, key) {
//   delete set[key];
//   return set;
// }
//
// /* Add all object keys to array */
// function addToArr(array, set) {
//   let property;
//   for (property in set) {
//     if (set.hasOwnProperty(property)) {
//       array.push(property);
//     }
//   }
//   return array;
// }
//
// /* Add flags to config */
// function addToConfig(set, array) {
//   let l = array.length;
//   while (l--) {
//     set[array[l]] = true;
//   }
//   return set;
// }

if (ZWAF$2.version === '7.0.0' && !ZWAF$2.Console) {
  ZWAF$2.defineProperty(ZWAF$2, 'Console', // No I18N
  Console, true, false, false, true);
}
if (!ZWAF$2['7_0_0'].Console) {
  ZWAF$2.defineProperty(ZWAF$2['7_0_0'], 'Console', // No I18N
  Console, true, false, false, true);
}

var COOKIE_NAMES = ['_zcsr_tmp', // No I18N
'com_chat_owner', // No I18N
'com_avcliq_owner', // No I18N
'wms.agent' // No I18N
];
var loggedInUser = COOKIE_NAMES.some(function (e) {
  return hasCookie(e);
});
if (loggedInUser) {
  ZWAF$2 && ZWAF$2['7_0_0'] && ZWAF$2['7_0_0'].Console && ZWAF$2['7_0_0'].Console.log();
}

/**
 * Identify specific browsers like Chromium-based Ulaa, Brave, Arc
 *
 * These browsers are usually not identifiable through User-Agent Request Header
 * This is because they sometimes prefer to be identified as their parent browser (like Chromium)
 * to ensure webpages work correctly. But it is necessary for us to get accurate stats on browsers
 *
 * Eg: To show users which browser they recently used to log in
 *
 * Browser-specific identification or "duck-typing" is done to identify the browser.
 * If it is not in the list of usually identifiable browsers,
 * then we place this detail in a cookie named "_zwaf_ua".
 * For now, only browser name is added. Based on further needs we can add more info
 * like specific browser version and device type.
 */
var UA_COOKIE_NAME = '_zwaf_ua'; // No I18N

var UAIdentification = {
  /**
   * Called by default when SecurityJS is loaded.
   *
   */
  init: function init() {
    deleteCookie(UA_COOKIE_NAME);

    // Reference:
    // https://github.com/brave/brave-browser/issues/10165#issuecomment-641128278
    // https://github.com/brave/brave-browser/issues/10165#issuecomment-644949774
    var isUlaa = !!window.ulaa;
    var isBrave = navigator && navigator.brave && typeof navigator.brave.isBrave === 'function'; // No I18N
    if (isUlaa) {
      setCookie(UA_COOKIE_NAME, 'Ulaa'); // No I18N
    } else if (isBrave) {
      setCookie(UA_COOKIE_NAME, 'Brave'); // No I18N
    } else {
      // Reference:
      // https://webmasters.stackexchange.com/a/142231
      // Should be done after 1 second timeout after page is loaded.
      window && window.addEventListener('load', // No I18N
      function () {
        window.setTimeout(function () {
          var isArc = window.getComputedStyle(window.document.documentElement).getPropertyValue('--arc-palette-background'); // No I18N
          if (isArc) {
            setCookie(UA_COOKIE_NAME, 'Arc'); // No I18N
          }
        }, 1000);
      });
    }
  },
  disable: function disable() {
    // If any one does not want this cookie to be set, they can call ZWAF.UAIdentification.disable()
    deleteCookie(UA_COOKIE_NAME);
  }
};

if (ZWAF$2.version === '7.0.0' && !ZWAF$2.UAIdentification) {
  ZWAF$2.defineProperty(ZWAF$2, 'UAIdentification', // No I18N
  UAIdentification, true, false, false, true);
}
if (!ZWAF$2['7_0_0'].UAIdentification) {
  ZWAF$2.defineProperty(ZWAF$2['7_0_0'], 'UAIdentification', // No I18N
  UAIdentification, true, false, false, true);
}

ZWAF$2 && ZWAF$2['7_0_0'] && ZWAF$2['7_0_0'].UAIdentification && ZWAF$2['7_0_0'].UAIdentification.init();

/**
 * SecureRedirector
 *
 * Reference
 *  1)https://github.com/danielstjules/blankshield
 */

/* eslint-disable prefer-rest-params */

var winNav = window.navigator;
var oldIE = winNav.userAgent.indexOf('MSIE') !== -1;
var isChromium = window.chrome;
var vendorName = winNav.vendor;
var isOpera = typeof window.opr !== "undefined"; // No I18N
var isIEedge = winNav.userAgent.indexOf("Edge") > -1;
var isChrome = isChromium !== null && typeof isChromium !== "undefined" && // No I18N
vendorName === "Google Inc." && // No I18N
isOpera === false && isIEedge === false;
var isChromeAbove72 = false;
if (isChrome) {
  // is Google Chrome
  isChromeAbove72 = true;
  try {
    var match = navigator.userAgent.match(/Chrome\/(\d+)/);
    var version = match && parseInt(match[1]);
    if (!isNaN(version)) {
      isChromeAbove72 = version > 71;
    }
  } catch (e) {
    isChromeAbove72 = true;
  }
}

var _window = window;
var open = _window.open;

var jsVulnCharMap = {
  "'": '\\x27', // No I18N
  '"': '\\x22', // No I18N
  '`': '\\x60', // No I18N
  '\n': '\\x0A', // No I18N
  '\r': '\\x0D', // No I18N
  '<': '\\x3C', // No I18N
  '>': '\\x3E', // No I18N
  ')': '\\x29' // No I18N
};

/**
 * Checks if the given target is safe
 *
 * @param   {String}  target  target value for window.open
 *
 * @return  {Boolean}         Return true if target value is safe
 */
function safeTarget(target) {
  return target === '_top' || target === '_self' || target === '_parent'; // No I18N
}

/**
 * Replaces vulnerable characters in the given string
 * with safe characters from the given character map
 *
 * @param   {String}  str      The string with vulnerable characters
 * @param   {Map}     charMap  Map of vulnerable characters as keys with safe characters as values
 *
 * @return  {String}           Safe string without vulnerable characters
 */
function replaceVulnChars(str, charMap) {
  if (!charMap || !str) {
    return str;
  }
  var newStr = '';
  for (var i = 0; i < str.length; i++) {
    if (Object.prototype.hasOwnProperty.call(charMap, str[i])) {
      newStr += charMap[str[i]];
    } else {
      newStr += str[i];
    }
  }
  return newStr;
}

/**
 * It iterates over all the child elements and sets click listener for the
 * elements where reverse tabnabbing based phishing attacks are possible
 *
 * @param   {Element}  target  Element to add event listener
 *
 * @return  {undefined}        Doesn't return
 */
function checkAndAddListener(target) {
  if (target.nodeType !== 1) {
    return;
  }
  var elementName = target.nodeName;
  if (elementName == 'A' || // No I18N
  elementName == 'a' || // No I18N
  !isChrome && (elementName == 'MATH' || // No I18N
  elementName == 'math' // No I18N
  )) {
    target.setAttribute("rel", "noopener noreferrer"); // No I18N
    if (!isChromeAbove72) {
      addEventListener(target, 'click', clickListener); // No I18N
    }
  }
  if (!target.childNodes) {
    return;
  }
  var childElement = target.childNodes;
  for (var i = 0; i < childElement.length; i++) {
    var each = childElement[i];
    if (each.nodeType === 1) {
      checkAndAddListener(each);
    }
  }
}

/**
 * It sets listener for an element to capture the new element insertion, using either MutationObserver or element.addEventListener based on the browser support
 *
 * @param   {Element}    element   Element to add event listener
 * @param   {Function}   callback  Function to call on event
 *
 * @return  {undefined}            Doesn't return
 */
function elementInsertionListener(element, callback) {
  var MutationObserver = window.MutationObserver || window.WebKitMutationObserver;
  var eventListenerSupported = window.addEventListener;
  if (MutationObserver) {
    var obs = new MutationObserver(function (mutations) {
      for (var i = 0; i < mutations.length; i++) {
        var addedNodesSize = mutations[i].addedNodes.length;
        if (addedNodesSize) {
          var addedList = mutations[i].addedNodes;
          for (var j = 0; j < addedNodesSize; j++) {
            callback(addedList[j]);
          }
        }
      }
    });
    obs.observe(element, {
      childList: true,
      subtree: true
    });
  } else if (eventListenerSupported) {
    element.addEventListener('DOMNodeInserted', // No I18N
    function (e) {
      callback(e.target);
    }, false);
  }
}

/**
 * An event listener that can be attached to a click event to protect against
 * reverse tabnabbing. It retrieves the target anchors href, and if the link
 * was intended to open in a new tab or window, the browser's default
 * behavior is canceled. Instead, the destination url is opened using
 * "window.open" from an injected iframe, and the iframe is removed. Except
 * for IE < 11, which uses "window.open" followed by setting the child
 * window's opener to null.
 *
 * @param   {Event}  e              a click event
 *
 * @return  {undefined|Boolean}     Returns false if the link is correctly opened. Else returns nothing.
 */
function clickListener() {
  var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.event;

  // Use global event object for IE8 and below to get target
  // Won't work for IE8 and below for cases when e.srcElement
  // refers not to the anchor, but to the element inside it e.g. an image
  var target = e.currentTarget || e.srcElement;

  // Ignore anchors without an href
  var href = target.getAttribute('href');
  if (!href) {
    href = target.getAttribute('xlink:href');
    if (!href) {
      return;
    }
  }

  // Ignore anchors without an unsafe target or modifier key
  var usedModifier = e.ctrlKey || e.shiftKey || e.metaKey;
  var targetName = target.getAttribute('target');
  var target2 = target.getAttribute('xlink:show');
  if (!usedModifier && (!targetName || safeTarget(targetName)) && !target2) {
    return;
  }
  SecureRedirector.open(href);

  // IE8 and below don't support preventDefault
  if (e.preventDefault) {
    e.preventDefault();
  } else {
    e.returnValue = false;
  }
  return false;
}

/**
 * A cross-browser addEventListener function that adds a listener for the
 * supplied event type to the specified target.
 *
 * @param  {Element}    target     Element to add event listener
 * @param  {String}     type       Type of event
 * @param  {Function}   listener   Listener function to add
 *
 * @return  {undefined|Boolean}     Returns false if the link is correctly opened. Else returns nothing.
 */
function addEventListener(target, type, listener) {
  // Modern browsers
  if (target.addEventListener) {
    return target.addEventListener(type, listener, false);
  }

  // Older browsers
  var onType = 'on' + type; // No I18N
  if (target.attachEvent) {
    target.attachEvent(onType, listener);
  } else if (target[onType]) {
    var prevListener = target[onType];
    target[onType] = function () {
      listener();
      prevListener();
    };
  } else {
    target[onType] = listener;
  }
}

/**
 * Opens the provided url by injecting a hidden iframe that calls
 * window.open(), then removes the iframe from the DOM.
 *
 * @param   {String}  url                URL to open
 * @param   {String}  strWindowName      String specifying the name of the browsing context
 * @param   {String}  strWindowFeatures  String containing a comma-separated list of window features like size and position
 *
 * @return  {Window}                     Reference of the newly opened page
 */
function iframeOpen(url, strWindowName, strWindowFeatures) {
  var iframe = window.document.createElement('iframe');
  iframe.style.display = 'none';
  window.document.body.appendChild(iframe);
  var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;

  var openArgs = '"' + window.encodeURI(url) + '"'; // No I18N
  if (strWindowName) {
    openArgs += ', "' + replaceVulnChars(strWindowName, jsVulnCharMap) + '"'; // No I18N
  }
  if (strWindowFeatures) {
    openArgs += ', "' + replaceVulnChars(strWindowFeatures, jsVulnCharMap) + '"'; // No I18N
  }
  var script = iframeDoc.createElement('script');
  script.type = 'text/javascript';
  script.text = "window.parent = null; window.top = null; window.frameElement = null; var child = window.open(" + openArgs + "); try{ child.opener = null; }catch(e){}";
  iframeDoc.body.appendChild(script);
  var newWin = iframe.contentWindow.child;

  window.document.body.removeChild(iframe);
  return newWin;
}

/**
 * Accepts an element or array of elements which contains elements vulnerable to reverse tabnabbing based
 * phishing attacks and secures them by adding an event listener to help mitigate an attack.
 * It will also monitor the changes(if monitor flag set to true) in the element and
 * adds listeners to the newly added vulnerable elements.
 *
 * @param   {HTMLElement|HTMLElement[]}   target   Element or array of elements to listen for clicks and redirect securely
 * @param   {Boolean}                     monitor  If set to true, monitors the element to add listeners for any newly added children.
 *
 * @return  {undefined}           Doesn't return
 */
function SecureRedirector(target) {
  var monitor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  // For performance, any supplied object with a length attribute is assumed to be an array of elements.
  if (typeof target.length === 'undefined') {
    checkAndAddListener(target);
    if (monitor) {
      elementInsertionListener(target, SecureRedirector);
    }
  } else if (typeof target !== 'string' && !(target instanceof String)) {
    // No I18N
    for (var i = 0; i < target.length; i++) {
      checkAndAddListener(target[i]);
      if (monitor) {
        elementInsertionListener(target, SecureRedirector);
      }
    }
  }
}

/**
 * Accepts the same arguments as window.open. If the strWindowName is not
 * equal to one of the safe targets (_top, _self or _parent), then it opens
 * the destination url using "window.open" from an injected iframe, then
 * removes the iframe. This behavior applies to all browsers except IE < 11,
 * which use "window.open" followed by setting the child window's opener to
 * null. If the strWindowName is set to some other value, the url is simply
 * opened with window.open().
 *
 * @param   {String}  strUrl             URL to open
 * @param   {String}  strWindowName      String specifying the name of the browsing context
 * @param   {String}  strWindowFeatures  String containing a comma-separated list of window features like size and position
 *
 * @return  {Window}                     Reference of the newly opened page
 */
SecureRedirector.open = function (strUrl, strWindowName, strWindowFeatures) {
  if (safeTarget(strWindowName)) {
    return open.apply(window, arguments);
  }
  if (!oldIE && !isChromeAbove72) {
    return iframeOpen(strUrl, strWindowName, strWindowFeatures);
  }
  // Replace child.opener for old IE to avoid appendChild errors
  // We do it for all to avoid having to sniff for specific versions
  // 
  // 
  // The below line is commented because child reference was being returned as null. (Zoho Backstage Issue)
  // arguments[2]='noopener,noreferrer'+(arguments[2] && ','+arguments[2]||'');// No I18N
  var child = open.apply(window, arguments);
  child.opener = null;
  return child;
};

/**
 * Patches window.open() to use blankshield.open() for new window/tab targets.
 */
SecureRedirector.patch = function () {
  window.open = function () {
    return SecureRedirector.open.apply(this, arguments);
  };
};

if (Object.freeze) {
  Object.freeze(SecureRedirector);
}

if (ZWAF$2.version === '7.0.0' && !ZWAF$2.SecureRedirector) {
  ZWAF$2.defineProperty(ZWAF$2, 'SecureRedirector', // No I18N
  SecureRedirector, true, false, false, true);
}
if (!ZWAF$2['7_0_0'].SecureRedirector) {
  ZWAF$2.defineProperty(ZWAF$2['7_0_0'], 'SecureRedirector', // No I18N
  SecureRedirector, true, false, false, true);
}

return ZWAF$2;

})));
