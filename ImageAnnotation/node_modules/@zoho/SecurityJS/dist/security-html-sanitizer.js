(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.ZWAF = factory());
}(this, (function () { 'use strict';

/**
 * Polyfills
 */

/**
 * 
 * It's a wrapper over Object.defineProperty for setting  data descriptors for object .A data descriptor is a property that has a value, which sets isWritable,isConfigurable,isEnumerable for an object. By default all configuration values are false.
 * 
 * Below function will define Object.defineProperty if not defined.
 * Normal property addition through assignment(=) creates properties.
 * But it shows up during property enumeration (for...in loop or Object.keys method), whose values may be changed or deleted.
 * And it may even create some unusual behaviour. The Object.defineProperty method allows
 * three extra details(configurable, writable, and enumerable) to be set for the value.
 * By default all the value are true. Since defineProperty is not supported
 * below IE-9 we have implemented fall back to directly assign value to the object
 *
 * @param   {Object} obj
 * @param   {string} property
 * @param   {value}  value
 * @param   {boolean}  isOverrideDefaultValue
 * @param   {boolean}  isWritable
 * @param   {boolean}  isConfigurable
 * @param   {boolean}  isEnumerable
 * @returns {Object}
 */
/* eslint-disable-next-line max-params */
function defineProperty(obj, property, value, isOverrideDefaultValue, isWritable, isConfigurable, isEnumerable) {
  if (!isOverrideDefaultValue && property in obj) {
    return;
  }
  if (!Object.defineProperty || !function () {
    try {
      Object.defineProperty({}, 'x', {}); // No I18N
      return true;
    } catch (e) {
      return false;
    }
  }()) {
    obj[property] = value;
    return obj;
  }

  isWritable = isWritable === true;
  isConfigurable = isConfigurable === true;
  isEnumerable = isEnumerable === true;
  return Object.defineProperty(obj, property, {
    value: value,
    writable: isWritable,
    configurable: isConfigurable,
    enumerable: isEnumerable
  });
}

/**
 * Defining String.prototype.codePointAt if not defined already
 * This is not supported in IE 11 and below
 */


/**
 * Defining String.fromCodePoint if not defined already
 * Which is not supported in many browsers like IE ,Android ,Opera Mobile
 * */

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Logger = function () {
  function Logger(level) {
    _classCallCheck(this, Logger);

    this.LEVELS = {
      NONE: -1,
      DEBUG: 0,
      INFO: 1,
      WARN: 2,
      ERROR: 3
    };
    if (level === this.LEVELS.NONE || level === this.LEVELS.DEBUG || level === this.LEVELS.INFO || level === this.LEVELS.WARN || level === this.LEVELS.ERROR) {
      this.level = level;
    } else {
      this.level = this.LEVELS.ERROR;
    }
  }

  _createClass(Logger, [{
    key: "debug",
    value: function debug() {
      var _window;

      if (!window || !window.console || this.level === this.LEVELS.NONE || this.level !== this.LEVELS.DEBUG) {
        return;
      }

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      (_window = window["con" + "sole"]).debug.apply(_window, args.concat([performance.now()])); // No I18N
    }
  }, {
    key: "info",
    value: function info() {
      var _window2;

      if (!window || !window.console || this.level === this.LEVELS.NONE || this.level > this.LEVELS.INFO) {
        return;
      }

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      (_window2 = window["con" + "sole"]).log.apply(_window2, args.concat([performance.now()])); // No I18N
    }
  }, {
    key: "warn",
    value: function warn() {
      var _window3;

      if (!window || !window.console || this.level === this.LEVELS.NONE || this.level > this.LEVELS.WARN) {
        return;
      }

      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      (_window3 = window["con" + "sole"]).warn.apply(_window3, args.concat([performance.now()])); // No I18N
    }
  }, {
    key: "error",
    value: function error() {
      var _window4;

      if (!window || !window.console || this.level === this.LEVELS.NONE || this.level > this.LEVELS.ERROR) {
        return;
      }

      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      (_window4 = window["con" + "sole"]).error.apply(_window4, args.concat([performance.now()])); // No I18N
    }
  }]);

  return Logger;
}();

/**
 * @author: Patrick-2626 & Vigneshwar-5036
 *
 * @wiki: https://intranet.wiki.zoho.com/security/client-side-security.html
 *
 * Reference
 *  1)https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/
 *  2)https://github.com/danielstjules/blankshield
 */

var ZWAF$2 = window && window.ZWAF ? window.ZWAF : { version: '7.0.0' };
var logger = new Logger();

if (!ZWAF$2.defineProperty) {
  ZWAF$2.defineProperty = defineProperty;
}

if (!ZWAF$2.logger) {
  ZWAF$2.logger = logger;
}

if (!ZWAF$2['7_0_0']) {
  ZWAF$2['7_0_0'] = {
    version: '7.0.0',
    defineProperty: defineProperty,
    logger: logger
  };
}

/**
 * Display a message in the browser developer console, warning any unwary user.
 *
 * Only a static message is displayed for now. Support for giving API to user to customize message maybe given in future
 * INFO: This warning is linked to a common source (Wikipedia page).
 * This is because our products maybe used for Whitelabel Deployment and we shouldn't display anything specific to Zoho there.
 * So we will maintain this to be common source.
 */

var called = false;
var Console = {
  log: function log() {
    if (!window || !window.console || !window.console.log || !window.navigator || !window.navigator.userAgent || called) {
      return;
    }
    var userAgent = window.navigator.userAgent;

    var browser = userAgent.match(/opera|chrome|safari|firefox|msie|trident(?=\/)/i);
    called = true;
    if (browser && browser[0].search(/trident|msie/i) < 0) {
      // Supported  browser
      window.console.log('%cSTOP!', // No I18N
      'color:red;font-size:xx-large;font-weight:bold;' // No I18N
      );
      window.console.log("%cThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\nSee https://en.wikipedia.org/wiki/Self-XSS for more details", // No I18N
      'font-size:large;' // No I18N
      );
      return;
    }
    // Not supported browser
    window.console.log("STOP!\nThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\nSee https://en.wikipedia.org/wiki/Self-XSS for more details" // No I18N
    );
  }
};

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Custom Functions for Sanitizer
 **/

function objectIterator(obj, func) {
  if (!(obj instanceof Object)) {
    return;
  }
  for (var each in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, each)) {
      func(each, obj[each]);
    }
  }
}

function concatArray(arr1, arr2) {
  var _Array$prototype$spli;

  (_Array$prototype$spli = Array.prototype.splice).call.apply(_Array$prototype$spli, [arr1, arr1.length, 0].concat(_toConsumableArray(arr2)));
}

function toMap(list, key) {
  if (!list || list.constructor === Object) {
    return list;
  }
  var res = {};
  for (var i = 0; i < list.length; i++) {
    var each = list[i];
    res[each[key]] = each;
  }
  return res;
}

function toLowerCaseValue(value) {
  if (value && value.constructor === String) {
    return value.toLowerCase();
  }
  if (value.constructor === Array) {
    for (var i = 0; i < value.length; i++) {
      value[i] = toLowerCaseValue(value[i]);
    }
  }
  return value;
}

function copy(from, to, isDeepCopy, blackList) {
  if (Array.isArray(from)) {
    for (var i = 0, len = from.length; i < len; i++) {
      copyKey(from, to, i, isDeepCopy);
    }
  } else {
    for (var key in from) {
      if (blackList && blackList.indexOf(key) !== -1) {
        continue;
      }
      copyKey(from, to, key, isDeepCopy);
    }
  }
  return to;
}

function copyKey(from, to, key, isDeepCopy) {
  if (!isDeepCopy) {
    to[key] = from[key];
    return;
  }
  var obj = from[key];
  if (Array.isArray(obj)) {
    if (!to[key]) {
      to[key] = [];
    }
    copy(obj, to[key], isDeepCopy);
  } else if (obj instanceof Object) {
    if (!to[key]) {
      to[key] = {};
    }
    copy(obj, to[key], isDeepCopy);
  } else {
    to[key] = obj;
  }
}



/**
 * Cookie handling functions
 **/

function setCookie(name, value) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  options = Object.assign({
    path: '/',
    SameSite: 'lax', // No I18N
    // Default max age is 100 days
    'max-age': 100 * 24 * 60 * 60 * 1000 // No I18N
  }, options);
  if (!encodeURIComponent) {
    return;
  }
  var cookieVal = encodeURIComponent(name) + '=' + encodeURIComponent(value);

  for (var optionKey in options) {
    cookieVal += '; ' + optionKey;
    var optionValue = options[optionKey];
    if (optionValue !== true) {
      cookieVal += '=' + optionValue;
    }
  }
  document.cookie = cookieVal;
}
function deleteCookie(name) {
  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '/';

  setCookie(name, '', {
    path: path,
    'max-age': -1 // No I18N
  });
}

function getCookie(name) {
  name = name + '=';
  var cookieList = document.cookie;
  var res = void 0;
  cookieList.split('; ').forEach(function (cookie) {
    if (res !== undefined) {
      return;
    }
    var cookieValue = void 0;
    try {
      if (decodeURIComponent) {
        cookieValue = decodeURIComponent(cookie);
      }
    } catch (e) {
      cookieValue = cookie;
      ZWAF && ZWAF.logger && ZWAF.logger.warn && ZWAF.logger.warn("Error while trying to decode Cookie value!");
    }
    if (cookieValue.indexOf(name) === 0) {
      res = cookieValue.substring(name.length);
    }
  });
  return res;
}

function hasCookie(name) {
  return !!getCookie(name);
}











// Unused functions
//
// function setArray(arr1, arr2){
//   arr1.splice.apply(arr1,[0,arr1.length].concat(arr2));
// }
//
// function addObjsToSet(set, set2) {
//   for (let each in set2) {
//     if (set2.hasOwnProperty(each)) {
//       set[each] = true;
//     }
//   }
//   return set;
// };
//
// function removeFromSet(set, key) {
//   delete set[key];
//   return set;
// }
//
// /* Add all object keys to array */
// function addToArr(array, set) {
//   let property;
//   for (property in set) {
//     if (set.hasOwnProperty(property)) {
//       array.push(property);
//     }
//   }
//   return array;
// }
//
// /* Add flags to config */
// function addToConfig(set, array) {
//   let l = array.length;
//   while (l--) {
//     set[array[l]] = true;
//   }
//   return set;
// }

if (ZWAF$2.version === '7.0.0' && !ZWAF$2.Console) {
  ZWAF$2.defineProperty(ZWAF$2, 'Console', // No I18N
  Console, true, false, false, true);
}
if (!ZWAF$2['7_0_0'].Console) {
  ZWAF$2.defineProperty(ZWAF$2['7_0_0'], 'Console', // No I18N
  Console, true, false, false, true);
}

var COOKIE_NAMES = ['_zcsr_tmp', // No I18N
'com_chat_owner', // No I18N
'com_avcliq_owner', // No I18N
'wms.agent' // No I18N
];
var loggedInUser = COOKIE_NAMES.some(function (e) {
  return hasCookie(e);
});
if (loggedInUser) {
  ZWAF$2 && ZWAF$2['7_0_0'] && ZWAF$2['7_0_0'].Console && ZWAF$2['7_0_0'].Console.log();
}

/**
 * Identify specific browsers like Chromium-based Ulaa, Brave, Arc
 *
 * These browsers are usually not identifiable through User-Agent Request Header
 * This is because they sometimes prefer to be identified as their parent browser (like Chromium)
 * to ensure webpages work correctly. But it is necessary for us to get accurate stats on browsers
 *
 * Eg: To show users which browser they recently used to log in
 *
 * Browser-specific identification or "duck-typing" is done to identify the browser.
 * If it is not in the list of usually identifiable browsers,
 * then we place this detail in a cookie named "_zwaf_ua".
 * For now, only browser name is added. Based on further needs we can add more info
 * like specific browser version and device type.
 */
var UA_COOKIE_NAME = '_zwaf_ua'; // No I18N

var UAIdentification = {
  /**
   * Called by default when SecurityJS is loaded.
   *
   */
  init: function init() {
    deleteCookie(UA_COOKIE_NAME);

    // Reference:
    // https://github.com/brave/brave-browser/issues/10165#issuecomment-641128278
    // https://github.com/brave/brave-browser/issues/10165#issuecomment-644949774
    var isUlaa = !!window.ulaa;
    var isBrave = navigator && navigator.brave && typeof navigator.brave.isBrave === 'function'; // No I18N
    if (isUlaa) {
      setCookie(UA_COOKIE_NAME, 'Ulaa'); // No I18N
    } else if (isBrave) {
      setCookie(UA_COOKIE_NAME, 'Brave'); // No I18N
    } else {
      // Reference:
      // https://webmasters.stackexchange.com/a/142231
      // Should be done after 1 second timeout after page is loaded.
      window && window.addEventListener('load', // No I18N
      function () {
        window.setTimeout(function () {
          var isArc = window.getComputedStyle(window.document.documentElement).getPropertyValue('--arc-palette-background'); // No I18N
          if (isArc) {
            setCookie(UA_COOKIE_NAME, 'Arc'); // No I18N
          }
        }, 1000);
      });
    }
  },
  disable: function disable() {
    // If any one does not want this cookie to be set, they can call ZWAF.UAIdentification.disable()
    deleteCookie(UA_COOKIE_NAME);
  }
};

if (ZWAF$2.version === '7.0.0' && !ZWAF$2.UAIdentification) {
  ZWAF$2.defineProperty(ZWAF$2, 'UAIdentification', // No I18N
  UAIdentification, true, false, false, true);
}
if (!ZWAF$2['7_0_0'].UAIdentification) {
  ZWAF$2.defineProperty(ZWAF$2['7_0_0'], 'UAIdentification', // No I18N
  UAIdentification, true, false, false, true);
}

ZWAF$2 && ZWAF$2['7_0_0'] && ZWAF$2['7_0_0'].UAIdentification && ZWAF$2['7_0_0'].UAIdentification.init();

function _toConsumableArray$3(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var hasOwnProperty = Object.hasOwnProperty;
var setPrototypeOf = Object.setPrototypeOf;
var isFrozen = Object.isFrozen;
var getPrototypeOf = Object.getPrototypeOf;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var freeze$1 = Object.freeze;
var seal = Object.seal;
var create = Object.create; // eslint-disable-line import/no-mutable-exports

var _ref = typeof Reflect !== 'undefined' && Reflect;
var apply = _ref.apply;
var construct = _ref.construct; // No I18N

if (!apply) {
  apply = function apply(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}

if (!freeze$1) {
  freeze$1 = function freeze(x) {
    return x;
  };
}

if (!seal) {
  seal = function seal(x) {
    return x;
  };
}

if (!construct) {
  construct = function construct(Func, args) {
    return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray$3(args))))();
  };
}

var arrayForEach = unapply(Array.prototype.forEach);
var arrayPop = unapply(Array.prototype.pop);
var arrayPush = unapply(Array.prototype.push);
var stringToLowerCase = unapply(String.prototype.toLowerCase);
var stringToString = unapply(String.prototype.toString);
var stringMatch = unapply(String.prototype.match);
var stringReplace = unapply(String.prototype.replace);
var stringIndexOf = unapply(String.prototype.indexOf);
var stringTrim = unapply(String.prototype.trim);

var regExpTest = unapply(RegExp.prototype.test);

var typeErrorCreate = unconstruct(TypeError);

function numberIsNaN(x) {
  // eslint-disable-next-line unicorn/prefer-number-properties
  return typeof x === 'number' && isNaN(x);
}

function unapply(func) {
  return function (thisArg) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return apply(func, thisArg, args);
  };
}

function unconstruct(func) {
  return function () {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return construct(func, args);
  };
}

/* Add properties to a lookup table */
function addToSet(set, array, transformCaseFunc) {
  transformCaseFunc = transformCaseFunc || stringToLowerCase;
  if (setPrototypeOf) {
    // Make 'in' and truthy checks like Boolean(set.constructor) // No I18N
    // independent of any properties defined on Object.prototype.
    // Prevent prototype setters from intercepting set as a this value.
    setPrototypeOf(set, null);
  }

  var l = array.length;
  while (l--) {
    var element = array[l];
    if (typeof element === 'string') {
      // No I18N
      var lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        // Config presets (e.g. tags.js, attrs.js) are immutable.
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }

        element = lcElement;
      }
    }

    set[element] = true;
  }

  return set;
}

/* Shallow clone an object */
function clone(object) {
  var newObject = create(null);

  var property = void 0;
  for (property in object) {
    if (apply(hasOwnProperty, object, [property]) === true) {
      newObject[property] = object[property];
    }
  }

  return newObject;
}

/* IE10 doesn't support __lookupGetter__ so lets' // No I18N
 * simulate it. It also automatically checks
 * if the prop is function or getter and behaves
 * accordingly. */
function lookupGetter(object, prop) {
  while (object !== null) {
    var desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }

      if (typeof desc.value === 'function') {
        // No I18N
        return unapply(desc.value);
      }
    }

    object = getPrototypeOf(object);
  }

  function fallbackValue(element) {
    // console.warn('fallback value for', element); // No I18N
    return null;
  }

  return fallbackValue;
}

var html = freeze$1(['a', // No I18N
'abbr', // No I18N
'acronym', // No I18N
'address', // No I18N
'area', // No I18N
'article', // No I18N
'aside', // No I18N
'audio', // No I18N
'b', // No I18N
'bdi', // No I18N
'bdo', // No I18N
'big', // No I18N
'blink', // No I18N
'blockquote', // No I18N
'body', // No I18N
'br', // No I18N
'button', // No I18N
'canvas', // No I18N
'caption', // No I18N
'center', // No I18N
'cite', // No I18N
'code', // No I18N
'col', // No I18N
'colgroup', // No I18N
'content', // No I18N
'data', // No I18N
'datalist', // No I18N
'dd', // No I18N
'decorator', // No I18N
'del', // No I18N
'details', // No I18N
'dfn', // No I18N
'dialog', // No I18N
'dir', // No I18N
'div', // No I18N
'dl', // No I18N
'dt', // No I18N
'element', // No I18N
'em', // No I18N
'fieldset', // No I18N
'figcaption', // No I18N
'figure', // No I18N
'font', // No I18N
'footer', // No I18N
'form', // No I18N
'h1', // No I18N
'h2', // No I18N
'h3', // No I18N
'h4', // No I18N
'h5', // No I18N
'h6', // No I18N
'head', // No I18N
'header', // No I18N
'hgroup', // No I18N
'hr', // No I18N
'html', // No I18N
'i', // No I18N
'img', // No I18N
'input', // No I18N
'ins', // No I18N
'kbd', // No I18N
'label', // No I18N
'legend', // No I18N
'li', // No I18N
'main', // No I18N
'map', // No I18N
'mark', // No I18N
'marquee', // No I18N
'menu', // No I18N
'menuitem', // No I18N
'meter', // No I18N
'nav', // No I18N
'nobr', // No I18N
'ol', // No I18N
'optgroup', // No I18N
'option', // No I18N
'output', // No I18N
'p', // No I18N
'picture', // No I18N
'pre', // No I18N
'progress', // No I18N
'q', // No I18N
'rp', // No I18N
'rt', // No I18N
'ruby', // No I18N
's', // No I18N
'samp', // No I18N
'section', // No I18N
'select', // No I18N
'shadow', // No I18N
'small', // No I18N
'source', // No I18N
'spacer', // No I18N
'span', // No I18N
'strike', // No I18N
'strong', // No I18N
'style', // No I18N
'sub', // No I18N
'summary', // No I18N
'sup', // No I18N
'table', // No I18N
'tbody', // No I18N
'td', // No I18N
'template', // No I18N
'textarea', // No I18N
'tfoot', // No I18N
'th', // No I18N
'thead', // No I18N
'time', // No I18N
'tr', // No I18N
'track', // No I18N
'tt', // No I18N
'u', // No I18N
'ul', // No I18N
'var', // No I18N
'video', // No I18N
'wbr' // No I18N
]);

// SVG
var svg = freeze$1(['svg', // No I18N
'a', // No I18N
'altglyph', // No I18N
'altglyphdef', // No I18N
'altglyphitem', // No I18N
'animatecolor', // No I18N
'animatemotion', // No I18N
'animatetransform', // No I18N
'circle', // No I18N
'clippath', // No I18N
'defs', // No I18N
'desc', // No I18N
'ellipse', // No I18N
'filter', // No I18N
'font', // No I18N
'g', // No I18N
'glyph', // No I18N
'glyphref', // No I18N
'hkern', // No I18N
'image', // No I18N
'line', // No I18N
'lineargradient', // No I18N
'marker', // No I18N
'mask', // No I18N
'metadata', // No I18N
'mpath', // No I18N
'path', // No I18N
'pattern', // No I18N
'polygon', // No I18N
'polyline', // No I18N
'radialgradient', // No I18N
'rect', // No I18N
'stop', // No I18N
'style', // No I18N
'switch', // No I18N
'symbol', // No I18N
'text', // No I18N
'textpath', // No I18N
'title', // No I18N
'tref', // No I18N
'tspan', // No I18N
'view', // No I18N
'vkern' // No I18N
]);

var svgFilters = freeze$1(['feBlend', // No I18N
'feColorMatrix', // No I18N
'feComponentTransfer', // No I18N
'feComposite', // No I18N
'feConvolveMatrix', // No I18N
'feDiffuseLighting', // No I18N
'feDisplacementMap', // No I18N
'feDistantLight', // No I18N
'feFlood', // No I18N
'feFuncA', // No I18N
'feFuncB', // No I18N
'feFuncG', // No I18N
'feFuncR', // No I18N
'feGaussianBlur', // No I18N
'feImage', // No I18N
'feMerge', // No I18N
'feMergeNode', // No I18N
'feMorphology', // No I18N
'feOffset', // No I18N
'fePointLight', // No I18N
'feSpecularLighting', // No I18N
'feSpotLight', // No I18N
'feTile', // No I18N
'feTurbulence' // No I18N
]);

// List of SVG elements that are disallowed by default.
// We still need to know them so that we can do namespace
// checks properly in case one wants to add them to
// allow-list.
var svgDisallowed = freeze$1(['animate', // No I18N
'color-profile', // No I18N
'cursor', // No I18N
'discard', // No I18N
'fedropshadow', // No I18N
'font-face', // No I18N
'font-face-format', // No I18N
'font-face-name', // No I18N
'font-face-src', // No I18N
'font-face-uri', // No I18N
'foreignobject', // No I18N
'hatch', // No I18N
'hatchpath', // No I18N
'mesh', // No I18N
'meshgradient', // No I18N
'meshpatch', // No I18N
'meshrow', // No I18N
'missing-glyph', // No I18N
'script', // No I18N
'set', // No I18N
'solidcolor', // No I18N
'unknown', // No I18N
'use' // No I18N
]);

var mathMl = freeze$1(['math', // No I18N
'menclose', // No I18N
'merror', // No I18N
'mfenced', // No I18N
'mfrac', // No I18N
'mglyph', // No I18N
'mi', // No I18N
'mlabeledtr', // No I18N
'mmultiscripts', // No I18N
'mn', // No I18N
'mo', // No I18N
'mover', // No I18N
'mpadded', // No I18N
'mphantom', // No I18N
'mroot', // No I18N
'mrow', // No I18N
'ms', // No I18N
'mspace', // No I18N
'msqrt', // No I18N
'mstyle', // No I18N
'msub', // No I18N
'msup', // No I18N
'msubsup', // No I18N
'mtable', // No I18N
'mtd', // No I18N
'mtext', // No I18N
'mtr', // No I18N
'munder', // No I18N
'munderover' // No I18N
]);

// Similarly to SVG, we want to know all MathML elements,
// even those that we disallow by default.
var mathMlDisallowed = freeze$1(['maction', // No I18N
'maligngroup', // No I18N
'malignmark', // No I18N
'mlongdiv', // No I18N
'mscarries', // No I18N
'mscarry', // No I18N
'msgroup', // No I18N
'mstack', // No I18N
'msline', // No I18N
'msrow', // No I18N
'semantics', // No I18N
'annotation', // No I18N
'annotation-xml', // No I18N
'mprescripts', // No I18N
'none' // No I18N
]);

var text = freeze$1(['#text']); // No I18N

var html$1 = freeze$1(['accept', // No I18N
'action', // No I18N
'align', // No I18N
'alt', // No I18N
'autocapitalize', // No I18N
'autocomplete', // No I18N
'autopictureinpicture', // No I18N
'autoplay', // No I18N
'background', // No I18N
'bgcolor', // No I18N
'border', // No I18N
'capture', // No I18N
'cellpadding', // No I18N
'cellspacing', // No I18N
'checked', // No I18N
'cite', // No I18N
'class', // No I18N
'clear', // No I18N
'color', // No I18N
'cols', // No I18N
'colspan', // No I18N
'controls', // No I18N
'controlslist', // No I18N
'coords', // No I18N
'crossorigin', // No I18N
'datetime', // No I18N
'decoding', // No I18N
'default', // No I18N
'dir', // No I18N
'disabled', // No I18N
'disablepictureinpicture', // No I18N
'disableremoteplayback', // No I18N
'download', // No I18N
'draggable', // No I18N
'enctype', // No I18N
'enterkeyhint', // No I18N
'face', // No I18N
'for', // No I18N
'headers', // No I18N
'height', // No I18N
'hidden', // No I18N
'high', // No I18N
'href', // No I18N
'hreflang', // No I18N
'id', // No I18N
'inputmode', // No I18N
'integrity', // No I18N
'ismap', // No I18N
'kind', // No I18N
'label', // No I18N
'lang', // No I18N
'list', // No I18N
'loading', // No I18N
'loop', // No I18N
'low', // No I18N
'max', // No I18N
'maxlength', // No I18N
'media', // No I18N
'method', // No I18N
'min', // No I18N
'minlength', // No I18N
'multiple', // No I18N
'muted', // No I18N
'name', // No I18N
'nonce', // No I18N
'noshade', // No I18N
'novalidate', // No I18N
'nowrap', // No I18N
'open', // No I18N
'optimum', // No I18N
'pattern', // No I18N
'placeholder', // No I18N
'playsinline', // No I18N
'poster', // No I18N
'preload', // No I18N
'pubdate', // No I18N
'radiogroup', // No I18N
'readonly', // No I18N
'rel', // No I18N
'required', // No I18N
'rev', // No I18N
'reversed', // No I18N
'role', // No I18N
'rows', // No I18N
'rowspan', // No I18N
'spellcheck', // No I18N
'scope', // No I18N
'selected', // No I18N
'shape', // No I18N
'size', // No I18N
'sizes', // No I18N
'span', // No I18N
'srclang', // No I18N
'start', // No I18N
'src', // No I18N
'srcset', // No I18N
'step', // No I18N
'style', // No I18N
'summary', // No I18N
'tabindex', // No I18N
'title', // No I18N
'translate', // No I18N
'type', // No I18N
'usemap', // No I18N
'valign', // No I18N
'value', // No I18N
'width', // No I18N
'xmlns', // No I18N
'slot' // No I18N
]);

var svg$1 = freeze$1(['accent-height', // No I18N
'accumulate', // No I18N
'additive', // No I18N
'alignment-baseline', // No I18N
'ascent', // No I18N
'attributename', // No I18N
'attributetype', // No I18N
'azimuth', // No I18N
'basefrequency', // No I18N
'baseline-shift', // No I18N
'begin', // No I18N
'bias', // No I18N
'by', // No I18N
'class', // No I18N
'clip', // No I18N
'clippathunits', // No I18N
'clip-path', // No I18N
'clip-rule', // No I18N
'color', // No I18N
'color-interpolation', // No I18N
'color-interpolation-filters', // No I18N
'color-profile', // No I18N
'color-rendering', // No I18N
'cx', // No I18N
'cy', // No I18N
'd', // No I18N
'dx', // No I18N
'dy', // No I18N
'diffuseconstant', // No I18N
'direction', // No I18N
'display', // No I18N
'divisor', // No I18N
'dur', // No I18N
'edgemode', // No I18N
'elevation', // No I18N
'end', // No I18N
'fill', // No I18N
'fill-opacity', // No I18N
'fill-rule', // No I18N
'filter', // No I18N
'filterunits', // No I18N
'flood-color', // No I18N
'flood-opacity', // No I18N
'font-family', // No I18N
'font-size', // No I18N
'font-size-adjust', // No I18N
'font-stretch', // No I18N
'font-style', // No I18N
'font-variant', // No I18N
'font-weight', // No I18N
'fx', // No I18N
'fy', // No I18N
'g1', // No I18N
'g2', // No I18N
'glyph-name', // No I18N
'glyphref', // No I18N
'gradientunits', // No I18N
'gradienttransform', // No I18N
'height', // No I18N
'href', // No I18N
'id', // No I18N
'image-rendering', // No I18N
'in', // No I18N
'in2', // No I18N
'k', // No I18N
'k1', // No I18N
'k2', // No I18N
'k3', // No I18N
'k4', // No I18N
'kerning', // No I18N
'keypoints', // No I18N
'keysplines', // No I18N
'keytimes', // No I18N
'lang', // No I18N
'lengthadjust', // No I18N
'letter-spacing', // No I18N
'kernelmatrix', // No I18N
'kernelunitlength', // No I18N
'lighting-color', // No I18N
'local', // No I18N
'marker-end', // No I18N
'marker-mid', // No I18N
'marker-start', // No I18N
'markerheight', // No I18N
'markerunits', // No I18N
'markerwidth', // No I18N
'maskcontentunits', // No I18N
'maskunits', // No I18N
'max', // No I18N
'mask', // No I18N
'media', // No I18N
'method', // No I18N
'mode', // No I18N
'min', // No I18N
'name', // No I18N
'numoctaves', // No I18N
'offset', // No I18N
'operator', // No I18N
'opacity', // No I18N
'order', // No I18N
'orient', // No I18N
'orientation', // No I18N
'origin', // No I18N
'overflow', // No I18N
'paint-order', // No I18N
'path', // No I18N
'pathlength', // No I18N
'patterncontentunits', // No I18N
'patterntransform', // No I18N
'patternunits', // No I18N
'points', // No I18N
'preservealpha', // No I18N
'preserveaspectratio', // No I18N
'primitiveunits', // No I18N
'r', // No I18N
'rx', // No I18N
'ry', // No I18N
'radius', // No I18N
'refx', // No I18N
'refy', // No I18N
'repeatcount', // No I18N
'repeatdur', // No I18N
'restart', // No I18N
'result', // No I18N
'rotate', // No I18N
'scale', // No I18N
'seed', // No I18N
'shape-rendering', // No I18N
'specularconstant', // No I18N
'specularexponent', // No I18N
'spreadmethod', // No I18N
'startoffset', // No I18N
'stddeviation', // No I18N
'stitchtiles', // No I18N
'stop-color', // No I18N
'stop-opacity', // No I18N
'stroke-dasharray', // No I18N
'stroke-dashoffset', // No I18N
'stroke-linecap', // No I18N
'stroke-linejoin', // No I18N
'stroke-miterlimit', // No I18N
'stroke-opacity', // No I18N
'stroke', // No I18N
'stroke-width', // No I18N
'style', // No I18N
'surfacescale', // No I18N
'systemlanguage', // No I18N
'tabindex', // No I18N
'targetx', // No I18N
'targety', // No I18N
'transform', // No I18N
'transform-origin', // No I18N
'text-anchor', // No I18N
'text-decoration', // No I18N
'text-rendering', // No I18N
'textlength', // No I18N
'type', // No I18N
'u1', // No I18N
'u2', // No I18N
'unicode', // No I18N
'values', // No I18N
'viewbox', // No I18N
'visibility', // No I18N
'version', // No I18N
'vert-adv-y', // No I18N
'vert-origin-x', // No I18N
'vert-origin-y', // No I18N
'width', // No I18N
'word-spacing', // No I18N
'wrap', // No I18N
'writing-mode', // No I18N
'xchannelselector', // No I18N
'ychannelselector', // No I18N
'x', // No I18N
'x1', // No I18N
'x2', // No I18N
'xmlns', // No I18N
'y', // No I18N
'y1', // No I18N
'y2', // No I18N
'z', // No I18N
'zoomandpan' // No I18N
]);

var mathMl$1 = freeze$1(['accent', // No I18N
'accentunder', // No I18N
'align', // No I18N
'bevelled', // No I18N
'close', // No I18N
'columnsalign', // No I18N
'columnlines', // No I18N
'columnspan', // No I18N
'denomalign', // No I18N
'depth', // No I18N
'dir', // No I18N
'display', // No I18N
'displaystyle', // No I18N
'encoding', // No I18N
'fence', // No I18N
'frame', // No I18N
'height', // No I18N
'href', // No I18N
'id', // No I18N
'largeop', // No I18N
'length', // No I18N
'linethickness', // No I18N
'lspace', // No I18N
'lquote', // No I18N
'mathbackground', // No I18N
'mathcolor', // No I18N
'mathsize', // No I18N
'mathvariant', // No I18N
'maxsize', // No I18N
'minsize', // No I18N
'movablelimits', // No I18N
'notation', // No I18N
'numalign', // No I18N
'open', // No I18N
'rowalign', // No I18N
'rowlines', // No I18N
'rowspacing', // No I18N
'rowspan', // No I18N
'rspace', // No I18N
'rquote', // No I18N
'scriptlevel', // No I18N
'scriptminsize', // No I18N
'scriptsizemultiplier', // No I18N
'selection', // No I18N
'separator', // No I18N
'separators', // No I18N
'stretchy', // No I18N
'subscriptshift', // No I18N
'supscriptshift', // No I18N
'symmetric', // No I18N
'voffset', // No I18N
'width', // No I18N
'xmlns' // No I18N
]);

var xml = freeze$1(['xlink:href', // No I18N
'xml:id', // No I18N
'xlink:title', // No I18N
'xml:space', // No I18N
'xmlns:xlink' // No I18N
]);

// eslint-disable-next-line unicorn/better-regex
var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
var TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape
var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
);
var DOCTYPE_NAME = seal(/^html$/i);
var CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray$2(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var getGlobal = function getGlobal() {
  return typeof window === 'undefined' ? null : window;
}; // No I18N

/**
 * Creates a no-op policy for internal use only.
 * Don't export this function outside this module!
 * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
 * @param {Document} document The document object (to determine policy name suffix)
 * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
 * are not supported).
 */
var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
  if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || // No I18N
  typeof trustedTypes.createPolicy !== 'function' // No I18N
  ) {
      return null;
    }

  // Allow the callers to control the unique policy name
  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
  // Policy creation with duplicate names throws in Trusted Types.
  var suffix = null;
  var ATTR_NAME = 'data-tt-policy-suffix'; // No I18N
  if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
    suffix = document.currentScript.getAttribute(ATTR_NAME);
  }

  var policyName = 'dompurify' + (suffix ? '#' + suffix : ''); // No I18N

  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML: function createHTML(html$$1) {
        return html$$1;
      },
      createScriptURL: function createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_) {
    // Policy creation failed (most likely another DOMPurify script has
    // already run). Skip creating the policy, as this will only cause errors
    // if TT are enforced.
    // Comment #09
    // console.warn(
    //   'TrustedTypes policy ' + policyName + ' could not be created.' // No I18N
    // );
    return null;
  }
};

function createDOMPurify() {
  var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

  var DOMPurify = function DOMPurify(root) {
    return createDOMPurify(root);
  };

  /**
   * Version label, exposed for easier checks
   * if DOMPurify is up to date or not
   */
  DOMPurify.version = '2.5.4'; // Comment #00 // No I18N

  /**
   * Array of elements that DOMPurify removed during sanitation.
   * Empty if nothing was removed.
   */
  DOMPurify.removed = [];

  if (!window || !window.document || window.document.nodeType !== 9) {
    // Not running in a browser, provide a factory function
    // so that you can pass your own Window
    DOMPurify.isSupported = false;

    return DOMPurify;
  }

  var originalDocument = window.document;

  var document = window.document;
  var DocumentFragment = window.DocumentFragment,
      HTMLTemplateElement = window.HTMLTemplateElement,
      Node = window.Node,
      Element = window.Element,
      NodeFilter = window.NodeFilter,
      _window$NamedNodeMap = window.NamedNodeMap,
      NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
      HTMLFormElement = window.HTMLFormElement,
      DOMParser = window.DOMParser,
      trustedTypes = window.trustedTypes;


  var ElementPrototype = Element.prototype;

  var cloneNode = lookupGetter(ElementPrototype, 'cloneNode'); // No I18N
  var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling'); // No I18N
  var getChildNodes = lookupGetter(ElementPrototype, 'childNodes'); // No I18N
  var getParentNode = lookupGetter(ElementPrototype, 'parentNode'); // No I18N

  // As per issue #47, the web-components registry is inherited by a
  // new document created via createHTMLDocument. As per the spec
  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
  // a new empty registry is used when creating a template contents owner
  // document, so we use that as our parent document to ensure nothing
  // is inherited.
  if (typeof HTMLTemplateElement === 'function') {
    // No I18N
    var template = document.createElement('template'); // No I18N
    if (template.content && template.content.ownerDocument) {
      document = template.content.ownerDocument;
    }
  }

  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
  var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';

  var _document = document,
      implementation = _document.implementation,
      createNodeIterator = _document.createNodeIterator,
      createDocumentFragment = _document.createDocumentFragment,
      getElementsByTagName = _document.getElementsByTagName;
  var importNode = originalDocument.importNode;


  var documentMode = {};
  try {
    documentMode = clone(document).documentMode ? document.documentMode : {};
  } catch (_) {}

  var hooks = {};

  /**
   * Expose whether this browser supports running the full DOMPurify.
   */
  DOMPurify.isSupported = typeof getParentNode === 'function' && // No I18N
  implementation && implementation.createHTMLDocument !== undefined && documentMode !== 9;

  var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,
      ERB_EXPR$$1 = ERB_EXPR,
      TMPLIT_EXPR$$1 = TMPLIT_EXPR,
      DATA_ATTR$$1 = DATA_ATTR,
      ARIA_ATTR$$1 = ARIA_ATTR,
      IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,
      ATTR_WHITESPACE$$1 = ATTR_WHITESPACE,
      CUSTOM_ELEMENT$$1 = CUSTOM_ELEMENT;
  var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;

  /**
   * We consider the elements and attributes below to be safe. Ideally
   * don't add any new ones but feel free to remove unwanted ones.
   */

  /* allowed element names */

  var ALLOWED_TAGS = null;
  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$2(html), _toConsumableArray$2(svg), _toConsumableArray$2(svgFilters), _toConsumableArray$2(mathMl), _toConsumableArray$2(text)));
  var DONT_TRIM = true; // Comment #03

  /* Allowed attribute names */
  var ALLOWED_ATTR = null;
  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$2(html$1), _toConsumableArray$2(svg$1), _toConsumableArray$2(mathMl$1), _toConsumableArray$2(xml)));

  /*
   * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.
   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
   */
  var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));

  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
  var FORBID_TAGS = null;

  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
  var FORBID_ATTR = null;

  /* Decide if ARIA attributes are okay */
  var ALLOW_ARIA_ATTR = true;

  /* Decide if custom data attributes are okay */
  var ALLOW_DATA_ATTR = true;

  /* Decide if unknown protocols are okay */
  var ALLOW_UNKNOWN_PROTOCOLS = false;

  /* Decide if self-closing tags in attributes are allowed.
   * Usually removed due to a mXSS issue in jQuery 3.0 */
  var ALLOW_SELF_CLOSE_IN_ATTR = true;

  /* Output should be safe for common template engines.
   * This means, DOMPurify removes data attributes, mustaches and ERB
   */
  var SAFE_FOR_TEMPLATES = false;

  /* Output should be safe even for XML used within HTML and alike.
   * This means, DOMPurify removes comments when containing risky content.
   */
  var SAFE_FOR_XML = true;

  /* Decide if document with <html>... should be returned */
  var WHOLE_DOCUMENT = false;

  /* Track whether config is already set on this instance of DOMPurify. */
  var SET_CONFIG = false;

  /* Decide if all elements (e.g. style, script) must be children of
   * document.body. By default, browsers might move them to document.head */
  var FORCE_BODY = false;

  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
   * string (or a TrustedHTML object if Trusted Types are supported).
   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
   */
  var RETURN_DOM = false;

  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
   * string  (or a TrustedHTML object if Trusted Types are supported) */
  var RETURN_DOM_FRAGMENT = false;

  /* Try to return a Trusted Type object instead of a string, return a string in
   * case Trusted Types are not supported  */
  var RETURN_TRUSTED_TYPE = false;

  /* Output should be free from DOM clobbering attacks?
   * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
   */
  var SANITIZE_DOM = true;

  /* Achieve full DOM Clobbering protection by isolating the namespace of named
   * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
   *
   * HTML/DOM spec rules that enable DOM Clobbering:
   *   - Named Access on Window (§7.3.3)
   *   - DOM Tree Accessors (§3.1.5)
   *   - Form Element Parent-Child Relations (§4.10.3)
   *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)
   *   - HTMLCollection (§4.2.10.2)
   *
   * Namespace isolation is implemented by prefixing `id` and `name` attributes
   * with a constant string, i.e., `user-content-`
   */
  var SANITIZE_NAMED_PROPS = false;
  var SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';

  /* Keep element content when removing element? */
  var KEEP_CONTENT = true;

  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
   * of importing it into a new Document and returning a sanitized copy */
  var IN_PLACE = false;

  /* Allow usage of profiles like html, svg and mathMl */
  var USE_PROFILES = {};

  /* Tags to ignore content of when KEEP_CONTENT is true */
  var FORBID_CONTENTS = null;
  var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', // No I18N
  'audio', // No I18N
  'colgroup', // No I18N
  'desc', // No I18N
  'foreignobject', // No I18N
  'head', // No I18N
  'iframe', // No I18N
  'math', // No I18N
  'mi', // No I18N
  'mn', // No I18N
  'mo', // No I18N
  'ms', // No I18N
  'mtext', // No I18N
  'noembed', // No I18N
  'noframes', // No I18N
  'noscript', // No I18N
  'plaintext', // No I18N
  'script', // No I18N
  'style', // No I18N
  'svg', // No I18N
  'template', // No I18N
  'thead', // No I18N
  'title', // No I18N
  'video', // No I18N
  'xmp' // No I18N
  ]);

  /* Tags that are safe for data: URIs */
  var DATA_URI_TAGS = null;
  var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', // No I18N
  'video', // No I18N
  'img', // No I18N
  'source', // No I18N
  'image', // No I18N
  'track' // No I18N
  ]);

  /* Attributes safe for values like "javascript:" */ // No I18N
  var URI_SAFE_ATTRIBUTES = null;
  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', // No I18N
  'class', // No I18N
  'for', // No I18N
  'id', // No I18N
  'label', // No I18N
  'name', // No I18N
  'pattern', // No I18N
  'placeholder', // No I18N
  'role', // No I18N
  'summary', // No I18N
  'title', // No I18N
  'value', // No I18N
  'style', // No I18N
  'xmlns' // No I18N
  ]);

  var MATHML_NAMESPACE = 'ht' + 'tp://www.w3.org/1998/Math/MathML'; // No I18N
  var SVG_NAMESPACE = 'ht' + 'tp://www.w3.org/2000/svg'; // No I18N
  var HTML_NAMESPACE = 'ht' + 'tp://www.w3.org/1999/xhtml'; // No I18N
  /* Document namespace */
  var NAMESPACE = HTML_NAMESPACE;
  var IS_EMPTY_INPUT = false;

  /* Allowed XHTML+XML namespaces */
  var ALLOWED_NAMESPACES = null;
  var DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);

  /* Parsing of strict XHTML documents */
  var PARSER_MEDIA_TYPE = void 0;
  var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
  var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
  var transformCaseFunc = void 0;

  /* Keep a reference to config to pass to hooks */
  var CONFIG = null;

  /* Specify the maximum element nesting depth to prevent mXSS */
  var MAX_NESTING_DEPTH = 255;

  /* Ideally, do not touch anything below this line */
  /* ______________________________________________ */

  var formElement = document.createElement('form'); // No I18N

  var isRegexOrFunction = function isRegexOrFunction(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };

  /**
   * _parseConfig
   *
   * @param  {Object} cfg optional config literal
   */
  // eslint-disable-next-line complexity
  var _parseConfig = function _parseConfig(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }

    /* Shield configuration object from tampering */
    if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {
      // No I18N
      cfg = {};
    }

    /* Shield configuration object from prototype pollution */
    cfg = clone(cfg);

    PARSER_MEDIA_TYPE =
    // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;

    // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
    transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;

    /* Set configuration parameters */
    ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg // No I18N
    ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg // No I18N
    ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    ALLOWED_NAMESPACES = 'ALLOWED_NAMESPACES' in cfg // No I18N
    ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
    URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg // No I18N
    ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), // eslint-disable-line indent
    cfg.ADD_URI_SAFE_ATTR, // eslint-disable-line indent
    transformCaseFunc // eslint-disable-line indent
    ) // eslint-disable-line indent
    : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg // No I18N
    ? addToSet(clone(DEFAULT_DATA_URI_TAGS), // eslint-disable-line indent
    cfg.ADD_DATA_URI_TAGS, // eslint-disable-line indent
    transformCaseFunc // eslint-disable-line indent
    ) // eslint-disable-line indent
    : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {}; // No I18N
    FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {}; // No I18N
    USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
    SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
    RETURN_DOM = cfg.RETURN_DOM || false; // Default false
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
    DONT_TRIM = cfg.DONT_TRIM !== false; // Default true // Comment #03
    FORCE_BODY = cfg.FORCE_BODY || false; // Default false
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
    IN_PLACE = cfg.IN_PLACE || false; // Default false
    IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }

    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }

    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }

    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }

    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }

    /* Parse profile info */
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$2(text)));
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html);
        addToSet(ALLOWED_ATTR, html$1);
      }

      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg);
        addToSet(ALLOWED_ATTR, svg$1);
        addToSet(ALLOWED_ATTR, xml);
      }

      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg$1);
        addToSet(ALLOWED_ATTR, xml);
      }

      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl);
        addToSet(ALLOWED_ATTR, mathMl$1);
        addToSet(ALLOWED_ATTR, xml);
      }
    }

    /* Merge configuration parameters */
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }

      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }

    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }

      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }

    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }

    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }

      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }

    /* Add #text in case KEEP_CONTENT is set to true */
    if (KEEP_CONTENT) {
      ALLOWED_TAGS['#text'] = true; // No I18N
    }

    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']); // No I18N
    }

    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ['tbody']); // No I18N
      delete FORBID_TAGS.tbody;
    }

    // Prevent further manipulation of configuration.
    // Not available in IE8, Safari 5, etc.
    if (freeze$1) {
      freeze$1(cfg);
    }

    CONFIG = cfg;
  };

  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', // No I18N
  'mo', // No I18N
  'mn', // No I18N
  'ms', // No I18N
  'mtext' // No I18N
  ]);

  var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', // No I18N
  'annotation-xml' // No I18N
  ]);

  // Certain elements are allowed in both SVG and HTML
  // namespace. We need to specify them explicitly
  // so that they don't get erroneously deleted from
  // HTML namespace.
  var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', // No I18N
  'style', // No I18N
  'font', // No I18N
  'a', // No I18N
  'script' // No I18N
  ]);

  /* Keep track of all possible SVG and MathML tags
   * so that we can perform the namespace checks
   * correctly. */
  var ALL_SVG_TAGS = addToSet({}, svg);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);

  var ALL_MATHML_TAGS = addToSet({}, mathMl);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);

  /**
   *
   *
   * @param  {Element} element a DOM element whose namespace is being checked
   * @returns {boolean} Return false if the element has a
   *  namespace that a spec-compliant parser would never
   *  return. Return true otherwise.
   */
  var _checkValidNamespace = function _checkValidNamespace(element) {
    var parent = getParentNode(element);

    // In JSDOM, if we're inside shadow DOM, then parentNode
    // can be null. We just simulate parent in this case.
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: NAMESPACE,
        tagName: 'template' // No I18N
      };
    }

    var tagName = stringToLowerCase(element.tagName);
    var parentTagName = stringToLowerCase(parent.tagName);

    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
      return false;
    }

    if (element.namespaceURI === SVG_NAMESPACE) {
      // The only way to switch from HTML namespace to SVG
      // is via <svg>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'svg'; // No I18N
      }

      // The only way to switch from MathML to SVG is via`
      // svg if parent is either <annotation-xml> or MathML
      // text integration points.
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === 'svg' && ( // No I18N
        parentTagName === 'annotation-xml' || // No I18N
        MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }

      // We only allow elements that are defined in SVG
      // spec. All others are disallowed in SVG namespace.
      return Boolean(ALL_SVG_TAGS[tagName]);
    }

    if (element.namespaceURI === MATHML_NAMESPACE) {
      // The only way to switch from HTML namespace to MathML
      // is via <math>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'math'; // No I18N
      }

      // The only way to switch from SVG to MathML is via
      // <math> and HTML integration points
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName]; // No I18N
      }

      // We only allow elements that are defined in MathML
      // spec. All others are disallowed in MathML namespace.
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }

    if (element.namespaceURI === HTML_NAMESPACE) {
      // The only way to switch from SVG to HTML is via
      // HTML integration points, and from MathML to HTML
      // is via MathML text integration points
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }

      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }

      // We disallow tags that are specific for MathML
      // or SVG and should never appear in HTML namespace
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }

    // For XHTML and XML documents that support custom namespaces
    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {
      return true;
    }

    // The code should never reach this place (this means
    // that the element somehow got namespace that is not
    // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).
    // Return false just in case.
    return false;
  };

  /**
   * _forceRemove
   *
   * @param  {Node} node a DOM node
   */
  var _forceRemove = function _forceRemove(node) {
    arrayPush(DOMPurify.removed, { element: node });
    try {
      // eslint-disable-next-line unicorn/prefer-dom-node-remove
      node.parentNode.removeChild(node);
    } catch (_) {
      try {
        node.outerHTML = emptyHTML;
      } catch (_) {
        node.remove();
      }
    }
  };

  /**
   * _removeAttribute
   *
   * @param  {String} name an Attribute name
   * @param  {Node} node a DOM node
   */
  var _removeAttribute = function _removeAttribute(name, node) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node.getAttributeNode(name),
        from: node
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node
      });
    }

    node.removeAttribute(name);

    // We void attribute values for unremovable "is"" attributes // No I18N
    if (name === 'is' && !ALLOWED_ATTR[name]) {
      // No I18N
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node);
        } catch (_) {}
      } else {
        try {
          node.setAttribute(name, '');
        } catch (_) {}
      }
    }
  };

  /**
   * _initDocument
   *
   * @param  {String} dirty a string of dirty markup
   * @return {Document} a DOM, filled with the dirty markup
   */
  var _initDocument = function _initDocument(dirty) {
    /* Create a HTML document */
    var doc = void 0;
    var leadingWhitespace = void 0;

    if (FORCE_BODY) {
      dirty = '<remove></remove>' + dirty; // No I18N
    } else {
      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
      var matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }

    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {
      // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
    }

    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    /*
     * Use the DOMParser API by default, fallback later if needs be
     * DOMParser not work for svg when has multiple root element.
     */
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_) {}
    }

    /* Use createHTMLDocument in case DOMParser is not available */
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, 'template', null); // No I18N
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
      } catch (_) {
        // Syntax error if dirtyPayload is invalid xml
      }
    }

    var body = doc.body || doc.documentElement;

    if (dirty && leadingWhitespace) {
      body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }

    /* Work on whole document or just its body */
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body' // No I18N
      )[0];
    }

    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };

  /**
   * _createIterator
   *
   * @param  {Document} root document/fragment to create iterator for
   * @return {Iterator} iterator instance
   */
  var _createIterator = function _createIterator(root) {
    return createNodeIterator.call(root.ownerDocument || root, root,
    // eslint-disable-next-line no-bitwise
    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null, false);
  };

  /**
   * _isClobbered
   *
   * @param  {Node} elm element to check for clobbering attacks
   * @return {Boolean} true if clobbered, false if safe
   */
  var _isClobbered = function _isClobbered(elm) {
    return elm instanceof HTMLFormElement && (typeof elm.__depth !== 'undefined' && typeof elm.__depth !== 'number' || typeof elm.__removalCount !== 'undefined' && typeof elm.__removalCount !== 'number' || typeof elm.nodeName !== 'string' || // No I18N
    typeof elm.textContent !== 'string' || // No I18N
    typeof elm.removeChild !== 'function' || // No I18N
    !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || // No I18N
    typeof elm.setAttribute !== 'function' || // No I18N
    typeof elm.namespaceURI !== 'string' || // No I18N
    typeof elm.insertBefore !== 'function' || // No I18N
    typeof elm.hasChildNodes !== 'function') // No I18N
    ;
  };

  /**
   * _isNode
   *
   * @param  {Node} obj object to check whether it's a DOM node
   * @return {Boolean} true is object is a DOM node
   */
  var _isNode = function _isNode(object) {
    return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' // No I18N
    ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && // No I18N
    typeof object.nodeType === 'number' && // No I18N
    typeof object.nodeName === 'string'; // No I18N
  };

  /**
   * _executeHook
   * Execute user configurable hooks
   *
   * @param  {String} entryPoint  Name of the hook's entry point
   * @param  {Node} currentNode node to work on with the hook
   * @param  {Object} data additional hook parameters
   */
  var _executeHook = function _executeHook(entryPoint, currentNode, data) {
    if (!hooks[entryPoint]) {
      return;
    }

    arrayForEach(hooks[entryPoint], function (hook) {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  };

  /**
   * _sanitizeElements
   *
   * @protect nodeName
   * @protect textContent
   * @protect removeChild
   *
   * @param   {Node} currentNode to check for permission to exist
   * @return  {Boolean} true if node was killed, false if left alive
   */
  var _sanitizeElements = function _sanitizeElements(currentNode) {
    var content = void 0;

    /* Execute a hook if present */
    _executeHook('beforeSanitizeElements', currentNode, null); // No I18N

    /* Check if element is clobbered or can clobber */
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Check if tagname contains Unicode */
    if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Now let's check the element's type and name */ // No I18N
    var tagName = transformCaseFunc(currentNode.nodeName);

    /* Execute a hook if present */
    _executeHook('uponSanitizeElement', currentNode, { // No I18N
      tagName: tagName,
      allowedTags: ALLOWED_TAGS
    });

    /* Detect mXSS attempts abusing namespace confusion */
    if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Mitigate a problem with templates inside select */
    if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Remove any ocurrence of processing instructions */
    if (currentNode.nodeType === 7) {
      _forceRemove(currentNode);
      return true;
    }

    /* Remove any kind of possibly harmful comments */
    if (SAFE_FOR_XML && currentNode.nodeType === 8 && regExpTest(/<[/\w]/g, currentNode.data)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Remove element if anything forbids its presence */
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      /* Check if we have a custom element to handle */
      if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;
      }

      /* Keep content except for bad-listed elements */
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        var parentNode = getParentNode(currentNode) || currentNode.parentNode;
        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

        if (childNodes && parentNode) {
          var childCount = childNodes.length;

          for (var i = childCount - 1; i >= 0; --i) {
            var childClone = cloneNode(childNodes[i], true);
            childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
            parentNode.insertBefore(childClone, getNextSibling(currentNode));
          }
        }
      }

      _forceRemove(currentNode);
      return true;
    }

    /* Check whether element has a valid namespace */
    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Make sure that older browsers don't get fallback-tag mXSS */
    if ((tagName === 'noscript' || // No I18N
    tagName === 'noembed' || // No I18N
    tagName === 'noframes') && // No I18N
    regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Sanitize element content to be template-safe */
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      /* Get the element's text content */
      content = currentNode.textContent;
      content = stringReplace(content, MUSTACHE_EXPR$$1, ' '); // No I18N
      content = stringReplace(content, ERB_EXPR$$1, ' '); // No I18N
      content = stringReplace(content, TMPLIT_EXPR$$1, ' '); // No I18N
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
        currentNode.textContent = content;
      }
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeElements', currentNode, null); // No I18N

    return false;
  };

  /**
   * _isValidAttribute
   *
   * @param  {string} lcTag Lowercase tag name of containing element.
   * @param  {string} lcName Lowercase attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid, otherwise false.
   */
  // eslint-disable-next-line complexity
  var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
    /* Make sure attribute cannot clobber */
    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && ( // No I18N
    value in document || value in formElement || value === '__depth' || // No I18N
    value === '__removalCount') // No I18N
    ) {
        return false;
      }

    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) {
      // This attribute is safe
       // Comment #08
    } else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) {
      // This attribute is safe
      /* Otherwise, check the name is permitted */
       // Comment #08
    } else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
      // First condition does a very basic check if a) it's basically a valid custom element tagname AND
      // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
      // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
      _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) ||
      // Alternative, second condition checks if it's an `is`-attribute, AND
      // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
      lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) {
        // If user has supplied a regexp or function in CUSTOM_ELEMENT_HANDLING.tagNameCheck, we need to also allow derived custom elements using the same tagName test.
        // Additionally, we need to allow attributes passing the CUSTOM_ELEMENT_HANDLING.attributeNameCheck user has configured, as custom elements can define these at their own discretion.
         // Comment #08
      } else {
        return false;
      }
      /* Check value is safe. First, is attr inert? If so, is safe */
    } else if (URI_SAFE_ATTRIBUTES[lcName]) {
      // This attribute is safe
      /* Check no script, data or unknown possibly unsafe URI
        unless we know URI values are safe for that attribute */
       // Comment #08
    } else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) {
      // This attribute is safe
      /* Keep image data URIs alive if src/xlink:href is allowed */
      /* Further prevent gadget XSS for dynamically built script tags */
       // Comment #08
    } else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && // No I18N
    lcTag !== 'script' && // No I18N
    stringIndexOf(value, 'data:') === 0 && // No I18N
    DATA_URI_TAGS[lcTag]) {
      // This attribute is safe
      /* Allow unknown protocols: This provides support for links that
        are handled by protocol handlers which may be unknown ahead of
        time, e.g. fb:, spotify: */
       // Comment #08
    } else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) {
      // This attribute is safe
      /* Check for binary attributes */
      // eslint-disable-next-line no-negated-condition
       // Comment #08
    } else if (value) {
      return false;
    } else {
      // Binary attributes are safe at this point
      /* Anything else, presume unsafe, do not add it back */
       // Comment #08
    }

    return true;
  };

  /**
   * _basicCustomElementCheck
   * checks if at least one dash is included in tagName, and it's not the first char
   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
   * @param {string} tagName name of the tag of the node to sanitize
   */
  var _basicCustomElementTest = function _basicCustomElementTest(tagName) {
    return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT$$1);
  };

  /**
   * _sanitizeAttributes
   *
   * @protect attributes
   * @protect nodeName
   * @protect removeAttribute
   * @protect setAttribute
   *
   * @param  {Node} currentNode to sanitize
   * @return {Boolean} Returns true if the entire element needs to be removed, otherwise false. // Comment #04
   */
  var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
    var attr = void 0;
    var value = void 0;
    var lcName = void 0;
    var l = void 0;
    /* Execute a hook if present */
    _executeHook('beforeSanitizeAttributes', currentNode, null); // No I18N

    var attributes = currentNode.attributes;

    /* Check if we have attributes; if not we might have a text node */

    if (!attributes) {
      return false; // Comment #04
    }

    var hookEvent = {
      attrName: '',
      attrValue: '',
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR,
      nodeName: currentNode.nodeName.toLowerCase() // Comment #04
    };
    l = attributes.length;

    /* Go backwards over all attributes; safely remove bad ones */
    while (l--) {
      attr = attributes[l];
      var _attr = attr,
          name = _attr.name,
          namespaceURI = _attr.namespaceURI;

      value = name === 'value' ? attr.value : stringTrim(attr.value);
      if (DONT_TRIM) {
        value = attr.value;
      } // Comment #03
      lcName = transformCaseFunc(name);

      /* Execute a hook if present */
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.keepElement = true; // Comment #04
      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
      _executeHook('uponSanitizeAttribute', currentNode, hookEvent); // No I18N
      if (!hookEvent.keepElement) {
        return true;
      } // Comment #04
      value = hookEvent.attrValue;
      /* Did the hooks approve of the attribute? */
      if (hookEvent.forceKeepAttr) {
        continue;
      }

      /* Remove attribute */
      _removeAttribute(name, currentNode);

      /* Did the hooks approve of the attribute? */
      if (!hookEvent.keepAttr) {
        continue;
      }

      /* Work around a security issue in jQuery 3.0 */
      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }

      /* Work around a security issue with comments inside attributes */
      if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }

      /* Sanitize attribute content to be template-safe */
      if (SAFE_FOR_TEMPLATES) {
        value = stringReplace(value, MUSTACHE_EXPR$$1, ' '); // No I18N
        value = stringReplace(value, ERB_EXPR$$1, ' '); // No I18N
        value = stringReplace(value, TMPLIT_EXPR$$1, ' '); // No I18N
      }

      /* Is `value` valid for this attribute? */
      var lcTag = currentNode.nodeName.toLowerCase();
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }

      /* Full DOM Clobbering protection via namespace isolation,
       * Prefix id and name attributes with `user-content-`
       */
      if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
        // Remove the attribute with this value
        _removeAttribute(name, currentNode);

        // Prefix the value and later re-create the attribute with the sanitized value
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }

      /* Handle attributes that require Trusted Types */
      if (trustedTypesPolicy && (typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) === 'object' && typeof trustedTypes.getAttributeType === 'function') {
        if (namespaceURI) {
          /* Namespaces are not yet supported, see https://bugs.chromium.org/p/chromium/issues/detail?id=1305293 */
        } else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case 'TrustedHTML':
              {
                value = trustedTypesPolicy.createHTML(value);
                break;
              }

            case 'TrustedScriptURL':
              {
                value = trustedTypesPolicy.createScriptURL(value);
                break;
              }

            default:
              {
                break;
              }
          }
        }
      }

      /* Handle invalid data-* attribute set by try-catching it */
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */ // No I18N
          currentNode.setAttribute(name, value);
        }

        if (_isClobbered(currentNode)) {
          _forceRemove(currentNode);
        } else {
          arrayPop(DOMPurify.removed);
        }
      } catch (_) {}
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeAttributes', currentNode, null); // No I18N
    return false; // Comment #04
  };

  /**
   * _sanitizeShadowDOM
   *
   * @param  {DocumentFragment} fragment to iterate over recursively
   */
  var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
    var shadowNode = void 0;
    var shadowIterator = _createIterator(fragment);

    /* Execute a hook if present */
    _executeHook('beforeSanitizeShadowDOM', fragment, null); // No I18N

    while (shadowNode = shadowIterator.nextNode()) {
      /* Execute a hook if present */
      _executeHook('uponSanitizeShadowNode', shadowNode, null); // No I18N

      /* Sanitize tags and elements */
      if (_sanitizeElements(shadowNode)) {
        continue;
      }

      var parentNode = getParentNode(shadowNode);

      /* Set the nesting depth of an element */
      if (shadowNode.nodeType === 1) {
        if (parentNode && parentNode.__depth) {
          /*
            We want the depth of the node in the original tree, which can
            change when it's removed from its parent.
          */
          shadowNode.__depth = (shadowNode.__removalCount || 0) + parentNode.__depth + 1;
        } else {
          shadowNode.__depth = 1;
        }
      }

      /*
       * Remove an element if nested too deeply to avoid mXSS
       * or if the __depth might have been tampered with
       */
      if (shadowNode.__depth >= MAX_NESTING_DEPTH || numberIsNaN(shadowNode.__depth)) {
        _forceRemove(shadowNode);
      }

      /* Deep shadow DOM detected */
      if (shadowNode.content instanceof DocumentFragment) {
        shadowNode.content.__depth = shadowNode.__depth;
        _sanitizeShadowDOM(shadowNode.content);
      }

      /* Check attributes, sanitize if necessary */
      if (_sanitizeAttributes(shadowNode)) {
        _forceRemove(shadowNode);
      } // Comment #04
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeShadowDOM', fragment, null); // No I18N
  };

  /**
   * Sanitize
   * Public method providing core sanitation functionality
   *
   * @param {String|Node} dirty string or DOM node
   * @param {Object} configuration object
   */
  // eslint-disable-next-line complexity
  DOMPurify.sanitize = function (dirty) {
    var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var body = void 0;
    var importedNode = void 0;
    var currentNode = void 0;
    var oldNode = void 0;
    var returnNode = void 0;
    /* Make sure we have a string to sanitize.
      DO NOT return early, as this will return the wrong type if
      the user has requested a DOM object rather than a string */
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = '<!-->'; // No I18N
    }

    /* Stringify, in case dirty is an object */
    if (typeof dirty !== 'string' && !_isNode(dirty)) {
      // No I18N
      if (typeof dirty.toString === 'function') {
        // No I18N
        dirty = dirty.toString();
        if (typeof dirty !== 'string') {
          // No I18N
          throw typeErrorCreate('dirty is not a string, aborting'); // No I18N
        }
      } else {
        throw typeErrorCreate('toString is not a function'); // No I18N
      }
    }

    /* Check we can run. Otherwise fall back or ignore */
    if (!DOMPurify.isSupported) {
      if (_typeof(window.toStaticHTML) === 'object' || // No I18N
      typeof window.toStaticHTML === 'function' // No I18N
      ) {
          if (typeof dirty === 'string') {
            // No I18N
            return window.toStaticHTML(dirty);
          }

          if (_isNode(dirty)) {
            return window.toStaticHTML(dirty.outerHTML);
          }
        }

      return dirty;
    }

    /* Assign config vars */
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }

    /* Clean up removed elements */
    DOMPurify.removed = [];

    /* Check if dirty is correctly typed for IN_PLACE */
    if (typeof dirty === 'string') {
      // No I18N
      IN_PLACE = false;
    }

    if (IN_PLACE) {
      /* Do some early pre-sanitization to avoid unsafe root nodes */
      if (dirty.nodeName) {
        var tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
        }
      }
    } else if (dirty instanceof Node) {
      /* If dirty is a DOM element, append to an empty document to avoid
         elements being stripped by the parser */
      body = _initDocument('<!---->'); // No I18N
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
        // No I18N
        /* Node is already a body, use as is */
        body = importedNode;
      } else if (importedNode.nodeName === 'HTML') {
        // No I18N
        body = importedNode;
      } else {
        // eslint-disable-next-line unicorn/prefer-dom-node-append
        body.appendChild(importedNode);
      }
    } else {
      /* Exit directly if we have nothing to do */
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
      // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf('<') === -1 // No I18N
      ) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }

      /* Initialize the document to work on */
      body = _initDocument(dirty);

      /* Check we have a DOM node from the data */
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
      }
    }

    /* Remove first element node (ours) if FORCE_BODY is set */
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }

    /* Get node iterator */
    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);

    /* Now start iterating over the created document */
    while (currentNode = nodeIterator.nextNode()) {
      /* Fix IE's strange behavior with manipulated textNodes #89 */
      if (currentNode.nodeType === 3 && currentNode === oldNode) {
        continue;
      }

      /* Sanitize tags and elements */
      if (_sanitizeElements(currentNode)) {
        continue;
      }

      var parentNode = getParentNode(currentNode);

      /* Set the nesting depth of an element */
      if (currentNode.nodeType === 1) {
        if (parentNode && parentNode.__depth) {
          /*
            We want the depth of the node in the original tree, which can
            change when it's removed from its parent.
          */
          currentNode.__depth = (currentNode.__removalCount || 0) + parentNode.__depth + 1;
        } else {
          currentNode.__depth = 1;
        }
      }

      /*
       * Remove an element if nested too deeply to avoid mXSS
       * or if the __depth might have been tampered with
       */
      if (currentNode.__depth >= MAX_NESTING_DEPTH || numberIsNaN(currentNode.__depth)) {
        _forceRemove(currentNode);
      }

      /* Shadow DOM detected, sanitize it */
      if (currentNode.content instanceof DocumentFragment) {
        currentNode.content.__depth = currentNode.__depth;
        _sanitizeShadowDOM(currentNode.content);
      }

      /* Check attributes, sanitize if necessary */
      if (_sanitizeAttributes(currentNode)) {
        _forceRemove(currentNode);continue;
      } // Comment #04

      oldNode = currentNode;
    }

    oldNode = null;

    /* If we sanitized `dirty` in-place, return it. */
    if (IN_PLACE) {
      return dirty;
    }

    /* Return sanitized string or DOM */
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);

        while (body.firstChild) {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }

      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmod) {
        /*
          AdoptNode() is not used because internal state is not reset
          (e.g. the past names map of a HTMLFormElement), this is safe
          in theory but we would rather not risk another attack vector.
          The state that is cloned by importNode() is explicitly defined
          by the specs.
        */
        returnNode = importNode.call(originalDocument, returnNode, true);
      }

      return returnNode;
    }

    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;

    /* Serialize doctype if allowed */
    if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
    }

    /* Sanitize final string template-safe */
    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' '); // No I18N
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' '); // No I18N
      serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR$$1, ' '); // No I18N
    }

    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };

  /**
   * Public method to set the configuration once
   * setConfig
   *
   * @param {Object} cfg configuration object
   */
  DOMPurify.setConfig = function (cfg) {
    _parseConfig(cfg);
    SET_CONFIG = true;
  };

  /**
   * Public method to remove the configuration
   * clearConfig
   *
   */
  DOMPurify.clearConfig = function () {
    CONFIG = null;
    SET_CONFIG = false;
  };

  /**
   * Public method to check if an attribute value is valid.
   * Uses last set config, if any. Otherwise, uses config defaults.
   * isValidAttribute
   *
   * @param  {string} tag Tag name of containing element.
   * @param  {string} attr Attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
   */
  DOMPurify.isValidAttribute = function (tag, attr, value) {
    /* Initialize shared config vars if necessary. */
    if (!CONFIG) {
      _parseConfig({});
    }

    var lcTag = stringToLowerCase(tag);
    var lcName = stringToLowerCase(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };

  /**
   * AddHook
   * Public method to add DOMPurify hooks
   *
   * @param {String} entryPoint entry point for the hook to add
   * @param {Function} hookFunction function to execute
   */
  DOMPurify.addHook = function (entryPoint, hookFunction) {
    if (typeof hookFunction !== 'function') {
      // No I18N
      return;
    }

    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };

  /**
   * RemoveHook
   * Public method to remove a DOMPurify hook at a given entryPoint
   * (pops it from the stack of hooks if more are present)
   *
   * @param {String} entryPoint entry point for the hook to remove
   * @return {Function} removed(popped) hook
   */
  DOMPurify.removeHook = function (entryPoint) {
    if (hooks[entryPoint]) {
      return arrayPop(hooks[entryPoint]);
    }
  };

  /**
   * RemoveHooks
   * Public method to remove all DOMPurify hooks at a given entryPoint
   *
   * @param  {String} entryPoint entry point for the hooks to remove
   */
  DOMPurify.removeHooks = function (entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };

  /**
   * RemoveAllHooks
   * Public method to remove all DOMPurify hooks
   *
   */
  DOMPurify.removeAllHooks = function () {
    hooks = {};
  };

  return DOMPurify;
}

var createDOMPurify$1 = createDOMPurify();

/*
  Comment #00:
  Changing Version of DOMPurify

  Comment #03:
  Preserve the spaces in attribute values based on DONT_TRIM flag in config

  Comment #04:
  Added support to remove an Element based on attribute validation rule if ACTION = Remove Element

  Comment #08:
  Prevent empty block code-check issues

  Comment #09:
  Prevent console warning
 */

var seal$1 = Object.seal || function (x) {
  return x;
};

var REPLACEMENT_REGEX = seal$1(/\$\{[A-Z._]+?\}/i); // Specify Replacement detection regex for Attribute validation which replaces existing value

function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var freeze = Object.freeze;

/**
 * Factory Function to create new instances of HTMLPurifier
 *
 * @param   {Object}  config     Configuration to create the sanitizer instance
 * @param   {Object}  DOMPurify  DOMPurify instance which we use to create our Sanitizer Instance
 *
 * @return  {Object}             A fresh copy of HTMLPurifier.
 */

function factory(config, DOMPurify) {
  var GLOBAL_TAGS_ = 'GLOBAL_TAGS'; // No I18N
  var GLOBAL_ATTR_ = 'GLOBAL_ATTR'; // No I18N
  var GLOBAL_ATTRIBUTES_ = 'GLOBAL_ATTRIBUTES'; // No I18N // Comment #001
  var FORBID_TAGS_ = 'FORBID_TAGS'; // No I18N
  var FORBID_ATTR_ = 'FORBID_ATTR'; // No I18N
  var TAG_RULES_ = 'TAG_RULES'; // No I18N
  var STYLE_RULES_ = 'STYLE_RULES'; // No I18N
  var GLOBAL_ATTR_RULES_ = 'GLOBAL_ATTR_RULES'; // No I18N
  var GLOBAL_APPEND_ATTR_ = 'GLOBAL_APPEND_ATTR'; // No I18N
  var ADD_DATA_URI_TAGS_ = 'ADD_DATA_URI_TAGS'; // No I18N
  var ADD_URI_SAFE_ATTR_ = 'ADD_URI_SAFE_ATTR'; // No I18N

  var EXTENDS_ = 'EXTENDS'; // No I18N
  var REMOVE_ONEVENTS_ = 'REMOVE_ONEVENTS'; // No I18N

  var defaultForbiddenTags = ['script']; // No I18N
  var defaultForbiddenAttr = [];

  var runtimeConfigFlags = ['ALLOW_ARIA_ATTR', // No I18N
  'ALLOW_DATA_ATTR', // No I18N
  'ALLOW_UNKNOWN_PROTOCOLS', // No I18N
  'SAFE_FOR_TEMPLATES', // No I18N
  'WHOLE_DOCUMENT', // No I18N
  'RETURN_DOM', // No I18N
  'RETURN_DOM_FRAGMENT', // No I18N
  'IN_PLACE', // No I18N
  'DONT_TRIM', // No I18N
  'FORCE_BODY', // No I18N
  'SANITIZE_DOM', // No I18N
  'KEEP_CONTENT', // No I18N
  'ALLOWED_URI_REGEXP'];

  var nonExtendableConfigFlags = [];
  concatArray(nonExtendableConfigFlags, runtimeConfigFlags);
  concatArray(nonExtendableConfigFlags, [EXTENDS_, REMOVE_ONEVENTS_, 'ALLOWED_STYLE' // No I18N
  ]);

  var defaultTagRules = {
    iframe: {
      ATTR_RULES: {
        sandbox: {
          FALLBACK_VALUE: 'allow-popups allow-forms allow-scripts allow-same-origin', // No I18N
          CONDITIONS: [{
            NOT_CONTAINS: ['allow-top-navigation', // No I18N
            'allow-popups-to-escape-sandbox' // No I18N
            ]
          }]
        }
      },
      APPEND_ATTR: {
        sandbox: {
          APPEND_ATTR_VALUE: 'allow-popups allow-forms allow-scripts allow-same-origin' // No I18N
        }
      }
    },
    embed: {
      ATTR_RULES: {
        type: {
          CONDITIONS: [{
            EQUAL: 'application/pdf', // No I18N
            FALLBACK_VALUE: 'application/pdf' // No I18N
          }]
        }
      },
      APPEND_ATTR: {
        type: {
          APPEND_ATTR_VALUE: 'application/pdf' // No I18N
        },
        typemustmatch: {
          APPEND_ATTR_VALUE: 'true' // No I18N
        }
      }
    },
    object: {
      ATTR_RULES: {
        type: {
          CONDITIONS: [{
            EQUAL: 'application/pdf', // No I18N
            FALLBACK_VALUE: 'application/pdf' // No I18N
          }]
        }
      },
      APPEND_ATTR: {
        type: {
          APPEND_ATTR_VALUE: 'application/pdf' // No I18N
        },
        typemustmatch: {
          APPEND_ATTR_VALUE: 'true' // No I18N
        }
      }
    }
  };

  var altered = void 0;
  var tagRuleMap = void 0;
  var appendAttrMap = void 0;
  var GLOBAL_TAGS = config.GLOBAL_TAGS,
      GLOBAL_ATTR = config.GLOBAL_ATTR,
      FORBID_TAGS = config.FORBID_TAGS,
      FORBID_ATTR = config.FORBID_ATTR,
      TAG_RULES = config.TAG_RULES,
      STYLE_RULES = config.STYLE_RULES,
      GLOBAL_ATTR_RULES = config.GLOBAL_ATTR_RULES,
      GLOBAL_APPEND_ATTR = config.GLOBAL_APPEND_ATTR,
      TAG_SPECIFIC_ATTRS = config.TAG_SPECIFIC_ATTRS;
  var FORBID_PROPS = STYLE_RULES.FORBID_PROPS,
      FORBID_CSSRULES = STYLE_RULES.FORBID_CSSRULES,
      UNSAFE_PROP_RULES = STYLE_RULES.UNSAFE_PROP_RULES;


  var isStyleRulesPresent = FORBID_PROPS && FORBID_PROPS.length !== 0 || FORBID_CSSRULES && FORBID_CSSRULES.length !== 0;
  if (!isStyleRulesPresent) {
    objectIterator(UNSAFE_PROP_RULES, function () {
      isStyleRulesPresent = true;
    });
  }

  /**
   * Validate the Configuration given by the user when creating a new sanitizer instance. This attaches any missing, but required, flags/params.
   *
   * @param   {Object}  userConfig  User-given configuration object
   *
   * @return  {Object}              Valid/Complete configuration object
   */
  // eslint-disable-next-line complexity
  function validateUserConfig(userConfig) {
    if (!userConfig || userConfig.constructor !== Object) {
      // If no user configuration object is supplied, create a configuration with the default values
      userConfig = {};
      copy(config, userConfig, true);
      return userConfig;
    }
    /*
     * We tried to encode template content using the below 4 lines.
     * But it lead to double encoding issue because the value is inserted
     * using textContent but it is returned using innerHTML/outerHTML
     *
     * We do not have a solution to this issue as of now, so dropping support for this
     *
     * CODE:
     * value = value.replace(/\{\{/g,'&#x7b;&#x7b;'); // No I18N
     * value = value.replace(/\}\}/g,'&#x7d;&#x7d;'); // No I18N
     * value = value.replace(/<%/g,'&lt;&#x25;'); // No I18N
     * value = value.replace(/%>/g,'&#x25;&gt;'); // No I18N
     *
     */

    // Extending any configurations that may have been missed out
    if (!userConfig[TAG_RULES_]) {
      userConfig[TAG_RULES_] = {};
    }
    if (!userConfig[GLOBAL_ATTR_RULES_]) {
      userConfig[GLOBAL_ATTR_RULES_] = {};
    }
    if (!userConfig[GLOBAL_APPEND_ATTR_]) {
      userConfig[GLOBAL_APPEND_ATTR_] = {};
    }
    if (!userConfig[ADD_DATA_URI_TAGS_]) {
      userConfig[ADD_DATA_URI_TAGS_] = [];
    }
    if (!userConfig[ADD_URI_SAFE_ATTR_]) {
      userConfig[ADD_URI_SAFE_ATTR_] = [];
    }
    if (!userConfig[GLOBAL_TAGS_]) {
      userConfig[GLOBAL_TAGS_] = [];
    }
    if (!userConfig[GLOBAL_ATTR_]) {
      userConfig[GLOBAL_ATTR_] = [];
    }
    if (!userConfig[GLOBAL_ATTRIBUTES_]) {
      // Comment #001
      userConfig[GLOBAL_ATTRIBUTES_] = []; // Comment #001
    } // Comment #001
    if (!userConfig[FORBID_TAGS_]) {
      userConfig[FORBID_TAGS_] = [];
    }
    if (!userConfig[FORBID_ATTR_]) {
      userConfig[FORBID_ATTR_] = [];
    }
    if (!userConfig[STYLE_RULES_]) {
      userConfig[STYLE_RULES_] = {};
    }
    if (!userConfig[STYLE_RULES_].FORBID_CSSRULES) {
      userConfig[STYLE_RULES_].FORBID_CSSRULES = [];
    }
    if (!userConfig[STYLE_RULES_].FORBID_PROPS) {
      userConfig[STYLE_RULES_].FORBID_PROPS = [];
    }
    if (!userConfig[STYLE_RULES_].UNSAFE_PROP_RULES) {
      userConfig[STYLE_RULES_].UNSAFE_PROP_RULES = {};
    }

    // If we are extending from a parent, we need to reform the list of tag specific attributes. 
    userConfig.TAG_SPECIFIC_ATTRS = {};

    for (var i = 0; i < nonExtendableConfigFlags.length; i++) {
      var eachFlag = nonExtendableConfigFlags[i];
      if (userConfig[eachFlag] === undefined) {
        userConfig[eachFlag] = config[eachFlag];
      }
    }

    userConfig[TAG_RULES_] = toMap(userConfig[TAG_RULES_], 'NAME'); // No I18N
    userConfig[GLOBAL_ATTR_RULES_] = toMap(userConfig[GLOBAL_ATTR_RULES_], 'ATTR_NAME' // No I18N
    );
    userConfig[GLOBAL_APPEND_ATTR_] = toMap(userConfig[GLOBAL_APPEND_ATTR_], 'APPEND_ATTR_NAME' // No I18N
    );

    var _userConfig = userConfig,
        NEW_TAG_RULES = _userConfig.TAG_RULES,
        NEW_TAG_SPECIFIC_ATTRS = _userConfig.TAG_SPECIFIC_ATTRS,
        NEW_STYLE_RULES = _userConfig.STYLE_RULES,
        NEW_GLOBAL_ATTR = _userConfig.GLOBAL_ATTR,
        NEW_GLOBAL_ATTRIBUTES = _userConfig.GLOBAL_ATTRIBUTES,
        NEW_GLOBAL_ATTR_RULES = _userConfig.GLOBAL_ATTR_RULES,
        NEW_GLOBAL_APPEND_ATTR = _userConfig.GLOBAL_APPEND_ATTR,
        EXTENDS = _userConfig.EXTENDS;
    var NEW_FORBID_CSSRULES = NEW_STYLE_RULES.FORBID_CSSRULES,
        NEW_FORBID_PROPS = NEW_STYLE_RULES.FORBID_PROPS,
        NEW_UNSAFE_PROP_RULES = NEW_STYLE_RULES.UNSAFE_PROP_RULES;


    objectIterator(NEW_GLOBAL_APPEND_ATTR, function (key, value) {
      normalizeCase(value);
    });
    objectIterator(NEW_GLOBAL_ATTR_RULES, function (key, value) {
      normalizeCase(value);
    });

    var _loop = function _loop(_i) {
      var eachExtendConfig = EXTENDS[_i];
      switch (eachExtendConfig) {
        case GLOBAL_ATTR_:
          {
            var tempGlobalAttr = [];
            concatArray(tempGlobalAttr, GLOBAL_ATTR);
            objectIterator(TAG_SPECIFIC_ATTRS, function (attrName) {
              var index = tempGlobalAttr.indexOf(attrName);
              if (index > -1) {
                tempGlobalAttr.splice(index, 1);
              }
            });
            concatArray(NEW_GLOBAL_ATTR, NEW_GLOBAL_ATTRIBUTES); // Comment #001
            concatArray(NEW_GLOBAL_ATTR, tempGlobalAttr);
            break;
          }
        case GLOBAL_TAGS_:
        case FORBID_TAGS_:
        case FORBID_ATTR_:
        case ADD_DATA_URI_TAGS_:
        case ADD_URI_SAFE_ATTR_:
          concatArray(userConfig[eachExtendConfig], config[eachExtendConfig]);
          break;
        case TAG_RULES_:
          extendTagRules(NEW_TAG_RULES, TAG_RULES);
          break;
        case GLOBAL_APPEND_ATTR_:
        case GLOBAL_ATTR_RULES_:
          objectIterator(config[eachExtendConfig], function (attrName) {
            if (userConfig[eachExtendConfig][attrName]) {
              return;
            }
            userConfig[eachExtendConfig][attrName] = {};
            copy(config[eachExtendConfig][attrName], userConfig[eachExtendConfig][attrName], true);
          });
          break;
        // case GLOBAL_ATTR_RULES_:
        //   objectIterator(GLOBAL_ATTR_RULES, attrName => {
        //     if (NEW_GLOBAL_ATTR_RULES[attrName]) {
        //       return;
        //     }
        //     NEW_GLOBAL_ATTR_RULES[attrName] = {};
        //     copy(
        //       GLOBAL_ATTR_RULES[attrName],
        //       NEW_GLOBAL_ATTR_RULES[attrName],
        //       true
        //     );
        //   });
        //   break;
        // case GLOBAL_APPEND_ATTR_:
        //   objectIterator(GLOBAL_APPEND_ATTR, attrName => {
        //     if (NEW_GLOBAL_APPEND_ATTR[attrName]) {
        //       return;
        //     }
        //     NEW_GLOBAL_APPEND_ATTR[attrName] = {};
        //     copy(
        //       GLOBAL_APPEND_ATTR[attrName],
        //       NEW_GLOBAL_APPEND_ATTR[attrName],
        //       true
        //     );
        //   });
        //   break;
        case STYLE_RULES_:
          NEW_FORBID_PROPS.push.apply(NEW_FORBID_PROPS, _toConsumableArray$1(FORBID_PROPS));
          NEW_FORBID_CSSRULES.push.apply(NEW_FORBID_CSSRULES, _toConsumableArray$1(FORBID_CSSRULES));
          objectIterator(UNSAFE_PROP_RULES, function (propName) {
            if (NEW_UNSAFE_PROP_RULES[propName]) {
              return;
            }
            NEW_UNSAFE_PROP_RULES[propName] = {};
            copy(UNSAFE_PROP_RULES[propName], NEW_UNSAFE_PROP_RULES[propName], true);
          });
          break;
        default:
          break;
      }
    };

    for (var _i = 0; _i < EXTENDS.length; _i++) {
      _loop(_i);
    }

    // This is to add all attributes in GLOBAL_ATTR_RULES to NEW_GLOBAL_ATTR list if not already present.
    objectIterator(NEW_GLOBAL_ATTR_RULES, function (attrName) {
      if (NEW_GLOBAL_ATTR.indexOf(attrName) !== -1) {
        return;
      }
      NEW_GLOBAL_ATTR.push(attrName);
      // This is to note attribute which are given in GLOBAL_ATTR_RULES but not added in GLOBAL_ATTR
      // They need to be specifically noted down and removed before extending to another sanitizer instance
      if (!NEW_TAG_SPECIFIC_ATTRS[attrName] || NEW_TAG_SPECIFIC_ATTRS[attrName].constructor !== Array) {
        NEW_TAG_SPECIFIC_ATTRS[attrName] = [];
      }
      if (NEW_TAG_SPECIFIC_ATTRS[attrName].indexOf('*') === -1) {
        // No I18N
        NEW_TAG_SPECIFIC_ATTRS[attrName].push('*'); // No I18N
      }
    });

    objectIterator(NEW_TAG_RULES, function (tagName, tagRule) {
      tagName = toLowerCaseValue(tagName);

      if (!tagRule.APPEND_ATTR) {
        tagRule.APPEND_ATTR = {};
      }
      tagRule.APPEND_ATTR = toMap(tagRule.APPEND_ATTR, 'APPEND_ATTR_NAME'); // No I18N
      objectIterator(tagRule.APPEND_ATTR, function (key, value) {
        normalizeCase(value);
      });

      if (!tagRule.ATTR_RULES) {
        tagRule.ATTR_RULES = {};
      }
      tagRule.ATTR_RULES = toMap(tagRule.ATTR_RULES, 'ATTR_NAME'); // No I18N
      // The below loop is to add all attributes in Tag Rules to NEW_GLOBAL_ATTR list and a attribute-specific tag list
      objectIterator(tagRule.ATTR_RULES, function (attrName, attrRule) {
        normalizeCase(attrRule);
        attrName = toLowerCaseValue(attrName);
        if (NEW_GLOBAL_ATTR.indexOf(attrName) === -1 || NEW_TAG_SPECIFIC_ATTRS[attrName] && NEW_TAG_SPECIFIC_ATTRS[attrName].length > 0) {
          if (NEW_GLOBAL_ATTR.indexOf(attrName) === -1) {
            NEW_GLOBAL_ATTR.push(attrName);
          }
          if (!NEW_TAG_SPECIFIC_ATTRS[attrName] || NEW_TAG_SPECIFIC_ATTRS[attrName].constructor !== Array) {
            NEW_TAG_SPECIFIC_ATTRS[attrName] = [];
          }
          if (NEW_TAG_SPECIFIC_ATTRS[attrName].indexOf(tagName) === -1) {
            NEW_TAG_SPECIFIC_ATTRS[attrName].push(tagName);
          }
        }
      });
    });

    // Comment #002
    delete userConfig.USE_PROFILES;

    return userConfig;
  }

  /**
   * Parse any additional configurations passed while calling HTMLPurifier.sanitize
   * Merges the base configuration and runtime configuration
   *
   * @param   {Object}  runtimeConfig  User-given configuration at HTMLPurifier.sanitize
   *
   * @return  {Object}                 Valid/Complete configuration object
   */
  function parseConfig(runtimeConfig) {
    if (!runtimeConfig || runtimeConfig.constructor !== Object) {
      return config;
    }
    var customConfig = {};
    objectIterator(config, function (each, value) {
      if (each in runtimeConfig && runtimeConfigFlags.indexOf(each) !== -1 && (runtimeConfig[each] === true || runtimeConfig[each] === false || runtimeConfig[each] && runtimeConfig[each].constructor === RegExp)) {
        customConfig[each] = runtimeConfig[each];
        return;
      }
      customConfig[each] = value;
    });
    if (customConfig.SAFE_FOR_TEMPLATES) {
      customConfig.ALLOW_DATA_ATTR = false;
    }
    if (customConfig.RETURN_DOM_FRAGMENT) {
      customConfig.RETURN_DOM = true;
    }
    if (customConfig.KEEP_CONTENT) {
      customConfig.GLOBAL_TAGS.push('#text'); // No I18N
    }
    // Remove ADD_TAGS and ADD_ATTR from the runtime config
    // We are just making sure it's not passed to DOMPurify by deleting it explicitly.
    if (customConfig.ADD_TAGS) {
      delete customConfig.ADD_TAGS;
    }
    if (customConfig.ADD_ATTR) {
      delete customConfig.ADD_ATTR;
    }
    return customConfig;
  }

  /**
   * Sets all the necessary DOMPurify Hooks based on the sanitizer configuration
   */
  function setDOMPurifyHooks() {
    var ALLOWED_STYLE = config.ALLOWED_STYLE;

    // Clears any existing Hooks

    DOMPurify.removeAllHooks();
    altered = false;

    // Hooks for Style Validation
    // Default stance is to not allow any styles
    if (FORBID_TAGS.indexOf('style') === -1) {
      // No I18N
      FORBID_TAGS.push('style'); // No I18N
    }
    if (FORBID_ATTR.indexOf('style') === -1) {
      // No I18N
      FORBID_ATTR.push('style'); // No I18N
    }
    if (ALLOWED_STYLE === 'INLINE' || ALLOWED_STYLE === 'ALL') {
      // No I18N
      // Remove 'style' from FORBID_ATTR array and add it to GLOBAL_ATTR 
      // if (FORBID_ATTR.indexOf('style') !== -1) { // No I18N
      FORBID_ATTR.splice(FORBID_ATTR.indexOf('style'), 1); // No I18N
      // }
      if (GLOBAL_ATTR.indexOf('style') === -1) {
        // No I18N
        GLOBAL_ATTR.push('style'); // No I18N
      }
      if (isStyleRulesPresent) {
        // Hook to enforce CSS attribute sanitization
        DOMPurify.addHook('uponSanitizeAttribute', function (node, hookEvent) {
          // No I18N
          if (hookEvent.attrName !== 'style') {
            // No I18N
            return;
          }
          // Hack fix for baseURI + CSS problems in Chrome
          if (!node.ownerDocument.baseURI) {
            var _window = window,
                document = _window.document;

            var base = document.createElement('base'); // No I18N
            base.href = document.baseURI;
            node.ownerDocument.head.appendChild(base);
          }
          // Check all style attribute values and validate them
          // if (node.hasAttribute('style')) {  
          altered = false;
          validateStyles(node.style);

          var output = node.style.cssText;
          if (output.length === 0) {
            hookEvent.keepAttr = false;
            return;
          }
          hookEvent.attrValue = altered ? output : node.getAttribute('style'); // No I18N
        });
      }
    }
    if (ALLOWED_STYLE === 'INTERNAL' || ALLOWED_STYLE === 'ALL') {
      // No I18N
      // Remove 'style' from FORBID_TAGS array and add it to GLOBAL_TAGS 
      FORBID_TAGS.splice(FORBID_TAGS.indexOf('style'), 1); // No I18N
      if (GLOBAL_TAGS.indexOf('style') === -1) {
        // No I18N
        GLOBAL_TAGS.push('style'); // No I18N
      }
      if (isStyleRulesPresent) {
        // Hook to enforce CSS Element sanitization
        DOMPurify.addHook('uponSanitizeElement', function (node, data) {
          // No I18N
          if (data.tagName !== 'style' || node.sheet === null) {
            // No I18N
            return;
          }
          var styleSheet = node.sheet.cssRules;
          altered = false;
          validateStyleSheet(styleSheet, node.sheet);
          if (!altered) {
            return;
          }
          var output = [];
          copyValidatedStyleSheet(output, styleSheet);
          node.textContent = output.join('\n'); // No I18N
        });
      }
    }

    // Hook to set 'GLOBAL_ATTR_RULES' rules 
    if (GLOBAL_ATTR_RULES || TAG_RULES) {
      tagRuleMap = {};
      // First, copy all ATTR_RULES from default rules.
      objectIterator(defaultTagRules, function (nodeName, tagRule) {
        tagRuleMap[nodeName] = {};
        objectIterator(tagRule.ATTR_RULES, function (attrName, attrRule) {
          return tagRuleMap[nodeName][attrName] = attrRule;
        });
      });

      // Second, overwrite any ATTR_RULE if a rule is present for the same attribute in GLOBAL_ATTR_RULES
      objectIterator(tagRuleMap, function (nodeName, tagRule) {
        objectIterator(GLOBAL_ATTR_RULES, function (attrName, attrRule) {
          return tagRuleMap[nodeName][attrName] = attrRule;
        });
      });

      // Third, TAG_RULES have the highest precedence and they will overwrite any existing ATTR_RULE
      objectIterator(TAG_RULES, function (nodeName, tagRule) {
        if (!tagRuleMap[nodeName]) {
          tagRuleMap[nodeName] = {};
        }
        objectIterator(tagRule.ATTR_RULES, function (attrName, attrRule) {
          return tagRuleMap[nodeName][attrName] = attrRule;
        });
      });

      DOMPurify.addHook('uponSanitizeAttribute', function (node, hookEvent) {
        // No I18N
        var attrRule = tagRuleMap[hookEvent.nodeName] && tagRuleMap[hookEvent.nodeName][hookEvent.attrName] || GLOBAL_ATTR_RULES && GLOBAL_ATTR_RULES[hookEvent.attrName];

        if (!attrRule) {
          return;
        }

        var _validateAttributeRul = validateAttributeRule(node, attrRule, hookEvent.attrName),
            isValid = _validateAttributeRul.isValid,
            rule = _validateAttributeRul.rule;

        if (rule && rule.FORCE_KEEP_ATTR) {
          hookEvent.forceKeepAttr = true;
        }
        // The value of isValid will be a boolean by this point
        if (!isValid) {
          handleFailedAttributeValidation(node, rule, hookEvent);
        }
      });
    }

    // Hook to set 'GLOBAL_APPEND_ATTR' rules  
    if (GLOBAL_APPEND_ATTR || TAG_RULES) {
      appendAttrMap = {};
      // The order or precedence is as below:
      // 
      // Tag Rule > Global Rule for Element > Default Rule for Element
      // 
      // If there is a validation rule in the tag rule for this attribute, we choose it. 
      // Else if there is a global validation rule for this attribute, we choose it. 
      // Finally, we check if there is a default rule for this attribute and choose it.

      // First, copy all APPEND_RULES from default rules.
      objectIterator(defaultTagRules, function (nodeName, tagRule) {
        appendAttrMap[nodeName] = {};
        objectIterator(tagRule.APPEND_ATTR, function (attrName, attrRule) {
          return appendAttrMap[nodeName][attrName] = attrRule;
        });
      });

      // Second, overwrite any APPEND_RULE if a rule is present for the same attribute in GLOBAL_APPEND_ATTR
      objectIterator(appendAttrMap, function (nodeName, tagRule) {
        objectIterator(GLOBAL_ATTR_RULES, function (attrName, attrRule) {
          return appendAttrMap[nodeName][attrName] = attrRule;
        });
      });

      // Third, TAG_RULES have the highest precedence and they will overwrite any existing APPEND_RULE
      objectIterator(TAG_RULES, function (nodeName, tagRule) {
        if (!appendAttrMap[nodeName]) {
          appendAttrMap[nodeName] = {};
        }
        objectIterator(tagRule.APPEND_ATTR, function (attrName, attrRule) {
          return appendAttrMap[nodeName][attrName] = attrRule;
        });
      });

      DOMPurify.addHook('afterSanitizeAttributes', function (node) {
        // No I18N
        var name = node.nodeName.toLowerCase();
        var appendConfig = {};

        objectIterator(GLOBAL_APPEND_ATTR, function (attrName, appendAttrRule) {
          return appendConfig[attrName] = appendAttrRule;
        });
        objectIterator(appendAttrMap[name], function (attrName, appendAttrRule) {
          return appendConfig[attrName] = appendAttrRule;
        });

        appendAttributes(node, appendConfig);
      });
    }

    // Hook to remove all 'on' events 
    if (config[REMOVE_ONEVENTS_]) {
      DOMPurify.addHook('uponSanitizeAttribute', function (node, hookEvent) {
        // No I18N
        if (hookEvent.attrName.indexOf('on') === 0) {
          // No I18N
          hookEvent.keepAttr = false;
        }
      });
    }

    // Hook to remove tag-specific attributes which occur in tags other than those mentioned
    if (TAG_SPECIFIC_ATTRS) {
      DOMPurify.addHook('uponSanitizeAttribute', function (node, hookEvent) {
        // No I18N
        if (TAG_SPECIFIC_ATTRS[hookEvent.attrName] && TAG_SPECIFIC_ATTRS[hookEvent.attrName].indexOf(hookEvent.nodeName) === -1 && TAG_SPECIFIC_ATTRS[hookEvent.attrName].indexOf('*') === -1 // No I18N
        ) {
            hookEvent.keepAttr = false;
          }
      });
    }
  }

  /**
   * Core attribute validation logic
   * All condition must be satisfied to return true (AND condition)
   *
   * @param   {Object}   node               Node which has the attribute
   * @param   {[type]}   attrName           Name of attribute to validate
   * @param   {Object}   condition          Condition to validate the attribute
   *
   * @return  {Boolean}               Given condition is valid or not
   */
  function validateAttribute(node, attrName, condition) {
    var mandatory = condition.IS_MANDATORY !== false;

    if (attrName && !node.hasAttribute(attrName.toLowerCase())) {
      // Forbidden has a higher priority than mandatory check
      return condition.IS_FORBIDDEN || !mandatory;
    }
    if (condition.IS_FORBIDDEN) {
      return false;
    }

    var value = node.getAttribute(attrName.toLowerCase());
    if (value === undefined || value === null) {
      value = '';
    }
    return isValidAttributeValue(value, condition, attrName);
  }

  function isValidAttributeValue(value, condition, name) {
    if (value.constructor === String) {
      var caseSensitive = condition.CASE_SENSITIVE || false;
      if (!caseSensitive) {
        value = value.toLowerCase();
      }
      if (!condition.DONT_TRIM) {
        value = value.trim();
      }

      if (condition.MAX_LENGTH && value.length > condition.MAX_LENGTH) {
        return false;
      }
      if (condition.MIN_LENGTH && value.length < condition.MIN_LENGTH) {
        return false;
      }
      if (condition.REGEX && condition.REGEX.constructor === RegExp && value.search(condition.REGEX) === -1) {
        return false;
      }
      if (condition.REGEX && condition.REGEX.constructor === String) {
        var regex = new RegExp(condition.REGEX);
        if (value.search(condition.REGEX) === -1) {
          return false;
        }
      }
      if (condition.REGEX && condition.REGEX.constructor === Array) {
        for (var i = 0; i < condition.REGEX.length; i++) {
          if (value.search(condition.REGEX[i]) === -1) {
            return false;
          }
        }
      }

      if (condition.VALIDATOR && condition.VALIDATOR.HANDLER) {
        if (!condition.VALIDATOR.HANDLER(value, condition.VALIDATOR.CONFIG, name)) {
          return false;
        }
      }

      if (condition.STARTS_WITH !== undefined && value.indexOf(condition.STARTS_WITH) !== 0) {
        return false;
      }
      if (condition.ENDS_WITH !== undefined && value.lastIndexOf(condition.ENDS_WITH) !== value.length - condition.ENDS_WITH.length) {
        return false;
      }
      if (condition.CONTAINS && condition.CONTAINS.constructor === String && value.indexOf(condition.CONTAINS) === -1) {
        return false;
      }
      if (condition.CONTAINS && condition.CONTAINS.constructor === Array) {
        for (var _i2 = 0; _i2 < condition.CONTAINS.length; _i2++) {
          if (value.indexOf(condition.CONTAINS[_i2]) === -1) {
            return false;
          }
        }
      }
      if (condition.NOT_CONTAINS && condition.NOT_CONTAINS.constructor === String && value.indexOf(condition.NOT_CONTAINS) > -1) {
        return false;
      }
      if (condition.NOT_CONTAINS && condition.NOT_CONTAINS.constructor === Array) {
        for (var _i3 = 0; _i3 < condition.NOT_CONTAINS.length; _i3++) {
          if (value.indexOf(condition.NOT_CONTAINS[_i3]) > -1) {
            return false;
          }
        }
      }
      // eslint-disable-next-line eqeqeq
      if (condition.EQUAL !== undefined && value != condition.EQUAL) {
        // === check is avoided as condition value might also be number
        return false;
      }
      // eslint-disable-next-line eqeqeq
      if (condition.NOT_EQUAL !== undefined && value == condition.NOT_EQUAL) {
        // === check is avoided as condition value might also be number
        return false;
      }
    }
    if (condition.LIST && condition.LIST.indexOf(value) === -1) {
      return false;
    }
    if (condition.TYPE === 'INTEGER' || condition.TYPE === 'FLOAT') {
      // No I18N
      var tempValue = void 0;
      try {
        tempValue = condition.TYPE === 'INTEGER' // No I18N
        ? window.parseInt(value, 10) : window.parseFloat(value);
      } catch (e) {
        return false;
      }
      if (window.isNaN(tempValue)) {
        return false;
      }
      if (condition.GREATER_THAN !== undefined && tempValue <= condition.GREATER_THAN) {
        return false;
      }
      if (condition.GREATER_THAN_OR_EQUAL !== undefined && tempValue < condition.GREATER_THAN_OR_EQUAL) {
        return false;
      }
      if (condition.LESSER_THAN !== undefined && tempValue >= condition.LESSER_THAN) {
        return false;
      }
      if (condition.LESSER_THAN_OR_EQUAL !== undefined && tempValue > condition.LESSER_THAN_OR_EQUAL) {
        return false;
      }
      if (condition.EQUAL !== undefined && tempValue !== condition.EQUAL) {
        return false;
      }
      if (condition.NOT_EQUAL !== undefined && tempValue === condition.NOT_EQUAL) {
        return false;
      }
    }
    return true;
  }

  /**
   * Append an attribute to the DOM Element Node based on the given conditions
   * This is called through DOMPurify Hooks whenever append attribute rules are found
   * (like GLOBAL_APPEND_ATTR and TAG_RULES)
   *
   * @param   {Node}    node              DOM Element Node
   * @param   {Object}  appendConfig      Conditions to validate before adding the attribute
   */
  function appendAttributes(node, appendConfig) {
    objectIterator(appendConfig, function (attrName, attrRule) {
      if (node.hasAttribute(attrName.toLowerCase())) {
        return;
      }
      if (!attrRule.SIBLING_CONDITIONS || attrRule.SIBLING_CONDITIONS.length == 0) {
        node.setAttribute(attrName, attrRule.APPEND_ATTR_VALUE);
        return;
      }
      for (var i = 0; i < attrRule.SIBLING_CONDITIONS.length; i++) {
        var _validateAttributeRul2 = validateAttributeRule(node, attrRule.SIBLING_CONDITIONS[i]),
            isValid = _validateAttributeRul2.isValid,
            rule = _validateAttributeRul2.rule;

        if (!isValid) {
          continue;
        }
        var value = rule.APPEND_ATTR_VALUE !== undefined ? rule.APPEND_ATTR_VALUE : attrRule.APPEND_ATTR_VALUE;
        node.setAttribute(attrName, value);
        return;
      }
    });
  }

  /**
   * Validate an attribute in a given node based on validation conditions
   * This is called through DOMPurify Hooks whenever attribute validation rules are found
   * (like GLOBAL_ATTR_RULES and TAG_RULES)
   *
   * @param   {Node}    node            DOM Element Node
   * @param   {Object}  rule        Conditions to validate the given node and attribute
   * @param   {Object}  attrName        Name of attribute to validate
   *
   * @return  {Object}                  Returns 2 keys:
   *                                    1.isValid: True if attribute is valid. Else returns false.
   *                                    2.rule: The final rule it matched with
   */
  function validateAttributeRule(node, rule, attrName) {
    var isValid = true;
    if (!rule || !rule.CONDITIONS || rule.CONDITIONS.length === 0) {
      return { isValid: isValid, rule: rule };
    }
    attrName = rule.ATTR_NAME || attrName;

    for (var i = 0; i < rule.CONDITIONS.length; i++) {
      var eachCondition = rule.CONDITIONS[i];
      isValid = validateAttribute(node, attrName, eachCondition);
      if (eachCondition.NEGATION) {
        isValid = !isValid;
      }
      if (!isValid) {
        continue;
      }
      if (eachCondition.NEXT) {
        return validateAttributeRule(node, eachCondition.NEXT, attrName);
      }
      break;
    }
    return { isValid: isValid, rule: rule };
  }

  function handleFailedAttributeValidation(node, attrRule, hookEvent) {
    if (attrRule.ACTION === "REMOVE_ELEMENT") {
      hookEvent.keepElement = false;
      return;
    }
    // Default Action will be 'REMOVE_ATTRIBUTE' if no FALLBACK_VALUE is specified. 
    if (attrRule.FALLBACK_VALUE === undefined) {
      hookEvent.keepAttr = false;
      return;
    }
    var valueToSet = attrRule.FALLBACK_VALUE;
    var matched = REPLACEMENT_REGEX.exec(attrRule.FALLBACK_VALUE);
    if (matched) {
      var value = node.getAttribute(attrRule.ATTR_NAME);
      switch (matched[0]) {
        // eslint-disable-next-line no-template-curly-in-string
        case '${ZWAF.URL_COMPONENT}':
          // No I18N
          value = window.encodeURIComponent(value);
          break;
        // eslint-disable-next-line no-template-curly-in-string
        case '${ZWAF.REPLACE}':
          // No I18N
          // Simply replace the pattern with the actual attribute value
          // value = value;
          break;

        default:
          break;
      }
      valueToSet = attrRule.FALLBACK_VALUE.replace(matched[0], value);
    }
    if (IS_SCRIPT_OR_DATA.test(valueToSet.replace(ATTR_WHITESPACE, ''))) {
      // Remove as the value contains a possible XSS
      hookEvent.keepAttr = false;
    } else {
      hookEvent.attrValue = valueToSet;
    }
    return;
  }

  /**
   * Validate the given stylesheet
   * This is called from the DOMPurify Hook to sanitize styles
   *
   * @param   {CSSStyleSheet}  cssStyleSheet  CSS Stylesheet to validate
   */
  function validateStyleSheet(cssRules, cssStyleSheet) {
    for (var index = cssRules.length - 1; index >= 0; index--) {
      var rule = cssRules[index];
      if (FORBID_CSSRULES.length > 0 && FORBID_CSSRULES.indexOf(rule.type) > -1) {
        // Remove this rule
        cssStyleSheet.deleteRule(index);
        altered = true;
        continue;
      }
      // The cssRules.type determines whether it is a Media Query, KeyFrames Query, Regular CSS Query
      // https://developer.mozilla.org/en-US/docs/Web/API/CSSRule
      // 
      // TODO: Validation for @import CSS Rule Type? (type = 3)
      if (rule.type === 1 && rule.selectorText || rule.type === 8 && rule.keyText) {
        if (rule.style) {
          validateStyles(rule.style);
        }
      } else if ((rule.type === 4 || rule.type === 7 || rule.type === 12) && rule.cssRules) {
        validateStyleSheet(rule.cssRules, rule);
      }
    }
  }

  /**
   * Validate individual style properties from the CSS StyleSheet
   * This is called from the DOMPurify Hook to sanitize styles
   *
   * @param   {CSSStyleDeclaration}  styles  List of style property values
   */
  // TODO: Have to analyse adding SIBLING_CONDITIONS for Style validation 
  function validateStyles(styles) {
    // Validate regular CSS properties
    objectIterator(styles, function (property, value) {
      if (!value || value.constructor !== String) {
        return;
      }
      if (FORBID_PROPS.length > 0 && FORBID_PROPS.indexOf(property) > -1) {
        styles[property] = '';
        altered = true;
      }
      // Add UNSAFE_PROP_RULES validation here
      if (!UNSAFE_PROP_RULES[property]) {
        return;
      }
      var propRule = UNSAFE_PROP_RULES[property];
      for (var i = 0; i < propRule.CONDITIONS.length; i++) {
        if (isValidAttributeValue(value, propRule.CONDITIONS[i], property)) {
          // It has matched any one of the unsafe property rules. Need to remove or replace
          styles[property] = propRule.FALLBACK_VALUE === undefined ? '' : propRule.FALLBACK_VALUE;
          altered = true;
          return;
        }
      }
    });
  }

  /**
   * Copy the validated stylesheet content to replace the original stylesheet
   *
   * @param   {Array}         output         Array of safe stylesheet rules
   * @param   {CSSRuleList}   cssStyleSheet  Stylesheet with validated CSS rules
   */
  function copyValidatedStyleSheet(output, cssStyleSheet) {
    for (var index = cssStyleSheet.length - 1; index >= 0; index--) {
      // CSSRule type 8 is not checked below, as it will always come under CSSRule type 7
      // i.e , keyframe Rule will always be inside keyframes Rule
      if (cssStyleSheet[index].type === 1 || cssStyleSheet[index].type === 3 || cssStyleSheet[index].type === 4 || cssStyleSheet[index].type === 7 || cssStyleSheet[index].type === 12) {
        output.push(cssStyleSheet[index].cssText);
      }
    }
  }

  /**
   * Extend the configuration of a parent tag rule, to a child tag rule
   * Called when HTMLSanitizer is configured to extend the TAG_RULES of the base instance
   *
   * @param   {Object}  child   Child tag rule configuration
   * @param   {Object}  parent  Parent tag rule configuration
   */
  function extendTagRules(child, parent) {
    if (!parent || parent.constructor !== Object) {
      return;
    }
    objectIterator(parent, function (eachTag, eachTagRule) {
      if (!(eachTag in child)) {
        child[eachTag] = eachTagRule;
        return;
      }
      if (child[eachTag].APPEND_ATTR === undefined) {
        child[eachTag].APPEND_ATTR = eachTagRule.APPEND_ATTR;
      }
      if (child[eachTag].ATTR_RULES === undefined) {
        child[eachTag].ATTR_RULES = eachTagRule.ATTR_RULES;
      }
    });
  }

  // Helper functions to normalize the given sanitizer configuration
  /**
   * Normalizes uppercase and lowercase values in the configuration
   *
   * @param   {Object|Array}  config  Configuration object whose values should be normalized
   */
  function normalizeCase(config) {
    if (!config) {
      return;
    }
    if (config.CONDITIONS && config.CONDITIONS.length > 0) {
      // objectIterator(config, (key, value) => {
      config.CONDITIONS = normalizeCaseForConditions(config.CONDITIONS);
      // });
    }
    if (config.SIBLING_CONDITIONS && config.SIBLING_CONDITIONS.length > 0) {
      for (var i = 0; i < config.SIBLING_CONDITIONS.length; i++) {
        normalizeCase(config.SIBLING_CONDITIONS[i]);
      }
    }
  }

  function normalizeCaseForConditions(conditions) {
    if (!conditions) {
      return conditions;
    }
    for (var j = 0; j < conditions.length; j++) {
      conditions[j] = normalizeCaseForKey(conditions[j]);
    }
    return conditions;
  }
  /**
   * Normalizes uppercase and lowercase values of the given flags only.
   * Return unchanged if it is case sensitive.
   *
   * @param   {Object}  config  configuration object
   *
   * @return  {Object}          Case-normalized configuration object
   */
  function normalizeCaseForKey(config) {
    if (!config || config && config.CASE_SENSITIVE) {
      return config;
    }
    var flags = ['STARTS_WITH', // No I18N
    'ENDS_WITH', // No I18N
    'CONTAINS', // No I18N
    'EQUAL', // No I18N
    'NOT_EQUAL', // No I18N
    'LIST' // No I18N
    ];

    for (var i = 0; i < flags.length; i++) {
      var eachFlag = flags[i];
      if (!config[eachFlag]) {
        continue;
      }
      config[eachFlag] = toLowerCaseValue(config[eachFlag]);
    }
    if (config.NEXT) {
      normalizeCase(config.NEXT);
    }
    return config;
  }

  /**
   * Constructor for HTMLPurifier. Can be used to create fresh instances of HTMLPurifier
   *
   * @param  {Object}  conf   Configuration object
   *
   * @return {Object}         new HTMLPurifier instance
   */
  var HTMLPurifier = function HTMLPurifier(userConfig) {
    userConfig = validateUserConfig(userConfig);
    // eslint-disable-next-line new-cap
    return factory(userConfig, DOMPurify(window));
  };

  /**
   * Public method providing core sanitation functionality
   *
   * @param   {String|Node}   dirty   String or DOM node to sanitize
   * @param   {Object}        runtimeConfig     configuration object
   *
   * @return  {String|Node}           Sanitized safe content
   */
  HTMLPurifier.sanitize = function (dirty, runtimeConfig) {
    var _HTMLPurifier$removed;

    var customConfig = parseConfig(runtimeConfig);
    var result = DOMPurify.sanitize(dirty, customConfig);
    (_HTMLPurifier$removed = HTMLPurifier.removed).splice.apply(_HTMLPurifier$removed, [0, HTMLPurifier.removed.length].concat(_toConsumableArray$1(DOMPurify.removed)));
    return result;
  };

  concatArray(FORBID_TAGS, defaultForbiddenTags);
  concatArray(FORBID_ATTR, defaultForbiddenAttr);

  setDOMPurifyHooks();

  config.ALLOWED_TAGS = GLOBAL_TAGS;
  config.ALLOWED_ATTR = GLOBAL_ATTR;
  config.GLOBAL_ATTRIBUTES = GLOBAL_ATTR;

  if (config && !config.REUSE_CONFIG && freeze) {
    freeze(config);
  }

  HTMLPurifier.isSupported = DOMPurify.isSupported;
  HTMLPurifier.version = DOMPurify.version;
  HTMLPurifier.removed = [];

  return HTMLPurifier;
}

/// ///////////////////////////////////////////////////////
// Setting Base Configuration for HTMLPurifier Instance //
/// ///////////////////////////////////////////////////////

var config = {};

// Comment #002
// USE_PROFILES = false;

// No need to configure this as it will only increase size,
//  and we will anyway be using the default value of DOMPurify only
// config.ALLOW_ARIA_ATTR = true;
// config.ALLOW_DATA_ATTR = true;
// config.ALLOW_UNKNOWN_PROTOCOLS = false;
// config.ALLOW_SELF_CLOSE_IN_ATTR = true;
// config.SAFE_FOR_TEMPLATES = false;
// config.SAFE_FOR_XML = true;
// config.WHOLE_DOCUMENT = false;
// config.RETURN_DOM = false;
// config.RETURN_DOM_FRAGMENT = false;
// config.RETURN_TRUSTED_TYPE = false;
// config.DONT_TRIM = true;
config.FORCE_BODY = true;
// config.SANITIZE_DOM = true;
// config.SANITIZE_NAMED_PROPS = false;
// config.KEEP_CONTENT = true;
// config.IN_PLACE = false;
config.ALLOWED_URI_REGEXP = false;
// config.NAMESPACE = HTML_NAMESPACE;
// config.CUSTOM_ELEMENT_HANDLING = {};
// config.ALLOWED_NAMESPACES = [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE];
config.REUSE_CONFIG = false;

config.REMOVE_ONEVENTS = true;
config.EXTENDS = ['GLOBAL_TAGS', // No I18N
'GLOBAL_ATTR', // No I18N
'FORBID_TAGS', // No I18N
'FORBID_ATTR', // No I18N
'TAG_RULES', // No I18N
'GLOBAL_ATTR_RULES', // No I18N
'GLOBAL_APPEND_ATTR', // No I18N
'ADD_DATA_URI_TAGS', // No I18N
'ADD_URI_SAFE_ATTR' // No I18N
];
config.ALLOWED_STYLE = 'NONE'; // Values can be either 'INLINE', 'INTERNAL', 'ALL', 'NONE' // No I18N
config.STYLE_RULES = {
  FORBID_PROPS: [],
  FORBID_CSSRULES: [],
  UNSAFE_PROP_RULES: {
    // Same as attribute validation rule, but as blacklist
    //
    // {
    //   "NAME": "position",  
    //   "EQUALS": "absolute",  
    //   "DEFAULT_VALUE": "relative"  
    // }
  }
};

config.GLOBAL_TAGS = 'a|abbr|acronym|address|area|article|aside|audio|b|bdi|bdo|big|blink|blockquote|body|br|button|canvas|caption|center|cite|code|col|colgroup|content|data|datalist|dd|decorator|del|details|dfn|dir|div|dl|dt|element|em|fieldset|figcaption|figure|font|footer|form|h1|h2|h3|h4|h5|h6|head|header|hgroup|hr|html|i|img|input|ins|kbd|label|legend|li|main|map|mark|marquee|menu|menuitem|meter|nav|nobr|ol|optgroup|option|output|p|pre|progress|q|rp|rt|ruby|s|samp|section|select|shadow|small|source|spacer|span|strike|strong|sub|summary|sup|table|tbody|td|template|textarea|tfoot|th|thead|time|title|tr|track|tt|u|ul|var|video|wbr|#text'.split( // No I18N
'|' // No I18N
);
config.GLOBAL_ATTR = 'accept|action|align|alt|autocomplete|background|bgcolor|border|cellpadding|cellspacing|checked|cite|class|clear|color|cols|colspan|coords|datetime|default|dir|disabled|download|enctype|face|for|headers|height|hidden|high|href|hreflang|id|ismap|label|lang|list|loop|low|max|maxlength|media|method|min|multiple|name|noshade|novalidate|nowrap|open|optimum|pattern|placeholder|poster|preload|pubdate|radiogroup|readonly|rel|required|rev|reversed|role|rows|rowspan|spellcheck|scope|selected|shape|size|span|srclang|start|src|step|summary|tabindex|title|target|type|usemap|valign|value|width|xmlns|sandbox'.split( // No I18N
'|' // No I18N
);
config.FORBID_TAGS = []; // Add any forbidden tags here
config.FORBID_ATTR = []; // Add any forbidden attrs here
config.GLOBAL_ATTR_RULES = {};
config.GLOBAL_APPEND_ATTR = {};
config.ADD_DATA_URI_TAGS = [];
config.ADD_URI_SAFE_ATTR = [];
config.TAG_RULES = {
  a: {
    APPEND_ATTR: {
      rel: {
        ATTR_NAME: 'rel', // No I18N
        APPEND_ATTR_VALUE: 'noopener noreferrer', // No I18N
        SIBLING_CONDITIONS: [{
          ATTR_NAME: 'target', // No I18N
          CONDITIONS: [{
            IS_MANDATORY: 'true', // No I18N
            CONTAINS: '_blank' // No I18N
          }]
        }]
      }
    }
  }
};
config.TAG_SPECIFIC_ATTRS = {}; // HTMLPurifier will automatically add tag-specific attributes here
// {
//   'href' : ['a', 'div'] 
// }

var HTMLPurifier = factory(config, createDOMPurify$1);

if (freeze) {
  freeze(HTMLPurifier);
}

delete window.DOMPurify; //We are deleting the base DOMPurify Instance



/**
 *  Comment #001
 *  Temporary workaround for Lyte team. We can remove this after they migrate to GLOBAL_ATTR from GLOBAL_ATTRIBUTES
 */

/**
 *  Comment #002
 *  Deleting Profiles as it won't be used
 */

if (ZWAF$2.version === '7.0.0' && !ZWAF$2.HTMLPurifier) {
  ZWAF$2.defineProperty(ZWAF$2, 'HTMLPurifier', // No I18N
  HTMLPurifier, true, false, false, true);
}
if (!ZWAF$2['7_0_0'].HTMLPurifier) {
  ZWAF$2.defineProperty(ZWAF$2['7_0_0'], 'HTMLPurifier', // No I18N
  HTMLPurifier, true, false, false, true);
}

return ZWAF$2;

})));
