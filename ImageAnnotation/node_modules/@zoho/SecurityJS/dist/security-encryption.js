(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('@stardazed/streams-compression')) :
	typeof define === 'function' && define.amd ? define(['@stardazed/streams-compression'], factory) :
	(global.ZWAF = factory(global.streamsCompression));
}(this, (function (streamsCompression) { 'use strict';

/**
 * Polyfills
 */

/**
 * 
 * It's a wrapper over Object.defineProperty for setting  data descriptors for object .A data descriptor is a property that has a value, which sets isWritable,isConfigurable,isEnumerable for an object. By default all configuration values are false.
 * 
 * Below function will define Object.defineProperty if not defined.
 * Normal property addition through assignment(=) creates properties.
 * But it shows up during property enumeration (for...in loop or Object.keys method), whose values may be changed or deleted.
 * And it may even create some unusual behaviour. The Object.defineProperty method allows
 * three extra details(configurable, writable, and enumerable) to be set for the value.
 * By default all the value are true. Since defineProperty is not supported
 * below IE-9 we have implemented fall back to directly assign value to the object
 *
 * @param   {Object} obj
 * @param   {string} property
 * @param   {value}  value
 * @param   {boolean}  isOverrideDefaultValue
 * @param   {boolean}  isWritable
 * @param   {boolean}  isConfigurable
 * @param   {boolean}  isEnumerable
 * @returns {Object}
 */
/* eslint-disable-next-line max-params */
function defineProperty(obj, property, value, isOverrideDefaultValue, isWritable, isConfigurable, isEnumerable) {
  if (!isOverrideDefaultValue && property in obj) {
    return;
  }
  if (!Object.defineProperty || !function () {
    try {
      Object.defineProperty({}, 'x', {}); // No I18N
      return true;
    } catch (e) {
      return false;
    }
  }()) {
    obj[property] = value;
    return obj;
  }

  isWritable = isWritable === true;
  isConfigurable = isConfigurable === true;
  isEnumerable = isEnumerable === true;
  return Object.defineProperty(obj, property, {
    value: value,
    writable: isWritable,
    configurable: isConfigurable,
    enumerable: isEnumerable
  });
}

/**
 * Defining String.prototype.codePointAt if not defined already
 * This is not supported in IE 11 and below
 */


/**
 * Defining String.fromCodePoint if not defined already
 * Which is not supported in many browsers like IE ,Android ,Opera Mobile
 * */

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Logger = function () {
  function Logger(level) {
    _classCallCheck(this, Logger);

    this.LEVELS = {
      NONE: -1,
      DEBUG: 0,
      INFO: 1,
      WARN: 2,
      ERROR: 3
    };
    if (level === this.LEVELS.NONE || level === this.LEVELS.DEBUG || level === this.LEVELS.INFO || level === this.LEVELS.WARN || level === this.LEVELS.ERROR) {
      this.level = level;
    } else {
      this.level = this.LEVELS.ERROR;
    }
  }

  _createClass(Logger, [{
    key: "debug",
    value: function debug() {
      var _window;

      if (!window || !window.console || this.level === this.LEVELS.NONE || this.level !== this.LEVELS.DEBUG) {
        return;
      }

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      (_window = window["con" + "sole"]).debug.apply(_window, args.concat([performance.now()])); // No I18N
    }
  }, {
    key: "info",
    value: function info() {
      var _window2;

      if (!window || !window.console || this.level === this.LEVELS.NONE || this.level > this.LEVELS.INFO) {
        return;
      }

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      (_window2 = window["con" + "sole"]).log.apply(_window2, args.concat([performance.now()])); // No I18N
    }
  }, {
    key: "warn",
    value: function warn() {
      var _window3;

      if (!window || !window.console || this.level === this.LEVELS.NONE || this.level > this.LEVELS.WARN) {
        return;
      }

      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      (_window3 = window["con" + "sole"]).warn.apply(_window3, args.concat([performance.now()])); // No I18N
    }
  }, {
    key: "error",
    value: function error() {
      var _window4;

      if (!window || !window.console || this.level === this.LEVELS.NONE || this.level > this.LEVELS.ERROR) {
        return;
      }

      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      (_window4 = window["con" + "sole"]).error.apply(_window4, args.concat([performance.now()])); // No I18N
    }
  }]);

  return Logger;
}();

/**
 * @author: Patrick-2626 & Vigneshwar-5036
 *
 * @wiki: https://intranet.wiki.zoho.com/security/client-side-security.html
 *
 * Reference
 *  1)https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/
 *  2)https://github.com/danielstjules/blankshield
 */

var ZWAF$2 = window && window.ZWAF ? window.ZWAF : { version: '7.0.0' };
var logger = new Logger();

if (!ZWAF$2.defineProperty) {
  ZWAF$2.defineProperty = defineProperty;
}

if (!ZWAF$2.logger) {
  ZWAF$2.logger = logger;
}

if (!ZWAF$2['7_0_0']) {
  ZWAF$2['7_0_0'] = {
    version: '7.0.0',
    defineProperty: defineProperty,
    logger: logger
  };
}

/** @format */

var APP_AGENT_CONF_PROMISE = null;
var CSRF_DETAILS_PROMISE = null;
var CSRF_PROP_NAME = "csrf"; // No I18N
var CSRF_PARAM_PROP_NAME = "param_name"; // No I18N
var CSRF_COOKIE_PROP_NAME = "cookie_name"; // No I18N
var WAF_APP_AGENT_CONFIG_URL = "/waf/appAgentConf"; // No I18N

/**
 * Load App Agent Conf, primarily used now for getting CSRF info
 * As of now, this call will not be made. We are only using this to get CSRF param and cookie names
 * which are currently set by user using setCSRF.
 * But it might be used for other purposes in the future, and we will mandate getting this info
 * through the /waf call. So keeping this implementation for now.
 *
 * Response will be like:
 *   {
 *     csrf: {
 *       param_name: "ac_p"
 *       cookie_name: "_ca"
 *     }
 *   }
 * @return {Promise<Response>}
 */
function loadAppAgentConf() {

  if (APP_AGENT_CONF_PROMISE) {
    return APP_AGENT_CONF_PROMISE;
  }
  APP_AGENT_CONF_PROMISE = fetch(WAF_APP_AGENT_CONFIG_URL).catch(function (error) {
    throw Error("Error while fetching App Agent Conf: " + error); // No I18N
  });
  return APP_AGENT_CONF_PROMISE;
}

/**
 * Usage is like this:
 *    ZWAF.configuration.setCSRF({
 *      paramName: "_ca",
 *      cookieName: "ac_p"
 *    })
 * @param config
 */
function setCSRF(config) {
  if (config.paramName && config.cookieName) {
    CSRF_DETAILS_PROMISE = Promise.resolve([config.paramName, config.cookieName]);
  }
}

function getCSRFDetails() {
  if (CSRF_DETAILS_PROMISE) {
    return CSRF_DETAILS_PROMISE;
  }
  CSRF_DETAILS_PROMISE = this.loadAppAgentConf().then(function (response) {
    return response.json().then(function (jsonResponse) {
      var csrfParamName = jsonResponse && jsonResponse[CSRF_PROP_NAME] && jsonResponse[CSRF_PROP_NAME][CSRF_PARAM_PROP_NAME];
      if (!csrfParamName) {
        throw Error("Invalid CSRF Param Name in Conf"); // No I18N
      }
      var csrfCookieName = jsonResponse && jsonResponse[CSRF_PROP_NAME] && jsonResponse[CSRF_PROP_NAME][CSRF_COOKIE_PROP_NAME];
      if (!csrfCookieName) {
        throw Error("Invalid CSRF Cookie Name in Conf"); // No I18N
      }
      return [csrfParamName, csrfCookieName];
    });
  });
  return CSRF_DETAILS_PROMISE;
}

function getCSRFName() {
  return getCSRFDetails().then(function (response) {
    return response[0];
  });
}

function getCSRFValue() {
  return getCSRFDetails().then(function (response) {
    return response[1];
  });
}

var configuration = {
  setCSRF: setCSRF,
  getCSRFName: getCSRFName,
  getCSRFValue: getCSRFValue,
  getCSRFDetails: getCSRFDetails,
  loadAppAgentConf: loadAppAgentConf
};

if (Object.freeze) {
  Object.freeze(configuration);
}

if (ZWAF$2.version === '7.0.0' && !ZWAF$2.configuration) {
  ZWAF$2.defineProperty(ZWAF$2, 'configuration', // No I18N
  configuration, true, false, false, true);
}
if (!ZWAF$2['7_0_0'].configuration) {
  ZWAF$2.defineProperty(ZWAF$2['7_0_0'], 'configuration', // No I18N
  configuration, true, false, false, true);
}

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

/**
 * RequestUtils
 * */
var RequestUtils = {};
function mergeArrayBuffersToUint8Array(buffers) {
  var totalLength = buffers.reduce(function (acc, buffer) {
    return acc + buffer.byteLength;
  }, 0);
  var mergedUint8Array = new Uint8Array(totalLength);
  var offset = 0;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = buffers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var buffer = _step.value;

      mergedUint8Array.set(new Uint8Array(buffer), offset);
      offset += buffer.byteLength;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return mergedUint8Array;
}

function generateBoundaryString() {
  var prefix = "----WafFormBoundary"; // No I18N
  var length = 15;
  var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'; // No I18N
  var result = prefix;
  for (var i = 0; i <= length; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result;
}

function formUint8ArrayPayload(parts) {
  var te = new TextEncoder();
  var resultArrayBuffers = parts.map(function (each) {
    if (typeof each === "string") {
      return te.encode(each).buffer;
    } else {
      return each;
    }
  });
  return mergeArrayBuffersToUint8Array(resultArrayBuffers);
}

RequestUtils.createMultipartFormData = function (formData) {
  return new Promise(function (resolve, reject) {
    var boundary = generateBoundaryString();
    var parts = [];

    // Convert entries to an array for sequential processing
    var entries = Array.from(formData.entries());

    // Function to process each entry sequentially
    var processEntry = function processEntry(index) {
      if (index >= entries.length) {
        parts.push("--" + boundary + "--");

        var result = {};
        result.data = formUint8ArrayPayload(parts);
        result.boundary = boundary;
        resolve(result);
        return;
      }

      var _entries$index = _slicedToArray(entries[index], 2),
          name = _entries$index[0],
          value = _entries$index[1];

      if (value instanceof Blob) {
        value.arrayBuffer().then(function (fileBinaryArrayBuffer) {
          parts.push("--" + boundary + "\r\n", "Content-Disposition: form-data; name=\"" + name + "\"; filename=\"" + value.name + "\"\r\n", // No I18N
          "Content-Type: " + value.type + "\r\n", "\r\n", // No I18N
          fileBinaryArrayBuffer, "\r\n" // No I18N
          );
          processEntry(index + 1); // Process next entry
        }).catch(reject);
      } else {
        parts.push("--" + boundary + "\r\n", "Content-Disposition: form-data; name=\"" + name + "\"\r\n", // No I18N
        "\r\n", // No I18N
        value, "\r\n" // No I18N
        );
        processEntry(index + 1); // Process next entry
      }
    };

    // Start processing entries
    processEntry(0);
  });
};

if (Object.freeze) {
  Object.freeze(RequestUtils);
}

if (ZWAF$2.version === '7.0.0' && !ZWAF$2.RequestUtils) {
  ZWAF$2.defineProperty(ZWAF$2, 'RequestUtils', // No I18N
  RequestUtils, true, false, false, true);
}
if (!ZWAF$2['7_0_0'].RequestUtils) {
  ZWAF$2.defineProperty(ZWAF$2['7_0_0'], 'RequestUtils', // No I18N
  RequestUtils, true, false, false, true);
}

/**
 * Custom Functions for Sanitizer
 **/















/**
 * Cookie handling functions
 **/

function setCookie(name, value) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  options = Object.assign({
    path: '/',
    SameSite: 'lax', // No I18N
    // Default max age is 100 days
    'max-age': 100 * 24 * 60 * 60 * 1000 // No I18N
  }, options);
  if (!encodeURIComponent) {
    return;
  }
  var cookieVal = encodeURIComponent(name) + '=' + encodeURIComponent(value);

  for (var optionKey in options) {
    cookieVal += '; ' + optionKey;
    var optionValue = options[optionKey];
    if (optionValue !== true) {
      cookieVal += '=' + optionValue;
    }
  }
  document.cookie = cookieVal;
}
function deleteCookie(name) {
  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '/';

  setCookie(name, '', {
    path: path,
    'max-age': -1 // No I18N
  });
}

function getCookie(name) {
  name = name + '=';
  var cookieList = document.cookie;
  var res = void 0;
  cookieList.split('; ').forEach(function (cookie) {
    if (res !== undefined) {
      return;
    }
    var cookieValue = void 0;
    try {
      if (decodeURIComponent) {
        cookieValue = decodeURIComponent(cookie);
      }
    } catch (e) {
      cookieValue = cookie;
      ZWAF && ZWAF.logger && ZWAF.logger.warn && ZWAF.logger.warn("Error while trying to decode Cookie value!");
    }
    if (cookieValue.indexOf(name) === 0) {
      res = cookieValue.substring(name.length);
    }
  });
  return res;
}

function hasCookie(name) {
  return !!getCookie(name);
}

function getFromLocalStorage(name) {
  if (!window || !window.localStorage || name === undefined || name === null) {
    return null;
  }
  return window.localStorage.getItem(name);
}

function deleteFromLocalStorage(name) {
  if (!window || !window.localStorage || name === undefined || name === null) {
    return null;
  }
  return window.localStorage.removeItem(name);
}

function setToLocalStorage(name, value) {
  if (!window || !window.localStorage || name === undefined || name === null) {
    return null;
  }
  return window.localStorage.setItem(name, value);
}

function hasInLocalStorage(name) {
  return !!getFromLocalStorage(name);
}

function extend(obj, mixin, isDeep, isDeepMixArray) {
  if (!mixin) {
    return obj;
  }
  var keys = Object.keys(mixin);
  if (!keys.length) {
    return obj;
  }
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      var v2 = mixin[key];
      if (obj[key] === undefined) {
        obj[key] = mixin[key];
      } else if (isDeep) {
        var v1 = obj[key];
        if (is(v1, Object) && is(v2, Object)) {
          extend(v1, v2, isDeep, isDeepMixArray);
        } else if (isDeepMixArray && is(v1, Array) && is(v2, Array)) {
          obj[key] = v1.concat(v2);
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return obj;
}

// Unused functions
//
// function setArray(arr1, arr2){
//   arr1.splice.apply(arr1,[0,arr1.length].concat(arr2));
// }
//
// function addObjsToSet(set, set2) {
//   for (let each in set2) {
//     if (set2.hasOwnProperty(each)) {
//       set[each] = true;
//     }
//   }
//   return set;
// };
//
// function removeFromSet(set, key) {
//   delete set[key];
//   return set;
// }
//
// /* Add all object keys to array */
// function addToArr(array, set) {
//   let property;
//   for (property in set) {
//     if (set.hasOwnProperty(property)) {
//       array.push(property);
//     }
//   }
//   return array;
// }
//
// /* Add flags to config */
// function addToConfig(set, array) {
//   let l = array.length;
//   while (l--) {
//     set[array[l]] = true;
//   }
//   return set;
// }

var _createClass$1 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** @format */
var defaultConfig = {
  algorithm: "RSA-OAEP", // No I18N
  key_hash: "SHA-256", // No I18N
  key_size: 2048,
  key_encoding: "Base64", // No I18N
  transmission_algorithm: "AES-GCM", // No I18N

  publicKeyFormat: "spki", // No I18N
  privateKeyFormat: "pkcs8", // No I18N
  transmission_key_length: 256,
  transmission_iv_length: 12,

  logLevel: 3
};

var PayloadEncryptAgent = function () {
  function PayloadEncryptAgent(config) {
    _classCallCheck$1(this, PayloadEncryptAgent);

    config = extend(config || {}, defaultConfig);
    this.KEY_USAGES = {
      ENCRYPT: "encrypt", // No I18N
      DECRYPT: "decrypt" // No I18N
    };
    this.asymmetricEncryptionAlgorithm = config.algorithm;
    this.asymmetricEncryptionHash = config.key_hash;
    this.asymmetricEncryptionKeySize = config.key_size;
    this.asymmetricPublicKeyFormat = config.publicKeyFormat;
    this.asymmetricPrivateKeyFormat = config.privateKeyFormat;

    this.symmetricKeyEncryptionAlgorithm = config.transmission_algorithm;
    this.symmetricKeyLength = config.transmission_key_length;
    this.symmetricKeyIVLength = config.transmission_iv_length;
    this.logger = new Logger(config.logLevel);
  }

  _createClass$1(PayloadEncryptAgent, [{
    key: "setLogLevel",
    value: function setLogLevel(level) {
      this.logger = new Logger(level);
    }

    /**
     * Convert a Base64 String to Uint8Array
     * Since we are only dealing with base64 characters (which are within ASCII range),
     * no need to use codePointAt instead of charCodeAt
     * @param {String} base64string
     * @returns {Uint8Array}
     */

  }, {
    key: "base64ToUint8Array",
    value: function base64ToUint8Array(base64string) {
      var binaryString = atob(base64string);
      var bytes = new Uint8Array(binaryString.length);
      for (var i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return bytes;
    }

    /**
     * Convert a Uint8Array to Base64 String
     * Since we are only dealing with base64 characters (which are within ASCII range),
     * no need to use fromCodePoint instead of fromCharCode
     * @param {Uint8Array} uint8array
     * @returns {String}
     */

  }, {
    key: "uint8ArrayToBase64",
    value: function uint8ArrayToBase64(uint8array) {
      var binaryString = "";
      for (var i = 0; i < uint8array.length; i++) {
        binaryString += String.fromCharCode(uint8array[i]);
      }
      return btoa(binaryString);
    }

    /**
     * Convert data to binary (ArrayBuffer format)
     * This would be called to normalize data to be encrypted,
     * which can be normal string information or binary data like files.
     *
     * @param {String|Uint8Array|ArrayBuffer} data
     * @return {ArrayBuffer}
     */

  }, {
    key: "convertToBinary",
    value: function convertToBinary(data) {
      if (data.constructor === ArrayBuffer) {
        return data;
      }
      if (typeof data === "string") {
        // No I18N
        var dataBytes = new TextEncoder().encode(data); // Convert the given string to Uint8Array
        return dataBytes.buffer;
      }
      if (data.constructor === Uint8Array) {
        return data.buffer;
      }
      throw new Error("Data cannot be converted to Binary!"); // No I18N
    }

    /**
     * Export binary data to binary (ArrayBuffer format)
     * This would be called to normalize data to be encrypted,
     * which can be normal string information or binary data like files.
     *
     * @param {Uint8Array | Uint8Array[] | ArrayBuffer | ArrayBuffer[]} data
     * @return {String | String[]}
     */

  }, {
    key: "exportBinary",
    value: function exportBinary(data) {
      var _this = this;

      if (data.constructor === Array) {
        return data.map(function (eachData) {
          return _this.exportBinary(eachData);
        });
      }
      if (data.constructor === ArrayBuffer) {
        return this.uint8ArrayToBase64(new Uint8Array(data));
      }
      if (data.constructor === Uint8Array) {
        return this.uint8ArrayToBase64(data);
      }
      throw new Error("Data is not in Binary format!"); // No I18N
    }

    /**
     * Normalize binary data to ArrayBuffer
     * This would be called to normalize encrypted data or any binary data.
     * If datatype is string, then we can assume it is base64 encoded binary data.
     *
     * @param {String|Uint8Array|ArrayBuffer} binaryData
     * @return {ArrayBuffer}
     */

  }, {
    key: "normalizeBinaryData",
    value: function normalizeBinaryData(binaryData) {
      if (binaryData.constructor === ArrayBuffer) {
        return binaryData;
      } else if (typeof binaryData === "string") {
        // No I18N
        var binaryDataArray = this.base64ToUint8Array(binaryData);
        return binaryDataArray.buffer;
      } else if (binaryData.constructor === Uint8Array) {
        return binaryData.buffer;
      }
      throw new Error("Data cannot be normalized to Binary!"); // No I18N
    }

    /**
     * Get the asymmetric algorithm details for importing the asymmetric key
     * @param algorithm
     * @param keySize
     * @returns {RsaHashedKeyGenParams}
     */

  }, {
    key: "getAsymmetricEncryptionAlgorithmForGeneration",
    value: function getAsymmetricEncryptionAlgorithmForGeneration(algorithm, keySize) {
      return {
        name: algorithm || this.asymmetricEncryptionAlgorithm,
        hash: this.asymmetricEncryptionHash,
        modulusLength: keySize || this.asymmetricEncryptionKeySize,
        publicExponent: new Uint8Array([0x01, 0x00, 0x01])
      };
    }

    /**
     * Get the asymmetric algorithm details for importing the asymmetric key
     * @return {RsaHashedImportParams}
     */

  }, {
    key: "getAsymmetricEncryptionAlgorithmForImport",
    value: function getAsymmetricEncryptionAlgorithmForImport() {
      return {
        name: this.asymmetricEncryptionAlgorithm,
        hash: this.asymmetricEncryptionHash
      };
    }

    /**
     * Get the asymmetric algorithm details for encrypting/decrypting using the asymmetric key
     * @return {RsaOaepParams}
     */

  }, {
    key: "getAsymmetricEncryptionAlgorithmForUsage",
    value: function getAsymmetricEncryptionAlgorithmForUsage() {
      return { name: this.asymmetricEncryptionAlgorithm };
    }

    /**
     * Get the symmetric algorithm details for generating a new symmetric key
     * @return {AesKeyGenParams}
     */

  }, {
    key: "getSymmetricEncryptionAlgorithmForGeneration",
    value: function getSymmetricEncryptionAlgorithmForGeneration() {
      return {
        name: this.symmetricKeyEncryptionAlgorithm,
        length: this.symmetricKeyLength
      };
    }

    /**
     * Get the symmetric algorithm details for importing the symmetric key
     * @return {AlgorithmIdentifier}
     */

  }, {
    key: "getSymmetricEncryptionAlgorithmForImport",
    value: function getSymmetricEncryptionAlgorithmForImport() {
      return {
        name: this.symmetricKeyEncryptionAlgorithm
      };
    }

    /**
     * Get the symmetric algorithm details for encrypting/decrypting using the symmetric key
     * @return {AesGcmParams}
     */

  }, {
    key: "getSymmetricEncryptionAlgorithmForUsage",
    value: function getSymmetricEncryptionAlgorithmForUsage(IVBytes) {
      return {
        name: this.symmetricKeyEncryptionAlgorithm,
        iv: IVBytes
      };
    }

    /**
     * Generate a new asymmetric key pair
     * @param algorithm
     * @param keySize
     * @returns {Promise<CryptoKeyPair>}
     */

  }, {
    key: "generateAsymmetricKeyPair",
    value: function generateAsymmetricKeyPair(algorithm, keySize) {
      return crypto.subtle.generateKey(this.getAsymmetricEncryptionAlgorithmForGeneration(algorithm, keySize), true, [this.KEY_USAGES.ENCRYPT, this.KEY_USAGES.DECRYPT]).catch(function (error) {
        throw new Error("Failed to generate symmetric key! Error: " + error); // No I18N
      });
    }

    /**
     * Import the Asymmetric PublicKey
     * @param {String|Uint8Array|ArrayBuffer|CryptoKey} publicKey
     * @returns {Promise<CryptoKey>}
     */

  }, {
    key: "importAsymmetricPublicKey",
    value: function importAsymmetricPublicKey(publicKey) {
      if (publicKey === null || publicKey.constructor === CryptoKey) {
        return Promise.resolve(publicKey);
      }
      var publicKeyBuffer = this.normalizeBinaryData(publicKey);
      var algorithm = this.getAsymmetricEncryptionAlgorithmForImport();
      return crypto.subtle.importKey(this.asymmetricPublicKeyFormat, publicKeyBuffer, algorithm, true, [this.KEY_USAGES.ENCRYPT]).catch(function (error) {
        throw new Error("Failed to import Asymmetric Public Key! Algorithm: " + JSON.stringify(algorithm) + " Error: " + error);
      });
    }

    /**
     * Import the Asymmetric PrivateKey
     * @param {String|Uint8Array|ArrayBuffer|CryptoKey} privateKey
     * @returns {Promise<CryptoKey>}
     */

  }, {
    key: "importAsymmetricPrivateKey",
    value: function importAsymmetricPrivateKey(privateKey) {
      if (privateKey === null || privateKey.constructor === CryptoKey) {
        return Promise.resolve(privateKey);
      }
      var privateKeyBuffer = this.normalizeBinaryData(privateKey);
      var algorithm = this.getAsymmetricEncryptionAlgorithmForImport();
      // Import the public key
      return crypto.subtle.importKey(this.asymmetricPrivateKeyFormat, privateKeyBuffer, algorithm, true, [this.KEY_USAGES.DECRYPT]).catch(function (error) {
        throw new Error("Failed to import asymmetric private key! Algorithm: " + JSON.stringify(algorithm) + " Error: " + error);
      });
    }

    /**
     * Export the asymmetric public key
     * @param {CryptoKey} key
     * @returns {Promise<ArrayBuffer>}
     */

  }, {
    key: "exportAsymmetricPublicKey",
    value: function exportAsymmetricPublicKey(key) {
      if (key === null) {
        return Promise.resolve(key);
      }
      return crypto.subtle.exportKey(this.asymmetricPublicKeyFormat, key).catch(function (error) {
        throw new Error("Failed to export asymmetric public key! Error: " + error); // No I18N
      });
    }

    /**
     * Export the asymmetric private key
     * @param {CryptoKey} key
     * @returns {Promise<ArrayBuffer>}
     */

  }, {
    key: "exportAsymmetricPrivateKey",
    value: function exportAsymmetricPrivateKey(key) {
      if (key === null) {
        return Promise.resolve(key);
      }
      return crypto.subtle.exportKey(this.asymmetricPrivateKeyFormat, key).catch(function (error) {
        throw new Error("Failed to export asymmetric private key! Error: " + error); // No I18N
      });
    }

    /**
     * Generate IV for Symmetric Key
     * @returns {Uint8Array}
     */

  }, {
    key: "generateIV",
    value: function generateIV() {
      return crypto.getRandomValues(new Uint8Array(this.symmetricKeyIVLength));
    }

    /**
     * Extract the IV bytes from the Symmetric Key Data
     * @param {Uint8Array} AESKeyArray
     * @return {Uint8Array}
     */

  }, {
    key: "extractIVBytes",
    value: function extractIVBytes(AESKeyArray) {
      return AESKeyArray.slice(AESKeyArray.length - this.symmetricKeyIVLength);
    }

    /**
     * Extract the key bytes from the Symmetric Key Data
     * @param {Uint8Array} AESKeyArray
     * @return {Uint8Array}
     */

  }, {
    key: "extractSymmetricKeyBytes",
    value: function extractSymmetricKeyBytes(AESKeyArray) {
      return AESKeyArray.slice(0, AESKeyArray.length - this.symmetricKeyIVLength);
    }

    /**
     * Generate a new symmetric key
     * @returns {Promise<CryptoKey>}
     */

  }, {
    key: "generateSymmetricKey",
    value: function generateSymmetricKey() {
      return crypto.subtle.generateKey(this.getSymmetricEncryptionAlgorithmForGeneration(), true, [this.KEY_USAGES.ENCRYPT, this.KEY_USAGES.DECRYPT]).catch(function (error) {
        throw new Error("Failed to generate symmetric key! Error: " + error); // No I18N
      });
    }

    /**
     * Generate a new symmetric key
     * @param {String|Uint8Array|ArrayBuffer|Object} [key]
     * @returns {Promise<{key:CryptoKey,iv:Uint8Array}>}
     */

  }, {
    key: "getSymmetricKey",
    value: function getSymmetricKey(key) {
      var _this2 = this;

      var symmetricKeyPromise = void 0;
      var IVBytes = void 0;
      if (!key || key.constructor !== Object && key.constructor !== String && key.constructor !== Uint8Array && key.constructor !== ArrayBuffer) {
        symmetricKeyPromise = this.generateSymmetricKey();
        IVBytes = this.generateIV();
        symmetricKeyPromise.then(function (generatedKey) {
          _this2.logger.debug("Symmetric key generated: ", generatedKey); // No I18N
        });
      } else if (key.constructor === Object && key.key && key.key.constructor === CryptoKey && key.iv && key.iv.constructor === Uint8Array) {
        // reuse that key
        symmetricKeyPromise = Promise.resolve(key.key);
        IVBytes = key.iv;
      } else {
        var symmetricKeyArray = new Uint8Array(this.normalizeBinaryData(key));
        var symmetricKeyBytes = this.extractSymmetricKeyBytes(symmetricKeyArray);
        IVBytes = this.extractIVBytes(symmetricKeyArray);
        this.logger.debug("IV Bytes extracted: ", IVBytes); // No I18N
        symmetricKeyPromise = this.importSymmetricKey(symmetricKeyBytes);
        symmetricKeyPromise.then(function (importedKey) {
          _this2.logger.debug("Symmetric key imported: ", importedKey); // No I18N
        });
      }
      if (symmetricKeyPromise) {
        return symmetricKeyPromise.then(function (symmetricKey) {
          return {
            key: symmetricKey,
            iv: IVBytes
          };
        });
      } else {
        this.logger.error("Failed to get symmetric key!", key); // No I18N
      }
    }

    /**
     * Import the symmetric key bytes as a usable CryptoKey
     * @param {Uint8Array} key
     * @return {Promise<CryptoKey>}
     */

  }, {
    key: "importSymmetricKey",
    value: function importSymmetricKey(key) {
      var _this3 = this;

      return crypto.subtle.importKey("raw", // No I18N
      key.buffer, this.getSymmetricEncryptionAlgorithmForImport(), true, [this.KEY_USAGES.ENCRYPT, this.KEY_USAGES.DECRYPT]).catch(function (error) {
        _this3.logger.debug("Encrypted symmetric key bytes: ", key); // No I18N
        throw new Error("Failed to import symmetric key! Error: " + error);
      });
    }

    /**
     * Export the symmetric key
     * @param {CryptoKey} key
     * @returns {Promise<ArrayBuffer>}
     */

  }, {
    key: "exportSymmetricKey",
    value: function exportSymmetricKey(key) {
      return crypto.subtle.exportKey("raw", key) // No I18N
      .catch(function (error) {
        throw new Error("Failed to export symmetric key! Error: " + error); // No I18N
      });
    }

    /**
     * Encrypt the symmetric key data with asymmetric public key
     * @param {Uint8Array} aesKeyIV
     * @param {CryptoKey} publicKey
     * @returns {Promise<ArrayBuffer>}
     */

  }, {
    key: "encryptWithPublicKey",
    value: function encryptWithPublicKey(aesKeyIV, publicKey) {
      var _this4 = this;

      // Import the public key
      return this.importAsymmetricPublicKey(publicKey).then(function (asymmetricKey) {
        _this4.logger.debug("Asymmetric key imported: ", asymmetricKey); // No I18N
        var asymmetricAlgorithm = _this4.getAsymmetricEncryptionAlgorithmForUsage();
        // Encrypt data using the public key
        return _this4._encrypt(aesKeyIV, asymmetricKey, asymmetricAlgorithm).catch(function (error) {
          throw new Error("Failed to encrypt the symmetric key with asymmetric public key! Error: " + // No I18N
          error);
        });
      });
    }

    /**
     * Decrypt the symmetric key data with asymmetric private key
     * @param {String} encryptedSymmetricKey
     * @param {CryptoKey} privateKey
     * @return {Promise<ArrayBuffer>}
     */

  }, {
    key: "decryptWithPrivateKey",
    value: function decryptWithPrivateKey(encryptedSymmetricKey, privateKey) {
      var _this5 = this;

      return this.importAsymmetricPrivateKey(privateKey).then(function (asymmetricKey) {
        _this5.logger.debug("Asymmetric key imported: ", asymmetricKey); // No I18N
        // Encrypt data using the public key
        var asymmetricAlgorithm = _this5.getAsymmetricEncryptionAlgorithmForUsage();
        return _this5._decrypt(encryptedSymmetricKey, asymmetricKey, asymmetricAlgorithm).catch(function (error) {
          _this5.logger.warn("Failed to decrypt the symmetric key with asymmetric private key! Encrypted symmetric key bytes: ", // No I18N
          encryptedSymmetricKey);
          throw new Error("Failed to decrypt the symmetric key with asymmetric private key! Error: " + // No I18N
          error);
        });
      });
    }

    /**
     * Merge the symmetric key and IV, so they can be exported together
     * @param keyBytes
     * @param IVBytes
     * @return {Uint8Array}
     */

  }, {
    key: "mergeSymmetricKeyAndIV",
    value: function mergeSymmetricKeyAndIV(keyBytes, IVBytes) {
      if (keyBytes.constructor === ArrayBuffer) {
        keyBytes = new Uint8Array(keyBytes);
      }
      var keyAndIV = new Uint8Array(keyBytes.length + IVBytes.length);
      keyAndIV.set(keyBytes);
      keyAndIV.set(IVBytes, keyBytes.length);
      return keyAndIV;
    }

    /**
     *
     * @param {ArrayBuffer} symmetricKeyData
     * @return {Promise<{key: CryptoKey, iv: Uint8Array}>}
     */

  }, {
    key: "importSymmetricKeyAndIV",
    value: function importSymmetricKeyAndIV(symmetricKeyData) {
      var _this6 = this;

      var symmetricKeyArray = new Uint8Array(symmetricKeyData);
      var symmetricKeyBytes = this.extractSymmetricKeyBytes(symmetricKeyArray);
      var decryptedIVBytes = this.extractIVBytes(symmetricKeyArray);
      this.logger.debug("IV Bytes extracted: ", decryptedIVBytes); // No I18N
      return this.importSymmetricKey(symmetricKeyBytes).then(function (importedSymmetricKey) {
        _this6.logger.debug("AES Key imported: ", importedSymmetricKey); // No I18N
        return {
          key: importedSymmetricKey,
          iv: decryptedIVBytes
        };
      });
    }

    /**
     *
     * @param {CryptoKey} symmetricKey
     * @param {Uint8Array} IVBytes
     * @return {Promise<Uint8Array>}
     */

  }, {
    key: "exportSymmetricKeyAndIV",
    value: function exportSymmetricKeyAndIV(symmetricKey, IVBytes) {
      var _this7 = this;

      return this.exportSymmetricKey(symmetricKey).then(function (symmetricKeyBytes) {
        var keyAndIV = _this7.mergeSymmetricKeyAndIV(symmetricKeyBytes, IVBytes);
        _this7.logger.debug("Symmetric key exported: ", keyAndIV); // No I18N
        return keyAndIV;
      });
    }

    /**
     *
     * @param {Uint8Array} keyAndIV
     * @param {CryptoKey} publicKey
     * @return {Promise<ArrayBuffer>}
     */

  }, {
    key: "encryptSymmetricKeyAndIV",
    value: function encryptSymmetricKeyAndIV(keyAndIV, publicKey) {
      var _this8 = this;

      // Encrypt the key with RSA Public Key
      return this.encryptWithPublicKey(keyAndIV, publicKey).then(function (encryptedSymmetricKey) {
        _this8.logger.debug("Symmetric key encrypted: ", encryptedSymmetricKey); // No I18N
        return encryptedSymmetricKey;
      });
    }

    /**
     *
     * @param {String} encryptedSymmetricKey
     * @param {CryptoKey} privateKey
     * @return {Promise<ArrayBuffer>}
     */

  }, {
    key: "decryptSymmetricKeyAndIV",
    value: function decryptSymmetricKeyAndIV(encryptedSymmetricKey, privateKey) {
      var _this9 = this;

      return this.decryptWithPrivateKey(encryptedSymmetricKey, privateKey).then(function (symmetricKeyData) {
        _this9.logger.debug("AES Key Data decrypted: "); // No I18N
        return symmetricKeyData;
      });
    }

    /**
     *
     * @param {String|Uint8Array|ArrayBuffer} data
     * @param {CryptoKey} key
     * @param {RsaOaepParams,AesGcmParams} algorithm
     * @return {Promise<ArrayBuffer>}
     */

  }, {
    key: "_encrypt",
    value: function _encrypt(data, key, algorithm) {
      var dataArrayBuffer = this.convertToBinary(data);
      return crypto.subtle.encrypt(algorithm, key, dataArrayBuffer);
    }

    /**
     *
     * @param {String|Uint8Array|ArrayBuffer} data
     * @param {CryptoKey} key
     * @param {RsaOaepParams,AesGcmParams} algorithm
     * @return {Promise<ArrayBuffer>}
     */

  }, {
    key: "_decrypt",
    value: function _decrypt(data, key, algorithm) {
      var dataArrayBuffer = this.normalizeBinaryData(data);
      return crypto.subtle.decrypt(algorithm, key, dataArrayBuffer);
    }

    /**
     * Encrypt the given payload using symmetric key encryption
     * @param {String|Uint8Array|ArrayBuffer} data
     * @param {String|Uint8Array|ArrayBuffer|Object} [symmetricKey]
     * @return {Promise<{key:Uint8Array, data: ArrayBuffer|ArrayBuffer[]}>}
     */

  }, {
    key: "encrypt",
    value: function encrypt(data, symmetricKey) {
      var _this10 = this;

      this.logger.debug("Encryption started: "); // No I18N
      return this.getSymmetricKey(symmetricKey).then(function (_ref) {
        var key = _ref.key,
            iv = _ref.iv;

        var symmetricKeyAlgorithm = _this10.getSymmetricEncryptionAlgorithmForUsage(iv);
        _this10.logger.debug("Symmetric Encryption Algorithm: ", // No I18N
        symmetricKeyAlgorithm);
        return _this10.exportSymmetricKeyAndIV(key, iv).then(function (keyAndIV) {
          var dataArray = Array.isArray(data) ? data : [data];
          var promiseArray = dataArray.map(function (eachData, index) {
            _this10.logger.debug("Started encrypting data in " + index + ": ", eachData);
            return _this10._encrypt(eachData, key, symmetricKeyAlgorithm).then(function (encryptedData) {
              _this10.logger.debug("Finished encrypting data in " + index + ": ", encryptedData);
              return encryptedData;
            }).catch(function (error) {
              throw new Error("Failed to encrypt the data using Symmetric Encryption: " + // No I18N
              error);
            });
          });
          return Promise.all(promiseArray).then(function (encryptedData) {
            _this10.logger.debug("Encryption finished: "); // No I18N
            return {
              key: keyAndIV,
              data: encryptedData.length === 1 ? encryptedData[0] : encryptedData
            };
          });
        });
      });
    }

    /**
     * Decrypt the given payload using the given encrypted symmetric key
     * @param {String|Uint8Array|ArrayBuffer|Array} encryptedData
     * @param {ArrayBuffer} symmetricKeyData
     * @return {Promise<ArrayBuffer|Array<ArrayBuffer>>}
     */

  }, {
    key: "decrypt",
    value: function decrypt(encryptedData, symmetricKeyData) {
      var _this11 = this;

      this.logger.debug("Decryption started: "); // No I18N
      return this.importSymmetricKeyAndIV(symmetricKeyData).then(function (_ref2) {
        var key = _ref2.key,
            iv = _ref2.iv;

        var symmetricKeyAlgorithm = _this11.getSymmetricEncryptionAlgorithmForUsage(iv);
        if (!Array.isArray(encryptedData)) {
          encryptedData = [encryptedData];
        }
        var promiseArray = encryptedData.map(function (eachData, index) {
          _this11.logger.debug("Started decrypting data in " + index + ": ", eachData);
          return _this11._decrypt(eachData, key, symmetricKeyAlgorithm).then(function (decryptedData) {
            _this11.logger.debug("Completed decrypting data in " + index + ": ", decryptedData);
            return decryptedData;
          }).catch(function (error) {
            throw new Error("Decryption error! Error: " + error); // No I18N
          });
        });
        return Promise.all(promiseArray).then(function (data) {
          _this11.logger.debug("Decryption finished: "); // No I18N
          return data.length === 1 ? data[0] : data;
        });
      });
    }
  }]);

  return PayloadEncryptAgent;
}();

var responseKeyPair = {
  privateKey: "MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCIDx6RJqiLUYUOLGBMW2VpmrPnGfnBfH7WWenVyKul0Y3se6LpXJdSf5YwrB7355tM/g3NCzvE2VqJfOAYbi69T3diOfWKtv0M0Xqx0djSr1xpSsO7sYxFAa86Teq/bSwrGBjLrUrTDHoNK3HMYt9u/IMLKGGeZC74KlxWG2kexQS7ADPaUvtt+sbm+4J00hbUZ+6LcCyb+w183zXMPVG5hFC03hyfzVeIDn+wIYP0SCuTIAZordcj+R1E4Nsbf8BgWEUKTJlxvDSSl5tfICV/Z09pZdoBbvru2Lch5lMAiQknskgO7GC0K2EkjEreYGr7k9/jU0i+reDj+aCaKMAhAgMBAAECggEAdZDC8994obGWDDIyH6iVz5OawiWC1zqxCpz03gKgtw6E2QPYOFcGdoXCjFoeBE4/tl6MJFIBmk3J2qVpqhKDFpe0685zKiKGM+5KW56dASf/7QdqbCO1tecHt5SeNDysfqw6uLwLvKO6TujsUxRYRrmwrhJ9j3S31T4dPVZAFhIas9yNCFtVVSoejrsZBTCoccHuOCRzlvYGawBHtRPLQjXfWNjdfcbK6aU7RH3ORagJG3wiJ+GUnlPwwCCxJJaX5E6lYoP/JQfm0S8NOsN57Sm0RpQ7XruU1jSsYPBaoxzu5y5jaOPiSvgndMWBT6Y51Q9TJgH2ef5VzNvhxq94AQKBgQDGCRazu4LhRrm0bY+Ci6T0aqoV18c7lB3K1eKYFUI+dYAJHSoyqKAKG0rV/PxqVzK+rKRLl9+HSIV+G1e2TL9h5oraQAp5p46eXFj+0Lk2y4Z1nVODBmniWMk87/agp7izVLps17mrEaXpA5SyIKo5Sp2mXD3RljcJ+0uUcwjJQQKBgQCv4hnirz7+wq064pU03nWUW9WZHS2OWiDbH+3cqvHMH8mhduQUdz7pasGpH1U0k8PmqWdZBlvWdcZvaQkKdJoPEixOmTrn/ulI8KQEVnOIa4W+fJLctMPBqNZBvQdozq/uX3t3yFmx3YOLyhgPH2ezKVP2yawsOnwAxO6XKQpe4QKBgH6kFUZ+5SWXCu7dGWcMUkKTa41oXdo10A+EU9GZ1rEGhwhNBE09FIsiBOtvSyPd+2+AC9jjmGh08hlA9wh3b/P1cFo9lfVSN5wBxk+9vpPR93yDTYJ+uXur95Tmh7sZRr43srgkBHHnaUfnqFF5HiJhGwvl9Qpwm2Xgs+aM4dOBAoGBAJfHKwVmq5sXjnwRSiccjiTf9vyxpD2C43WVISPbVNwM1mgC/CH5IY42dTan9lRv648iwy+dACWa7wn3fzjJlKTKzvdo3d+UJ+as2y1vGTYxa3INeIMDbyawt2x1Xm6AZmvzc83TVCvcd4drd8WdGVUPpgiC0pQ8SAQ17Zr+bJehAoGADTgia4vtIj14cSkoR0qjK28zkrm4CPmyaB3ds2f3k7C4rrT/Z5j0SmSuv2rj1GfLCg4NrtzNhDkIsW0nIZithu7cClZFM37ZHIevpgCK3h8AV9v1M9mwVxHx8oue2fHTbuW+xZbX6mYF9/QaXqmAbKd1jDriyrgOh0Xn6k/Xet8=", // No I18N
  publicKey: "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAiA8ekSaoi1GFDixgTFtlaZqz5xn5wXx+1lnp1cirpdGN7Hui6VyXUn+WMKwe9+ebTP4NzQs7xNlaiXzgGG4uvU93Yjn1irb9DNF6sdHY0q9caUrDu7GMRQGvOk3qv20sKxgYy61K0wx6DStxzGLfbvyDCyhhnmQu+CpcVhtpHsUEuwAz2lL7bfrG5vuCdNIW1Gfui3Asm/sNfN81zD1RuYRQtN4cn81XiA5/sCGD9EgrkyAGaK3XI/kdRODbG3/AYFhFCkyZcbw0kpebXyAlf2dPaWXaAW767ti3IeZTAIkJJ7JIDuxgtCthJIxK3mBq+5Pf41NIvq3g4/mgmijAIQIDAQAB", // No I18N
  algorithm: "RSA_2048" // No I18N
};

var requestKeyPair = {
  privateKey: "MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDVDVF6vdb0wKcdJY9G0Oe4X4slqAcZID4Zr1t6GHqTMDU/GTEjWsHgYC5c5vxg+WWP3I0tbLmu7e9Jkz+FIeVFKQz08DoxmPW9/SIvMOlKZzukmGo6r2mR/3OIyT9VICnvIEh2k9GlkiYdOIgOrNpwu+ZSCq6CzTc5YC3p+rpJAi8Fet7Ynan7uI/ysB99HsZnH450rCTMKB1AqBmIDtOgqZs0GqbRyau7BZkZV65jYecZQ0oOi3utkm+1L7U7EixEcZf+AB75TqwMdTIA4uwg3gktoOs8ZDsFgWQfkd10CK8nSs3w6onNqrfcKpiRTKF8qhBdONtPsElqR410572TAgMBAAECggEBAKyV0lhMqnGwEm/Q+kSSe/NmKlEB0WYwMT4bSE4awEi1d5y6qoyKO52oLEaDsxRXU0d7kT2n4q7q/bkrN/x/3brtqxpL88gzsXYLNYLm60SjZbRK51rMuAdV2OCIre4mVPHpw+mSivTF9GwdXFIPAhDqlYQGNSGuXbrzx53PxtHWIaP+nFU/LBMONatyq/h0iNj5HLByLLURgWkPWIiz4W5t4K12OndWAjGenR19DdbnVk5eHWwau1bSZCm750tV+qMemVUVCcSgiiQdzG51rUfvJfTFnyXq0W2qlEKmLFmWfKwrsbk+cE6ZMfE44FxYojywSoKZJ+p2cKRoP1ZGk2ECgYEA6g9hwuMeAW0WnfdnO7NrVSuPsRywRMscArJBA6wJgtnk4OCD1bh+y3obQXafOw5nEUytmOT8LJvCxfqfdL6TsNMglykU4c7ePsbmTo4558iykceI0zD/Dmsr6GncJlG/W9pJE/rXHLKcyVwGlkA141nt6thSRjz0SlK4XC0dEoMCgYEA6QXRH5rsQpBi77FXVHcP9R6GBjy19q5kCro44c8/90qZHwPVCpl50QW63/wNwuk/pnPVBYYV2Q+JVTdYK7xWVWaTlGYdd3ACxM8M/QNsd5vWDGRk2jQTFM7u6bNaxBKgBASDtNXtHK2HIKJCASTXYyQqILs5IlBnAa/iiewje7ECgYBYiCrtQWT3GyEj7RGiNlJR6+E1F+ngi4bzyiLnVapfUTXOjX2wWFG1e2FV2J2QA/meRIehPnPYF66Lnim0SeWpS6KXKpXYd5v+2NMCQa/LaVGJ7JRnda/z7zuzdF8uK1ubTay4nvfAxhqh22ouaOk5LqncW6h7ItEwT6umSfYmKwKBgQCI7QAbYD+gRZO9YSn92hCoao06sQYDtCnZG+A84DmoKE+dp/TRy6mHJ6TN5SB4/fKG7t2n50iDSdvbFTBcUskwWZwywWZjPpCB8WCidBaSmiHHGl8g0SS9P3OoI9ocCQ26DqUN5/7ysQ0MIgxC+9EM0r1mil1iSnicxyuI/BdFoQKBgQDQlKmcSjgft/2EhwN16Ck8+RWQluEG+nmoI/WB+LU56+TQzc3GGXQHjwDnrfX9vGgdBcI62Dk+S+d7HS8YY8XOAPugJ4/G1gABLjniG1N0GyeJmjjP2M+sLmljtxyLVwdz/PXVdT+7mnuwTt3TLEJUcI+EVL4D8oq6L7vwbcYzdQ==", // No I18N
  publicKey: "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1Q1Rer3W9MCnHSWPRtDnuF+LJagHGSA+Ga9behh6kzA1PxkxI1rB4GAuXOb8YPllj9yNLWy5ru3vSZM/hSHlRSkM9PA6MZj1vf0iLzDpSmc7pJhqOq9pkf9ziMk/VSAp7yBIdpPRpZImHTiIDqzacLvmUgqugs03OWAt6fq6SQIvBXre2J2p+7iP8rAffR7GZx+OdKwkzCgdQKgZiA7ToKmbNBqm0cmruwWZGVeuY2HnGUNKDot7rZJvtS+1OxIsRHGX/gAe+U6sDHUyAOLsIN4JLaDrPGQ7BYFkH5HddAivJ0rN8OqJzaq33CqYkUyhfKoQXTjbT7BJakeNdOe9kwIDAQAB", // No I18N
  algorithm: "RSA_2048" // No I18N
};

/** @format */

var SCOPES = {
  ORG: "org", // No I18N
  COMMON: "common" // No I18N
};
var constants = {
  WAF_ENCRYPTION_HANDSHAKE_URL: "/zwaf/encryption/handshake", // No I18N
  WAF_ENCRYPTION_KEY_HEADER: "Waf-Encryption-Key", // No I18N
  WAF_ENCRYPTION_ID_HEADER: "Waf-Encryption-Id", // No I18N
  WAF_CONTENT_ENCODING_HEADER: "Waf-Content-Encoding" // No I18N
};

function factory(baseConfig) {
  var encryptAgent = new PayloadEncryptAgent();
  var _initPromise = null;
  var _isInitialized = false;
  var _config = null;
  var _clientKeyPair = null;
  var _serverKeyPair = null;
  var _clientKeyExpiry = null;
  var _wafEncryptionId = null;
  var _forced = false;
  /**
   * Encrypt the given payload using AES-GCM. publicKeyData contains the keyID, followed by version and
   * publicKey.
   *
   * @param {String|Array<String>|Uint8Array|Array<Uint8Array>|ArrayBuffer|Array<ArrayBuffer>} data
   * @param {Object} keyIV
   * @param {CryptoKey} publicKey
   *
   * @return {Promise<Object>}
   */
  function _encrypt(data, keyIV, publicKey) {
    var encryptPromise = encryptAgent.encrypt(data, keyIV).then(function (_ref) {
      var key = _ref.key,
          data = _ref.data;

      return encryptAgent.encryptSymmetricKeyAndIV(key, publicKey).then(function (encryptedKeyData) {
        var exportedBinaryDataAndKey = encryptAgent.exportBinary([encryptedKeyData, data]);
        return {
          key: exportedBinaryDataAndKey[0],
          data: exportedBinaryDataAndKey[1]
        };
      });
    });
    return encryptPromise.then(function (result) {
      encryptAgent.logger.debug("Encryption complete: ", data); // No I18N
      return result;
    }).catch(function (error) {
      throw Error("Error while encrypting data: " + error); // No I18N
    });
  }

  /**
   * @param {String|Array} encryptedData
   * @param {String} encryptedAESKey
   * @param {CryptoKey} privateKey
   * @return {Promise<ArrayBuffer|Array<ArrayBuffer>>}
   */
  function _decrypt(encryptedData, encryptedAESKey, privateKey) {
    var decryptPromise = encryptAgent.decryptSymmetricKeyAndIV(encryptedAESKey, privateKey).then(function (key) {
      return encryptAgent.decrypt(encryptedData, key);
    });
    return decryptPromise.catch(function (error) {
      throw Error("Error while decrypting data: " + error); // No I18N
    });
  }

  /**
   * Returns a DecompressionStream.
   * In case of old Firefox browsers where it is not available, we use the alternate package
   * @return {DecompressionStream|{prototype: DecompressionStream, new(format: CompressionFormat): DecompressionStream}}
   */
  function getDecompressionStream() {
    if (DecompressionStream) {
      return DecompressionStream;
    }
    return streamsCompression.DecompressionStream;
  }

  /**
   * Used to decompress Gzipped content
   * Called after decryption is performed based on whether the "decompress" flag is enabled
   * Decompression is performed through a Decompression Stream and is read recursively until the stream is closed
   * @param compressedContent
   * @return {Promise<ArrayBuffer>}
   */
  function decompressGzipContent(compressedContent) {
    return new Promise(function (resolve, reject) {
      encryptAgent.logger.debug("Decompressing data"); // No I18N
      var gzipBlob = new Blob([compressedContent]);
      var decompressionStream = getDecompressionStream();
      var decompressionStreamInstance = new decompressionStream("gzip"); // No I18N
      var response = new Response(gzipBlob);
      var decompressedStream = response.body.pipeThrough(decompressionStreamInstance);
      var reader = decompressedStream.getReader();
      var result = [];

      function readDecompressedStream() {
        try {
          return reader.read().then(function (_ref2) {
            var done = _ref2.done,
                value = _ref2.value;

            // Check if there's data to read
            if (!done) {
              // Push the Uint8Array to the result array for merging after reading is complete
              encryptAgent.logger.debug("Partial decompressed content:", value); // No I18N
              result.push(value);
              // Continue reading recursively
              return readDecompressedStream();
            }
            encryptAgent.logger.debug("Decompression complete"); // No I18N
            resolve(result);
          });
        } catch (error) {
          reject("Error while decompressing data: " + error); // No I18N
        }
      }

      // Start reading the stream
      return readDecompressedStream();
    }).then(function (arrayOfReadChunks) {
      var totalLength = 0;
      for (var i = 0; i < arrayOfReadChunks.length; i++) {
        totalLength += arrayOfReadChunks[i].length;
      }
      var resultUint8Array = new Uint8Array(totalLength);
      var offset = 0;
      for (var _i = 0; _i < arrayOfReadChunks.length; _i++) {
        resultUint8Array.set(arrayOfReadChunks[_i], offset);
        offset += arrayOfReadChunks[_i].length;
      }
      return resultUint8Array.buffer;
    });
  }

  /**
   * The return value of the decrypt function can vary based on the flags set.
   * This function handles that in a single place.
   * It can return the binary data as an ArrayBuffer directly. It can perform decompression for gzipped content.
   * It can also convert the data back to string format, which is the default behaviour.
   * @param response
   * @param config
   * @return {Promise<string>|Promise<Awaited<unknown>>}
   */
  function handleDecryptionResponse(response, config) {
    var promise = Promise.resolve(response);
    if (config && config.decompress === true) {
      promise = decompressGzipContent(response);
    }
    if (config && config.returnBinary === true) {
      return promise;
    }
    try {
      return promise.then(function (value) {
        if (!Array.isArray(value)) {
          return new TextDecoder().decode(value);
        } else {
          return value.map(function (each) {
            return new TextDecoder().decode(each);
          });
        }
      });
    } catch (error) {
      encryptAgent.logger.error(error);
      encryptAgent.logger.debug(value);
      throw new Error("Failed to decode the decrypted content as string!"); // No I18N
    }
  }

  /**
   * Create a unique string to store the given property
   * This is scoped to ZWAF and the particular tag for which the encrypt agent is initialized
   * Default Tag value is domain. But Teams can customise this to include the org ID or similar value
   * @param name
   * @return {string}
   */
  function getStorageKeyName(name) {
    var localStoragePrefix = "_zwaf"; // No I18N
    var localStorageDelimiter = "__";
    return localStoragePrefix + localStorageDelimiter + _config.tag + localStorageDelimiter + name;
  }

  /**
   * Determine whether a handshake is needed based on the given factors
   *
   * @return {boolean}
   */
  function isHandshakeNeeded() {
    // Need to make handshake if any one of these checks fail
    var serverIDInLocalStorage = getFromLocalStorage(getStorageKeyName(_config.serverIDCookie));
    var serverIDInCookie = getCookie(_config.serverIDCookie);
    return !(
    // Check if clientKey is active
    hasInLocalStorage(getStorageKeyName(_config.clientKeyExpiry)) && isClientKeyActive() &&
    // Check if clientPrivateKey present in LocalStorage
    hasInLocalStorage(getStorageKeyName(_config.clientPrivateKey)) &&
    // Check if serverPublicKey present in LocalStorage
    hasInLocalStorage(getStorageKeyName(_config.serverPublicKey)) &&
    // Check if clientID present in LocalStorage
    // TODO: Is this check needed? Any scenario to check clientID cookie in LocalStorage
    hasInLocalStorage(getStorageKeyName(_config.clientIDCookie)) &&
    // Check if clientID present in Cookie
    hasCookie(_config.clientIDCookie) &&
    // Check if serverID present in LocalStorage
    serverIDInLocalStorage &&
    // Check if serverID present in Cookie
    serverIDInCookie &&
    // Check if serverID present in Cookie matches the serverID stored in LocalStorage
    // Because if server has changed the key, we need to know about it.
    serverIDInLocalStorage === serverIDInCookie);
  }

  /**
   * Export and share the Client Public key along with the key information like algorithm and size
   * @param clientPublicKey {ArrayBuffer}
   * @return {Promise<Object>}
   */
  function fetchDetailsFromServer(clientPublicKey) {
    var url = _config.handshakeURL;
    return configuration.getCSRFDetails().then(function (detail) {
      var csrfParamName = detail[0];
      var csrfValue = getCookie(detail[1]);
      var formData = new FormData();
      formData.append("scope", _config.scope); // No I18N
      formData.append("size", _config.keySize); // No I18N
      formData.append("algorithm", _config.algorithm); // No I18N
      formData.append("data", JSON.stringify({ "client-public-key": encryptAgent.exportBinary(clientPublicKey) })); // No I18N
      formData.append(csrfParamName, csrfValue);
      return fetch(url, {
        method: "POST", // No I18N
        headers: _config.handshakeHeaders || {},
        body: formData
      }).then(function (response) {
        return response.json();
      }).then(function (response) {
        var serverPublicKeyData = response[_config.serverPublicKey]; // Name of the server public key prop in the handshake response
        if (!serverPublicKeyData) {
          throw new Error("Failed to fetch Server Public Key!"); // No I18N
        }
        return response;
      });
    });
  }

  /**
   * To get client key pair
   * @return {Promise<boolean>}
   */
  function initializeClientKeyPair() {
    // TODO: We currently only maintain a single client key pair in memory since key size is fixed
    // Need to handle multiple key sizes which fetching existing key, etc. If such cases do exist.
    var clientKeyPairPromise = void 0;
    var storeClientKeyPair = false;
    //common scope, use hard-coded key pairs
    if (_config.scope === SCOPES.COMMON) {
      // If already loaded into memory, no need to import from LocalStorage again!
      if (_clientKeyPair) {
        clientKeyPairPromise = Promise.resolve(_clientKeyPair);
      } else {
        clientKeyPairPromise = importAsymmetricKeyPair(responseKeyPair);
      }
    }
    // generate new key pair
    else if (!isClientKeyActive() || _forced || isHandshakeNeeded()) {
        clientKeyPairPromise = encryptAgent.generateAsymmetricKeyPair(_config.algorithm, _config.keySize);
        storeClientKeyPair = true;
      }
      // load from localStorage
      else {
          // If already loaded into memory, no need to import from LocalStorage again!
          if (_clientKeyPair) {
            clientKeyPairPromise = Promise.resolve(_clientKeyPair);
          } else {
            var clientPublicKey = getFromLocalStorage(getStorageKeyName(_config.clientPublicKey));
            var clientPrivateKey = getFromLocalStorage(getStorageKeyName(_config.clientPrivateKey));
            var clientKeyPairFromLS = normalizeKeyPair(clientPublicKey, clientPrivateKey);

            clientKeyPairPromise = importAsymmetricKeyPair(clientKeyPairFromLS);
          }
        }
    //store in memory variable
    return clientKeyPairPromise.then(function (clientKeyPair) {
      _clientKeyPair = clientKeyPair;
      encryptAgent.logger.info("Client Key Pair stored in memory !"); // No I18N
      return storeClientKeyPair;
    });
  }

  /**
   * To get server key pair
   * @return {Promise<boolean>}
   */
  function initializeServerKeyPair(handshake) {
    // TODO: We currently only maintain a single client key pair in memory since key size is fixed
    // Need to handle multiple key sizes which fetching existing key, etc. If such cases do exist.
    var serverKeyPairPromise = void 0;
    var storeServerKeyPair = false;

    //common scope, use hard-coded key pairs
    if (_config.scope === SCOPES.COMMON) {
      // If already loaded into memory, no need to import from LocalStorage again!
      if (_serverKeyPair) {
        serverKeyPairPromise = Promise.resolve(_serverKeyPair);
      } else {
        serverKeyPairPromise = importAsymmetricKeyPair(requestKeyPair);
      }
    }
    //fetch from server
    else if (handshake) {
        storeServerKeyPair = true;
        serverKeyPairPromise = encryptAgent.exportAsymmetricPublicKey(_clientKeyPair.publicKey).then(function (exportedClientPublicKey) {
          _clientKeyExpiry = null;
          _wafEncryptionId = null;
          return fetchDetailsFromServer(exportedClientPublicKey).then(function (response) {
            _clientKeyExpiry = response[_config.clientKeyExpiry] || -1;
            _wafEncryptionId = response[_config.wafEncryptionId] || null;
            var serverPublicKey = response[_config.serverPublicKey];
            var serverPrivateKey = null;
            var serverKeyPair = normalizeKeyPair(serverPublicKey, serverPrivateKey);
            return importAsymmetricKeyPair(serverKeyPair);
          });
        });
      }
      //load from localStorage
      else {
          // If already loaded into memory, no need to import from LocalStorage again!
          if (_serverKeyPair) {
            serverKeyPairPromise = Promise.resolve(_serverKeyPair);
          } else {
            var serverPublicKey = getFromLocalStorage(getStorageKeyName(_config.serverPublicKey));
            var serverPrivateKey = null;
            var serverKeyPair = normalizeKeyPair(serverPublicKey, serverPrivateKey);
            serverKeyPairPromise = importAsymmetricKeyPair(serverKeyPair);
          }
        }
    //store in memory variable
    return serverKeyPairPromise.then(function (serverKeyPair) {
      _serverKeyPair = serverKeyPair;
      encryptAgent.logger.info("Server Key Pair stored in memory !"); // No I18N
      return storeServerKeyPair;
    });
  }

  /**
   * Import Asymmetric Key Pair
   * @param keyPair
   * @return {Promise<CryptoKeyPair>}
   */
  function importAsymmetricKeyPair(keyPair) {
    return encryptAgent.importAsymmetricPublicKey(keyPair.publicKey).then(function (importedPublicKey) {
      return encryptAgent.importAsymmetricPrivateKey(keyPair.privateKey).then(function (importedPrivateKey) {
        return normalizeKeyPair(importedPublicKey, importedPrivateKey);
      });
    });
  }

  /**
   * Normalize Key Pair
   * @param publicKey
   * @param privateKey
   * @return {{privateKey, publicKey}}
   */
  function normalizeKeyPair(publicKey, privateKey) {
    return {
      publicKey: publicKey,
      privateKey: privateKey
    };
  }

  /**
   * Trigger a handshake request based on the given config. Once it is called, it returns a client key pair
   * which can be the default hardcoded one, already created one from LocalStorage or create a new one.
   * The server public key is obtained through server call, along with the client id, server id and client key expiry.
   * @return {Promise<boolean>}
   */
  function initializeHandshake() {
    return initializeClientKeyPair().then(function (storeClientKeyPair) {
      return initializeServerKeyPair(storeClientKeyPair).then(function (storeServerKeyPair) {
        if (storeServerKeyPair || storeClientKeyPair) {
          // update localStorage if it's new from server
          return storeDetailsInLocalStorage().then(function (isDetailsStoredInLocalstorage) {
            return isDetailsStoredInLocalstorage;
          });
        }
        encryptAgent.logger.debug("Handshake not needed, ignoring this init call!"); // No I18N
        return true;
      });
    });
  }

  /**
   * Determine whether the existing private key from our LocalStorage is active
   * @return {boolean}
   */
  function isClientKeyActive() {
    // get Client key expiry from localStorage
    var clientKeyExpiry = getFromLocalStorage(getStorageKeyName(_config.clientKeyExpiry));
    // Client Expiry time in secs
    var clientExpiryTime = Number(clientKeyExpiry);
    // Check if its valid number
    if (!clientExpiryTime) {
      return false;
    }
    var clientExpiryUnixTime = clientExpiryTime * 1000; // Convert to milliseconds
    var currentUnixTime = Date.now(); // Current time in milliseconds
    // Check if expiry time is greater than current time
    return clientExpiryUnixTime > currentUnixTime;
  }

  /**
   * Handles and stores details like ClientKeyPair, ServerKeyPair and ClientKeyExpiry
   * LocalStorage would then contain,
   *      1. Server ID
   *      2. Server Public Key
   *
   *      4. Client ID
   *      3. Client Expiry Time
   *      5. Client Public Key
   *      6. Client Private Key
   *
   * @return {Promise<boolean>}
   */
  function storeDetailsInLocalStorage() {
    // TODO:
    //  If we are unable to store any of the details in LocalStorage (due to storage constraints, etc),
    //  we need to handle it without LocalStorage. No solution for now - discuss later
    var promiseArray = [];

    // Store Server ID
    try {
      var serverID = getCookie(_config.serverIDCookie);
      setToLocalStorage(getStorageKeyName(_config.serverIDCookie), serverID);
    } catch (e) {
      encryptAgent.logger.error("Failed to store Server ID in localStorage!"); // No I18N
    }

    // Store Server Public Key
    try {
      var serverPublicKeyPromise = encryptAgent.exportAsymmetricPublicKey(_serverKeyPair.publicKey).then(function (serverPublicKeyData) {
        setToLocalStorage(getStorageKeyName(_config.serverPublicKey), encryptAgent.exportBinary(serverPublicKeyData));
        return true;
      });
      promiseArray.push(serverPublicKeyPromise);
    } catch (e) {
      encryptAgent.logger.error("Failed to store Server Public Key in localStorage!"); // No I18N
    }

    // Store Client ID
    try {
      var clientID = getCookie(_config.clientIDCookie);
      setToLocalStorage(getStorageKeyName(_config.clientIDCookie), clientID);
    } catch (e) {
      encryptAgent.logger.error("Failed to store Client ID in localStorage!"); // No I18N
    }

    // Store Client Expiry Time
    var clientKeyExpiry = _clientKeyExpiry + Math.floor(Date.now() / 1000); // Current time in seconds + given expiry time
    try {
      setToLocalStorage(getStorageKeyName(_config.clientKeyExpiry), clientKeyExpiry);
    } catch (e) {
      encryptAgent.logger.error("Failed to store Client Expiry time in localStorage!"); // No I18N
    }

    // Store Waf Encryption ID
    try {
      if (_wafEncryptionId) {
        setToLocalStorage(getStorageKeyName(_config.wafEncryptionId), _wafEncryptionId);
      }
    } catch (e) {
      encryptAgent.logger.error("Failed to store Waf Encryption ID in localStorage!"); // No I18N
    }

    // Store Client Public Key
    try {
      var clientPublicKeyPromise = encryptAgent.exportAsymmetricPublicKey(_clientKeyPair.publicKey).then(function (clientPublicKeyData) {
        setToLocalStorage(getStorageKeyName(_config.clientPublicKey), encryptAgent.exportBinary(clientPublicKeyData));
        return true;
      });
      promiseArray.push(clientPublicKeyPromise);
    } catch (e) {
      encryptAgent.logger.error("Failed to store Client Public Key in localStorage!"); // No I18N
    }

    // Store Client Private Key
    try {
      var clientPrivateKeyPromise = encryptAgent.exportAsymmetricPrivateKey(_clientKeyPair.privateKey).then(function (clientPrivateKeyData) {
        setToLocalStorage(getStorageKeyName(_config.clientPrivateKey), encryptAgent.exportBinary(clientPrivateKeyData));
        return true;
      });
      promiseArray.push(clientPrivateKeyPromise);
    } catch (e) {
      encryptAgent.logger.error("Failed to store Client Private Key in localStorage!"); // No I18N
    }

    return Promise.all(promiseArray).then(function (res) {
      encryptAgent.logger.info("Key details stored in localStorage!"); // No I18N
      return true;
    });
  }

  /**
   * Delete the stored handshake details from LocalStorage
   * Maybe exposed to service team later
   */
  function deleteHandshakeDetails() {
    // LocalStorage entries to be deleted
    var localStorageEntriesToBeDeleted = [_config.serverIDCookie, _config.serverPublicKey, _config.clientIDCookie, _config.clientKeyExpiry, _config.clientPublicKey, _config.clientPrivateKey];
    var cookieEntriesToBeDeleted = [_config.serverIDCookie, _config.clientIDCookie];
    localStorageEntriesToBeDeleted.forEach(function (key) {
      var storageKeyName = getStorageKeyName(key);
      try {
        if (hasInLocalStorage(storageKeyName)) {
          deleteFromLocalStorage(storageKeyName);
        }
      } catch (e) {
        encryptAgent.logger.error("Failed to delete " + key + " from localStorage!"); // No I18N
      }
    });
    cookieEntriesToBeDeleted.forEach(function (key) {
      try {
        if (hasCookie(storageKeyName)) {
          deleteCookie(storageKeyName);
        }
      } catch (e) {
        encryptAgent.logger.error("Failed to delete " + key + " from localStorage!"); // No I18N
      }
    });

    return true;
  }

  /**
   * Used to get the Server Public Key from memory for Request Encryption
   *  When using hardcoded keys (common scope), we can return the Client Public Key for Response Encryption
   * @param [encryptAsServer]
   * @return {Promise<CryptoKey>}
   */
  function getPublicKey(encryptAsServer) {
    if (!_isInitialized) {
      throw new Error("ZWAF Encryption Agent not initialized yet!"); // No I18N
    }
    var publicKey = encryptAsServer ? _clientKeyPair.publicKey : _serverKeyPair.publicKey;
    return Promise.resolve(publicKey);
  }

  /**
   * Used to get the Client Private Key from memory for Response Decryption
   *  When using hardcoded keys (common scope), we can return the Server Private Key for Request Decryption
   * @param [decryptAsServer]
   * @return {Promise<CryptoKey>}
   */
  function getPrivateKey(decryptAsServer) {
    if (!_isInitialized) {
      throw new Error("ZWAF Encryption Agent not initialized yet!"); // No I18N
    }
    var privateKey = _config.scope === SCOPES.COMMON && decryptAsServer ? _serverKeyPair.privateKey : _clientKeyPair.privateKey;
    return Promise.resolve(privateKey);
  }

  function encrypt(data, keyIV) {
    return getPendingHandshakePromise().then(function (handshakeAndStoreCompleted) {
      return getPublicKey().then(function (publicKey) {
        return _encrypt(data, keyIV, publicKey);
      });
    });
  }

  function encryptAsServer(data, keyIV) {
    return getPendingHandshakePromise().then(function (handshakeAndStoreCompleted) {
      return getPublicKey(true).then(function (publicKey) {
        return _encrypt(data, keyIV, publicKey);
      });
    });
  }

  function decrypt(data, encryptedAESKey, config) {
    return getPrivateKey().then(function (privateKey) {
      return _decrypt(data, encryptedAESKey, privateKey).then(function (decryptedBinaryContent) {
        return handleDecryptionResponse(decryptedBinaryContent, config);
      });
    });
  }

  function decryptAsServer(data, encryptedAESKey, config) {
    return getPrivateKey(true).then(function (privateKey) {
      return _decrypt(data, encryptedAESKey, privateKey).then(function (decryptedBinaryContent) {
        return handleDecryptionResponse(decryptedBinaryContent, config);
      });
    });
  }

  /**
   * Entry function to be called to initialize encryption details
   * Must be called first before using encrypt/decrypt functions
   * User can customize the tag(domain), handshake URL, algorithm, key size, scope, etc.
   * Returns whether handshake was performed or not
   * @param config
   * @return {Promise<boolean>}
   */
  function init(config) {
    _config = extend(config || {}, baseConfig);
    if (_isInitialized) {
      encryptAgent.logger.warn("Already initialized! Is this call really necessary?"); // No I18N
    }
    if (_initPromise) {
      encryptAgent.logger.debug("Init in progress so returning the same promise!"); // No I18N
      return _initPromise;
    }
    _initPromise = initializeHandshake().then(function (didHandshakeOccur) {
      _isInitialized = didHandshakeOccur;
      _initPromise = null;
      return _isInitialized;
    });
    return _initPromise;
  }

  /**
   * To be used as a fallback to force a handshake request. This bypasses existing checks and is not recommended.
   * ONLY USE THIS IF YOU ARE SURE ABOUT IT!
   * @param config
   * @return {Promise<boolean>}
   */
  function reInit(config) {
    _forced = true;
    _config = extend(config || {}, baseConfig);
    encryptAgent.logger.warn("Using forced handshake!"); // No I18N
    deleteHandshakeDetails();
    _initPromise = initializeHandshake().then(function (didHandshakeOccur) {
      _isInitialized = didHandshakeOccur;
      _initPromise = null;
      _forced = false;
      return _isInitialized;
    });
    return _initPromise;
  }

  /**
   * To get any pending handshake / store details promise while invoking user-exposed functions
   * @return {Promise<boolean>}
   */

  function getPendingHandshakePromise() {
    if (!_isInitialized && !_initPromise) {
      throw new Error("ZWAF Encryption Agent not initialized yet!"); // No I18N
    }
    if (_initPromise) {
      encryptAgent.logger.debug("Handshake in progress so returning the same promise!"); // No I18N
      return _initPromise;
    }
    _initPromise = initializeHandshake().then(function (didHandshakeOccur) {
      _isInitialized = didHandshakeOccur;
      _initPromise = null;
      return _isInitialized;
    });
    return _initPromise;
  }

  /**
   * Get a new encrypted Symmetric key
   * @return {Promise<string>}
   */
  function getKey() {
    return getReusableKey().then(function (symmetricKeyAndIv) {
      // Returning encrypted key depends on server public key received from handshake
      // so wait for handshake / store to complete and encrypt the symmetric key
      return getPendingHandshakePromise().then(function (handshakeAndStoreCompleted) {
        return encryptAgent.exportSymmetricKeyAndIV(symmetricKeyAndIv.key, symmetricKeyAndIv.iv).then(function (exportedSymmetricKey) {
          return getPublicKey().then(function (publicKey) {
            return encryptAgent.encryptSymmetricKeyAndIV(exportedSymmetricKey, publicKey).then(function (encryptedKeyData) {
              return encryptAgent.exportBinary(encryptedKeyData);
            });
          });
        });
      });
    });
  }

  /**
   * Get a new Symmetric key and iv that can be reused multiple times.
   * This will be useful when trying to encrypt queryString and body separately
   * @return {Promise<{key: CryptoKey, iv: Uint8Array}>}
   */
  function getReusableKey() {
    return encryptAgent.getSymmetricKey();
  }

  /**
   * Customise the logging level. By default, only errors are logged.
   * We can set the level to DEBUG and call encrypt/decrypt and revert back to the original level
   * Log levels can be found in ZWAF.logger.LEVELS
   * Eg:
   *    ZWAF.Encryption.setLogLevel(ZWAF.logger.LEVELS.DEBUG);
   *    ZWAF.Encryption.encrypt("data");
   *    ZWAF.Encryption.setLogLevel();
   * @param level
   */
  function setLogLevel(level) {
    encryptAgent.setLogLevel(level);
  }

  /**
   * Function to expose the PayloadEncryptAgent instance used internally
   * @return {PayloadEncryptAgent}
   */
  function getEncryptAgent() {
    return encryptAgent;
  }

  function getWafEncryptionId() {
    if (!_isInitialized && !_initPromise) {
      throw new Error("ZWAF Encryption Agent not initialized yet!"); // No I18N
    }
    if (_initPromise) {
      encryptAgent.logger.debug("Handshake in progress. Please call after Handshake is complete!"); // No I18N
      return null;
    }
    // get Waf Encryption Id from localStorage
    return getFromLocalStorage(getStorageKeyName(_config.wafEncryptionId));
  }

  /**
   * Constructor for Encryption. Can be used to create fresh instances of Encryption
   * @return {Object}
   */
  var Encryption = function Encryption(config) {
    config = extend(config || {}, defaultConf);
    return factory(config);
  };

  Encryption.SCOPES = SCOPES;
  Encryption.constants = constants;
  Encryption.encrypt = encrypt;
  Encryption.decrypt = decrypt;
  Encryption.encryptAsServer = encryptAsServer;
  Encryption.decryptAsServer = decryptAsServer;
  Encryption.init = init;
  Encryption.reInit = reInit;
  Encryption.deleteHandshakeDetails = deleteHandshakeDetails;
  Encryption.getKey = getKey;
  Encryption.getReusableKey = getReusableKey;
  Encryption.setLogLevel = setLogLevel;
  Encryption.getEncryptAgent = getEncryptAgent;
  Encryption.getWafEncryptionId = getWafEncryptionId;

  // TODO: To be deprecated soon as the asymmetric keys shouldn't be accessed by service teams!
  Encryption.getPublicKey = getPublicKey;
  Encryption.getPrivateKey = getPrivateKey;

  return Encryption;
}

var defaultConf = {
  clientIDCookie: "_zwaf_enc_clientid", // No I18N
  serverIDCookie: "_zwaf_enc_serverid", // No I18N
  serverPublicKey: "server-public-key", // No I18N
  clientKeyExpiry: "client-id-expiry", // No I18N
  clientPublicKey: "client-public-key", // No I18N
  clientPrivateKey: "client-private-key", // No I18N
  wafEncryptionId: "waf-encryption-id", // No I18N

  algorithm: "RSA-OAEP", // No I18N
  keySize: 2048,

  scope: SCOPES.COMMON,
  handshakeURL: constants.WAF_ENCRYPTION_HANDSHAKE_URL,
  // Default tag value is domain
  // Domain is taken from window.location, not from document.domain. Because it's deprecated
  // Ref: https://developer.mozilla.org/en-US/docs/Web/API/Document/domain
  tag: window && window.location && window.location.hostname || "null" // No I18N
};

var Encryption = factory(defaultConf);

if (Object.freeze) {
  Object.freeze(Encryption);
}

if (ZWAF$2.version === '7.0.0' && !ZWAF$2.Encryption) {
  ZWAF$2.defineProperty(ZWAF$2, 'Encryption', // No I18N
  Encryption, true, false, false, true);
}
if (!ZWAF$2['7_0_0'].Encryption) {
  ZWAF$2.defineProperty(ZWAF$2['7_0_0'], 'Encryption', // No I18N
  Encryption, true, false, false, true);
}

return ZWAF$2;

})));
