import { extendEventListeners } from "./lyte-utils";

const level = 0;
class Logger extends Error{ 
    static get level(){
        return level;
    }
    constructor(){
        super(...arguments);
    }
    static register(){
        var context = this;
        while(context !== Logger){
            if(!context.hasOwnProperty("addEventListener")){
                extendEventListeners(context);
            }
            context = Object.getPrototypeOf(context);
        }
        if(!Logger.triggerEvent){
            extendEventListeners(Logger);
        }
    }
    static errorCodes = {
        ERR02 : "Mandatory prop cannot be empty", 
        ERR03 : "Type of value does not match the specified data type",
        ERR04 : "Value is greater than the maximum value allowed",
        ERR05 : "Value is less than the minimum value allowed", 
        ERR06 : "Length of string/array is greater than the maximum limit allowed", 
        ERR07 : "Length of string/array is less than the minimum limit allowed",
        ERR08 : "String does not match the specified pattern", 
        ERR09 : "Values in array are not unique", 
        ERR10 : "Value is not equal to the specified constant", 
        ERR29: "Property not defined in the object",
        ERR30: "Property's value is not an instanceof the mentioned class", 
        ERR31: "Type definition for nested properties / items does not match with the value" ,     
        L001: "{0} {1} is already registered"
        // /* move to component */
        // LC001: "Error while parsing custom prop handler attribute {0}. Check if the value provided is a valid JSON",
        // LC002: "{0} Component is not compiled. Please compile using Lyte CLI",
        // LC003: "Helper named {0} is not defined",
        // LC004: "Action named {0} doesn't exists",
        // LC005: "Lyte.objectUtils doesn't support {0} function",
        // LC006: "Lyte.arrayUtils doesn't support {0} function",
        // LC007: "Component name not specified in Lyte.Component.render",
        // LC008: "Specified outlet {0} doesn't exists - Lyte.Component.render",
        // LC009: "Method named {0} doesn't exists in {1} component",
        // LC010: "Parent Node / reference Node not provided for insertBefore method",
    };
    static registerErrorCodes(obj, defineProperty){
        if(obj && typeof obj == "object"){
            for(var key in obj){
                var message = obj[key];
                if(defineProperty){
                    Object.defineProperty(this.errorCodes, key, {
                        value: message
                    });
                }
                else{
                    this.errorCodes[key] = message;
                }
            }
        }
    }
    static getErrorMessage(code, withCode){
      var args = Array.from(arguments).slice(1);
      if(this.errorCodes[code]) {
          var msg = this.errorCodes[code].replace(/{(\d+)}/g, function(t, i) {
              return args[i];
          });
          return code+": "+msg;
      } else {
          return code;
      }
    }
    static setErrorMessage(code, message, defineProperty){
        if(defineProperty){
            Object.defineProperty(this.errorCodes, code, {
                value: message
            });
        }
        else{
            this.errorCodes[code] = message;
        }
    }
    static error(){
        var args = Array.from(arguments), arg0 = arguments[0], ins, errorObj, logLevel = Logger.level, scIns;
        if(arg0.__isApp || arg0.__isAddon){
            ins = arg0;
            args.splice(0,1);
            if(ins.hasOwnProperty("logLevel")){
                logLevel = ins.logLevel;
            }
        }
        else if(arg0.$app || arg0.$addon){
            scIns = arg0;
            ins = arg0.$app || arg0.$addon;
            args.splice(0, 1);
            if(ins.hasOwnProperty("logLevel")){
                logLevel = ins.logLevel;
            }
        }
        if(logLevel < 3){
            errorObj = args[0];
            var parse = errorObj.stack, 
            context = this;
            errorObj = parse ? errorObj : new this(this.getErrorMessage.apply(this, args));
            while(context !== Logger){
                if (context.hasOwnProperty("onerror")) {
                    context.onerror.call(context, errorObj, args[1], this, ins, scIns);
                }
                if(context.hasOwnProperty("triggerEvent")){
                    context.triggerEvent.call(context, "error", errorObj, args[1], this, ins, scIns);
                }
                context = Object.getPrototypeOf(context);
            }
            if (Logger.hasOwnProperty("onerror")) {
                Logger.onerror.call(Logger, errorObj, args[1], this, ins, scIns);
            }
            if(Logger.hasOwnProperty("triggerEvent")){
                Logger.triggerEvent.call(Logger, "error", errorObj, args[1], this, ins, scIns);
            }
            if(scIns){
                // if(scIns.onerror) {
                //     scIns.onerror.call(scIns, errorObj, args[1], this, ins, scIns);
                // }
                // if(scIns.triggerEvent){
                //     scIns.triggerEvent.call(scIns, "error", errorObj, args[1], this, ins, scIns);
                // }
                var scCls = scIns.constructor;
                if(scCls.onerror) {
                    scCls.onerror.call(scCls, errorObj, args[1], this, ins, scIns);
                }
                if(scCls.triggerEvent){
                    scCls.triggerEvent.call(scCls, "error", errorObj, args[1], this, ins, scIns);
                }
                if(scIns.$registry || scIns.$router){
                    var Ins = scIns.$registry || scIns.$router;
                    // if(Ins.onerror) {
                    //     Ins.onerror.call(Ins, errorObj, args[1], this, ins, scIns);
                    // }
                    // if(Ins.triggerEvent){
                    //     Ins.triggerEvent.call(Ins, "error", errorObj, args[1], this, ins, scIns);
                    // }
                    var regcls = Ins.constructor;
                    if(regcls.onerror) {
                        regcls.onerror.call(regcls, errorObj, args[1], this, ins, scIns);
                    }
                    if(regcls.triggerEvent){
                        regcls.triggerEvent.call(regcls, "error", errorObj, args[1], this, ins, scIns);
                    }
                }
            }
            if(ins){
                if(ins.onerror) {
                    ins.onerror.call(ins, errorObj, args[1], this, ins, scIns);
                }
                if(ins.triggerEvent){
                    ins.triggerEvent.call(ins, "error", errorObj, args[1], this, ins, scIns);
                }
                var insCls = ins.constructor;
                if(insCls.onerror) {
                    insCls.onerror.call(insCls, errorObj, args[1], this, ins, scIns);
                }
                if(insCls.triggerEvent){
                    insCls.triggerEvent.call(insCls, "error", errorObj, args[1], this, ins, scIns);
                }
            }
            var safari = errorObj.stack && errorObj.stack.indexOf(errorObj.message) == -1
            if (parse && !safari) {
                errorObj = JSON.parse(JSON.stringify(errorObj, Object.getOwnPropertyNames(errorObj)));
            }
            if(args[1]) {
                console.error(errorObj.stack ? (safari ? errorObj : errorObj.stack) : errorObj.message, args[1]);
            } else {
                console.error(errorObj.stack ? (safari ? errorObj : errorObj.stack) : errorObj.message);    
            }
        }
    }
    static warn(){
        var args = Array.from(arguments), arg0 = arguments[0], ins, errorObj, logLevel = Logger.level;
        if(arg0.__isApp || arg0.__isAddon){
            ins = arg0;
            args.splice(0,1);
            if(ins.hasOwnProperty("logLevel")){
                logLevel = ins.logLevel;
            }
        }
        else if(arg0.$app || arg0.$addon){
            ins = arg0.$app || arg0.$addon;
            args.splice(0, 1);
            if(ins.hasOwnProperty("logLevel")){
                logLevel = ins.logLevel;
            }
        }
        if(logLevel < 2){
            var errorObj = args[0];
            errorObj = errorObj.stack ? JSON.parse(JSON.stringify(errorObj, Object.getOwnPropertyNames(errorObj))) : new this(this.getErrorMessage.apply(this, args));
            console.warn(errorObj.stack ? (errorObj.stack.indexOf(errorObj.message) != -1 ? errorObj.stack.replace("Error: ", "Warn: ") : errorObj) : errorObj.message);
        }
    }
    static log(){
        var args = Array.from(arguments), arg0 = arguments[0], ins, errorObj, logLevel = Logger.level;
        if(arg0.__isApp || arg0.__isAddon){
            ins = arg0;
            args.splice(0,1);
            if(ins.hasOwnProperty("logLevel")){
                logLevel = ins.logLevel;
            }
        }
        else if(arg0.$app || arg0.$addon){
            ins = arg0.$app || arg0.$addon;
            args.splice(0, 1);
            if(ins.hasOwnProperty("logLevel")){
                logLevel = ins.logLevel;
            }
        }
        if(logLevel == 0){
            var errorObj = args[0];
            errorObj = errorObj.stack ? JSON.parse(JSON.stringify(errorObj, Object.getOwnPropertyNames(errorObj))) : new this(this.getErrorMessage.apply(this, args));
            console.log(errorObj.stack ? (errorObj.stack.indexOf(errorObj.message) != -1 ? errorObj.stack.replace("Error: ", "Log: ") : errorObj) : errorObj.message);        
        }
    }
}
extendEventListeners(Logger);
export { Logger };
