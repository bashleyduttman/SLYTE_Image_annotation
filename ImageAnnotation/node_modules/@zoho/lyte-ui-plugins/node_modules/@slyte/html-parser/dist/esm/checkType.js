
/**
 * ## Check Type ( type checking library ) <vignesh.prv>
 * # Why we need this ?
 * - Increasingly we are checking types of user inputs and various values
 * - This will help us to register a type pattern well before and thus 
 * - making it easier to check the input
 * 
 * * Example : 
 * - If there is a input which is of type object and has some required keys 
 * - and some allowable keys ( if present , they have to be type checked )
 * 
 * ? tool = {
 * ?  label : String, // Required
 * ?  callback : Function, // Required
 * ?  title : String // Allowable
 * ? }
 * 
 * - We can create a type 'tool' for the above configuration, thus now we can 
 * - check for derived type 'tool'.
 * 
 * ! This will be more helpful when the types are subjected to change
 * ! Error message to the user can be verbose from this
 * 
 * # What if the value can have more than one structure ?
 * - Here, in checktype there are 2 logical operator APIs are available
 * - 'OR' & 'AND' which makes it easy to incorporate more than one structure
 * - This also helps us to atomize the types and reuse the existing type checks
 * 
 * # What is API "later" means ?
 * - As the name suggest the API "later" will get registered later.
 * - Normally, when we extend a existing type, the function on which the extension is made has 
 * - to be present.
 * - But in this case, There is no need for such thing,On registering this later will bind an 
 * - Symbol of type's label 
 * - Only on performing the check function, this Symbol will be parsed and if there is no such
 * - type registered the function will be ignored under the hood and 'false' will be returned
 * 
 * ! Once a type is registered it cannot be re-registered and delete
 * ! It will be available windowly once registered
 * 
 * # What if we need more control over the types ?
 * - On registering , There is a third argument which accepts a callback, from which more
 * - customized checks can be done
 * 
 */
import deepFreezer from "./deepFreezer.js";
export const checkType = (function () {//No I18n
  const errorMsgs = {
    //ignorei18n_start
    MISSING_KEY: function (key, object) {
      object = typeof object === 'string' ? object : JSON.stringify(object, null, 4)
      return key + " is a required key in the object.\nStringified Object for reference :\n" + object
    },
    TYPE_MUST_BE: function (type, key, additional) {
      return 'The value for the ' + key + ' should be of type ' + (Array.isArray(type) ? type.join(' | ') : type) + '. ' + (additional || '')
    },
    INVALID_VALUE: function (key, object) {
      return 'Value for ' + key + ' is invalid, Source object : ' + JSON.stringify(object, null, 2)
    },
    VALUE_EXISTS: function (type, object) {
      return type + ' already exists' + (object && ' in ' + object) + '. Please try another name'
    }
    //ignorei18n_end
  }
  // const console = 'console';//No I18n
  // const logError = window[console].error;//No I18n
  const symbolMap = {};
  let skipExistsCheck = false;
  const checkInSymbols = function (mightBeSymbol) {
    if (typeof mightBeSymbol === 'symbol') {//No I18n
      const type = symbolMap[mightBeSymbol];
      return typeChecks[type] || mightBeSymbol;
    }
    return mightBeSymbol;
  }
  const basicTypeChecks = {
    STRING: function (baseConstraints, callback) {
      baseConstraints = baseConstraints ? baseConstraints : {};
      return function (value, runTimeConstraints, onConstraintFailure) {
        const constraints = Object.assign({}, baseConstraints, runTimeConstraints);
        const constraintFailure = typeof onConstraintFailure === 'boolean' ? onConstraintFailure : false;//No I18n
        if (typeof value !== 'string') {//No I18n
          return false;
        }
        let valid = true;
        for (let key in constraints) {
          const constraint = checkInSymbols(constraints[key]);
          if (typeof constraint !== 'symbol') {//No I18n
            switch (key) {
              case 'nonEmptyString': {
                if (typeof constraint === 'boolean') {
                  if (constraint) {
                    valid = value.trim().length > 0;
                  }
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'length': {
                if (typeof constraint === 'function') {//No I18n
                  if (!constraint(value.length)) {
                    valid = false;
                  }
                } else if (typeof constraint === 'number' && constraint === constraint) {//No I18n
                  if (constraint !== value.length) {
                    valid = false;
                  }
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'allowableValues': {
                if (Array.isArray(constraint)) {
                  if (!constraint.includes(value)) {
                    valid = false;
                  }
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'matchRegex': {
                if (constraint instanceof RegExp) {
                  if (!constraint.test(value)) {
                    valid = false;
                  }
                } else if (constraintFailure) {
                  valid = false;
                }
              }
            }
          } else {
            valid = false;
          }
        }
        return (valid && callback) ? callback(value) : valid;
      }
    },
    NUMBER: function (baseConstraints, callback) {
      baseConstraints = baseConstraints ? baseConstraints : {};
      return function (value, runTimeConstraints, onConstraintFailure) {
        const constraints = Object.assign({}, baseConstraints, runTimeConstraints);
        const constraintFailure = typeof onConstraintFailure === 'boolean' ? onConstraintFailure : false;//No I18n
        if (typeof value !== 'number') {//No I18n
          return false;
        }
        let valid = true;
        for (let key in constraints) {
          const constraint = checkInSymbols(constraints[key]);
          if (typeof constraint !== 'symbol') {//No I18n
            switch (key) {
              case 'min': {
                if (typeof constraint === 'number' && constraint === constraint) {//No I18n
                  if (constraint > value) {
                    valid = false;
                  }
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'max': {
                if (typeof constraint === 'number' && constraint === constraint) {//No I18n
                  if (constraint < value) {
                    valid = false;
                  }
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'whole': {
                if (typeof constraint === 'boolean' && constraint) {//No I18n
                  if ((value - Math.floor(value)) !== 0) {
                    valid = false;
                  }
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'positive': {
                if (typeof constraint === 'boolean') {//No I18n
                  if (constraint && value < 0) {
                    valid = false;
                  }
                  if (!constraint && value > 0) {
                    valid = false;
                  }
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'allowableValues': {
                if (Array.isArray(constraint)) {
                  if (!constraint.includes(value)) {
                    valid = false;
                  }
                } else if (constraintFailure) {
                  valid = false;
                }
              }
            }
          } else {
            valid = false;
          }
        }
        return (valid && callback) ? callback(value) : valid;
      }
    },
    ARRAY: function (baseConstraints, callback) {
      baseConstraints = baseConstraints ? baseConstraints : {};
      return function (value, runTimeConstraints, onConstraintFailure) {
        const constraints = Object.assign({}, baseConstraints, runTimeConstraints);
        const constraintFailure = typeof onConstraintFailure === 'boolean' ? onConstraintFailure : false;//No I18n
        if (!Array.isArray(value)) {
          return false;
        }
        let valid = true;
        for (let key in constraints) {
          const constraint = checkInSymbols(constraints[key]);
          if (typeof constraint !== 'symbol') {//No I18n
            switch (key) {
              case 'size': {
                if (typeof constraint === 'function') {//No I18n
                  if (!constraint(value.length)) {
                    valid = false;
                  }
                } else if (typeof constraint === 'number' && constraint === constraint) {//No I18n
                  if (constraint !== value.length) {
                    valid = false;
                  }
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'instanceOf': {
                if (typeof constraint === 'function') {//No I18n
                  valid = value instanceof constraint
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'every': {
                if (typeof constraint === 'function') {
                  valid = value.every(function (eachValue) { return constraint(eachValue) });
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'some': {
                if (typeof constraint === 'function') {
                  valid = value.some(function (eachValue) { return constraint(eachValue) });
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
            }
          } else {
            valid = false;
          }
        }
        return (valid && callback) ? callback(value) : valid;
      }
    },
    OBJECT: function (baseConstraints, callback) {
      baseConstraints = baseConstraints ? baseConstraints : {};
      return function (value, runTimeConstraints, onConstraintFailure) {
        const constraints = Object.assign({}, baseConstraints, runTimeConstraints);
        const constraintFailure = typeof onConstraintFailure === 'boolean' ? onConstraintFailure : false;//No I18n
        if (typeof value !== 'object' || Array.isArray(value) || value === null) {//No I18n
          return false;
        }
        let valid = true;
        for (let key in constraints) {
          const constraint = checkInSymbols(constraints[key]);
          if (typeof constraint !== 'symbol') {//No I18n
            switch (key) {
              case 'requiredKeys': {
                if (Array.isArray(constraint)) {//No I18n
                  valid = constraint.every(function (keyName) {
                    return value.hasOwnProperty(keyName)
                  });
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'instanceOf': {
                if (typeof constraint === 'function') {//No I18n
                  valid = value instanceof constraint
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'required': {
                if (typeChecks.object(constraint)) {
                  for (let keyName in constraint) {
                    if (value.hasOwnProperty(keyName)) {
                      const validatorFn = constraint[keyName];
                      if (typeChecks.function(validatorFn)) {
                        if (!validatorFn(value[keyName])) {
                          valid = false;
                          break;
                        }
                      } else if (constraintFailure) {
                        valid = false;
                        break;
                      }
                    } else {
                      // logError(errorMsgs.MISSING_KEY(keyName, value));
                      valid = false;
                      break;
                    }
                  }
                } else if (constraintFailure) {
                  valid = false;
                } else {
                  throw new Error(errorMsgs.TYPE_MUST_BE('required', 'object'));//No I18n
                }
              }
                break;
              case 'allowable': {
                if (typeChecks.object(constraint)) {
                  for (let keyName in constraint) {
                    if (value.hasOwnProperty(keyName)) {
                      const validatorFn = constraint[keyName];
                      if (typeChecks.function(validatorFn)) {
                        if (!validatorFn(value[keyName])) {
                          // logError(errorMsgs.INVALID_VALUE(keyName, value));
                          valid = false;
                          break;
                        }
                      } else if (constraintFailure) {
                        valid = false;
                        break;
                      }
                    }
                  }
                } else if (constraintFailure) {
                  valid = false;
                } else {
                  throw new Error(errorMsgs.TYPE_MUST_BE('allowable', 'object'));//No I18n
                }
              }
                break;
              case 'everyValue': {
                if (typeof constraint === 'function') {//No I18n
                  valid = Object.keys(value).every(function (key) {
                    const eachValue = value[key];
                    return constraint(eachValue);
                  })
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'prototype': {
                if (typeChecks.object(constraint)) {
                  if (constraint.required) {
                    const subConstraint = constraint.required;
                    if (typeChecks.object(subConstraint)) {
                      for (let keyName in subConstraint) {
                        if (keyName in value) {
                          const validatorFn = subConstraint[keyName];
                          if (typeChecks.function(validatorFn)) {
                            if (!validatorFn(value[keyName])) {
                              valid = false;
                              break;
                            }
                          } else if (constraintFailure) {
                            valid = false;
                            break;
                          }
                        } else {
                          // logError(errorMsgs.MISSING_KEY(keyName, value));
                          valid = false;
                          break;
                        }
                      }
                    } else if (constraintFailure) {
                      valid = false;
                    } else {
                      throw new Error(errorMsgs.TYPE_MUST_BE('required', 'object'));//No I18n
                    }
                  }
                  if (constraint.allowable) {
                    const subConstraint = constraint.allowable;
                    if (typeChecks.object(subConstraint)) {
                      for (let keyName in subConstraint) {
                        if (keyName in value) {
                          const validatorFn = subConstraint[keyName];
                          if (typeChecks.function(validatorFn)) {
                            if (!validatorFn(value[keyName])) {
                              // logError(errorMsgs.INVALID_VALUE(keyName, value));
                              valid = false;
                              break;
                            }
                          } else if (constraintFailure) {
                            valid = false;
                            break;
                          }
                        }
                      }
                    } else if (constraintFailure) {
                      valid = false;
                    } else {
                      throw new Error(errorMsgs.TYPE_MUST_BE('allowable', 'object'));//No I18n
                    }
                  }
                } else if (constraintFailure) {
                  valid = false;
                } else {
                  throw new Error(errorMsgs.TYPE_MUST_BE('required', 'object'));//No I18n
                }
              }
                break;
            }
          } else {
            valid = false;
          }
        }
        return (valid && callback) ? callback(value) : valid;
      }
    }
  }
  const extender = function (name, options, extendFrom, callback) {
    if (!skipExistsCheck && this[name]) {
      throw new Error(errorMsgs.VALUE_EXISTS(name, 'Type Checks'));//No I18n
    } else if (basicTypeChecks.hasOwnProperty(extendFrom)) {
      if (typeof name !== 'string') {
        throw new Error('Name must be a string. Found ' + name);//No I18n
      } else {
        this[name] = basicTypeChecks[extendFrom](options, callback)
        return this[name];
      }
    }
    return false;
  }
  const safeExtender = function (name, options, extendFrom, callback) {
    if (this[name]) {
      return this[name];
    } else {
      skipExistsCheck = true;
      const output = extender.call(this, name, options, extendFrom, callback);
      skipExistsCheck = false;
      return output;
    }
  }
  for (let basicType in basicTypeChecks) {
    extender[basicType.toLowerCase()] = function (name, options, callback) {
      return this.call(typeChecks, name, options, basicType, callback);
    }
    safeExtender[basicType.toLowerCase()] = function (name, options, callback) {
      return this.call(typeChecks, name, options, basicType, callback);
    }
  }
  const manipulator = deepFreezer({
    $extend: extender,
    $safeExtend: safeExtender,
    later: function (typeName) {
      const symbol = Symbol(typeName);
      symbolMap[symbol] = typeName;
      return symbol;
    },
    or: function () {
      const args = Array.from(arguments);
      return function (value) {
        return args.some(function (typeCheck) {
          typeCheck = checkInSymbols(typeCheck);
          if (typeof typeCheck !== 'function') {//No I18n
            return false;
          }
          return typeCheck(value, true); // Constraint Failure is allowable here
        })
      }
    },
    and: function () {
      const args = Array.from(arguments);
      return function (value) {
        return args.every(function (typeCheck) {
          typeCheck = checkInSymbols(typeCheck);
          if (typeof typeCheck !== 'function') {//No I18n
            return false;
          }
          return typeCheck(value, true); // Constraint Failure is allowable here
        })
      }
    },
    dispose: function () {
      for (let key in this) {
        delete this[key];
      }
    }
  })
  const typeChecks = Object.assign(Object.create(manipulator), {
    boolean: function (value) {
      return typeof value === 'boolean';//No I18n
    },
    regex: function (value) {
      return (function () {
        // ? This is done to take the current RegExp Instance whenever the function runs
        return value instanceof RegExp;
      }());
    },
    function: function (value) {
      return typeof value === 'function';//No I18n
    }
  })
  typeChecks.$extend.string('string', {});
  typeChecks.$extend.number('number', {});
  typeChecks.$extend.array('array', {});
  typeChecks.$extend.object('object', {});
  return typeChecks;
});
export default checkType;
// window[PACKAGE_NAME].checkType = checkType;