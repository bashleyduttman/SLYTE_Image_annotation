//ignorei18n_start
//BabelCodeStarts
function _wrapRegExp() {
    _wrapRegExp = function (e, r) {
        return new BabelRegExp(e, void 0, r);
    };
    var e = RegExp.prototype,
        r = new WeakMap();

    function BabelRegExp(e, t, p) {
        var o = RegExp(e, t);
        return r.set(o, p || r.get(e)), _setPrototypeOf(o, BabelRegExp.prototype);
    }

    function buildGroups(e, t) {
        var p = r.get(t);
        return Object.keys(p).reduce(function (r, t) {
            var o = p[t];
            if ("number" == typeof o){ 
                r[t] = e[o]
            }
            else {
                for (var i = 0; void 0 === e[o[i]] && i + 1 < o.length;) {i++;}
                r[t] = e[o[i]];
            }
            return r;
        }, Object.create(null));
    }
    return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (r) {
        var t = e.exec.call(this, r);
        if (t) {
            t.groups = buildGroups(t, this);
            var p = t.indices;
            p && (p.groups = buildGroups(p, this));
        }
        return t;
    }, BabelRegExp.prototype[Symbol.replace] = function (t, p) {
        if ("string" == typeof p) {
            var o = r.get(this);
            return e[Symbol.replace].call(this, t, p.replace(/\$<([^>]+)>/g, function (e, r) {
                var t = o[r];
                return "$" + (Array.isArray(t) ? t.join("$") : t);
            }));
        }
        if ("function" == typeof p) {
            var i = this;
            return e[Symbol.replace].call(this, t, function () {
                var e = arguments;
                return "object" != typeof e[e.length - 1] && (e = [].slice.call(e)).push(buildGroups(e, i)), p.apply(this, e);
            });
        }
        return e[Symbol.replace].call(this, t, p);
    }, _wrapRegExp.apply(this, arguments);
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    Object.defineProperty(subClass, "prototype", {
        writable: false
    });
    if (superClass) {
        _setPrototypeOf(subClass, superClass)
    };
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
//BabelCodeEnds

const HTMLParser = (function () {
    const regexFor = {
            endTag: /*#__PURE__*/ _wrapRegExp(/^<\/([a-zA-z][-a-zA-Z0-9_]*)((?:\s*[a-zA-Z_:!0-9,][-a-zA-Z0-9_:%."'`;]*(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>]+))?)*)\s*(\/?)>/, {
                nodeName: 1,
                attributes: 2
            }),
            attr: /([a-zA-Z0-9_:!'"},@{$][-a-zA-Z0-9_:."'`%;{]*)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|([^>\s]+)))?/g
        },
        svgCamelCaseTags = {
            "filterunits": "filterUnits",
            "allowreorder": "allowReorder",
            "attributename": "attributeName",
            "attributetype": "attributeType",
            "autoreverse": "autoReverse",
            "basefrequency": "baseFrequency",
            "baseprofile": "baseProfile",
            "calcmode": "calcMode",
            "clippathunits": "clipPathUnits",
            "contentScriptType": "contentScriptType",
            "contentstyletype": "contentStyleType",
            "diffuseconstant": "diffuseConstant",
            "edgemode": "edgeMode",
            "externalresourcesrequired": "externalResourcesRequired",
            "filterres": "filterRes",
            "filterUnits": "filterUnits",
            "glyphref": "glyphRef",
            "gradienttransform": "gradientTransform",
            "gradientunits": "gradientUnits",
            "kernelmatrix": "kernelMatrix",
            "kernelunitlength": "kernelUnitLength",
            "keypoints": "keyPoints",
            "keysplines": "keySplines",
            "keytimes": "keyTimes",
            "lengthadjust": "lengthAdjust",
            "limitingconeangle": "limitingConeAngle",
            "markerheight": "markerHeight",
            "markerunits": "markerUnits",
            "markerwidth": "markerWidth",
            "maskcontentunits": "maskContentUnits",
            "maskunits": "maskUnits",
            "patterncontentunits": "patternContentUnits",
            "patterntransform": "patternTransform",
            "patternunits": "patternUnits",
            "pointsatx": "pointsAtX",
            "pointsaty": "pointsAtY",
            "pointsatz": "pointsAtZ",
            "preservealpha": "preserveAlpha",
            "preserveaspectratio": "preserveAspectRatio",
            "primitiveunits": "primitiveUnits",
            "repeatcount": "repeatCount",
            "repeatdur": "repeatDur",
            "requiredextensions": "requiredExtensions",
            "requiredfeatures": "requiredFeatures",
            "specularconstant": "specularConstant",
            "specularexponent": "specularExponent",
            "spreadmethod": "spreadMethod",
            "startoffset": "startOffset",
            "stddeviation": "stdDeviation",
            "stitchtiles": "stitchTiles",
            "surfacescale": "surfaceScale",
            "systemlanguage": "systemLanguage",
            "tablevalues": "tableValues",
            "textlength": "textLength",
            "viewbox": "viewBox",
            "viewtarget": "viewTarget",
            "xchannelselector": "xChannelSelector",
            "ychannelselector": "yChannelSelector",
            "refx": "refX",
            "refy": "refY",
            "targetx": "targetX",
            "targety": "targetY",
            "numoctaves": "numOctaves",
            "zoomandpan": "zoomAndPan",
        },
        chromeChangedTags = {
            "image": "img"
        },
        createMapFor = function (array) {
            return array.reduce(function (acc, item) {
                acc[item] = true;
                return acc;
            }, {});
        },
        dasherize = function(string,fancyComponent,attr) {
            let lowerTagName, specifiedComponentCheck = typeof fancyComponent == "object";
            if( string &&
                !svgCamelCaseTags[lowerTagName  = string.toLowerCase()] &&
                !svgMiddleMen[lowerTagName] &&
                (!specifiedComponentCheck || fancyComponent[string]) &&
                (!attr || !string.match(/^on/gm))
            ){
                if(!cache_d[string]){
                    cache_d[string] = string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
                    string!= cache_d[string] && console.log(string);
                }
                return cache_d[string];
            }
            return string;
        },
        svgMiddleMen = createMapFor(['foreignobject']),
        svgSelfClosingTags = createMapFor([
            'title',
            "animate",
            "animateColor",
            "animateTransform",
            "circle",
            "ellipse",
            "feBlend",
            "feColorMatrix",
            "feComponentTransfer",
            "feComposite",
            "feConvolveMatrix",
            "feDiffuseLighting",
            "feDisplacementMap",
            "feDistantLight",
            "feFlood",
            "feFuncA",
            "feFuncB",
            "feFuncG",
            "feFuncR",
            "feGaussianBlur",
            "feImage",
            "feMergeNode",
            "feMorphology",
            "feOffset",
            "fePointLight",
            "feSpecularLighting",
            "feSpotLight",
            "feTile",
            "feTurbulence",
            "line",
            "path",
            "polygon",
            "polyline",
            "rect",
            "stop",
            "use"
        ]),
        tableTags = createMapFor(["tbody", "thead", "tfoot", "colgroup", "caption", "tr", "th", "td", "col"]),
        EMPTY_ELEMENTS = createMapFor([
            "area",
            "base",
            "basefont",
            "br",
            "col",
            "frame",
            "hr",
            "img",
            "track",
            "input",
            "link",
            "meta",
            "param",
            "embed",
            "command",
            "keygen",
            "source",
            "wbr",
            // "circle",
            // "ellipse",
            // "line",
            // "polyline",
            // "rect",
        ]),
        SELF_CLOSING = createMapFor([
            "colgroup",
            "dd",
            "dt",
            "li",
            "options",
            "p",
        ]),
        SPECIAL_ELEMENTS = createMapFor([
            'style',
            'script'
        ]),
        nodeStartStack = [];

    let cache_d = {},cache_c = {},
        paragraphTagStarted = 0,
        willHaveUnclosedClosingTag = false,
        checkClosingTag = false,
        selfClosingTags = createMapFor(['style', 'area', 'base', 'br', 'col', 'embed', 'hr', 'input', 'keygen', 'link', 'meta', 'param', 'wbr', 'img', 'track']),
        notAllowedTagsInsideParagraphTag = createMapFor(["div", "table", "body", "h1", "h2", "h3", "h4", "h5", "h6", "ul", "li"]);
    
    return function (htmlString, callbacks, options, errorObj, lineIndex = 1, colIndex = 0) {
        let {emberFlag, fileName, withoutTableProcessing, fancyComponent} = options,
            hasUnparsedChars,
            match,
            mismatchColIndex = {},
            stack = [],
            seenSVGBefore = 0, 
            seenSvgMiddleMenBefore = 0, 
            seenTableBefore = 0,
            stringInPrevLoopState = htmlString,
            elemStack = [];
            
        stack.getLastItem = function () {
            return this[this.length - 1];
        };
        elemStack.getLastItem = function () {
            return this[this.length - 1];
        }
        function validateTagName(str, errorObject) {
            str = str.trim()
            if (str.length == 0 || !(/^[a-zA-Z_][-a-zA-Z0-9_]*$/).test(str)) {
                errorObject.bool = false;
                errorObject.error = "Invalid tag name :`" + "<" + str + "`";
                errorObject.fromParser = true;
                return false;
            }
            return chromeChangedTags[str] ? chromeChangedTags[str] : str;
        }

        function getStartTag(str) {
            try {
                let foundTagName = false,
                    tagName = "",
                    errorObject = {
                        bool: true
                    },
                    doubleQuotesStarted = false,
                    dIndex = 0,
                    singleQuotesStarted = false,
                    sIndex = 0,
                    mustacheStarted = 0,
                    mIndex = 0,
                    attrStartIndex = 0,
                    tickStarted = false;

                for (let i = 0; i < str.length; i++) {
                    if (!foundTagName) {
                        if (str[i] == " " || str[i] == "\n" || str[i] == "/" || str[i] == "\t") {
                            tagName = validateTagName(tagName, errorObject)
                            if (!tagName) return errorObject;
                            foundTagName = true
                            attrStartIndex = i;
                            continue;
                        }
                        if (str[i] == ">") {
                            tagName = validateTagName(tagName, errorObject)
                            if (!tagName) return errorObject;
                            let res = ["<" + str.substring(0, i + 1), tagName, "", "", "<" + str];
                            res.bool = true;
                            return res;
                        }
                        if (str[i] == "/" && str[i + 1] == ">") {
                            tagName = validateTagName(tagName, errorObject)
                            if (!tagName) return errorObject;
                            let res = ["<" + str.substring(0, i + 1), tagName, "", "/", "<" + str];
                            res.bool = true;
                            return res;
                        }
                        tagName += str[i];
                        continue;
                    }
                    if (str[i] == "`" && str[i - 1] != "\\" && !doubleQuotesStarted && !singleQuotesStarted) {
                        tickStarted = !tickStarted;
                        sIndex = i + 1;
                    }
                    if (str[i] == "'" && str[i - 1] != "\\" && !doubleQuotesStarted && !tickStarted) {
                        singleQuotesStarted = !singleQuotesStarted;
                        sIndex = i + 1;
                    }
                    if (str[i] == '"' && str[i - 1] != "\\" && !singleQuotesStarted && !tickStarted) {
                        doubleQuotesStarted = !doubleQuotesStarted;
                        dIndex = i + 1;
                    }
                    if (!tickStarted && !singleQuotesStarted && !doubleQuotesStarted && str[i] == "{" && str[i + 1] == "{") {
                        mustacheStarted = true;
                        mIndex = i;
                    }
                    if (!tickStarted && !singleQuotesStarted && !doubleQuotesStarted && str[i] == "}" && str[i + 1] == "}") {
                        mustacheStarted = false;
                    }
                    if (!tickStarted && !singleQuotesStarted && !doubleQuotesStarted && !mustacheStarted && str[i] == "<") {
                        errorObject.bool = false;
                        errorObject.error = "Unclosed `>` for the tag `" + tagName + "`";
                        errorObject.fromParser = true;
                        let temp = str.substr(0, i).split("\n");
                        lineIndex += (temp.length - 1);
                        colIndex = temp[temp.length - 1].length;
                        return errorObject;
                    }
                    if (!tickStarted && !singleQuotesStarted && !doubleQuotesStarted && !mustacheStarted && str[i] == ">") {
                        let res = [];
                        if (str[i - 1] == "/") {
                            res = ["<" + str.substring(0, i + 1), tagName, str.substring(attrStartIndex, i - 1), "/", "<" + str];
                            res.bool = true;
                            return res;
                        }
                        res = ["<" + str.substring(0, i + 1), tagName, str.substring(attrStartIndex, i), "", "<" + str]
                        res.bool = true;
                        return res;
                    }
                }
                errorObject.bool = false;
                let temp;
                if (singleQuotesStarted) {
                    errorObject.error = "Unclosed Single Quote ";
                    temp = str.substr(0, sIndex).split("\n");
                    lineIndex += (temp.length - 1);
                    colIndex = temp[temp.length - 1].length;
                    errorObject.index = str.substring(0, sIndex);
                } else if (doubleQuotesStarted) {
                    errorObject.error = "Unclosed Double Quote ";
                    temp = str.substr(0, dIndex).split("\n");
                    lineIndex += (temp.length - 1);
                    colIndex = temp[temp.length - 1].length;
                    errorObject.index = str.substring(0, dIndex);
                } else if (mustacheStarted) {
                    errorObject.error = "Unclosed Mustache ";
                    temp = str.substr(0, mIndex).split("\n");
                    lineIndex += (temp.length - 1);
                    colIndex = temp[temp.length - 1].length;
                    errorObject.index = str.substring(0, mIndex);
                } else {
                    errorObject.error = "Unclosed tag `>`";
                }
                return errorObject;
            } catch (e) {
                console.log("Error in parsing")
            }
        }

        function parseStartTag(tag, tagName, rest, unary) {
            if (tagName) {
                fancyComponent && (tagName = dasherize(tagName, fancyComponent));
                let lowerTagName = tagName.toLowerCase();
                if (lowerTagName == "svg") {
                    seenSVGBefore++;
                }
                // if (lowerTagName == "pre") {
                //     seenPreBefore = true;
                // }
                if (lowerTagName == "table") {
                    seenTableBefore += 1;
                }
                if (svgMiddleMen[lowerTagName]) {
                    seenSvgMiddleMenBefore++;
                }
                if (seenSVGBefore == 0 && tagName.toLowerCase) {
                    tagName = lowerTagName;
                }
            }
            // @Handle3055 to get precise line and column number
            // if(tagName && !seenPreBefore){
            //   tagName = tagName.replace(/\r?\n|\r/g,' ').replace(/\s+/g,' ');
            //   if (tag) {
            //     tag = tag.replace(/\r?\n|\r/g, ' ').replace(/\s+/g, ' ');
            //   }
            // }
            if (unary && !seenSVGBefore && svgSelfClosingTags[tagName]) {
                let err = new Error("Error: Invalid svg tag " + tag + ".....");
                err.fromParser = true;
                throw err;
            }
            if (stack.getLastItem() == tagName && SELF_CLOSING[tagName]) {
                parseEndTag("", tagName);
            }
            let matchRes;
            if (tag && (matchRes = tag.match(/(?!({{)|"|'.*)\n(?!.*(}})|"|')/g))) {
                lineIndex = lineIndex + matchRes.length;
                colIndex = matchRes[matchRes.length - 1].length;
            }
            let col = colIndex;
            if (tag) {
                colIndex = colIndex + tag.length;
            }

            unary = EMPTY_ELEMENTS[tagName] || !!unary;
            if (!unary) {
                stack.push(tagName);
                if (tagName != "p") {
                    elemStack.push(tagName);
                }
            }
            let attrs = [];
            rest.replace(regexFor.attr, function (match, name) {
                const arg2 = arguments[2];
                const arg3 = arguments[3];
                const arg4 = arguments[4];
                const value = arg2 ? arg2 : (arg3 ? arg3 : (arg4 ? arg4 : ''));
                let quote = name.indexOf("'"),
                    err,
                    indexOfValue = tag.indexOf(value),
                    attrStartIndex = col+indexOfValue;
                for (let index=indexOfValue; index>=0;index--){
                    if(tag[index] == "\n"){
                        attrStartIndex = indexOfValue-index;
                        break;
                    }
                }
                if (quote !== -1) {
                    err = new Error("Error: Unclosed Single quote in " + tag + "....." + "</" + tagName + ">");
                    err.fromParser = true;
                    err.lineIndex = lineIndex;
                    err.colIndex = colIndex;
                    throw err;
                }
                quote = name.indexOf('"')
                if (quote !== -1) {
                    err = new Error("Error: Unclosed Double quote in " + tag.substring(0, 100) + "....." /* + "....." + "</" + tagName+ ">"*/ );
                    err.fromParser = true;
                    err.lineIndex = lineIndex;
                    err.colIndex = colIndex;
                    throw err;
                }
                if (name.indexOf("{{") == 0) {
                    err = new Error("Error: Invalid Mustache : " + name + "...");
                    err.fromParser = true;
                    err.lineIndex = lineIndex;
                    err.colIndex = colIndex;
                    throw err;
                }
                fancyComponent && (name = dasherize(name,false,true));
                if (seenSVGBefore > 0 && svgCamelCaseTags[name.toLowerCase()]) {
                    name = svgCamelCaseTags[name.toLowerCase()];
                } else {
                    name = name.toLowerCase();
                }
                let obj = {
                    name: name,
                    value: value.replace(/"/g, "&quot;"),
                    escaped: value.replace(/(^|[^\\])"/g, '$1\\\"'),
                    attrStartIndex
                }
                if (name == "lyte-if" || (name == "is" && value == "if") || name == "lyte-switch" || (name == "is" && value == "switch") || name == "lyte-for" || (name == "is" && value == "for") || name == "lyte-for-in" || (name == "is" && value == "forIn")) {
                    obj.errorInfo = {
                        name: "errorInfo",
                        details: {
                            tagName: tagName,
                            name: name,
                            value: value.replace(/"/g, "&quot;")
                        }
                    }
                }
                attrs.push(obj);
            });
            if (callbacks.start) {
                if (tag && tag.match(/<.*\/>/g)) {
                    if (!(selfClosingTags[tagName] || svgSelfClosingTags[tagName])) {
                        let err = new Error("Invalid self-closing tag `" + tagName + "` in " + (tag + htmlString).substring(0, 100) + "...");
                        err.fromParser = true;
                        err.lineIndex = lineIndex;
                        err.colIndex = colIndex;
                        throw err;
                    }
                } else {
                    if (!selfClosingTags[tagName]) {
                        nodeStartStack.push(tagName);
                    }
                }
                if (checkClosingTag) {
                    attrs.push({
                        name: "checkClosingTag",
                        value: "true",
                        escaped: "true"
                    });
                }
                callbacks.start(tagName, attrs, unary, seenSVGBefore, lineIndex, col);
            }
        }

        function parseEndTag(tag, tagName) {
            if (tagName) {
                fancyComponent && (tagName = dasherize(tagName, fancyComponent));
                let lowerTagName = tagName.toLowerCase();
                if (lowerTagName == "svg") {
                    seenSVGBefore--;
                }
                if (svgMiddleMen[lowerTagName]) {
                    seenSvgMiddleMenBefore--;
                }
                if (lowerTagName == "table") {
                    seenTableBefore--;
                }
                // if (lowerTagName == "pre") {
                //     seenPreBefore = false;
                // }
                if (seenSVGBefore == 0 && tagName.toLowerCase) {
                    tagName = lowerTagName;
                }
                if (tagName != "p" && !EMPTY_ELEMENTS[tagName]) {
                    let lastElem = elemStack.pop();
                    if (lastElem.toLowerCase() != tagName.toLowerCase()) {
                        if (tagName != "template") {
                            let i = elemStack.length - 1;
                            for (; i >= 0; i--) {
                                if (elemStack[i] == tagName) {
                                    break;
                                }
                            }
                            let removeIndex = i;
                            for (; i > 0; i--) {
                                if (elemStack[i] == "template") {
                                    elemStack.splice(removeIndex, 1);
                                    break;
                                }
                            }
                            elemStack.push(lastElem);
                            return;
                        }
                    }
                }
            }
            if (tag) {
                colIndex += tag.length;
            }
            let pos;
            if (!tagName) {
                pos = 0;
            } else {
                for (pos = stack.length - 1; pos >= 0; pos--) {
                    if (stack[pos] == tagName) {
                        break;
                    }
                }
            }
            if (pos >= 0) {
                for (let i = stack.length - 1; i >= pos; i--) {
                    if (callbacks.end) {
                        callbacks.end(stack[i], stack[i] != tagName, this && this.misMatchCase ? this.misMatchCase : null, ((seenSvgMiddleMenBefore > 0) ? 0 : seenSVGBefore));
                    }
                }
                stack.length = pos;
            }
            else if (tagName == "br") {
                parseStartTag(null, tagName, "", null);
            }
        }
        const replacerFn = function (all, text) {
            let matchRes;
            if (text && (matchRes = text.match(/(?!({{)|"|'.*)\n(?!.*(}})|"|')/g))) {
                lineIndex += matchRes.length;
                colIndex = matchRes[matchRes.length - 1].length;
            }
            text = text.replace(/<!--([\s\S]*?)-->|<!\[CDATA\[([\s\S]*?)]]>/g, "$1$2");
            let col = colIndex;
            colIndex += text.length;

            if (callbacks.chars) {
                callbacks.chars(text, lineIndex, col, checkClosingTag);
            }
            return "";
        }
        if (emberFlag && htmlString.indexOf("{{!--")) {
            htmlString = htmlString.replace(/{{!--[\s\S]*?--}}/g, "");
        }
        while (htmlString) {
            hasUnparsedChars = true;
            if (!stack.getLastItem() || !SPECIAL_ELEMENTS[stack.getLastItem()]) {
                let checkStr = htmlString.substring(0, 5);
                if (checkStr.indexOf("<!--")== 0) {
                    let index = htmlString.indexOf("-->");
                    if (index >= 0) {
                        if (callbacks.comment) {
                            let col = colIndex;
                            colIndex += htmlString.substring(4, index).length + 7;
                            callbacks.comment(htmlString.substring(4, index), lineIndex, col);
                            let matchRes = htmlString.substring(4, index).match(/\n/g)
                            if (matchRes) {
                                lineIndex = lineIndex + matchRes.length;
                                colIndex = matchRes[matchRes.length - 1].length;
                            }
                        }
                        htmlString = htmlString.substring(index + 3);
                        hasUnparsedChars = false;
                    }
                }else if(checkStr.indexOf("<?xml") == 0){
                    let index = htmlString.indexOf("?>");
                    if(index>=0){
                        if(callbacks.comment){
                            let col = colIndex,matchedString,match;
                            colIndex += htmlString.substring(5, index).length + 7;
                            callbacks.comment("___PI:XMLStarts___"+(matchedString = htmlString.substring(5,index))+"___PI:XMLEnds___",lineIndex,col,true);//PI ~ Parser Internals
                            if(match = matchedString.match(/\n/g)){
                                lineIndex = lineIndex + match.length;
                                colIndex = 0;
                            }
                            htmlString = htmlString.substring(index + 2);
                            hasUnparsedChars = false;
                        }
                    }
                } else if (checkStr.indexOf("</") == 0) {
                    match = htmlString.match(regexFor.endTag);
                    if (match) {
                        let misMatchCase = false;
                        if (match[1] == "p") {
                            paragraphTagStarted = 0;
                        }
                        if (paragraphTagStarted == 2 && match[1] == "template") {
                            paragraphTagStarted = 1;
                        }
                        if (match[1] == "p" && stack.getLastItem() != "p" && willHaveUnclosedClosingTag) {
                            parseStartTag(null, "p", "", null);
                        }
                        if (match[1] == "checkClosingTag") {
                            checkClosingTag = false;
                            htmlString = htmlString.substring(match[0].length);
                            continue;
                        }
                        let check = fancyComponent ? dasherize(match[1], fancyComponent) : match[1];
                        if (seenSVGBefore == 0 && check && check.toLowerCase) {
                            check = check.toLowerCase();
                        }
                        if (check != stack.getLastItem() && !EMPTY_ELEMENTS[check]) {
                            let err = new Error("Unclosed `" + elemStack.getLastItem() + "` in " + htmlString.substring(0, 100) + "...");
                            err.fromParser = true;
                            err.lineIndex = lineIndex;
                            err.colIndex = colIndex;
                            throw err;
                        }
                        if (match[1] == "template" && elemStack.getLastItem() != "template" && match[1] != "p" && !EMPTY_ELEMENTS[match[1]]) {
                            let match2 = htmlString.match(`<\/\s*` + elemStack.getLastItem() + `\s*>`);
                            if (match2) {
                                htmlString = htmlString.replace(match2[0], "</checkClosingTag>");
                                checkClosingTag = true;
                                htmlString = htmlString.replace(match[0], match2[0]);
                                htmlString = htmlString.substring(0, match2[0].length) + match[0] + htmlString.substring(match2[0].length);
                                match = htmlString.match(regexFor.endTag);
                                stringInPrevLoopState = undefined;
                                misMatchCase = true;
                            }
                        }
                        htmlString = htmlString.substring(match[0].length);

                        match[0].replace(regexFor.endTag, parseEndTag.bind({
                            misMatchCase: misMatchCase
                        }));
                        hasUnparsedChars = false;
                    }
                } else if (checkStr.indexOf("<") == 0) {
                    match = getStartTag(htmlString.slice(1));
                    if (match.bool) {
                        if (paragraphTagStarted == 1 && match[1] != "p" && notAllowedTagsInsideParagraphTag[match[1]]) {
                            paragraphTagStarted = 0;
                            parseEndTag(null, "p");
                            willHaveUnclosedClosingTag = true;
                        }
                        htmlString = htmlString.substring(match[0].length);
                        if (match[1] == "template") {
                            while (htmlString.match(/^[^<]*?<\/br\s*>/)) {
                                htmlString = htmlString.replace(/<\/br\s*>/, "");
                            }
                        }
                        if (!withoutTableProcessing) {
                            if (stack.getLastItem() != "template" && seenTableBefore == 0 && tableTags[match[1]]) {
                                if (errorObj) {
                                    errorObj.warnings.push({
                                        message: "Warning: Misplaced " + match[1] + " tag in " + match[0] + "....." + "</" + match[1] + ">" + ((fileName && fileName.trim().length != 0) ? "\n\t  at Component: " + fileName : "")
                                    });
                                } else {
                                    console.warn("Warning: Misplaced " + match[1] + " tag in " + match[0] + "....." + "</" + match[1] + ">" + ((fileName && fileName.trim().length != 0) ? "\n\t  at Component: " + fileName : ""));
                                }
                            }
                        }
                        parseStartTag(match[0], match[1], match[2], match[3]);
                        hasUnparsedChars = false;
                        if (match[1] == "p") {
                            paragraphTagStarted = 1;
                        }
                        if (paragraphTagStarted == 1 && match[1] == "template") {
                            paragraphTagStarted = 2;
                        }
                    } else {
                        let err = new Error(match.error + ((match.index) ? " in <" + match.index.substring(0, (match.index.indexOf(">") != -1) ? match.index.indexOf(">") + 1 : 51) + "....." : ""));
                        err.fromParser = true;
                        err.lineIndex = lineIndex;
                        err.colIndex = colIndex;
                        throw err;
                    }
                }
                if (hasUnparsedChars) {
                    let hasSeenOpenMustache = false,
                        newLineCount = 0,
                        index,
                        mustacheIndex = {};
                    for (let i = 0; i < htmlString.length; i++) {
                        if (htmlString[i] == "\n") {
                            newLineCount++;
                        }
                        if (htmlString[i] == '{' && htmlString[i + 1] == '{') {
                            hasSeenOpenMustache = true;
                            mustacheIndex = {
                                colIndex: i - newLineCount,
                                lineIndex: lineIndex + newLineCount
                            };
                        }
                        if (htmlString[i] == '}' && htmlString[i + 1] == '}') {
                            hasSeenOpenMustache = false;
                        }
                        if (htmlString[i] == '<' && !hasSeenOpenMustache) {
                            index = i;
                            break;
                        }
                    }
                    if (hasSeenOpenMustache) {
                        let err = new Error("Unclosed Mustache at " + htmlString.substring(mustacheIndex.colIndex, mustacheIndex.colIndex + 50));
                        err.fromParser = true;
                        err.lineIndex = mustacheIndex.lineIndex;
                        err.colIndex = (mustacheIndex.lineIndex == lineIndex) ? /* <h1>check{{{}</h1> */ colIndex + mustacheIndex.colIndex : /* <h1>che\nck{{{}</h1> */ mustacheIndex.colIndex;
                        throw err;
                    }
                    if (!index) {
                        mismatchColIndex = {
                            colIndex,
                            lineIndex
                        };
                        index = htmlString.length;
                        newLineCount = 0;
                    }
                    let text = index < 0 ? htmlString : htmlString.substring(0, index);
                    htmlString = index < 0 ? "" : htmlString.substring(index);
                    if (callbacks.chars) {
                        // @Handle3055 to get precise line and column number
                        // if(!seenPreBefore && text){
                        //   text = text.replace(/\r?\n|\r/g,' ').replace(/\s+/g,' ');
                        // }
                        callbacks.chars(text, lineIndex, colIndex, checkClosingTag);
                        colIndex = colIndex + text.length;
                        if (newLineCount) {
                            lineIndex += newLineCount;
                            colIndex = 0;
                        }
                    }
                }
            } else {
                htmlString = htmlString.replace(new RegExp("([\\s\\S]*?)<\/" + stack.getLastItem() + "[^>]*>"), replacerFn);
                parseEndTag("", stack.getLastItem());
            }
            if (htmlString == stringInPrevLoopState) {
                throw "Parse Error: " + htmlString.substring(0, 100) + "...";
            }
            stringInPrevLoopState = htmlString;
        }
        if (stack.length > 0) {
            let err = new Error("Unclosed `" + elemStack.getLastItem() + "` in " + htmlString.substring(0, 100) + "..." + ((fileName && fileName.trim().length != 0) ? "\n\t    at Component: " + fileName : ""));
            err.lineIndex = mismatchColIndex.lineIndex || lineIndex;
            err.colIndex = mismatchColIndex.colIndex || colIndex;
            throw err;
        }
        parseEndTag();
    }
}());
export default HTMLParser;
//ignorei18n_end