/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/deepFreezer.js":
/*!****************************!*\
  !*** ./src/deepFreezer.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   deepFreezer: () => (/* binding */ deepFreezer),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const deepFreezer = function (value) {
  /**
   * ## Freezer - <vignesh.prv> 
   * # Why we need this ?
   * - This is just a deep freezer function which we might need on sending data to users
   * 
   * TODO : Not Much of the validation is done here
   * * For basics requirements this is fine, but on large scale we might need 
   * * a better freezer function which validates its inputs and then freezes it
   * 
   **/
  if (typeof value === 'object') {
    if (Array.isArray(value)) {
      value.forEach(deepFreezer)
    } else {
      for (let key in value) {
        deepFreezer(value[key]);
      }
    }
  }
  return Object.freeze(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (deepFreezer);
// module.exports = deepFreezer;
// window[PACKAGE_NAME].deepFreezer = deepFreezer;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!**************************!*\
  !*** ./src/checkType.js ***!
  \**************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkType: () => (/* binding */ checkType),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _deepFreezer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./deepFreezer.js */ "./src/deepFreezer.js");

/**
 * ## Check Type ( type checking library ) <vignesh.prv>
 * # Why we need this ?
 * - Increasingly we are checking types of user inputs and various values
 * - This will help us to register a type pattern well before and thus 
 * - making it easier to check the input
 * 
 * * Example : 
 * - If there is a input which is of type object and has some required keys 
 * - and some allowable keys ( if present , they have to be type checked )
 * 
 * ? tool = {
 * ?  label : String, // Required
 * ?  callback : Function, // Required
 * ?  title : String // Allowable
 * ? }
 * 
 * - We can create a type 'tool' for the above configuration, thus now we can 
 * - check for derived type 'tool'.
 * 
 * ! This will be more helpful when the types are subjected to change
 * ! Error message to the user can be verbose from this
 * 
 * # What if the value can have more than one structure ?
 * - Here, in checktype there are 2 logical operator APIs are available
 * - 'OR' & 'AND' which makes it easy to incorporate more than one structure
 * - This also helps us to atomize the types and reuse the existing type checks
 * 
 * # What is API "later" means ?
 * - As the name suggest the API "later" will get registered later.
 * - Normally, when we extend a existing type, the function on which the extension is made has 
 * - to be present.
 * - But in this case, There is no need for such thing,On registering this later will bind an 
 * - Symbol of type's label 
 * - Only on performing the check function, this Symbol will be parsed and if there is no such
 * - type registered the function will be ignored under the hood and 'false' will be returned
 * 
 * ! Once a type is registered it cannot be re-registered and delete
 * ! It will be available windowly once registered
 * 
 * # What if we need more control over the types ?
 * - On registering , There is a third argument which accepts a callback, from which more
 * - customized checks can be done
 * 
 */

const checkType = (function () {//No I18n
  const errorMsgs = {
    //ignorei18n_start
    MISSING_KEY: function (key, object) {
      object = typeof object === 'string' ? object : JSON.stringify(object, null, 4)
      return key + " is a required key in the object.\nStringified Object for reference :\n" + object
    },
    TYPE_MUST_BE: function (type, key, additional) {
      return 'The value for the ' + key + ' should be of type ' + (Array.isArray(type) ? type.join(' | ') : type) + '. ' + (additional || '')
    },
    INVALID_VALUE: function (key, object) {
      return 'Value for ' + key + ' is invalid, Source object : ' + JSON.stringify(object, null, 2)
    },
    VALUE_EXISTS: function (type, object) {
      return type + ' already exists' + (object && ' in ' + object) + '. Please try another name'
    }
    //ignorei18n_end
  }
  // const console = 'console';//No I18n
  // const logError = window[console].error;//No I18n
  const symbolMap = {};
  let skipExistsCheck = false;
  const checkInSymbols = function (mightBeSymbol) {
    if (typeof mightBeSymbol === 'symbol') {//No I18n
      const type = symbolMap[mightBeSymbol];
      return typeChecks[type] || mightBeSymbol;
    }
    return mightBeSymbol;
  }
  const basicTypeChecks = {
    STRING: function (baseConstraints, callback) {
      baseConstraints = baseConstraints ? baseConstraints : {};
      return function (value, runTimeConstraints, onConstraintFailure) {
        const constraints = Object.assign({}, baseConstraints, runTimeConstraints);
        const constraintFailure = typeof onConstraintFailure === 'boolean' ? onConstraintFailure : false;//No I18n
        if (typeof value !== 'string') {//No I18n
          return false;
        }
        let valid = true;
        for (let key in constraints) {
          const constraint = checkInSymbols(constraints[key]);
          if (typeof constraint !== 'symbol') {//No I18n
            switch (key) {
              case 'nonEmptyString': {
                if (typeof constraint === 'boolean') {
                  if (constraint) {
                    valid = value.trim().length > 0;
                  }
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'length': {
                if (typeof constraint === 'function') {//No I18n
                  if (!constraint(value.length)) {
                    valid = false;
                  }
                } else if (typeof constraint === 'number' && constraint === constraint) {//No I18n
                  if (constraint !== value.length) {
                    valid = false;
                  }
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'allowableValues': {
                if (Array.isArray(constraint)) {
                  if (!constraint.includes(value)) {
                    valid = false;
                  }
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'matchRegex': {
                if (constraint instanceof RegExp) {
                  if (!constraint.test(value)) {
                    valid = false;
                  }
                } else if (constraintFailure) {
                  valid = false;
                }
              }
            }
          } else {
            valid = false;
          }
        }
        return (valid && callback) ? callback(value) : valid;
      }
    },
    NUMBER: function (baseConstraints, callback) {
      baseConstraints = baseConstraints ? baseConstraints : {};
      return function (value, runTimeConstraints, onConstraintFailure) {
        const constraints = Object.assign({}, baseConstraints, runTimeConstraints);
        const constraintFailure = typeof onConstraintFailure === 'boolean' ? onConstraintFailure : false;//No I18n
        if (typeof value !== 'number') {//No I18n
          return false;
        }
        let valid = true;
        for (let key in constraints) {
          const constraint = checkInSymbols(constraints[key]);
          if (typeof constraint !== 'symbol') {//No I18n
            switch (key) {
              case 'min': {
                if (typeof constraint === 'number' && constraint === constraint) {//No I18n
                  if (constraint > value) {
                    valid = false;
                  }
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'max': {
                if (typeof constraint === 'number' && constraint === constraint) {//No I18n
                  if (constraint < value) {
                    valid = false;
                  }
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'whole': {
                if (typeof constraint === 'boolean' && constraint) {//No I18n
                  if ((value - Math.floor(value)) !== 0) {
                    valid = false;
                  }
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'positive': {
                if (typeof constraint === 'boolean') {//No I18n
                  if (constraint && value < 0) {
                    valid = false;
                  }
                  if (!constraint && value > 0) {
                    valid = false;
                  }
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'allowableValues': {
                if (Array.isArray(constraint)) {
                  if (!constraint.includes(value)) {
                    valid = false;
                  }
                } else if (constraintFailure) {
                  valid = false;
                }
              }
            }
          } else {
            valid = false;
          }
        }
        return (valid && callback) ? callback(value) : valid;
      }
    },
    ARRAY: function (baseConstraints, callback) {
      baseConstraints = baseConstraints ? baseConstraints : {};
      return function (value, runTimeConstraints, onConstraintFailure) {
        const constraints = Object.assign({}, baseConstraints, runTimeConstraints);
        const constraintFailure = typeof onConstraintFailure === 'boolean' ? onConstraintFailure : false;//No I18n
        if (!Array.isArray(value)) {
          return false;
        }
        let valid = true;
        for (let key in constraints) {
          const constraint = checkInSymbols(constraints[key]);
          if (typeof constraint !== 'symbol') {//No I18n
            switch (key) {
              case 'size': {
                if (typeof constraint === 'function') {//No I18n
                  if (!constraint(value.length)) {
                    valid = false;
                  }
                } else if (typeof constraint === 'number' && constraint === constraint) {//No I18n
                  if (constraint !== value.length) {
                    valid = false;
                  }
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'instanceOf': {
                if (typeof constraint === 'function') {//No I18n
                  valid = value instanceof constraint
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'every': {
                if (typeof constraint === 'function') {
                  valid = value.every(function (eachValue) { return constraint(eachValue) });
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'some': {
                if (typeof constraint === 'function') {
                  valid = value.some(function (eachValue) { return constraint(eachValue) });
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
            }
          } else {
            valid = false;
          }
        }
        return (valid && callback) ? callback(value) : valid;
      }
    },
    OBJECT: function (baseConstraints, callback) {
      baseConstraints = baseConstraints ? baseConstraints : {};
      return function (value, runTimeConstraints, onConstraintFailure) {
        const constraints = Object.assign({}, baseConstraints, runTimeConstraints);
        const constraintFailure = typeof onConstraintFailure === 'boolean' ? onConstraintFailure : false;//No I18n
        if (typeof value !== 'object' || Array.isArray(value) || value === null) {//No I18n
          return false;
        }
        let valid = true;
        for (let key in constraints) {
          const constraint = checkInSymbols(constraints[key]);
          if (typeof constraint !== 'symbol') {//No I18n
            switch (key) {
              case 'requiredKeys': {
                if (Array.isArray(constraint)) {//No I18n
                  valid = constraint.every(function (keyName) {
                    return value.hasOwnProperty(keyName)
                  });
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'instanceOf': {
                if (typeof constraint === 'function') {//No I18n
                  valid = value instanceof constraint
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'required': {
                if (typeChecks.object(constraint)) {
                  for (let keyName in constraint) {
                    if (value.hasOwnProperty(keyName)) {
                      const validatorFn = constraint[keyName];
                      if (typeChecks.function(validatorFn)) {
                        if (!validatorFn(value[keyName])) {
                          valid = false;
                          break;
                        }
                      } else if (constraintFailure) {
                        valid = false;
                        break;
                      }
                    } else {
                      // logError(errorMsgs.MISSING_KEY(keyName, value));
                      valid = false;
                      break;
                    }
                  }
                } else if (constraintFailure) {
                  valid = false;
                } else {
                  throw new Error(errorMsgs.TYPE_MUST_BE('required', 'object'));//No I18n
                }
              }
                break;
              case 'allowable': {
                if (typeChecks.object(constraint)) {
                  for (let keyName in constraint) {
                    if (value.hasOwnProperty(keyName)) {
                      const validatorFn = constraint[keyName];
                      if (typeChecks.function(validatorFn)) {
                        if (!validatorFn(value[keyName])) {
                          // logError(errorMsgs.INVALID_VALUE(keyName, value));
                          valid = false;
                          break;
                        }
                      } else if (constraintFailure) {
                        valid = false;
                        break;
                      }
                    }
                  }
                } else if (constraintFailure) {
                  valid = false;
                } else {
                  throw new Error(errorMsgs.TYPE_MUST_BE('allowable', 'object'));//No I18n
                }
              }
                break;
              case 'everyValue': {
                if (typeof constraint === 'function') {//No I18n
                  valid = Object.keys(value).every(function (key) {
                    const eachValue = value[key];
                    return constraint(eachValue);
                  })
                } else if (constraintFailure) {
                  valid = false;
                }
              }
                break;
              case 'prototype': {
                if (typeChecks.object(constraint)) {
                  if (constraint.required) {
                    const subConstraint = constraint.required;
                    if (typeChecks.object(subConstraint)) {
                      for (let keyName in subConstraint) {
                        if (keyName in value) {
                          const validatorFn = subConstraint[keyName];
                          if (typeChecks.function(validatorFn)) {
                            if (!validatorFn(value[keyName])) {
                              valid = false;
                              break;
                            }
                          } else if (constraintFailure) {
                            valid = false;
                            break;
                          }
                        } else {
                          // logError(errorMsgs.MISSING_KEY(keyName, value));
                          valid = false;
                          break;
                        }
                      }
                    } else if (constraintFailure) {
                      valid = false;
                    } else {
                      throw new Error(errorMsgs.TYPE_MUST_BE('required', 'object'));//No I18n
                    }
                  }
                  if (constraint.allowable) {
                    const subConstraint = constraint.allowable;
                    if (typeChecks.object(subConstraint)) {
                      for (let keyName in subConstraint) {
                        if (keyName in value) {
                          const validatorFn = subConstraint[keyName];
                          if (typeChecks.function(validatorFn)) {
                            if (!validatorFn(value[keyName])) {
                              // logError(errorMsgs.INVALID_VALUE(keyName, value));
                              valid = false;
                              break;
                            }
                          } else if (constraintFailure) {
                            valid = false;
                            break;
                          }
                        }
                      }
                    } else if (constraintFailure) {
                      valid = false;
                    } else {
                      throw new Error(errorMsgs.TYPE_MUST_BE('allowable', 'object'));//No I18n
                    }
                  }
                } else if (constraintFailure) {
                  valid = false;
                } else {
                  throw new Error(errorMsgs.TYPE_MUST_BE('required', 'object'));//No I18n
                }
              }
                break;
            }
          } else {
            valid = false;
          }
        }
        return (valid && callback) ? callback(value) : valid;
      }
    }
  }
  const extender = function (name, options, extendFrom, callback) {
    if (!skipExistsCheck && this[name]) {
      throw new Error(errorMsgs.VALUE_EXISTS(name, 'Type Checks'));//No I18n
    } else if (basicTypeChecks.hasOwnProperty(extendFrom)) {
      if (typeof name !== 'string') {
        throw new Error('Name must be a string. Found ' + name);//No I18n
      } else {
        this[name] = basicTypeChecks[extendFrom](options, callback)
        return this[name];
      }
    }
    return false;
  }
  const safeExtender = function (name, options, extendFrom, callback) {
    if (this[name]) {
      return this[name];
    } else {
      skipExistsCheck = true;
      const output = extender.call(this, name, options, extendFrom, callback);
      skipExistsCheck = false;
      return output;
    }
  }
  for (let basicType in basicTypeChecks) {
    extender[basicType.toLowerCase()] = function (name, options, callback) {
      return this.call(typeChecks, name, options, basicType, callback);
    }
    safeExtender[basicType.toLowerCase()] = function (name, options, callback) {
      return this.call(typeChecks, name, options, basicType, callback);
    }
  }
  const manipulator = (0,_deepFreezer_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    $extend: extender,
    $safeExtend: safeExtender,
    later: function (typeName) {
      const symbol = Symbol(typeName);
      symbolMap[symbol] = typeName;
      return symbol;
    },
    or: function () {
      const args = Array.from(arguments);
      return function (value) {
        return args.some(function (typeCheck) {
          typeCheck = checkInSymbols(typeCheck);
          if (typeof typeCheck !== 'function') {//No I18n
            return false;
          }
          return typeCheck(value, true); // Constraint Failure is allowable here
        })
      }
    },
    and: function () {
      const args = Array.from(arguments);
      return function (value) {
        return args.every(function (typeCheck) {
          typeCheck = checkInSymbols(typeCheck);
          if (typeof typeCheck !== 'function') {//No I18n
            return false;
          }
          return typeCheck(value, true); // Constraint Failure is allowable here
        })
      }
    },
    dispose: function () {
      for (let key in this) {
        delete this[key];
      }
    }
  })
  const typeChecks = Object.assign(Object.create(manipulator), {
    boolean: function (value) {
      return typeof value === 'boolean';//No I18n
    },
    regex: function (value) {
      return (function () {
        // ? This is done to take the current RegExp Instance whenever the function runs
        return value instanceof RegExp;
      }());
    },
    function: function (value) {
      return typeof value === 'function';//No I18n
    }
  })
  typeChecks.$extend.string('string', {});
  typeChecks.$extend.number('number', {});
  typeChecks.$extend.array('array', {});
  typeChecks.$extend.object('object', {});
  return typeChecks;
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (checkType);
// window[PACKAGE_NAME].checkType = checkType;
})();

Object(window["html-parser"]).checkType = __webpack_exports__["default"];
/******/ })()
;