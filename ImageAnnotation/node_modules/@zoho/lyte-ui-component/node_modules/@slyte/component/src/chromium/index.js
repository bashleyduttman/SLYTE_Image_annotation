//ignorei18n_start
if(!debug) {
    console.warn = console.log = function() {};   
}
win = window || {};
dom = document || {};
win.elifHold = false;

var templateWorker = new Worker("worker.js");
function replaceErrors(key, value) {
    if (value instanceof Error) {
        var error = {};
        Object.getOwnPropertyNames(value).forEach(function (key) {
            error[key] = value[key];
        });
        return error;
    }
    return value;
}
var defaultComponents = ["link-to"];
var defaultSrcComponents = ["lyte-event-listener","import-shadow-style"];
var defaultHelpers = ["unbound","action","lbind","method","unescape","escape","debugger","log","ifEquals","if","negate","ifNotEquals",'concat','encAttr','expHandlers'];
var defaultDirectives = ["shadow","shadow-supported","turbo","turbo-supported","view-in","view-out","unbound"];
var defaultImpDetails = {
    components : [],
    helpers : [],
    alreadyImported : false
}
function getArgString(name, array) {
    let retString;
    for(let i=0;i < array.length;i++) {
        console.log("array content"+JSON.stringify(array[i]));
        if(array[i] && typeof array[i] === "object") {
            array[i] = this.getArgString(array[i].value.name, array[i].value.args);
        }
    }
    if(name) {
        retString = name +  "(" + array.toString() + ")";
    } else {
        retString = array.toString();
    }
    return retString;
}
function getImportedHelpers(array , helperArr) {
    for(let i=0;i < array.length;i++) {
        if(array[i] && typeof array[i] === "object") {
            let helperName = array[i].value.name;
            if(helperArr.indexOf(helperName) == -1 && defaultHelpers.indexOf(helperName) == -1){
                helperArr.push(helperName);   
            }
            array[i] = this.getImportedHelpers(array[i].value.args ,helperArr);
        }
    }
}

function trimAttr(tempVal, errors, node, attrNode, componentName){
    var trimmedVal;
    trimmedVal = tempVal.replace(/((const)|(continue)|(default)|(delete)|(do)|(else)|(enum)|(export)|(extends)|(finally)|(for)|(function)|(if)|(import)|(in)|(instanceof)|(new)|(return)|(super)|(switch)|(try)|(typeof)|(var)|(void)|(while)|(with))(?!\w)/g,'__LyteHelper$1__')
    try {
        var expOutput = expHandlers.handleExpression(Espree.parse(trimmedVal), true);
        if(expOutput && (expOutput !== trimmedVal)) {
            expOutput = expOutput.replace(/__LyteHelper(\w*?)__/g,'$1' );
            tempVal = "{{" + expOutput + "}}";
        }
    } catch(e) {
        trimmedVal = trimmedVal.replace(/__LyteHelper(\w*?)__/g,'$1' );
        tempVal = trimmedVal;
        if(e.message === "Only helper function calls are allowed") {
            if(attrNode) {
                e.message = "(LC:1)Syntax error in node "+node.nodeName+" for the attribute: "+attrNode.nodeName+" - "+attrNode.nodeValue + ". Only helper function calls are allowed"
                errors.push(new Error(e));
            } else {
                e.message = "(LC:2)Syntax Error in node "+node.nodeName+" for :"+node.nodeValue + ". Only helper function calls are allowed"
                errors.push(new Error(e));
            }
        }
    }
    return tempVal;
}
function syntaxCheckWorkerNew(val){
    var parsingMustache;
    var retObj = {
        "mustache":0,
        bool : true,
        err : null
    }
    for(i=0;i<val.length;i++){
        if(parsingMustache){
            if(val[i] == "\\"){
                i=i+1;
            }
            else if(val[i] == "'"){
                if(lastString != '"'){//val[i-1] != "\\"  && 
                    if(!stringStarted){
                        stringStarted = true;
                        lastString = "'";
                    }else{
                        stringStarted = false;
                        lastString = undefined;
                    }
                }
            }
            else if(val[i] == '"'){
                if(lastString != "'"){//val[i-1] != "\\" &&
                    if(!stringStarted){
                        stringStarted = true;
                        lastString = '"'
                    }else{
                        stringStarted = false;
                        lastString = undefined;
                    }
                }
            }
            else if(val[i] == "{" && !stringStarted){
                retObj.bool = false;
                retObj.err = " unexpected '{' bracket ";
                return retObj;
            }
            else if(val[i] == "{" && stringStarted && val[i-1] == "{"){
                retObj.mustache ++;
                // val = val.substr(0,i-1) + "_à__à_" + val.substr(i+1,val.length);
                // i = i + 4;
            }
            else if(val[i] == "}" && val[i-1] == "}" && !stringStarted){
                if(curlyBracket.length){
                    retObj.bool = false;
                    retObj.err = " error unmatched '(' bracket ";
                    return retObj;
                }
                if(squareBracket.length){
                    retObj.bool = false;
                    retObj.err = " unmatched '['bracket ";
                    return retObj;
                }
                parsingMustache = false;
            }
            else if(val[i] == "[" && !stringStarted){
                squareBracket.push("[");
            }
            else if(val[i] == "]" && !stringStarted){
                if(squareBracket.length){
                    squareBracket.pop();
                }else{
                    retObj.bool = false;
                    retObj.err = " unmatched ']' bracket ";
                    return retObj;
                }
            }
            else if(val[i] == "(" && !stringStarted){
                curlyBracket.push('(');
            }
            else if(val[i] == ")" && !stringStarted){
                if(curlyBracket.length){
                    curlyBracket.pop();
                }else{
                    retObj.bool = false;
                    retObj.err = " unmatched ')' bracket ";
                    return retObj;
                }
            }
        }
        else if((val[i] == "{" && val[i-1] == "{" && val[i-2] != "\\")){
            var curlyBracket =[] ,squareBracket =[] ,stringStarted ,lastString;
            var parsingMustache = true;
        }
    }
    if(parsingMustache){
        retObj.bool = false;
        retObj.err = " unmatched '{' bracket";
        return retObj;
    }
    return retObj;
}
function pushDir(impObj,dirName){
    if(defaultDirectives.indexOf(dirName) != -1){
        let actDirName = impObj.dirMap[dirName];
        if(actDirName && impObj.defaultDirectives.indexOf(actDirName) == -1){
            impObj.defaultDirectives.push(actDirName);
        }else if(impObj.defaultDirectives.indexOf(dirName) == -1){
            impObj.defaultDirectives.push(dirName);
        }
    }
    else if(impObj.directives.indexOf(dirName) == -1){
        impObj.directives.push(dirName);
    }
}
function getDynamicNodes(fileName) {
    return new Promise(async function(resolve,reject) {
        var timmer = new Date().getTime();
    var s, comp ,errors = [], warnings = [];
    if(debug) {
        comp = dom.querySelector("template[tag-name='"+fileName+"']")
    } else {
        comp = dom.querySelector("template[tag-name='"+fileName+"']")
    }
    console.log("components generating dynamicNodes"+fileName);
    if(!comp) {
        errors.push(new Error("(LC:20)Cannot find template "+fileName));           
        popTheTab(fileName,{
            componentName : fileName,
            errors : JSON.stringify(errors,replaceErrors),
            warnings : warnings
        });     
    } else {
        var nextElement = comp.nextElementSibling;
        if(nextElement && nextElement.tagName == "TEMPLATE" && nextElement.hasAttribute("view-port-template")) {
            warnings.push({message: "Depricated Syntax : 'view-port-template' found in " + fileName + " . Migrate your app to using latest slyte-migrator."});
            var viewPortIf = dom.createElement("template");
            viewPortIf.setAttribute("lyte-if", "{{lyteViewPort}}");
            viewPortIf.setAttribute("__vp","c-old");
            viewPortIf.content.appendChild(dom.createElement("dummy-port-element"));
            viewPortIf.content.appendChild(nextElement.content);
            viewPortIf.content.appendChild(dom.createElement("dummy-port-element"));
            var falseCase = dom.createElement("template");
            falseCase.setAttribute("lyte-else","");
            falseCase.content.appendChild(comp.content);
            comp.innerHTML = "";
            comp.content.appendChild(viewPortIf);
            comp.content.appendChild(falseCase);
            nextElement.remove();
        }
        else if(nextElement && nextElement.tagName == "TEMPLATE" && nextElement.attributes["@view-out"]) {
            var viewPortIf = dom.createElement("template"); //actual content
            let attrVal = comp.getAttribute("@view-in");
            if(attrVal.startsWith("{{")){
                attrVal = attrVal.substring(2, attrVal.length-2);
                viewPortIf.setAttribute("lyte-if", "{{lyteViewPort(" + attrVal + ")}}");
            }else if(attrVal === ""){;
                viewPortIf.setAttribute("lyte-if", "{{lyteViewPort()}}");
            }
            else{
                viewPortIf.setAttribute("lyte-if", "{{lyteViewPort(" + attrVal + ")}}");
            }
            viewPortIf.setAttribute("__vp","c-new");
            viewPortIf.content.appendChild(comp.content);
            comp.removeAttribute("@view-in");
            
            var viewPortElse = dom.createElement("template");//loading
            viewPortElse.setAttribute("lyte-else", "");

            viewPortElse.content.appendChild(dom.createElement("dummy-port-element"));
            viewPortElse.content.appendChild(nextElement.content);
            viewPortElse.content.appendChild(dom.createElement("dummy-port-element"));

            comp.innerHTML = "";
            
            comp.content.appendChild(viewPortIf);
            comp.content.appendChild(viewPortElse);
            nextElement.remove();
            comp.setAttribute("__vp","c-new");
        }
        s = comp.content;               
    }
    if(s) {
        var impObj = {
            "components" : [],
            "helpers" : [],
            "directives" : [],
            "defaultDirectives" : [],
            "defaultComponents" : [],
            "registryMap" : {},
            "options" : {
                "internalSlicer" : {}
            },
            dirMap : {
                "shadow-supported" : "lyte-shadow",
                "shadow" : "lyte-shadow",
                "turbo-supported" : "lyte-turbo",
                "unbound" : "lyte-turbo",
                "turbo" : "lyte-turbo",
                "view-in" : "lyte-view",
                "view-out" : "lyte-view"
            }
        }
        splitTextNodes(s,warnings,undefined,impObj,errors,fileName);
        var dynamicNodes = [];
        var attrStrict = comp.getAttribute("use-strict");
        // var isStrict = ( attrStrict != null ) ? true : false;
        // var strict = window.useStrict || isStrict;
        // strict = strict ? attrStrict !== "false" : strict; 
        var strict = (attrStrict == false ||  attrStrict == "false") ? attrStrict : attrStrict == undefined ? window.useStrict: attrStrict;
        if(strict == "false") {
            strict = false;
        } else if(strict == "true") {
            strict = true;
        }

        if(strict) {
            let err;
            if(s.querySelector("script")){
                err = new Error("(LC:21)Security: Script tags should not be included")
                err.strict = true;
                errors.push(err);
            }
            if(s.querySelector("style")){
                err = new Error("(LC:22)Security: Style tags should not be included");
                err.strict = true;
                errors.push(err);
            }                 
        }
        var d = [];
        try{
            await newGetDeepNodes(fileName, comp, d, [], undefined, true , errors, warnings);
            await processTemplate(s,dynamicNodes,fileName,strict,errors,warnings);
            getTransitionOrder(dynamicNodes);
        }catch(e){
            errors.push(new Error("Syntax error : " + " : " +e));
        }
        var obb = {};
        getTemplateDirectChild(dynamicNodes,obb);
        if(obb && (obb.hc || obb.trans)){
            var newobb = {
                "type" : "dc",
                "trans" : obb.trans,
                hc: obb.hc,
                p : obb.dc
            }
            dynamicNodes.push(newobb);
        }
        let attr = comp.attributes;
        for(let i = 0; i< attr.length; i++){
            let attrName = attr[i].name;
            if(attrName.startsWith("@")){
                let dirName = attrName.split("@")[1];
                pushDir(impObj,dirName);
            }
        }
        if(errors.length){             
            popTheTab(fileName,{
                componentName : fileName,
                timeoutError :  localStorage.getItem(fileName),
                errors : JSON.stringify(errors,replaceErrors),
                warnings :warnings
            });
        } else {   
            let template = comp.outerHTML;
            template = "_template = " + JSON.stringify(template+"____cssContent")+";";
            dynamicNodes ="_dynamicNodes = " + JSON.stringify(dynamicNodes)+";";
            popTheTab(fileName,{ 
                componentName : fileName,
                timeoutError :  localStorage.getItem(fileName),
                template,
                dynamicNodes,
                _templateAttributes : d[0],
                warnings : warnings,
                importDetails : impObj,
                needToImpDetails  : defaultImpDetails
            });   
            defaultImpDetails = {
                components : [],
                helpers : [],
                alreadyImported : false
            }         
        }
    }

    if(new Date().getTime()-timmer > 10000) {        
        var xhr = new XMLHttpRequest();
        xhr.open("POST", 'ht'+'tp:'+'//'+'localhost:'+window.location.port+'/warning', true);
        xhr.setRequestHeader("Content-Type","application/text");
        xhr.send(fileName);   
    }
     
      
    resolve();
    
    });       
}
function popTheTab(fileName,result) {
    if(production) {
        response[fileName] = response[fileName] ? Object.assign(response[fileName],result) : result;
    } else {
        worker.port.postMessage({msg :"tabfree",finalObj : result,componentName : fileName,portNo : portNo,endTime : new Date().getTime(),tabno : tabno});
    }
}
function getImpDetails(node){
    var obj = {};
    var name = node.getAttribute("name");
    var from = node.hasAttribute("from") ? node.getAttribute("from") : false;
    try{
        name = JSON.parse(name);
    }catch(e){

    }
    if(!Array.isArray(name)){
        name = [name];
    }
    obj.name = name;
    if(from){
        obj.from = from;
    }
    return obj;
}
function impDetails(node,impObj){
    var nodeType = node.localName;
    var obj = {};
    let compArr = impObj.components;
    let helpersArr = impObj.helpers;
    let pushToObj = function(obj,arr){
        let names = obj.name;
        let length = names.length;
        for(let i =0;i<length;i++){
            impObj.registryMap[names[i]] = obj.from;
        }
        arr.push(...names);
    }
    switch(nodeType){
        case "import-component" : {
            obj = this.getImpDetails(node);
            pushToObj(obj,compArr);
        }break;
        case "import-helper" : {
            obj = this.getImpDetails(node);
            pushToObj(obj,helpersArr);
        }break;
    }
}
function pushImpDetails(obj,helpersArr){
    if(obj && obj.importHelperArray && obj.importHelperArray.length){
        for(var n=0; n<obj.importHelperArray.length; n++){
            let val = obj.importHelperArray[n];
            if(!helpersArr.includes(val)){
                helpersArr.push(val);
            }   
        }
    }
}
function checkAttr(obj,key){
    return (obj.hasAttribute(key)) ? key : false;
}
function getErrorInfo(obj){
    
    let key = checkAttr(obj,"lyte-if") || checkAttr(obj,"lyte-switch") || checkAttr(obj,"lyte-for") || checkAttr(obj,"lyte-for-in"),
        errorInfo = undefined;
    if(!key && /(for|forIn|if|switch)$/.test(obj.getAttribute("is"))){
        key = obj.getAttribute("is");
    }
    if (key) {
        errorInfo = {
            name: "errorInfo",
            details: {
                tagName: obj.tagName,
                name: key,
                value: obj.getAttribute(key).replace(/{{/g, "@mus@")
            }
        }
    }
    return errorInfo;
}
function addUnbound(node,template,tagName,parentElementName){
    let hasUnbound,unboundVal,hasFastRender,fastRenderVal;
    if(node.hasAttribute("@unbound")){
        hasUnbound = true;
        unboundVal  = node.getAttribute("@unbound");
        node.removeAttribute("@unbound");
    }
    if(node.hasAttribute("@turbo")){
        hasFastRender = true;
        fastRenderVal  = node.getAttribute("@turbo");
        node.removeAttribute("@turbo");
    }
    if(hasUnbound || hasFastRender){
        let unboundHtml;
        if(unboundVal || fastRenderVal){
            unboundHtml = "<" + tagName;
            if(hasUnbound){
                if(unboundVal){
                    unboundHtml = unboundHtml + " @unbound=" + unboundVal;
                }else{
                    unboundHtml = unboundHtml +" @unbound";
                }
            }
            if(hasFastRender){
                if(fastRenderVal){
                    unboundHtml = unboundHtml + " @turbo=" + fastRenderVal;
                }else{
                    unboundHtml = unboundHtml +" @turbo";
                }
            }
            unboundHtml = unboundHtml + ">" + "</" + tagName + ">";
        }else if(hasUnbound){
            unboundHtml = "<"+ tagName +" @unbound></"+ tagName +">";
        }else if(hasFastRender){
            unboundHtml = "<"+ tagName +" @turbo></"+ tagName +">";
        }
        let root = "div";
        if(parentElementName){
            root = parentElementName;
        }
        let div = dom.createElement(root);
        div.innerHTML = unboundHtml;
        template = div.firstChild;
    }else{
        template = dom.createElement(tagName);
    }
    return template;
}
function splitTextNodes(node, warnings,svg,impObj,errors,fileName) {
    var nodeName = node.localName;
    let compVal = defaultImpDetails.components;
    if(nodeName && nodeName.indexOf("-") != -1 && compVal.indexOf(nodeName) == -1 && defaultComponents.indexOf(nodeName) == -1 ){
        if(nodeName == "lyte-import" || nodeName == "import-component" || nodeName == "import-helper"){
            defaultImpDetails.alreadyImported = true;
        }else if(defaultSrcComponents.indexOf(nodeName) != -1 && impObj.defaultComponents.indexOf(nodeName) == -1){
            impObj.defaultComponents.push(nodeName);
        }else{
           compVal.push(nodeName);
        }
    }

    if(node.tagName === "svg") {
        svg = true;
    }
    if(node.hasAttribute) {
        if(node.hasAttribute("is") && /(for|forIn|if|switch)$/.test(node.getAttribute("is")) && node.getAttribute("_jsp") != "true"  && !node.hasAttribute("lyte-for") && !node.hasAttribute("lyte-for-in") && !node.hasAttribute("lyte-if") && !node.hasAttribute("lyte-switch") && !node.hasAttribute("_new")){
            warnings.push({message: "Depricated Syntax : '"+errorNodeDetails(node)+"' Change it to " +"'lyte-" + node.getAttribute("is") + "' syntax. It will not be supported in upcoming versions.\n"})
        }
        if(svg && node.tagName == "template" && node.hasAttribute("is") && /(for|forIn|if|switch)$/.test(node.getAttribute("is"))){
            var template = dom.createElement("template");
            template.innerHTML = node.innerHTML
            var attrs = node.attributes;
            for(var i=0;i<attrs.length;i++) {
                template.setAttribute(attrs[i].nodeName, attrs[i].nodeValue);
            }
            node.replaceWith(template);
            node = template;
        }
        if(node.hasAttribute("lyte-for")) {
            let errorInfo = getErrorInfo(node);
            var lyteFor = node.getAttribute("lyte-for");
            var lyteForOptions = {};
            if(node.hasAttribute("lyte-options")) {
                try{
                lyteForOptions = JSON.parse(node.getAttribute("lyte-options"));
                } catch(e) {
                    lyteForOptions = {};
                } 
            }
            var lyteForArr = lyteFor.split(" ");
            var template;
            if(node.tagName === "TEMPLATE") {
                template = node;   
            } else if(svg && node.tagName == "template"){
                template = this.addUnbound(node,template,"template");    
                node.removeAttribute("lyte-for");
                node.removeAttribute("lyte-options");
                template.innerHTML = node.innerHTML;
                node.replaceWith(template);
                node = template;
            }
            else {
                template = this.addUnbound(node,template,"template");
                node.removeAttribute("lyte-for");
                node.removeAttribute("lyte-options");
                template.innerHTML = node.outerHTML;
                node.replaceWith(template);
                node = template;
            }
            node.removeAttribute("lyte-for");
            node.removeAttribute("lyte-options");
            template.setAttribute("items" , lyteForArr[0]);
            template.setAttribute("item", lyteForArr[2] || "item");
            template.setAttribute("index", lyteForArr[3] || "index");
            template.setAttribute("is", "for");
            template.setAttribute("_new","true");
            template.setAttribute("errorinfo" , JSON.stringify(errorInfo));
            if(lyteForOptions.unbound) {
                template.setAttribute("unbound", lyteForOptions.unbound);
            }

        } else if(node.hasAttribute("lyte-for-in")) {
            let errorInfo = getErrorInfo(node);
            var lyteFor = node.getAttribute("lyte-for-in");
            var lyteForOptions = {};
            if(node.hasAttribute("lyte-options")) {
                try{
                    lyteForOptions = JSON.parse(node.getAttribute("lyte-options"));
                } catch(e) {
                    lyteForOptions = {};
                } 
            }
            var lyteForArr = lyteFor.split(" ");
            var template;
            if(node.tagName === "TEMPLATE") {
                template = node;
                node.removeAttribute("lyte-for-in");
                node.removeAttribute("lyte-options");
            } 
            else if(svg && node.tagName=="template"){
                template = this.addUnbound(node,template,"template");
                node.removeAttribute("lyte-for-in");
                node.removeAttribute("lyte-options");
                template.innerHTML = node.innerHTML
                node.replaceWith(template);
                node = template;
            }
            else {
                template = this.addUnbound(node,template,"template");
                node.removeAttribute("lyte-for-in");
                node.removeAttribute("lyte-options");
                template.innerHTML = node.outerHTML;
                node.replaceWith(template);
                node = template;
            }

            template.setAttribute("object" , lyteForArr[0]);
            template.setAttribute("value", lyteForArr[2] || "value");
            template.setAttribute("key", lyteForArr[3] || "key");
            template.setAttribute("is", "forIn");
            template.setAttribute("_new","true");
            template.setAttribute("errorinfo", JSON.stringify(errorInfo));
            if(lyteForOptions.unbound) {
                template.setAttribute("unbound", lyteForOptions.unbound);
            }
        } else if(node.hasAttribute("lyte-if")) {
            var modifiedIf = handleLyteIf(node,svg);
            node.replaceWith(modifiedIf);
            node = modifiedIf;
        } else if(node.hasAttribute("lyte-switch")) {
            // handleLyteSwitch(node,svg);//af check
            var modifiedSwitch = handleLyteSwitch(node,svg);
            node.replaceWith(modifiedSwitch);
            node = modifiedSwitch;
        } else if(svg && node.tagName == "template" && node.hasAttribute("is") && /(for|forIn|if|switch)$/.test(node.getAttribute("is"))){
            var template = dom.createElement("template");
            template.innerHTML = node.innerHTML
            var attrs = node.attributes;
            for(var i=0;i<attrs.length;i++) {
                template.setAttribute(attrs[i].nodeName, attrs[i].nodeValue);
            }
            node.replaceWith(template);
            node = template;
        }else if(node.hasAttribute("is") && node.getAttribute("is") == "if"){
            var modifiedIf = jspIfToSwitch(node);
            node.replaceWith(modifiedIf);
            node = modifiedIf;
        } 
        for(let i=0; i<node.attributes.length; i++){
            let attrName = node.attributes[i].name;
            if(attrName.startsWith("@")){
                let dirName = attrName.substring(1);
                pushDir(impObj,dirName);
                if(dirName == "view-in"){
                    let attrVal = node.attributes[i].value;
                    if(attrVal.startsWith("{{")){
                        attrVal = attrVal.substring(2, attrVal.length-2);
                        node.setAttribute("lyte-if", "{{lyteViewPort(" + attrVal + ")}}");
                    }else if(attrVal === ""){;
                        node.setAttribute("lyte-if", "{{lyteViewPort()}}");
                    }
                    else{
                        node.setAttribute("lyte-if", "{{lyteViewPort(" + attrVal + ")}}");
                    }
                    node.removeAttribute(attrName);
                    if(node.nextElementSibling && node.nextElementSibling.hasAttribute("@view-out")){
                        node.nextElementSibling.removeAttribute("@view-out");
                        node.nextElementSibling.setAttribute("lyte-else","");
                        var modifiedIf = handleLyteIf(node,svg);
                        node.replaceWith(modifiedIf);
                        node = modifiedIf;
                    }else{
                        errors.push(new Error("(LC:26) view-out directive not found"));
                    }
                }
            }
        }
        for(let i=0; i<node.attributes.length; i++){
            let attrName = node.attributes[i].name;
            if(attrName.startsWith("@")){
                let dirName = attrName.substring(1);
                pushDir(impObj,dirName);
            }
        }
    }

    if(node && node.childNodes && node.childNodes.length) {
        for(var i=node.childNodes.length-1;i>=0;i--) {
            var chlNode = node.childNodes[i];
            if(chlNode.hasAttribute) {
                if(chlNode.hasAttribute("lyte-if-else") || chlNode.hasAttribute("lyte-else")) {
                    if(!(chlNode.previousElementSibling && (chlNode.previousElementSibling.hasAttribute("lyte-if") || chlNode.previousElementSibling.hasAttribute("lyte-else-if") ) ) ) {
                        warnings.push({message: "Element with lyte-else must be preceded by a element having lyte-if or lyte-else :\n \t" + chlNode.cloneNode().outerHTML})
                    }
                } else {
                    if(ide && node.childNodes[i].getAttribute("case") == "false"){
                        win.elifHold = true;
                    }
                    splitTextNodes(node.childNodes[i], warnings,svg,impObj,errors,fileName);    
                }
            } else {
                splitTextNodes(node.childNodes[i], warnings,svg,impObj,errors,fileName);    
            }
        }
    }
    if(node.tagName === "TEMPLATE") {
        splitTextNodes((node.content)?node.content:createDocFragment(node), warnings ,svg ,impObj,errors,fileName);
    }
    if(node.tagName == "LYTE-IMPORT"){
        var impNode = node;
        while(impNode.previousSibling){
            if(impNode.previousSibling.nodeValue.trim() != ""){
                errors.push(new Error("(LC:25) lyte-import tag should be the first child of the component."))
            }
            impNode = impNode.previousSibling;
        }
        for(let c=0; c<node.children.length; c++){
            impDetails(node.children[c],impObj);
        }
        if(node.previousSibling && node.previousSibling.nodeValue == " " && node.nextSibling && node.nextSibling.nodeValue == " "){
            node.previousSibling.remove();
        }
        node.remove();
        return;
    }
    if(node.nodeType === node.TEXT_NODE) {
        var nodeValue = node.nodeValue;
        if(nodeValue){
    let mustacheValues = nodeValue.match(/{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}/g); //'
    if(!mustacheValues) {
                return;
            }
            var newNodeArray = [];
            for(var i=0;i<mustacheValues.length;i++) {
                var mustacheStartIndex = nodeValue.indexOf(mustacheValues[i]);
                var mustacheEndIndex = mustacheStartIndex + mustacheValues[i].length;
                if(mustacheStartIndex) {
                        newNodeArray.push(dom.createTextNode(nodeValue.substring(0, mustacheStartIndex)));
                }
                newNodeArray.push(dom.createTextNode(nodeValue.substring(mustacheStartIndex, mustacheEndIndex)));
                nodeValue = nodeValue.substring(mustacheEndIndex);
            }
            newNodeArray.push(dom.createTextNode(nodeValue));
            node.replaceWith.apply(node, newNodeArray);
        }
    }
}

//This method will run through all the nodes of the template and put the dynamicNode positions 
//in deepNodes and helper node positions in helperNodes
//By helper nodes, we mean all the for and if helpers which are present in the component template. 
//The template will contain the dynamicNodes. 
//For template contains - _forTemplate, which will contain the content and _dynamicNodes
//If template contains - _trueCase, _falseCase, which will contain the content and _dynamicNodes.
async function processTemplate(node, deepNodes, componentName,strict,errors,warnings,nearByParent){
    let isBreak = node.querySelector('template[is=break]');
    if(isBreak) {
        this.getTrimmedContent(node, undefined, isBreak);
    }
    let isContinue = node.querySelector('template[is=continue]');
    if(isContinue) {
        this.getTrimmedContent(node,undefined, isContinue);
    }
    this.helperNodes = [];
    if(node.hasChildNodes()) {
        let runningIndex = 0;
        let oldParent;
        if(nearByParent == "svg" || nearByParent == "foreignObject"){
            oldParent = nearByParent;
        }
        for(let i=0;i<node.childNodes.length;i++) {
            let deepN = [];
            deepN.push(i);
            let index = 0;
            let tagName = node.childNodes[i].tagName;
            if(tagName) {
                if(tagName == "svg"){
                    nearByParent = "svg";
                } else if(tagName == "foreignObject" || tagName == "FOREIGNOBJECT"){
                    nearByParent = "foreignObject";
                }
                let is = node.childNodes[i].getAttribute("is");
                if(tagName === "TEMPLATE" && is) {
//                        index = helperNodes.push(node.childNodes[i]);
                    //We will be adding an attribute index1 in the helper templates, 
                    //This is done because we will be storing all the helper nodes as such in an array _helperNodes in the component template. 
                    //In order to lookup to the dynamicNodes of the for template or if template, we need to have a reference of which 
                    //helper we are calling. 
                    //By this way, we will be adding an index1 Attribute which will contain index startign from 0. 
                    //This index refreshes for each component registration. 
//                        node.childNodes[i].setAttribute("index1", index-1);
                    await this.newGetDeepNodes(componentName,node.childNodes[i], deepNodes, deepN, is,strict,errors,warnings,nearByParent);
                }
                else {
                    await this.newGetDeepNodes(componentName,node.childNodes[i], deepNodes, deepN,undefined,strict,errors,warnings,nearByParent);
                }
                node.childNodes[i].removeAttribute("errorinfo")
            } else {
                await this.newGetDeepNodes(componentName,node.childNodes[i], deepNodes, deepN,undefined,strict,errors,warnings,nearByParent);
            }
            nearByParent = oldParent;
        }
        
    }

}
function errorNodeDetails(node){
    if(node.hasAttribute("errorinfo")){
        let errorInfo = JSON.parse(node.getAttribute("errorinfo"));
        return "`" + errorInfo.details.tagName + "`" + " with attribute " + errorInfo.details.name + "=\"" + errorInfo.details.value.replace(/@mus@/g,"{{") +"\"";
    }
    var str = node.cloneNode(true);
    str.innerHTML = ".....";
    return str.outerHTML;
}
function checkForMixedCase(val) {
    let seenDoubleQuotes = false,
        seenSingleQuotes = false,
        mustacheStarted = false,
        mixedCase = false;
    let slashCount = 0;
    let mustacheSpots = [],res = "",mus={};
    for (var i = 0; i < val.length; i++) {
        //remove spaces other than present in double and single quotes
        if (mustacheStarted && ((seenDoubleQuotes || seenSingleQuotes) || val[i].match(/\S/))) {
            res += val[i];
        }
        if (val[i - 1] != "\\" && val[i] == "{" && val[i + 1] == "{" && !seenDoubleQuotes && !seenSingleQuotes) {
            if(mustacheStarted){
                return {
                    bool:false,
                    errorIndex:i-mus.index[0]+1,
                    err:"Invalid dynamic value inside dynamic value `{{`"
                };
            }
            if (!mixedCase && i != 0) {
                mixedCase = true
            }
            mus = {}
            mus.index = [i];
            // spot[0] = i;
            mustacheStarted = true;
        }
        if (val[i] == "}" && val[i + 1] == "}" && !seenDoubleQuotes && !seenSingleQuotes && mustacheStarted) {
            if (!mixedCase && i + 1 != val.length - 1) {
                mixedCase = true
            }
            // spot[1] = i + 1;
            mus.index[1] = i + 1;
            mus.orgMus = val.substring(mus.index[0],mus.index[1]+1);
            mus.mus = "{"+res+"}";
            res = "";
            mustacheSpots.push(mus);
            mustacheStarted = false;
        }
        if (val[i] == "\\") {
            slashCount++;
        }
        if (val[i - 1] != "\\" || (val[i - 1] == "\\" && slashCount % 2 == 0)) {
            if (val[i] == "'" && !seenDoubleQuotes && mustacheStarted) {
                seenSingleQuotes = !seenSingleQuotes;
            }
            if (val[i] == '"' && !seenSingleQuotes && mustacheStarted) {
                seenDoubleQuotes = !seenDoubleQuotes;
            }
        }
        if (val[i] != "\\") {
            slashCount = 0;
        }

    }
    return {
        bool:true,
        mixedCase: mixedCase,
        mustacheSpots: mustacheSpots
    };
}
async function processAttr(componentName,node, deepNodes, deepN, is,strict,errors,warnings){
    if(node.hasAttributes && node.hasAttributes()) { //template has no attributes
        let add = false, toBeRemoved = [],toBeAdded = [];
        var attr = {};
        for(let i=0;i<node.attributes.length;i++) {
            let fnFlag;
            let eventListRegex = /^(onfocus|onfocusin|onfocusout|onresize|onscroll|onclick|ondblclick|onmousedown|onmouseup|onmousemove|onmouseover|onmouseout|onmouseenter|onmouseleave|onchange|onselect|onsubmit|onkeydown|onkeypress|onkeyup|oncontextmenu|ondragstart|ondrag|ondragenter|ondragleave|ondragover|ondrop|ondragend|onload|onunload|onabort|onerror|onscroll|onreset|onblur|onafterprint|onbeforeprint|ononbeforeunload|onerror|onhashchange|onload|onmessage|onoffline|ononline|onpagehide|onpageshow|onpopstate|onstorage|onunload|oninput|oninvalid|onsearch|ononmousewheel|onwheel|ondrag|ondragend|ondragenter|ondragleave|ondragover|ondragstart|ondrop|onscroll|ondrag|ondragend|ondragenter|ondragleave|ondragover|ondragstart|ondrop|onscroll|ondrag|ondragend|ondragenter|ondragleave|ondragover|ondragstart|ondrop|onscroll|onabort|oncanplay|oncanplaythrough|oncuechange|ondurationchange|onemptied|onended|onloadeddata|onloadedmetadata|onloadstart|onpause|onplay|onplaying|onprogress|onratechange|onseeked|onseeking|onstalled|onsuspend|ontimeupdate|onvolumechange|onwaiting|onpaste)$/;
            if(eventListRegex.test(node.attributes[i].nodeName) && strict){
                fnFlag = true;
            }
            if(node.attributes[i].nodeValue.indexOf("{{") !== -1) {
                node.attributes[i].nodeValue = node.attributes[i].nodeValue.replace('.{}','____lyteinternal____').trim();
                let val = node.attributes[i].nodeValue,
                    res = checkForMixedCase(val);
                if (res.bool) {
                    let {
                        mustacheSpots
                    } = res;
                    if (mustacheSpots.length && mustacheSpots.length > 0) {
                        for (let j = 0; j < mustacheSpots.length; j++) {
                            let x = mustacheSpots[j].mus
                            if(x.match(/\&|\||\!|\=|\+|-|\*|\/|<|>|\?|:|%/gm)){
                                x = trimAttr(x, errors, node, node.attributes[i], componentName);
                            }
                            val = val.replace(mustacheSpots[j].orgMus,function(){return x});
                        }
                    }
                    node.attributes[i].nodeValue = val;
                }
     
                var syn = syntaxCheckWorkerNew(node.attributes[i].nodeValue); 
                if(!syn.bool){
                    errors.push(new Error("(LC:syn2)Syntax error in node "+syn.err+" in "+node.nodeName+" for the attribute: "+node.attributes[i].nodeName+" - "+node.attributes[i].nodeValue));
                    continue;
                }
                var actObj,actValue;
                var splittedMus = val.split("{{");
                var splittedMusLen = splittedMus.length;
                if(syn && syn.mustache >0){
                    splittedMusLen = splittedMusLen - syn.mustache;
                }
                var ind = val.indexOf("}}");
                if((splittedMusLen > 2 || !/^{{/.test(val) || !/}}$/.test(val)) || val[ind+2] && /{{.*}}/.test(val) && !/\\{{.*}}/.test(val) ){
                    actObj = await splitMixedText(val,componentName,errors,node,i);
                }
                else{
                    actValue = await this.getMustache(val,componentName,syn);
                    if(actValue && actValue == "timeoutError"){
                        errors.push(new Error("(LC:timeout3)Syntax error in node "+actValue.err+" in "+node.nodeName+" for the attribute: "+node.attributes[i].nodeName+" - "+node.attributes[i].nodeValue));
                        continue;
                    }
                console.log("actValue response "+actValue+"val given to mustache"+val)
                if(actValue && typeof actValue === 'object'){
                    if(actValue.bool === false){
                    errors.push(new Error("(LC:6)Syntax error in node "+actValue.err+" in "+node.nodeName+" for the attribute: "+node.attributes[i].nodeName+" - "+node.attributes[i].nodeValue));
                    continue;
                    }
                }
                if(actValue){
                    actObj = await this.getArray(actValue);  
                    if(actObj && actObj == "timeoutError"){
                        errors.push(new Error("(LC:timeout7)Syntax error in node "+node.nodeName+" for the attribute: "+node.attributes[i].nodeName+" - "+node.attributes[i].nodeValue));
                        continue;
                    }
                    else if(actObj === false){
                        errors.push(new Error("(LC:12)Syntax error in node "+node.nodeName+" for the attribute:"+node.attributes[i].nodeName+"- "+node.attributes[i].nodeValue));
                        continue;
                    }
                }
                if(!actObj && actValue){
                    actValue = actValue.replace('____lyteinternal____','.{}');
                    actObj = await this.getHelper(actValue,componentName);  
                    if(actObj && actObj.args == "lbindError" || actObj == "lbindError"){
                        errors.push(new Error("(LC:lbind4)Syntax Error : lbind are not allowed inside helpers on node "+node.nodeName+" for: "+node.attributes[i].nodeValue));
                        continue;
                    }
                    else if(actObj && actObj.name == "lbind" && node.tagName == "TEMPLATE"&& node.hasAttribute("is") && /if|for|switch/g.test(node.getAttribute("is"))){
                        errors.push(new Error("(LC:lbind3)Syntax Error : lbind not allowed as value in if/for/switch node"+"for: "+val));
                    }
                    else if(actObj && actObj == "timeoutError"){
                        errors.push(new Error("(LC:timeout4)Syntax error in node "+node.nodeName+" for the attribute:"+node.attributes[i].nodeName+"- "+node.attributes[i].nodeValue));
                        continue;
                    }
                    else if(actObj === false){
                        errors.push(new Error("(LC:7)Syntax error in node "+node.nodeName+" for the attribute:"+node.attributes[i].nodeName+"- "+node.attributes[i].nodeValue));
                        continue;
                    }
                    if(actObj){
                        if(defaultImpDetails.helpers.indexOf(actObj.name) == -1 && defaultHelpers.indexOf(actObj.name) == -1){
                            defaultImpDetails.helpers.push(actObj.name);   
                        }
                        getImportedHelpers(actObj.args,defaultImpDetails.helpers);
                    }
                }
                }
                if( actObj && (actObj.name === "action" || actObj.name === "method") && /^(onfocus|onfocusin|onfocusout|onresize|onscroll|onclick|ondblclick|onmousedown|onmouseup|onmousemove|onmouseover|onmouseout|onmouseenter|onmouseleave|onchange|onselect|onsubmit|onkeydown|onkeypress|onkeyup|oncontextmenu)$/.test(node.attributes[i].name)){
                        add = true;
                        attr[node.attributes[i].name.substr(2)] = {name:node.attributes[i].name.substr(2),helperInfo: actObj, globalEvent: true};
                        let actArgs = deepCopyObject(actObj.args);
                        let actName = actArgs.splice(0,1)[0];
                        if (typeof actName != 'string' || !actName.startsWith("'")){
                            warnings.push({message:" action or method must start with string on "+node.nodeName+" for the attribute:"+node.attributes[i].nodeName+"- "+node.attributes[i].nodeValue});
                        }
                        else{
                        actName = actName.startsWith("'")? actName.replace(/'/g,''):  actName;
                        }
                        console.log("In action "+actName+' ,'+actArgs)
                        let actString = this.getArgString(actName, actArgs);
                        //node.setAttribute(node.attributes[i].name.substr(2),componentName+" => "+ actString);
                        toBeRemoved.push(node.attributes[i].name);                            
                }
                else{
                    if (actObj && (actObj.name === "action" || actObj.name === "method")){
                        if(actObj.args && (typeof actObj.args[0] === 'object' || !actObj.args[0].startsWith("'"))){
                            warnings.push({message:" action or method must start with string on "+node.nodeName+" for the attribute:"+node.attributes[i].nodeName+"- "+node.attributes[i].nodeValue});
                        }
                    } 
                    if(actObj || actValue) {
                        add = true;
                        let attrToPush = {};
                        if(node.attributes[i].name.startsWith("lbind:")) {
                            toBeRemoved.push(node.attributes[i].name);
                            toBeAdded.push({"name" : node.attributes[i].name.substring(6), "value": node.attributes[i].nodeValue});
                            attrToPush.isLbind = true;
                            attrToPush.name = node.attributes[i].name.substring(6);
                        }
                        else {
                            attrToPush.name = node.attributes[i].name;
                        }
                        if(actObj) {
                            if(actObj.name === "lbind") {
                                attrToPush.dynamicValue = actObj.args[0];
                                attrToPush.isLbind = true;
                            }
                            else {
                                attrToPush.helperInfo = actObj; 
                            }
                        } 
                        else {
                            attrToPush.dynamicValue = actValue;
//                              LN to do
//                              attrToPush.dynamicValue = getDynamicValue(actValue);
                        }
                        add = true;
                        attr[attrToPush.name] = attrToPush;
                    }                  
                }
                node.attributes[i].nodeValue = node.attributes[i].nodeValue.replace('____lyteinternal____','.{}');
                if(fnFlag && !(actObj && (actObj.name === "action"))){
                    console.log("(LC:22)Strict-Mode: Please specify action in "+node.nodeName+" for attribute-"+node.attributes[i].nodeName);
                    err = new Error("(LC:22)Strict-Mode: Please specify action in "+node.nodeName+" for attribute-"+node.attributes[i].nodeName);
                    err.strict= true;
                    errors.push(err);
                }
            }
            else {
                if(fnFlag){
                    console.log("(LC:23)Strict-Mode: Please specify action in "+node.nodeName+" for attribute-"+node.attributes[i].nodeName)
                    err = new Error("(LC:23)Strict-Mode: Please specify action in "+node.nodeName+" for attribute-"+node.attributes[i].nodeName);
                    err.strict= true;
                    errors.push(err);
                }  
                // else if((/{.*}/.test(node.attributes[i].nodeValue))){
                //     try {
                //         JSON.parse(node.attributes[i].nodeValue);
                //     } catch(e) {
                //         warnings.push({message:"Syntax error in node "+node.nodeName+" for the attribute:"+node.attributes[i].nodeName+"- "+node.attributes[i].nodeValue +" in the component "+componentName});
                        
                //     }
                 
                // }  
                // else if((/{.*:/.test(node.attributes[i].nodeValue)) || (/{/.test(node.attributes[i].nodeValue))) {
                //     try {
                //         JSON.parse(node.attributes[i].nodeValue);
                //     } catch(e) {                            
                //         errors.push(new Error("(LC:8)Syntax error in node "+node.nodeName+" for the attribute:"+node.attributes[i].nodeName+"- "+node.attributes[i].nodeValue +" in the component "+componentName));
                //         continue;
                //     }
                // }   
            }
            if(node.attributes[i].name.startsWith("@")){
                add = true;
                node._special = true;
                let attrToPush = {};
                attrToPush.name = node.attributes[i].name;
                attrToPush.dynamicValue = node.attributes[i].nodeValue;
                attr[attrToPush.name] = attrToPush;
                attr._special = true;
            }
        }
        
        if(attr && add){
            let dummyAttr = {}; 
            let keys = Object.keys(attr);
            if(keys.indexOf("style") !== -1) {
                dummyAttr.style = attr.style;
            }
            if(keys.indexOf("type") !== -1 && (node.tagName === "BUTTON" || node.tagName === "INPUT")) {
                dummyAttr.t = attr.type;
            }
            if(node.tagName === "INPUT" && node.getAttribute("type") === "number") {
                dummyAttr.value = attr.value;   
            }
            if(keys.indexOf("placeholder") !== -1 && node.tagName === "TEXTAREA") {
                node.removeAttribute("placeholder");
                dummyAttr.placeholder = attr.placeholder;
            }
            var obj = {"t": "a", p: deepN.slice()};
            if(node._special){
                obj.trans = true;
            }
            if(Object.keys(dummyAttr).length) {
                obj.a = dummyAttr;
            }
            deepNodes.push(obj);
        }
    }
    return attr;
}
//This method is the place where the deepNodes and helperNodes gets updated with the 
//Values of the positions of dynamicNodes and helperNodes. 
async function newGetDeepNodes(componentName,node, deepNodes, deepN, is,strict,errors,warnings,nearByParent) {
    node._parent = node.parentNode;
    let toBePushed;
    let errorMsg = "Usage of block helpers (for|forIn|if|switch) inside the tags (TABLE|TR|SELECT) will not work in IE11. \n If your app is supported for IE11, please use lyte ui components lyte-table and lyte-dropdown instead of table and select tags respectively";
    if(node.nodeType == 8){
        deepN.pop();
        return;
    }
    if(node.tagName && node.tagName.indexOf("-") !== -1 && node.tagName !== "LYTE-YIELD") {
        toBePushed = {"t" : "cD", p: deepN.slice()};
    }
    if(node.tagName === "LYTE-YIELD") {
        toBePushed = {"t" : "i", p : deepN.slice()};
    } else 
    if(is === "registerYield" || is === "yield") {
        let dynamicNodes = [];
        if(node.tagName != "TEMPLATE"){
            errors.push(new Error("(LC:24)Syntax error in node '"+errorNodeDetails(node)+"'"+". Yield must be given in template tag only"));
        }else{
            await this.processTemplate(node.content, dynamicNodes, componentName,strict,errors,warnings,nearByParent);
            getTransitionOrder(dynamicNodes);
            toBePushed = {"t" : "r", p: deepN.slice(), "dN" : dynamicNodes};
            getTemplateDirectChild(dynamicNodes,toBePushed);
        }
    } else if(is === "insertYield") {
        deepNodes.push({"t" : "i", p : deepN.slice()});
    } else 
    if(is === "for") {
        let template = node;
        // if(template.parentElement && /^(SELECT|TR|TABLE)$/.test(template.parentElement.tagName)) {
        //     warnings.push({message: errorMsg});
        // }
        node._forTemplate = {};
        
        if(template) {
            node._forTemplate.content = template.content;
            node._forTemplate.content._parent = template;
            let dynamicNodes = [];
            await this.processTemplate(node._forTemplate.content, dynamicNodes, componentName,strict,errors,warnings,nearByParent);
            getTransitionOrder(dynamicNodes);
            toBePushed = {"t": "f" ,p: deepN.slice(), "dN":dynamicNodes};
            getTemplateDirectChild(dynamicNodes,toBePushed);
            node = replaceParentNode(node, "for", toBePushed,componentName,errors,true,nearByParent);
        }
    } else if(is === "forIn"){
        let template = node;
        // if(template.parentElement && /^(SELECT|TR|TABLE)$/.test(template.parentElement.tagName)) {
        //     warnings.push({message: errorMsg});
        // }
        node._forInTemplate = {};
        
        if(template) {
            node._forInTemplate.content = template.content;
            node._forInTemplate.content._parent = template;
            let dynamicNodes = [];
            await this.processTemplate(node._forInTemplate.content, dynamicNodes ,componentName,strict,errors,warnings,nearByParent);
            getTransitionOrder(dynamicNodes);
            toBePushed = {"t": "fI" ,p: deepN.slice(), "dN":dynamicNodes};
            getTemplateDirectChild(dynamicNodes,toBePushed);
        }
        node = replaceParentNode(node, "forIn", toBePushed,componentName,errors,true,nearByParent);
    }
    else if(is === "switch" || is === "if" || is == "case"){
        // if(node.parentElement && /^(SELECT|TR|TABLE)$/.test(node.parentElement.tagName)) {
        //     warnings.push({message: errorMsg});
        // }
        let casesArr = {},defaultArr = {};
        let defaultCase = node.content.querySelector("[default]");
        let cases = node.content.querySelectorAll("[case]");
        var currentCaseTemplate;
        var tobj = {};
        var hasDynamicCase;
        var casesOrder = [];
        let prevCaseName;
        var rtObj = {};
        for(var i=0;i<cases.length;i++){
            let dynamicCaseName = false;
            var casesDeepNodes = []
            let currentCase = cases[i];
            currentCaseTemplate = cases[i];
            let caseName = currentCase.getAttribute("case");
            let actCaseName = caseName;
            tobj[actCaseName] = {};
            if(is === "switch" && caseName == ""){
                caseName = "\"\"";
            }
            if(is === "switch"){//check
                cases[i].setAttribute("is","case");
            }
            if(currentCase.tagName === "TEMPLATE" && (!currentCase.getAttribute("is") || currentCase.getAttribute("is")=='case')){
                currentCase.setAttribute("case", caseName );
                currentCase = currentCase.content;
            } 
            else {
                let temp = dom.createElement('template');
                let clone = currentCase.cloneNode(true);
                temp.content.appendChild(clone);
                temp.setAttribute("case", caseName );
                clone.removeAttribute('case');
                currentCaseTemplate = temp;
                currentCase = temp.content;
                cases[i].replaceWith(temp);
            }
            await processAttr(componentName,currentCaseTemplate, casesDeepNodes, [i], is,strict,errors,warnings);
            if(casesDeepNodes.length && cases[i].getAttribute("case").startsWith("{{")){
                dynamicCaseName = true;
                hasDynamicCase = true;
                var actName = cases[i].getAttribute("case");
                cases[i].dcn = true;
                caseName = "lc_id_"+i;
                currentCaseTemplate.setAttribute("lc-id",caseName);
                tobj[caseName] = tobj[actCaseName];
                delete tobj[actCaseName];
            }
            casesOrder.push(caseName);
            let dynamicNodes = [];
            currentCase._parent = node;
            await this.processTemplate(currentCase, dynamicNodes, componentName,strict,errors,warnings,nearByParent);
            getTransitionOrder(dynamicNodes);
            getTemplateDirectChild(dynamicNodes,tobj[caseName]);
            var rtObj = {};
            if(is === "if") {
                replaceCaseNode(currentCaseTemplate,componentName,errors,node,rtObj,nearByParent);
            }
            
            if(caseName === "") {
                caseName = '""';
            }
            casesArr[caseName] = {dN: dynamicNodes,cdp: casesDeepNodes[0]};
            dynamicNodes.forEach(function(dyn){
                dyn.cn = caseName;
            })
            if(dynamicCaseName){
                casesArr[caseName].dcn = true;
            }
            if(is==="if") {
                continue;
            }
            var prevCase = casesArr[prevCaseName];
            if(dynamicCaseName && prevCase && prevCase.additional && prevCase.additional.next){
                prevCase.additional.next = cases[i].getAttribute("lc-id");
            }
            let isBreak = currentCase.querySelector("template[is=break]");
            if(!isBreak) {
                if(cases[i+1]) {
                    casesArr[caseName].additional = {"next" : cases[i+1].getAttribute("case")};
                } else if(defaultCase){
                    casesArr[caseName].additional = {"default" : true};
                }
            }
            else {
                isBreak.remove();
            }
            replaceCaseNode(currentCaseTemplate,componentName,errors,node,rtObj,nearByParent);
            prevCaseName = caseName;
        }
        if(defaultCase){               
            let dCase;     
            let dCaseTemplate;           
            tobj["default"] = {}         
            if(defaultCase.tagName === "TEMPLATE" && !defaultCase.getAttribute("is")){               
                dCase = defaultCase.content;                  
                dCaseTemplate = defaultCase;
                }           
            else {        
                let temp = dom.createElement('template');             
                let clone = defaultCase.cloneNode(true);            
                temp.content.appendChild(clone);     
                temp.setAttribute("default", '');     
                clone.removeAttribute('default');             
                dCase = temp.content;               
                dCaseTemplate = temp;
                defaultCase.replaceWith(temp);      
            }      
            let isBreak = dCaseTemplate.content.querySelector("template[is=break]");
            if(isBreak){
                isBreak.remove();
            }
            let dynamicNodes = [];     
            dCase._parent = node;       
            await this.processTemplate(dCase, dynamicNodes, componentName,strict,errors,warnings,nearByParent);     
            getTransitionOrder(dynamicNodes);
            getTemplateDirectChild(dynamicNodes,tobj.default);
            dynamicNodes.forEach(function(dyn){
                dyn.cn = "default";
            })
            defaultArr = {dN: dynamicNodes};    
            replaceCaseNode(dCaseTemplate,componentName,errors,node,rtObj,nearByParent); 
        }
        is =="if" ? is="e" : is="s";

        if(is === "s"){
            getSwitchOrder(casesArr,tobj,defaultArr);
            let keys = Object.keys(casesArr);
            for(let i=0;i<keys.length;i++){
                getTemplateDirectChild(casesArr[keys[i]].dN,tobj[keys[i]]);
            }

        }
        toBePushed = {"t": is, p: deepN.slice(),"c":casesArr,"d":defaultArr,dc : tobj,"hd":hasDynamicCase,"co":casesOrder};
        if(rtObj.svg){
            toBePushed.svg = true;
        }
        is =="e" ? is="if" : is="switch";
        var keys = Object.keys(tobj);
        for(var x=0; x<keys.length; x++){
            if(tobj[keys[x]].hc){
                toBePushed.hc = true;
                toBePushed.trans = true;
            }
        }
        node = replaceParentNode(node, is, toBePushed,componentName,errors,undefined,nearByParent);
    }
    else if(is==="component") {
        
        node._componentTemplate = {};
        node._componentTemplate.content = node.content;
        let dynamicNodes = [];
        await this.processTemplate(node._componentTemplate.content, dynamicNodes, componentName,strict,errors,warnings,nearByParent);
        getTransitionOrder(dynamicNodes);
        toBePushed = {"t" : "cM", p: deepN.slice(), "dN" : dynamicNodes};
        getTemplateDirectChild(dynamicNodes,toBePushed);
    }
    else if(node.nodeType == 3) {
        if(node.nodeValue.indexOf("{{") !== -1) {
                node.nodeValue = node.nodeValue.replace('.{}','____lyteinternal____');
                let val = node.nodeValue,
                    res = checkForMixedCase(val);
                if (res.bool) {
                    const {
                        mustacheSpots
                    } = res;
                    tempVal = [];
                    if (mustacheSpots.length && mustacheSpots.length > 0) {
                        for (let j = 0; j < mustacheSpots.length; j++) {
                            let x = mustacheSpots[j].mus
                            if(x.match(/\&|\||\!|\=|\+|-|\*|\/|<|>|\?|:|%/gm)){
                                x = trimAttr(x, errors, node, undefined, componentName);
                            }
                            val = val.replace(mustacheSpots[j].orgMus,function(){return x});
                        }
                    }
                    node.nodeValue = val;
                }
   
                var syn = syntaxCheckWorkerNew(node.nodeValue);
                if(!syn.bool){
                    errors.push(new Error("(LC:syn1)Syntax error in node "+syn.err+" in "+node.nodeName+" for the node value: "+node.nodeValue));
                    return;
                }
                let mustache = await this.getMustache(node.nodeValue,componentName,syn),dynamicValue,helperFunc;
                if(mustache && mustache == "timeoutError"){
                    errors.push(new Error("(LC:timeout1) Syntax error in node "+mustache.err+" in "+node.nodeName+" for the attribute: "+node.nodeName+" - "+node.nodeValue));
                    return;
                }
            // let mustache = await this.getMustache(node.nodeValue),dynamicValue,helperFunc;
            if(mustache && typeof mustache === 'object'){
                if(mustache.bool === false){
                    errors.push(new Error("(LC:3)Syntax error in node "+mustache.err+" in "+node.nodeName+" for the attribute: "+node.nodeName+" - "+node.nodeValue));
                }
            }
            if(mustache){
                helperFunc = await this.getArray(mustache);  
                if(helperFunc && helperFunc == "timeoutError"){
                    errors.push(new Error("(LC:timeout6)Syntax error in node "+node.nodeName+" for the value: "+" - "+node.nodeValue));
                    return;
                }else if(helperFunc === false){
                    errors.push(new Error("(LC:11)Syntax Error in node "+node.nodeName+"for the value:"+node.nodeValue));
                    return;
                }
            }
            if(mustache){
                if(!helperFunc){
                    mustache = mustache.replace('____lyteinternal____','.{}');
                    helperFunc = await this.getHelper(mustache,componentName);
                    if(helperFunc && helperFunc.args == "lbindError" || helperFunc == "lbindError"){
                        errors.push(new Error("(LC:lbind2) Syntax Error : lbind are not allowed inside helpers in "+node.nodeName+" for : "+node.nodeValue));
                    }
                    else if(helperFunc && helperFunc.name == "lbind"){
                        errors.push(new Error("(LC:lbind1) Syntax Error : lbind are not allowed to render in dom "+node.nodeName+" for: "+node.nodeValue));
                    }
                    else if(helperFunc && helperFunc == "timeoutError"){
                        errors.push(new Error("(LC:timeout2)Syntax Error in node "+node.nodeName+"for :"+node.nodeValue));
                        return;
                    }
                    else if(helperFunc === false){
                        errors.push(new Error("(LC:4)Syntax Error in node "+node.nodeName+"for :"+node.nodeValue));
                        return;
                    }
                    if(helperFunc){
                        if(defaultImpDetails.helpers.indexOf(helperFunc.name) == -1 && defaultHelpers.indexOf(helperFunc.name) == -1){
                            defaultImpDetails.helpers.push(helperFunc.name);   
                        }
                        getImportedHelpers(helperFunc.args,defaultImpDetails.helpers);
                    }
                }
            } else {
                
                errors.push(new Error("(LC:5)Syntax Error in node "+node.nodeName+"for :"+node.nodeValue));
            }    
            node.nodeValue = node.nodeValue.replace('____lyteinternal____','.{}');
            let dynamic = mustache;
            if(helperFunc){
                deepNodes.push({t: "tX", p:deepN.slice()/*, helperInfo: helperFunc*/}); 
            }
            else if(dynamic){
                deepNodes.push({t: "tX", p:deepN.slice()/*, dynamicValue: dynamic*/});
//                  LN to do
//                  deepNodes.push({type: "text", position:deepN.slice(), dynamicValue: getDynamicValue(dynamic)});                    
            }
        }
        deepN.pop();
        return;
    }
    var attr = await processAttr(componentName,node, deepNodes, deepN, is,strict,errors,warnings);
    if(node.hasChildNodes()){
        let oldParent;
        if(nearByParent == "svg" || nearByParent == "foreignObject"){
            oldParent = nearByParent;
        }
        for(let i=0;i<node.childNodes.length;i++) {
            deepN.push(i);
            let tagName = node.childNodes[i].tagName;
            if(tagName) {
                if(tagName == "svg"){
                    nearByParent = "svg";
                } else if(tagName == "foreignObject" || tagName == "FOREIGNOBJECT"){
                    nearByParent = "foreignObject";
                }
                let is = node.childNodes[i].getAttribute("is");
                if(tagName && is) {
                    await this.newGetDeepNodes(componentName, node.childNodes[i], deepNodes, deepN, is ,strict,errors,warnings,nearByParent);
                }
                else {
                    await this.newGetDeepNodes(componentName, node.childNodes[i], deepNodes, deepN,undefined,strict,errors,warnings,nearByParent);
                }
                node.childNodes[i].removeAttribute("errorinfo")
            }
            else {
                await this.newGetDeepNodes(componentName, node.childNodes[i], deepNodes, deepN,undefined,strict,errors,warnings,nearByParent);
            }
            nearByParent = oldParent;
        }
    } 
    if(attr && attr._special && toBePushed && toBePushed.t == "cD"){
        toBePushed._igTs = true;
    }
    if(attr && attr._special && toBePushed && toBePushed.t == "cM"){
        toBePushed._igTs = true;
    }
    if(attr && attr._special && toBePushed && toBePushed.t == "i"){
        toBePushed._igTs = true;
    }
    if(toBePushed) {
        deepNodes.push(toBePushed);
    }
    deepN.pop();
}

function getArrayIndex(array,value) {
    for(let i=0;i<array.length;i++) {
        if(array[i] === value) {
            return i
        };
    }
}

function getTrimmedContent(content, position, node) {
    let dummyContent = content;
    if(node) {
        position = [];
        let parentNode = node.parentNode;
        while(true) {
            position.unshift(this.getArrayIndex(parentNode.childNodes,node));
            parentNode = parentNode.parentNode;
            node = node.parentNode;
            if(!parentNode) {
                break;
            }
        }
    }
    for(let i=0;i<position.length;i++) {
        for(let j=content.childNodes.length-1;j>position[i];j--) {
            content.childNodes[j].remove();
        }
        content = content.childNodes[position[i]];
    }
    return dummyContent;
}

function createDocFragment(template){
    var childNodes = template.cloneNode(true).childNodes;
    var frag = dom.createDocumentFragment();
    var len = childNodes.length;
    for(var i=0; i<len; i++){
        frag.appendChild(childNodes[0]);
    }
    return frag;
}

async function splitMixedText(str,componentName,errors,node,x){
    console.log("str",str);
    var stack=[],actObj, start=0, helper = { name:"concat", args: []},dynamicVal;
    for(var i=0;i<str.length;i++){
      var j = i;
      if(str[i-1] !== "\\" && str[i] === "{" && str[++i] === "{"){
        stack.push('{{');
        helper.args.push("'"+str.substr(start,j-start)+"'");
        start = i + 1;
        dynamicVal = true;
      }
      else if(str[i] === "}" && str[++i] === "}" && stack.length){
        stack.pop(start);
        var toPush = str.substr(start,j-start);
        if((toPush.startsWith("'") && toPush.endsWith("'")) || (toPush.startsWith('"') && toPush.endsWith('"'))){
            console.warn("Rendering string value inside dynamic data (mustache) is depriciated","for the value ",toPush ,"on the attribute value ",str);
        }
        var actObj  = await this.getArray(toPush);  
        if(actObj && actObj == "timeoutError"){
            errors.push(new Error("(LC:timeout8)Syntax error in node "+node.nodeName+" for the value: "+" - "+node.nodeValue));
            return;
        }else if(actObj === false){
            errors.push(new Error("(LC:14)Syntax Error in node "+node.nodeName+"for the value:"+node.nodeValue));
            return;
        }
        if(actObj){
            toPush = actObj;
            helper.args.push({type:"sq",value:actObj});
        }
        if(!actObj){
            actObj = await this.getHelper(toPush,componentName);  
            if(actObj){
                if(actObj == "timeoutError"){
                    errors.push(new Error("(LC:timeout5)Syntax Error in node "+"for :"+str));
                    return;
                }
                else if(actObj.name == "lbind"){
                    errors.push(new Error("(LC:lbind5) Syntax Error : lbind are not allowed with prepending or appending with texts "+"for :"+str));
                    return;
                }
                else if(actObj == "lbindError" || actObj.args == "lbindError"){
                    errors.push(new Error("(LC:lbind6)Syntax Error : lbind are not allowed inside helpers on node "+node.nodeName+" for: "+ str));
                    return;
                }
                else if(actObj.name == "lbind" && node.tagName == "TEMPLATE"&& node.hasAttribute("is") && /if|for|switch/g.test(node.getAttribute("is"))){
                    errors.push(new Error("(LC:lbind7)Syntax Error : lbind not allowed as value in if/for/switch node"+"for: "+str));
                    return;
                }
                else if(actObj.name == "action"){
                    errors.push(new Error("(LC:9)Syntax Error : action are not allowed with prepending or appending with texts "+"for :"+str));
                    return;
                }
                else if(actObj.name == "method"){
                    errors.push(new Error("(LC:10)Syntax Error : method are not allowed with prepending or appending with texts "+"for :"+str));
                    return;
                }
                toPush = actObj;
                helper.args.push({ type: "helper", value: toPush })

                if(defaultImpDetails.helpers.indexOf(actObj.name) == -1 && defaultHelpers.indexOf(actObj.name) == -1){
                    defaultImpDetails.helpers.push(actObj.name);   
                }
                getImportedHelpers(actObj.args,defaultImpDetails.helpers);
            }
            else if(actObj === false){
                errors.push(new Error("(LC:13)Syntax error in node "+node.nodeName+" for the attribute:"+node.attributes[x].nodeName+"- "+node.attributes[x].nodeValue));
                return;
            }
            else{
                if((toPush.startsWith("'") && toPush.endsWith("'")) || (toPush.startsWith('"') && toPush.endsWith('"'))){
                    console.warn("Rendering string value inside dynamic data (mustache) is depriciated","for the value ",toPush ,"on the attribute value ",str);
                }
                helper.args.push(toPush);
            }
            start = i + 1;
        }
     }

    }
    if(!dynamicVal){
        return false;
    }
    if(start<str.length){
        helper.args.push("'"+str.substr(start,str.length-start)+"'");
    }
    console.log("str is helper",helper);

    return helper;
}

function syntaxCheck(value){
    var stack = [],lastAdded;
    for(var i=0;i<value.length;i++){
        if(value[i] === "'"){
            if(lastAdded === "'" && value[i-1] !== "\\"){
                stack.pop();
                lastAdded = undefined;
            }
            else if(!stack.length){
                lastAdded = value[i];
                stack.push(lastAdded);
            }
        }
        else if(value[i] === "\""){
            if(lastAdded === "\"" && value[i-1] !== "\\"){
                stack.pop();
                lastAdded = undefined;
            }
            else if(!stack.length){
                lastAdded = value[i];
                stack.push(lastAdded);
            }
        }
    }
    if(stack.length){
        return false;
    }
    return true;
}

/* function getMustache(value){
    value=(value && typeof value === "string") ? value.trim() : value;
    if(/^{{(?=[\s]*[\w-_]+)/.test(value)){
        let arr = value.match(/{{[a-zA-Z0-9_.\[\]\(\)]*(?![\\])}}/g);
        if(arr && arr.length > 1){
            console.log("length>1",value)
            return undefined;
        }
        console.log(value);
        if(!this.syntaxCheck(value)){
            return false;
        }
        if(!(/{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}$/.test(value))){
            return undefined;
        }
        let dynamic = value.match(/[\w!@#\$%\^\&*\)\(+=.,_-]+[\s]*[(]{0,1}(?:"([^"]|\\")*?"|'([^']|\\')*?'|[\w\s!@#\$%\^\&*\)\(\[\]+=.,_-]*?)*?[)]{0,1}[\s]*(?=}})/g);
        if(dynamic && dynamic.length > 1){
            return undefined;
        }
        else{
            dynamic = (dynamic) ? dynamic[0].trim(): dynamic;                
        }
//            let dynamic = /[\w!@#\$%\^\&*\)\(+=.,_-]+(?:"([^"]|\\")*?"|'([^']|\\')*?'|[\w\s!@#\$%\^\&*\)\(\[\]+=.,_-]*?)*?(?=}}$)/.exec(value);
        return dynamic;
    }
    return undefined;
} 

function getHelperArgs(str){
    let stack = [], args = [] , from=0;
    let lastPushed; 
    for(let i=0; i<str.length; i++){
        if(!stack.length && str.charAt(i) === ","){
            let toPush = str.substr(from,i-from);
            toPush = toPush.trim();
            if(toPush && toPush.startsWith("\"") && toPush.endsWith("\"")){
                toPush = toPush.slice(1,-1);
                toPush = "'" + toPush + "'";
            }
            toPush = getHelperArgValue(toPush);
            args.push(toPush);
            from = i + 1;
        }
        else if(str.charAt(i) === "("){
            if(lastPushed != "'" || lastPushed != "\""){
                stack.push(str.charAt(i));
                lastPushed = str.charAt(i);
            }
        }
        else if(str.charAt(i) === ")"){
            if(stack[stack.length-1] === "("){
                stack.pop();
            }
        }
        else if(str.charAt(i) === "'" && str.charAt(i-1) !== "\\"){
            if(stack[stack.length-1] === "'"){
                stack.pop();
            }
            else if(stack[stack.length-1] !== "\""){
                stack.push(str.charAt(i));
                lastPushed = str.charAt(i);
            }
        }
        else if(str.charAt(i) === "\"" && str.charAt(i-1) !== "\\"){
            if(stack[stack.length-1] === "\""){
                stack.pop();
//                  str.replaceAt(i, "'");
            }
            else if(stack[stack.length-1] !== "'"){
                stack.push(str.charAt(i));
                lastPushed = str.charAt(i);
//                  str.replaceAt(i, "'");
            }
        }
    }
    if(stack.length){
        return false;
    }
    let toPush = str.substr(from,str.length-from);
    toPush = toPush.trim();
    if(toPush && toPush.startsWith("\"") && toPush.endsWith("\"")){
        toPush = toPush.slice(1,-1);
        toPush = "'" + toPush + "'";
    }
    try{
        toPush = getHelperArgValue(toPush);
    }
    catch(err){
        console.log("errr",err);
        return false;
    }
    args.push(toPush);
    return args;
}



function getHelperInfo(dynamicValue, helperValue){
    let helperFunc = {};
    helperFunc.name = dynamicValue.substr(0,helperValue.index).replace(/\s/g,'');
    helperValue = (helperValue) ? helperValue[0].trim() : helperValue;
    let args = getHelperArgs(helperValue.substr(1,helperValue.length-2));
    if(args === false){
        return false;
    }
    helperFunc.args = args;
    return helperFunc;
}

function getHelper(dynamicValue){
    console.log(dynamicValue);
    let helperValue = /\((?:[^\)]*|(?:(?:"(?:[^"\\]|\\.)*?")|(?:'([^'\\]|\\.)*?')|[\w\s!@#$%^&*)([\]+=.,_-]*?)*?)\)$/.exec(dynamicValue);
    if(helperValue){
        return getHelperInfo(dynamicValue,helperValue);
    }
    return undefined;
} */

async function getMustache(value,componentName,syn){
    
    var newPromise = new Promise(function(resolve,reject) {
        var timeoutId = setTimeout(function() {
            str += '\n getMustache error : '+value;
            localStorage.setItem(componentName,str);
            console.log("getMustache error", value);
            templateWorker.terminate();
            // resolve(false);
            resolve("timeoutError")
            templateWorker = new Worker("worker.js");
        },4000);
        templateWorker.postMessage({"func" : "getMustache", "params" : [value,componentName,syn], debug : debug});
        templateWorker.onmessage = function(value) {
            resolve(value.data);
            clearTimeout(timeoutId);
        }
    });
    return newPromise;
}
async function getArray(value){
        
    var newPromise = new Promise(function(resolve,reject) {
        var timeoutId = setTimeout(function() {
            str += '\n getArray error : '+value;
            // localStorage.setItem(componentName,str);
            console.log("getArray error", value);
            templateWorker.terminate();
            // resolve(false);
            resolve("timeoutError")
            templateWorker = new Worker("worker.js");
        },4000);
        var arr = [];
        templateWorker.postMessage({"func" : "getArray", "params" : [value,arr,defaultHelpers], debug : debug});
        templateWorker.onmessage = function(value) {
            resolve(value.data);
            clearTimeout(timeoutId);
        }
    });
    return newPromise;
}
async function getHelper(dynamicValue,componentName) {
    var newPromise = new Promise(function(resolve,reject) {
        var timeoutId = setTimeout(function() {
            str += '\n getHelper error : '+dynamicValue
            localStorage.setItem(componentName,str);
            console.log("getHelper error" , dynamicValue);
            templateWorker.terminate();
            // resolve(false);
            resolve("timeoutError")
            templateWorker = new Worker("worker.js");
        },4000000);
        var arr = [];
        templateWorker.postMessage({"func" : "getHelper", "params" : [dynamicValue], debug : debug});
        templateWorker.onmessage = function(value) {
            resolve(value.data);
            clearTimeout(timeoutId);
        }
    });

    return newPromise;
}

function getDynamicValue(value){    
    var result = [],ref = result,arr = [],data = "",strStack = [],arrayStack = [],refStack = [],strLast,str;
    console.log("dynamic start",value);
    for(var i=0;i<value.length;i++){
        if(value[i] === "."){
            if(data.length){
                ref.push(data);
            }
            data = "";
            continue;
        }
        else if(value[i] === "["){
            arrayStack.push(i)
            if(data.length){
                ref.push(data);
            }
            while(value[i+1] === "\s"){
                i++;
            }
            if(value[i+1] === "\"" || value[i+1] === "'"){
                strStack.push(value[i+1]);
                strLast = value[i+1];
                i++;
            }
            else if(arr.length){
                ref.push([]);
                refStack.push(ref);
                ref = ref[ref.length-1];
            }else{
                arr.push([]);
                refStack.push(ref);
                ref = arr[arr.length-1];
            }
            data = "";
            continue;
        }
        else if((value[i] === "\"" || value[i] === "'" ) && value[i++] === strLast){
            while(value[i] === "\s" && value[i] != "]"){
                i++;
            }
            strStack.pop();
            str = true;
        }
        if(value[i] === "]"){
            arrayStack.pop();
            if(data.length){
                if(str === true){
                    ref.push(data);    
                }
                else if(!isNaN(parseInt(data))){
                    if(refStack.length){
                        ref = refStack.pop();
                        if(arr.length && Array.isArray(ref[ref.length-1]) && !ref[ref.length-1].length){
                            ref.pop();
                        }
                        ref.push(data);
                        if(!arrayStack.length && arr.length){
                            arr.shift();
                        }
                    }
                }
                else{
                    ref.push(data);
                }
            }
            if(!arrayStack.length && arr.length){
                result.push(arr.shift());
                ref = result;
            }
            else if(refStack.length && !arr.length){ 
                ref = refStack.pop();
            }
            data = "";
            str = "";
            continue;
        }
        data = data.concat(value[i]);
    }
    if(data.length){
        result.push(data);
    }
    if(strStack.length || arrayStack.length){
        console.log("check the syntax",strStack,arrayStack);
    }
    console.log(result,"dynamic end");
    return result;
}
function deepCopyObject( obj )  {
    var current, copies = [{source : obj, target : Object.create(Object.getPrototypeOf(obj))}], keys, propertyIndex, descriptor, nextSource, indexOf, sourceReferences = [obj];
    var cloneObject = copies[0].target, targetReferences = [cloneObject];
    while(current = copies.shift()){
        keys = Object.getOwnPropertyNames(current.source);
        for(propertyIndex = 0; propertyIndex < keys.length; propertyIndex++){
            descriptor = Object.getOwnPropertyDescriptor(current.source, keys[propertyIndex]);
            if(!descriptor.value || typeof descriptor.value != "object"){
                Object.defineProperty(current.target, keys[propertyIndex], descriptor);
                continue;
            }
              nextSource = descriptor.value;
              descriptor.value = Array.isArray(nextSource) ? [] : Object.create(Object.getPrototypeOf(nextSource));
              indexOf = sourceReferences.indexOf(nextSource);
              if(indexOf != -1){
                  descriptor.value = targetReferences[indexOf];
                  Object.defineProperty(current.target, keys[propertyIndex], descriptor);
                  continue;
              }
              sourceReferences.push(nextSource);
              targetReferences.push(descriptor.value);
              Object.defineProperty(current.target, keys[propertyIndex], descriptor);
              copies.push({source : nextSource, target : descriptor.value});
          }
      }
    return cloneObject;
}

function replaceCaseNode(node,componentName,errors,templateNode,rtObj,nearByParent) {
    var tagName;
    var template;
    if(nearByParent){
        if(nearByParent == "svg"){
            rtObj.svg = true;
            var template = node.cloneNode();
            template.innerHTML = "<svg>" + node.innerHTML + "</svg>";
            template.setAttribute("depth", 1);
            node.replaceWith(template);
            return;
        }
    }
    for(var i=0;i<node.content.children.length;i++) {
        if(node.content.children[i].tagName !== "TEMPLATE") {
            if(/^(TR|TD|TH|TBODY|THEAD|TFOOT)$/.test(node.content.children[i].tagName)) {
                tagName = node.content.children[i].tagName;
            }
            break;
        }
    }
    if(tagName) {
        if(tagName === "TR") {
            template = node.cloneNode();
            template.innerHTML = "<table><tbody>" + node.innerHTML + "</tbody></table>";
            template.setAttribute("depth", 2);

        }
        else if(/^(TBODY|THEAD|TFOOT)$/.test(tagName)){
            template = node.cloneNode()
            template.innerHTML = "<table>" + node.innerHTML + "</table>";
            template.setAttribute("depth", 1);
        } 
        else {
            template = node.cloneNode();
            template.innerHTML = "<table><tbody><tr>" + node.innerHTML + "</tr></tbody></table>";
            template.setAttribute("depth", 3);
        }
        if(template.content.childNodes.length > 1){
            template.content.childNodes.forEach(function(item){
                if(item.nodeName != "TABLE"){
                    if(item.nodeType == 1){
                        errors.push(new Error("(LC:15)Syntax Error : Unexpected node - "+item.nodeName+ "tag"+ "inside "+ tagName +" tag "))
                    }else{
                        errors.push(new Error("(LC:16)Syntax Error : Unexpected text node - "+item.nodeValue+ "present inside "+ tagName +" tag "))
                    }
                }
            })
        }
        node.replaceWith(template);
    }
}
function getParent(node){
    var newNode = node;
    while(newNode){
        if(newNode._parent){
            if(newNode._parent.tagName && newNode._parent.tagName!="TEMPLATE"){
                return newNode._parent;
            }
        }
        newNode = newNode._parent;
    }
}
function getTemplateDirectChild(dynamicNodes,info){
    var stack = [];
    info["dc"] = [];
    // info["hc"] = false;
    for(var i=0; i<dynamicNodes.length; i++){
        var dyn = dynamicNodes[i]
        var x=false;
        if((dyn.trans || dyn.hc || dyn._comp || dyn.t == "cD"|| dyn.t == "i"|| dyn.t == "cM") && !dyn._igTs){
            stack.forEach(function(item,index){
                if(this.subArray(dyn.p,item)){
                    x =true;
                }
            });
            if(!x){
                stack.push(dyn.p);
                // dyn["dirctChld"] = true;
                info["dc"].push(dyn.in)   
            }
            info["hc"] = true;
            info["trans"] = true;
        }
        
    }
    if(!info.hc){
        for(var i=0; i<dynamicNodes.length; i++){
            if(dynamicNodes[i].in != undefined && dynamicNodes[i].t != "cD" && dynamicNodes[i].t != "i"){
                dynamicNodes[i].in = undefined;
            }
        }
        delete info.dc;
    }
}
function getSwitchOrder(casesArr,tobj,defaultArr){
    var keys = Object.keys(casesArr);
    var ln = keys.length;
    var club = [];
    for(var i=0; i<ln; i++){
        if(tobj[keys[i]].trans && casesArr[keys[i]].additional){
            var stack = [];
            var flag = false;
            casesArr[keys[i]].dN.forEach(function(dyn){
                club.push(dyn);
            })
            stack.push(keys[i]);
            while(keys[i] && casesArr[keys[i]].additional){
                flag = true;
                var caseName;
                if(casesArr[keys[i]].additional.next){
                    caseName = casesArr[keys[i]].additional.next;    
                }else if(casesArr[keys[i]].additional.default){
                    caseName = "default";
                    defaultArr.dN.forEach(function(dyn){
                        club.push(dyn);
                    })      
                    i++;
                    continue;
                }
                if(tobj[caseName].trans){
                    casesArr[caseName].dN.forEach(function(dyn){
                        club.push(dyn);
                    })      
                }
                stack.push(caseName);
                i++;
            }
            if(flag){
                getTransitionOrder(club,true);
                // for(var i=0;i<stack.length;i++){
                //     getTemplateDirectChild(club,tobj[stack[i]]);
                // }
            }
        }
    }
}
function getTransitionOrder(a,switchcase){
    var count = 0 ;
    var previousTransition;
    for(var i=a.length-1; i>=0;i--){
        if((a[i].trans || /^f|fI|e|s|cD|cM|i|r|yield$/g.test(a[i].t)) && !a[i]._igTs){
            a[i]["in"] = count;
            count++;
            if(previousTransition){
                if(subArray(previousTransition.p,a[i].p)){
                    a[i]["chld"] = getChild(a,i,switchcase);
                }
                else if(previousTransition){
                    a[i]["sibl"] = [previousTransition.in];        
                }
            }
            previousTransition = a[i]
        }
    }
}
// function subArray(master,sub){
//     if ((master.toString() != sub.toString()) && (master.toString()).indexOf(sub.toString()) != -1 ){
//         return true;
//     }
//     return false;
// }
function subArray(sub,master){
    //master//small //sub //big
    var brk = false;
    for(var i=0; i<master.length; i++){
        if(master[i] == sub[i]){
            continue;
        }else{
            brk = true;
            break;
        }
    }

    if(!brk && master.length != sub.length){
        return true;
    }else{
        return false;
    }
}
function getChild(a,i,switchcase){
    var childArr = [];
    var x = i;
    var previous;
    var caseName;
    if(switchcase){
        caseName = a[i].cn;
    }
    while(a[i]){
        i++;
        if(switchcase){
            if(a[i] && a[i].cn != caseName){
                break;
            }
        }
        if(a[i] && (a[i].trans ||a[i]._comp || /^f|fI|e|s|cD|i|r|yield$/g.test(a[i].t)) && !a[i]._igTs){
            if(previous != undefined){
                if(subArray(a[i].p, previous)){
                    //ignoring child's child
                    continue;
                }
            }
            if(subArray(a[i].p,a[x].p)){
                childArr.push(a[i].in);
            }else{
                break;
            }
            previous = a[i].p;
        }
    }
    if(a[i]){
        a[x].sibl = [a[i].in];
    }
    return childArr;
}
function svgFix(node,type, toBePushed,parentElementName,componentName,errors){
    var templateNode = node.cloneNode();
    var newElementName;
    if(!node.content || !node.content.children || !node.content.children[0] || !node.content.children[0].tagName){
        errors.push(new Error("Syntax Error in the node "+ this.errorNodeDetails(node)));
        return node;
    }else{
        newElementName = node.content.children[0].tagName;
    }
    templateNode.innerHTML = "<svg>" + node.innerHTML + "</svg>"
    templateNode.setAttribute("depth", 1);
    return inner(node,templateNode,type,newElementName,parentElementName,toBePushed);
}
function replaceParentNode(node, type, toBePushed,componentName,errors,forHold,nearByParent) {
    var parentNode = getParent(node);
    if(parentNode && nearByParent){
        if(nearByParent == "svg"){
            var parentElementName = parentNode.tagName;
            toBePushed.svg = true;
            return svgFix(node,type, toBePushed,parentElementName,componentName,errors);
        }
        return node;
    }
    if(!parentNode) {
        return node;
    }
    var parentElementName = parentNode.tagName;
    var newElementName;
    var templateNode = node.cloneNode();
    var childTagName;
    if(forHold){
        for(var i=0;i<node.content.children.length;i++) {
            if(node.content.children[i].tagName !== "TEMPLATE") {
                if(/^(TR|TD|TH|TBODY|THEAD|TFOOT)$/.test(node.content.children[i].tagName)) {
                    childTagName = node.content.children[i].tagName;
                }
                break;
            }
        }
    }
    if(parentNode && /^(SELECT|TR|TABLE|TBODY|THEAD|TFOOT)$/.test(parentElementName)) {
        switch(parentElementName) {
            case "SELECT" : 
                newElementName = "option";
            break;
            case "TR" : 
                if(!forHold){ 
                    templateNode.innerHTML = "<table><tbody><tr>" + node.innerHTML + "</tr></tbody></table>"
                    templateNode.setAttribute("depth", 3);
                    newElementName = "td";
                }else{
                    if(childTagName && childTagName == "TR"){
                        errors.push(new Error("(LC:17)Syntax Error : Unexpected node - "+childTagName+ "tag inside "+ parentElementName +" tag "))
                    }else{
                        templateNode.innerHTML = "<table><tbody><tr>" + node.innerHTML + "</tr></tbody></table>"
                        templateNode.setAttribute("depth", 3);
                        newElementName = "td";
                    }
                }
            break;
            case "TABLE" :
                if(!forHold){
                    templateNode.innerHTML = "<table>" + node.innerHTML + "</table>";
                    templateNode.setAttribute("depth", 1);
                    newElementName = "tbody";
                }else{
                    if(childTagName && (childTagName == "TBODY" || childTagName =="THEAD" || childTagName =="TFOOT")){
                        templateNode.innerHTML = "<table>" + node.innerHTML + "</table>";
                        templateNode.setAttribute("depth", 1);
                    }
                    else if(childTagName && childTagName == "TR"){
                        templateNode.innerHTML = "<table><tbody>" + node.innerHTML + "</tbody></table>";
                        templateNode.setAttribute("depth", 2);
                    }
                    else{
                        templateNode.innerHTML = "<table><tbody><tr>" + node.innerHTML + "</tr></tbody></table>"
                        templateNode.setAttribute("depth", 3);
                    }
                    newElementName = "tbody";
                }
            break;
            case "TBODY" : 
            case "THEAD" : 
            case "TFOOT" : 
                if(!forHold){
                    templateNode.innerHTML = "<table><tbody>" + node.innerHTML + "</tbody></table>";
                    templateNode.setAttribute("depth",2);
                    newElementName = "tr";
                }else{
                    if(childTagName && (childTagName == "TR")){
                        templateNode.innerHTML = "<table><tbody>" + node.innerHTML + "</tbody></table>";
                        templateNode.setAttribute("depth",2);
                    }else{
                        templateNode.innerHTML = "<table><tbody><tr>" + node.innerHTML + "</tr></tbody></table>"
                        templateNode.setAttribute("depth", 3);
                    }
                    newElementName = "tr";
                }
            break;
        }
        if(templateNode.content.childNodes.length > 1){
            templateNode.content.childNodes.forEach(function(item){
                if(item.nodeName != "TABLE"){
                    if(item.nodeType == 1){
                        errors.push(new Error("(LC:18)Syntax Error : Unexpected node - "+item.nodeName+ "tag inside "+ parentElementName +" tag "))
                    }else{
                        errors.push(new Error("(LC:19)Syntax Error : Unexpected text node - "+item.nodeValue+ "present inside "+ parentElementName +" tag "))
                    }
                }
            })
        }
        return inner(node,templateNode,type,newElementName,parentElementName,toBePushed);
    }
    return node;
}
function inner(node,templateNode,type,newElementName,parentElementName,toBePushed){
    var newElement = this.addUnbound(node,newElement,newElementName,parentElementName);
    var parentElement = dom.createElement(parentElementName);
    switch(type) {
        case "for" : 
            newElement.setAttribute("is", "for");
            newElement.setAttribute("lyte-for", "true");
            if(node.hasAttribute("unbound")) {
                newElement.setAttribute("unbound", node.getAttribute("unbound"));
            }
            // newElement.setAttribute("items", node.getAttribute("items"));
            // newElement.setAttribute("item", node.getAttribute("item"));
            // newElement.setAttribute("index", node.getAttribute("index"));
        break;
        case "if" :
        case "switch" :  
            newElement.setAttribute("is", type);
            newElement.setAttribute("lyte-"+type, "true");
            //newElement.setAttribute("value", node.getAttribute("value"));
        break;
        case "forIn" : 
            newElement.setAttribute("is", "forIn");
            newElement.setAttribute("lyte-forin", "true");
            if(node.hasAttribute("unbound")) {
                newElement.setAttribute("unbound", node.getAttribute("unbound"));
            }
            // newElement.setAttribute("object", node.getAttribute("object"));
            // newElement.setAttribute("key", node.getAttribute("key"));
            // newElement.setAttribute("value", node.getAttribute("value"));
        break;
    }
    var attrs = node.attributes;
    for(var i=0;i<attrs.length;i++) {
        if(!attrs[i].nodeName.startsWith("@")){
            newElement.setAttribute(attrs[i].nodeName, attrs[i].nodeValue);
        }
    }
     if(parentElementName !== "SELECT" && (type === "for" || type === "forIn")) {
        this.removeAllAttributes(templateNode);
        toBePushed.actualTemplate = templateNode.outerHTML;  
        toBePushed.tagName = parentElementName;  
        if(templateNode.hasAttribute("depth")) {
            newElement.setAttribute("depth" , templateNode.getAttribute("depth"));
        }
    } else {
        this.removeAllAttributes(node);
        toBePushed.actualTemplate = node.outerHTML;
    }
    node.replaceWith(newElement);
    return newElement;
}
function removeAllAttributes(node){
    let ls = node.querySelectorAll("errorinfo");
    for (let i = 0; i < ls.length;i++){
        ls.removeAttribute("errorinfo");
    }
    var arr = Array.from(node.attributes);
    for(let i=0; i<arr.length; i++) {
        if(arr[i].nodeName != "depth" && arr[i].nodeName != "is"){
            node.removeAttribute(arr[i].nodeName);
        }
    }
}
function siblingNullCheck(nextSibling){
    if(nextSibling.previousSibling.nodeValue === null || nextSibling.nextSibling.nodeValue === null){
        return null;
    }
    else{
        return 1;
    }
}
function jspIfToSwitch(element){
    var ifStmt;
    var temp = dom.createElement("template");
    if(element.hasAttribute("is") && element.getAttribute("is") == "if") {
        temp.setAttribute("is", "switch");
        temp.setAttribute("l-c",true);
        if(element.hasAttribute("_jsp")){
            temp.setAttribute("_jsp",element.getAttribute("_jsp"));
        }
    }
    getCase(temp,element);
    return temp;
}
function appendBreak(temp){
    var breakTemp = dom.createElement("template");
    breakTemp.setAttribute("is", "break");
    temp.content.appendChild(breakTemp);
}
// function getCase(temp,element){
//     var ifStmt;
//     ifStmt = element.getAttribute("value");
//     let trueCase = element.content.children[0];
//     if(trueCase && trueCase.getAttribute("case") == "true") {
//         let caseTemp = createCase(ifStmt,trueCase.content);
//         temp.content.appendChild(caseTemp);
//         appendBreak(caseTemp);
//     }
//     let falseCase = element.content.children[1];
//     if(falseCase && falseCase.getAttribute("case") == "false") {
//         if(falseCase.content.children[0] && falseCase.content.children[0].hasAttribute("lyte-elif")){
//             getCase(temp,falseCase.content.children[0]);
//         }else{
//             let tempCase = document.createElement("template");
//             tempCase.setAttribute("default", "");
//             tempCase.content.appendChild(falseCase.content);
//             temp.content.appendChild(tempCase);
//         }
//     }
// }
function getCase(temp,element){
    var ifStmt, trueCase ,falseCase;
    ifStmt = element.getAttribute("value");
    if(element.getAttribute("_jsp") == "true"){
        trueCase = element.content.children[0];
        falseCase = element.content.children[1];
    }else{
        trueCase = element.content.querySelector("[case=true]");
        falseCase = element.content.querySelector("[case=false]");
    }
    if(!trueCase && falseCase){
        //create empty true case
        let tempCase = dom.createElement("template");
        tempCase.setAttribute("case","true");
        trueCase = tempCase;
    }
    if(trueCase || falseCase){
        if(trueCase && trueCase.getAttribute("case") == "true") {
            if(trueCase.tagName != "TEMPLATE"){
                trueCase.removeAttribute("case");
                caseTemp = createCase(ifStmt,trueCase);
            }else{
                caseTemp = createCase(ifStmt,trueCase.content);
            }
            temp.content.appendChild(caseTemp);
            appendBreak(caseTemp);
        }
        if(falseCase && falseCase.getAttribute("case") == "false") {
            var elif = false;
            if(falseCase.tagName != "TEMPLATE"){
                falseCase.removeAttribute("case");
                let tempCase = dom.createElement("template");
                tempCase.setAttribute("default", "");
                tempCase.content.appendChild(falseCase);
                temp.content.appendChild(tempCase);
            }else{
                if(falseCase.content.children && falseCase.content.children.length && falseCase.content.children[0].getAttribute("lyte-elif") == "true"){
                    elif = falseCase.content.children[0];
                    getCase(temp,elif);
                }else{
                    let tempCase = dom.createElement("template");
                    tempCase.setAttribute("default", "");
                    tempCase.content.appendChild(falseCase.content);
                    temp.content.appendChild(tempCase);
                }
            }
        }
    }
    else{
        temp.innerHTML = element.innerHTML;
    }
}
function createCase(value,content){
    let tempCase = dom.createElement("template");
        tempCase.setAttribute("is","case");
        tempCase.setAttribute("case", value);
        tempCase.content.appendChild(content);
        return tempCase;
        // temp.content.appendChild(tempCase);
}
function handleLyteIf(element,svg) {
    var ifStmt;
    var temp = dom.createElement("template");
    let errorInfo = getErrorInfo(element);
    if(element.hasAttribute("lyte-if")) {
        ifStmt = element.getAttribute("lyte-if");
        element.removeAttribute("lyte-if")
        temp.setAttribute("is", "switch");
        if(element.hasAttribute("__vp")){
            temp.setAttribute("__vp", element.getAttribute("__vp"));
        }
        temp.setAttribute("value", ifStmt);
        temp.setAttribute("l-c",true);
        temp.setAttribute("_new","true");
        temp.setAttribute("errorinfo" ,JSON.stringify(errorInfo));
    } else if(element.hasAttribute("lyte-else-if")) {
        ifStmt = element.getAttribute("lyte-else-if");
        element.removeAttribute("lyte-else-if");
    }
    if(ide && win.elifHold){
        temp.setAttribute("el", true);
        win.elifHold =false;
    }
        var trueTemp;
        if(svg && element.tagName=="template"){
            trueTemp = dom.createElement("template");
            trueTemp.innerHTML = element.innerHTML
        } else if(element.tagName === "TEMPLATE") {
            trueTemp = element.cloneNode();
            trueTemp.innerHTML = element.innerHTML;
        } else {
            trueTemp = dom.createElement("template");
            trueTemp.innerHTML = element.outerHTML;
        }
        if(trueTemp.hasAttribute("is")){
            var wrapperTemp  =dom.createElement("template");
            wrapperTemp.content.appendChild(trueTemp);
            trueTemp = wrapperTemp;
        }
        temp.content.appendChild(trueTemp);
        trueTemp.setAttribute("case", ifStmt);
        trueTemp.setAttribute("is", "case");
        if(temp.getAttribute("is") == "switch" && temp.hasAttribute("value")){
            if(temp.getAttribute("value").startsWith("{{")){
                temp.removeAttribute("value");
            }
        }
        var breakTemp = dom.createElement("template");
        breakTemp.setAttribute("is", "break");
        trueTemp.content.appendChild(breakTemp);
    //Else case handling
    if(element.nextElementSibling) {
        var nextSibling = element.nextElementSibling;
        var falseTemp;
        var type;
        if(nextSibling.hasAttribute("lyte-else")) {
            type = "lyte-else";
        } else if(nextSibling.hasAttribute("lyte-else-if")) {
            type = "lyte-else-if";
        }
        if(type) {
            if(type === "lyte-else") {
                nextSibling.removeAttribute("lyte-else");
                if(svg && nextSibling.tagName=="template"){
                    falseTemp = dom.createElement("template");
                    // falseTemp.setAttribute("case", "false");
                    falseTemp.innerHTML = nextSibling.innerHTML
                } else if(nextSibling.tagName === "TEMPLATE") {
                    falseTemp = nextSibling.cloneNode();
                    falseTemp.innerHTML = nextSibling.innerHTML;
                } else {
                    falseTemp = dom.createElement("template");
                    // falseTemp.setAttribute("default", "");
                    falseTemp.innerHTML = nextSibling.outerHTML;
                }
                falseTemp.setAttribute("default", "");
                if(nextSibling.nextSibling && nextSibling.previousSibling &&siblingNullCheck(nextSibling) && (nextSibling.nextSibling.nodeValue.trim() === "") && ("" === nextSibling.previousSibling.nodeValue.trim())) {
                    nextSibling.nextSibling.remove();
                }
                nextSibling.remove();
            } else {
                // falseTemp = document.createElement("template");
                // falseTemp.setAttribute("case", "false");
                // falseTemp.innerHTML = handleLyteIf(nextSibling,svg).outerHTML;
                falseTemp = handleLyteIf(nextSibling,svg).content;

                if(nextSibling.nextSibling  && nextSibling.previousSibling && siblingNullCheck(nextSibling)  && (nextSibling.nextSibling.nodeValue.trim() === "") && ("" === nextSibling.previousSibling.nodeValue.trim())) {
                    nextSibling.nextSibling.remove();
                }
                nextSibling.remove();

            }
            temp.content.appendChild(falseTemp);
        }
    }
    return temp;
}

function handleLyteSwitch(node,svg) {
    var template;
    var switchValue = node.getAttribute("lyte-switch");
    let errorInfo = getErrorInfo(node);
    var childElements;
    var type;
    if(node.tagName === "TEMPLATE") {
        template = node;
        template.removeAttribute("lyte-switch");
        childElements = Array.from(template.content.children);
        type = "template";
    } 
    else if(svg && node.tagName=="template"){
        template = dom.createElement("template");
        var attrs = node.attributes;
        for(var j=0;j<attrs.length;j++) {
            template.setAttribute(attrs[j].nodeName, attrs[j].nodeValue);
        }
        // falseTemp.setAttribute("case", "false");
        template.removeAttribute("lyte-switch");
        // template.innerHTML = node.innerHTML
        type = "template";
        childElements = Array.from(node.children);
    } 
    else {
        node.removeAttribute("lyte-switch");
        template = dom.createElement("template");
        if(ide){
            template.setAttribute("nt",true);
        }
        childElements = Array.from(node.children);
    }
    template.setAttribute("_new","true");
    var cases = {};
    
    for(var i=0;i<childElements.length;i++) {
        var child = childElements[i];
        if(child.hasAttribute("lyte-case")) {
            var isChildTemplate = child.tagName === "TEMPLATE";
            if(svg && child.tagName === "template"){
                var temp = dom.createElement("template");
                temp.innerHTML = child.innerHTML;
                var attrs = child.attributes;
                for(var j=0;j<attrs.length;j++) {
                    temp.setAttribute(attrs[j].nodeName, attrs[j].nodeValue);
                }
                child = temp;
                isChildTemplate = true;
            }
            //var childTemplate = isChildTemplate ? child : document.createElement("template");
            var childTemplate = child;
            var hasBreak = child.hasAttribute("lyte-break");
            var caseValue = child.getAttribute("lyte-case");

            child.removeAttribute("lyte-case");
            child.removeAttribute("lyte-break");
            if(child.hasAttribute("lyte-if")) {
                isChildTemplate = false;
                var oldChild = child;
                child = handleLyteIf(child,svg);
                oldChild.remove();
            } else if(child.hasAttribute("lyte-switch")) {
                isChildTemplate = false;
                handleLyteSwitch(child,svg);
            }
            if(isChildTemplate) {
                template.content.appendChild(child);
                child.setAttribute("case", caseValue);
                child.removeAttribute("lyte-case");
            } else {
                childTemplate = dom.createElement("template");
                childTemplate.setAttribute("case", caseValue);
                child.removeAttribute("lyte-case");
                childTemplate.content.appendChild(child);
                template.content.appendChild(childTemplate);
                
            }
            if(hasBreak) {
                var breakTemp = dom.createElement("template");
                breakTemp.setAttribute("is", "break");
                childTemplate.content.appendChild(breakTemp);
                child.removeAttribute("lyte-break");
            }
        } 
    }
    var defaultCase;// = type ? node.content.querySelector("[lyte-default]") : node.querySelector("[lyte-default]");
    if(svg && node.tagName == "template"){
        defaultCase = type ? node.querySelector("[lyte-default]") : node.querySelector("[lyte-default]");
    }else{
        defaultCase = type ? node.content.querySelector("[lyte-default]") : node.querySelector("[lyte-default]");
    }
    if(defaultCase) {
        var isDefCaseTemp;
        if(defaultCase.tagName === "TEMPLATE"){
            isDefCaseTemp = true;
        }
        else if(svg && defaultCase.tagName === "template"){
            var temp = dom.createElement("template");
            temp.innerHTML = defaultCase.innerHTML;
            var attrs = defaultCase.attributes;
            for(var j=0;j<attrs.length;j++) {
                temp.setAttribute(attrs[j].nodeName, attrs[j].nodeValue);
            }
            defaultCase = temp;
            isDefCaseTemp = true;
        }
        defaultCase.removeAttribute("lyte-default");
        if(defaultCase.hasAttribute("lyte-if")) {
            isDefCaseTemp = false;
            var oldDefault = defaultCase;
            defaultCase = handleLyteIf(defaultCase,svg);
            oldDefault.remove();
        } else if(defaultCase.hasAttribute("lyte-switch")) {
            isDefCaseTemp = false;
            handleLyteSwitch(defaultCase,svg);
        }
        if(isDefCaseTemp) {
            template.content.appendChild(defaultCase);
            defaultCase.setAttribute("default" , "");
        } else {
            var defTemp = dom.createElement("template");
            defTemp.setAttribute("default" , "");
            defTemp.content.appendChild(defaultCase);
            template.content.appendChild(defTemp);
        }
    }
    template.setAttribute("value", switchValue);
    template.setAttribute("is", "switch");
    if(!type) {
        template.setAttribute("errorinfo", JSON.stringify(errorInfo));
        node.innerHTML = template.outerHTML;
    } else {
        node = template;
        node.setAttribute("errorinfo", JSON.stringify(errorInfo));
    }
    return node;
}
//ignorei18n_end