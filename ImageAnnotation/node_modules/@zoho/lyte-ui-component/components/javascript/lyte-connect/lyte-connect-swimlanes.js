import { prop } from "@slyte/core";
import { Component } from "../../component.js";
import $L from "@zoho/lyte-dom";

class LyteConnectSwimlanesComponent extends Component {
    constructor() {
        super();
    }

    data() {
		return {

			/* Basic data */
			ltPropData: prop('array', { default: [] }),

			/* Swim Lanes Properties */

			ltPropSwimNodes: prop('boolean', { default: false }),

			/* Scroll properties - here scroll means transform */

			ltPropScrollLeft: prop('number', { default: 0 }),
			ltPropScrollTop: prop('number', { default: 0 }),

			/* To adjust inner children position of a group shape*/

			ltPropSelectors: prop('object', {
				default: {
					selector: "lyte-connection-footer,.lyteConnectAnchorPoint",
					markerEnd: "url(#lyteConnectionTailMarker)",
					markerStart: ""
				}
			}),

			/* Elbow connector properties */

			ltPropConnectionType: prop("string", { default: "curve" }),
			ltPropConnectorRadius: prop('number', { default: 5 }),
			ltPropAvoidWithModule: prop('boolean', { default: false }),
			ltPropCheckLineBreak: prop("boolean", { default: false }),
			ltPropElbowArc: prop("boolean", { default: false }),
			ltPropCurveOffset: prop('number', { default: 0 }),
			ltPropAvoidLine: prop('boolean', { default: false }),


			ltPropLineMarker: prop('array'),

			ltPropBoundary: prop('object', { default: {} }),

			ltPropContextualWheel: prop('boolean', { default: false }),

			ltPropScale: prop('number', { default: 1 }),

			ltPropCenter: prop('object', { default: { vert: 0 } }),

			ltPropSwimlaneOnDrop: prop('boolean', { default: false }),

			ltPropTextBox: prop('boolean', { default: false }),
			ltPropCheckLineBreak: prop('boolean', { default: false }),
			ltPropTextBoxAvoidance: prop('boolean', { default: false }),

			/*  SVG dimension. Change if number of connectors occupies more area*/

			ltPropWidth: prop('number', { default: 200000 }),
			ltPropHeight: prop('number', { default: 200000 }),

			/* System data */

			viewBox: prop('string', { default: '' }),
			textBoxArray: prop('array', { default: [] }),
			styleValue: prop('string', { default: '' }),
			cornerConnect: prop('object', { default: {} }),
			details: prop('object', { default: {} }),
			atLimit: prop('object', { default: {} }),
			out_range: prop('object', { default: {} }),
			onDrop: prop('boolean', { default: true })

		};
	}

    didConnect() {
        var lyteSelf = this;
        var data = this.data,
			node=this.$node,
			$node = $L(node),
			default_obj = data.ltPropSelectors,
			connect_func = $L(this.$node.children[0]).data(),
			obj = $L.extend({
				swimlanes: true,
				connection_type: data.ltPropConnectionType,
				connector_radius: data.ltPropConnectorRadius,
				avoid_with_module: data.ltPropAvoidWithModule,
				check_break: false,
				elbow_arc: data.ltPropElbowArc,
				avoid_line: data.ltPropAvoidLine,
				textbox_avoidance: data.ltPropTextBoxAvoidance,
				line_marker: data.ltPropLineMarker,
				module: "lyte-connect-item",
				default_top: "lyte-connection-header",
				default_bottom: "lyte-connection-footer",
				scroll_parent: "lyte-connection-content",
				wrapperElement: $node.find('.lyteConnectionSwimlanesMarker').get(0),
				offset: {
					left: 12,
					top: 12,
					right: 12,
					bottom: 12
				},
				curve_offset: data.ltPropCurveOffset,

				setScroll: function (_left, value) {
					this.setData('ltPropScroll' + _left, value);
				}.bind(this),

				getScroll: function () {
					var data = this.data;
					// return{
					// 	left : 0,
					// 	top : 0
					// };
					return {
						left: data.ltPropScrollLeft,
						top: data.ltPropScrollTop
					}
				}.bind(this),

				getBoundary: function () {
					return data.ltPropBoundary;
				}.bind(this),


				getScale: function () {
					return data.ltPropContextualWheel ? 1 : data.ltPropScale;
				}.bind(this),

				splitIndiv : connect_func.connection_data.splitRanges.bind(this),

				join_ranges : connect_func.connection_data.join_ranges.bind(this)

			}, default_obj);

        this.__wrapper = node;

        $node.connection(obj);

        node.connect = function (src, target, options, ignore) {
			var __data = this.data;
			if (__data.ltPropTextBox) {
				var textBox = (options || (options = {})).textBox,
					__arr = __data.textBoxArray,
					__index = __arr.length,
					__id;

				if (!textBox) {
					options.textBox = textBox = { text: [] };
				}

				__id = textBox.id = textBox.id || ("text_box" + Date.now() + parseInt(Math.random() * 1000));

				lyteSelf.$addon.arrayUtils(__data.textBoxArray, 'push', textBox);
				options.text_box = document.getElementById(__id);
			}
			$node.connection('create', src, target, options);

			delete options.text_box;
		}.bind(this);

        node.arrange = function(arr){
			var conn_data = $L('lyte-connect'),
				is_array = Array.isArray(arr);
			Array.from(conn_data).forEach(item=>{
				var valid=is_array?(arr.indexOf(item.id)==-1)?false:true:true;
				valid && item.arrange();
			});
		}
    }

    static actions() {
        return {
            textclick : function( evt, __this, index ){

                if( this.data.ltPropReadonly ){
                    return;
                }

                var $this = $L( __this ),
                connection = $this.data( 'connector' ),
                cb = "onTextbodyClick",
                arr = this.data.textBoxArray;

                this.getMethods( cb ) && this.executeMethod( cb, __this, $this.attr( 'connector-id' ), arr[ index ].text, connection.data( 'options' ), evt, this.$node );
            }
        };
    }

    static methods() {
        return {
            setDetails: function (_this, elem, position) {
                var position = $L.extend({}, position),
                    details = this.data.details,
                    cur_id = elem.id,
                    scr_left = _this.data.ltPropScrollLeft,
                    scr_top = _this.data.ltPropScrollTop,
                    off_left = _this.$node.offsetLeft,
                    off_top = _this.$node.offsetTop;
                if (details[cur_id]) {//set position
                    position.left = off_left + scr_left + position.left;
                    position.top = off_top + scr_top + position.top;
                    this.$addon.objectUtils(details[cur_id], 'add', 'position', position);
                } else {
                    var cur_pos = position.position;
                    cur_pos.left = off_left + scr_left - cur_pos.left;
                    cur_pos.top = off_top + scr_top - cur_pos.top;
                    position.parent = _this.$node;
                    this.$addon.objectUtils(details, 'add', cur_id, position);
                }
            },
            restrictLimits: function (moving, xInc, yInc, _this_node) {
                var lyteSelf = this;
                var mov_item = moving[0].get(0),
                    item_pos = mov_item.getBoundingClientRect(),
                    tot_item = this.data.ltPropSwimNodes ? mov_item.closest("lyte-connect-swimlanes") : mov_item.closest("lyte-connect"),
                    tot_pos = tot_item.getBoundingClientRect(),
                    on_range = this.data.out_range,
                    limit = this.data.atLimit,
                    ret = { xInc: xInc, yInc: yInc },
                    restrictMovement = function (side, inc) {
                        var moving_in = ret[inc] <= 0,
                            beyond_lim = parseInt(item_pos[side]) < parseInt(tot_pos[side]);
                        if (side == 'right' || side == 'bottom') {
                            moving_in = ret[inc] >= 0;
                            beyond_lim = parseInt(item_pos[side]) > parseInt(tot_pos[side]);
                        }
                        if (moving_in && (limit[side] || on_range[side])) {//reached limit||item at line 
                            ret[inc] = 0;//left movement is avoided
                        } else if (beyond_lim && !on_range[side]) {
                            lyteSelf.$addon.objectUtils(limit, "add", side, true);//reched limit
                            ret[inc] = parseInt(tot_pos[side]) - parseInt(item_pos[side]);//remove extra
                        } else {
                            if (!beyond_lim && on_range[side]) {
                                lyteSelf.$addon.objectUtils(on_range, "add", side, false);//not on line came in 
                            }
                            if (!moving_in) {//moved from limit to right
                                lyteSelf.$addon.objectUtils(limit, "add", side, false);
                            }
                        }
                    };

                restrictMovement("left", "xInc");
                restrictMovement("right", "xInc");
                restrictMovement("top", "yInc");
                restrictMovement("bottom", "yInc");

                return ret;
            },
            swimNodes: function (evt, _this, cur_item) {
                var new_conn = evt.target.closest("lyte-connect"),
                    old_conn = _this.$node;
                if (new_conn) {
                    if (new_conn != old_conn) {
                        var data = _this.data,
                            new_conn_data = new_conn.component.data,
                            cur_item_val = _this.delete(cur_item.id),
                            cur_item_data = cur_item_val.data,
                            cur_item_pos = cur_item_data.position,
                            old_conn_right = old_conn.offsetWidth - data.ltPropScrollLeft,
                            cur_item_left = parseInt(cur_item.style.left);
                        if (old_conn_right <= cur_item_left) {
                            cur_item_pos.left = Math.abs(cur_item_left - (old_conn_right + (new_conn.offsetLeft - (old_conn.offsetLeft + old_conn.offsetWidth)))) - new_conn_data.ltPropScrollLeft;
                        } else {
                            cur_item_pos.left = (new_conn.offsetWidth - new_conn_data.ltPropScrollLeft) - Math.abs(cur_item_left - (-data.ltPropScrollLeft - (old_conn.offsetLeft - (new_conn.offsetLeft + new_conn.offsetWidth))))
                        }
                        cur_item_pos.top = Math.abs(parseInt(cur_item.style.top) + data.ltPropScrollTop) - new_conn_data.ltPropScrollTop;
                        new_conn.insertShape(cur_item_data);
                        cur_item_val.connections.forEach(item => {
                            var data = this.data;
                            data.textBoxArray.forEach((textbox, index) => {
                                if (textbox.id == item.options.textBox.id) {
                                    this.$addon.arrayUtils(data.textBoxArray, 'removeAt', index);
                                }
                            });
                            old_conn.offsetParent.connect(item.src, item.target, item.options)
                        });
                    }
                } else if (this.data.ltPropSwimlaneOnDrop) {
                    this.setData("onDrop", false);//go back to mousedown position
                }
            },
            onDrop: function ( elem, old_position, new_position, node, evt ) {
                var ret = this.data.onDrop;
                node.unSelectShape( elem, evt );
                this.setData( "onDrop", true );
                return ret;
            }
        };
    }
}

export { LyteConnectSwimlanesComponent };
