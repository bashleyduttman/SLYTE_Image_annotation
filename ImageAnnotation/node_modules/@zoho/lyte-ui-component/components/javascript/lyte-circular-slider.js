import { prop } from "@slyte/core";
import { Component } from "../component.js";


class LyteCircularSliderComponent extends Component {
    constructor() {
		super();
	}

    data() {
        return {
            ltPropValue: prop('number', { default: 0 }),
            ltPropMin: prop('number', { default: 0 }),
            ltPropMax: prop('number', { default: 100 }),
            ltPropStrokeWidth: prop('number', { default: 10 }),
            ltPropStroke: prop('string', { default: "#42a2eb" }),
            ltPropStrokeBackground: prop('string', { default: "#DCE0E3" }),
            ltPropHandlerColor: prop('string', { default: "red" }),
            ltPropTextDisplay: prop('string', { default: "value" }),
            ltPropDigits: prop('number', { default: 0 }),
            ltPropStopAtEnd: prop('boolean', { default: false }),
            ltPropStartDirection: prop('string', { default: 'top' }),
            ltPropAtend: prop('string', { default: 'default' }),
            ltPropDisabled: prop('boolean', { default: false }),
            ltPropRefresh: prop('boolean', { default: false }),

            dashOffset: prop('number', { default: 345.5749 }),
            textValue: prop('string'),
            bcr: prop('object'),
            setAt: prop('string')

        }
    }

    didConnect() {
        var $node = this.$node,
            rotateVal;
        $node.mainCircle = $L('.lyteCirSliderOuterCircle', $node).get(0);
        $node.stroke = $L('.lyteCirSliderStrokeCircle', $node).get(0);
        $node.handler = $L('.lyteCirSliderHandler', $node).get(0);
        $node.svg = $L('.lyteCirSliderSvg', $node).get(0);
        switch (this.data.ltPropStartDirection) {
            case 'right': {
                rotateVal = 0;
                break;
            }
            case 'bottom': {
                rotateVal = 90;
                break;
            }
            case 'left': {
                rotateVal = 180;
                break;
            }
            default: {
                rotateVal = 270;
            }
        }
        $L('.lyteCirSliderWrapper', $node).get(0).setAttribute("transform", "rotate(" + rotateVal + ", 60, 60)");
        this.rotateVal = rotateVal;
    }

    static actions() {
        return{
            click: function (event) {
                if (this.preventClick || this.data.ltPropDisabled) {
                    delete this.preventClick;
                    return;
                }
                this.angleFromPoint(event.x, event.y);
            },
    
            mousedown: function (event) {
                if(this.data.ltPropDisabled){
                    return;
                }
                var $node = this.$node,
                    handler = $node.handler;
                this.up = this.mouseup.bind(this);
                this.move = this.mousemove.bind(this);
                this.setData('bcr', {
                    mainCircle: $node.mainCircle.getBoundingClientRect(),
                    handler: handler.getBoundingClientRect()
                });
                !this.data.ltPropStopAtEnd && this.angleFromPoint(event.x, event.y);
                if (this.prevAngle == undefined) {
                    var bcr = handler.getBoundingClientRect();
                    if (this.data.ltPropValue == this.data.ltPropMin) {
                        this.prevAngle = 0;
                    } else {
                        this.angleFromPoint(bcr.x + (bcr.width / 2), (bcr.y + (bcr.height / 2)), false, true);
                    }
                }
                $L($node).addClass('lyteCircularSliderDrag');
                document.addEventListener('mousemove', this.move);
                document.addEventListener('mouseup', this.up);
            },
    
            keydown: function (event) {
                if(this.data.ltPropDisabled){
                    return;
                }
                var prevent,
                    data = this.data,
                    value = data.ltPropValue,
                    atend = data.ltPropAtend,
                    max = data.ltPropMax,
                    min = data.ltPropMin,
                    checkVal = function (value) {
                        if (value < max && value > min) {
                            return value;
                        }
                        if (data.ltPropStopAtEnd) {
                            if (value > max) {
                                value = max;
                            } else if (value < min) {
                                value = min;
                            }
                        } else {
                            if (value == max || value == min) {
                                atend == 'end' ? value = max : value = min;
                            }
                            if (value > max || value < min) {
                                // default: {
                                if (value > max) {
                                    value = min + 1;
                                } else if (value < min) {
                                    value = max - 1;
                                }
                                // value = value > max && (min + 1);
                                // value = value < min && (max - 1);
                                // }
                                // }
                                // atend == 'end' ? value = max : value = min;
                            }
                            // if(atend == 'end'){
                            //     if(value > max || value < min){
                            //         value = max;
                            //     }
                            // }else if(atend == 'start'){
                            //     if(value > max || value < min){
                            //         value = min;
                            //     }
                            // }
                        }
                        return value;
                    };
                switch (event.key) {
                    case 'ArrowUp':
                    case 'ArrowRight': {
                        var newVal = value + 1;
                        this.changeValue(checkVal(newVal));
                        prevent = true;
                        break;
                    }
                    case 'ArrowDown':
                    case 'ArrowLeft': {
                        var newVal = data.ltPropDigits ? value - 1 : Math.ceil(this.actVal) - 1;
                        this.changeValue(checkVal(newVal));
                        prevent = true;
                        break;
                    }
                    case 'Home': {//fn left
                        this.changeValue(data.ltPropMin);
                        prevent = true;
                        break;
                    }
                    case 'End': {
                        this.changeValue(data.ltPropMax);
                        prevent = true;
                        break;
                    }
                }
                prevent && event.preventDefault();
            }
        }
    }


    static observers() {
		return {
            disabled: function () {
                $L(this.$node)[this.data.ltPropDisabled ? 'addClass' : 'removeClass']('lyteCircularSliderDisabled');
            }.observes('ltPropDisabled').on('init'),

            valObs: function () {
                if (this.avoid) {
                    delete this.avoid;
                    return;
                }
                this.changeValue(this.data.ltPropValue, true);
            }.observes('ltPropValue').on('didConnect'),

            refresh: function () {
                if(this.data.ltPropRefresh){
                    this.changeValue(this.data.ltPropValue);
                    this.setData('ltPropRefresh', false);
                }
            }.observes('ltPropRefresh')
        }
    }

    changeValue(custVal, fromObs) {
        var data = this.data,
            min = data.ltPropMin,
            max = data.ltPropMax,
            $node = this.$node;
        if (custVal < min || custVal == undefined) {
            this.setData('ltPropValue', min);
        } else if (custVal > max) {
            this.setData('ltPropValue', max);
        } else {
            var textType = data.ltPropTextDisplay,
                bcr = data.bcr,
                largeCircle = { r: parseInt($node.mainCircle.getAttribute('r')), strokeWidth: parseInt($node.stroke.getAttribute('stroke-width')) },
                handler = $node.handler,
                setVal = this.data.ltPropDigits ? parseFloat(custVal).toFixed(this.data.ltPropDigits) : parseInt(custVal),
                bcr = {
                    mainCircle: $node.svg.getBoundingClientRect(),
                    handler: handler.getBoundingClientRect()
                },
                halfWidth = bcr.mainCircle.width / 2,
                halfHeight = bcr.mainCircle.height / 2,
                radiuspct = largeCircle.r / (largeCircle.r + largeCircle.strokeWidth / 2),
                radius = radiuspct * Math.min(halfHeight, halfWidth),
                valueChanged,angleRad, percent;
            // if (textType == "value" && ((data.setAt == 'start' || data.setAt == 'end') && setVal != max && setVal != min)) {
            //     this.setData('setAt', undefined);
            // }
            // setVal = data.setAt ? data.setAt == 'start' ? min : max : setVal;
            if (!data.ltPropStopAtEnd && !fromObs/* && textType == "value"*/) {
                if (setVal == max || setVal == min) {
                    switch (data.ltPropAtend) {
                        case 'combine':
                            {
                                var p1 = Math.abs(max - this.prevValue),
                                    p2 = Math.abs(this.prevValue - min);
                                if (p1 < p2) {
                                    setVal = max;
                                } else {
                                    setVal = min;
                                }
                            }
                            break;
                        case 'start':
                            {
                                setVal = min;
                            }
                            break;
                        case 'end':
                            {
                                setVal = max;
                            }
                    }
                } else {
                    this.prevValue = setVal;
                }
            }
            percent = (setVal - min) / (max - min);
            if (textType == "value") {
                this.setData('textValue', setVal);
            } else if(textType == 'percent'){
                var prctVal = Math.round(percent * 100);
                this.setData('textValue', prctVal + '%');
            }
            this.setData('dashOffset', (1 - percent) * 345.5749);
            valueChanged = this.data.ltPropValue != setVal
            if (!fromObs && valueChanged) {
                this.avoid = true;
                this.setData('ltPropValue', setVal);
            }
            this.actVal = custVal;
            angleRad = ((percent + (this.rotateVal / 90) * .25) * 360) * (Math.PI / 180);

            handler.style.transform = 'translate(' + ((halfWidth - (bcr.handler.width / 2)) + radius * Math.cos(angleRad)) + 'px, ' + ((halfHeight - (bcr.handler.height / 2)) + radius * Math.sin(angleRad)) + 'px)';
            valueChanged && this.getMethods('onValueChange') && this.executeMethod('onValueChange', setVal, $node);
        }
    }

    angleFromPoint(x, y, drag, readonly) {
        var pos = this.$node.mainCircle.getBoundingClientRect(),
            angle = Math.atan2((y - (pos.y + (pos.height / 2))), (x - (pos.x + (pos.width / 2)))) * (180 / Math.PI),
            anglediff;
        angle < 0 && (angle += 360);
        angle += 360 - this.rotateVal;
        angle > 360 && (angle -= 360);
        anglediff = angle - (this.prevAngle == undefined ? 0 : this.prevAngle);
        // if (!this.data.ltPropStopAtEnd && (Math.round(angle) == 360 || Math.round(angle) == 0) && drag && anglediff != 0) {
        //     if(atend == 'smart'){
        //         this.setData('setAt', Math.abs(anglediff) > 90 ? 'start' : 'end');
        //     } else if(atend == 'end'){
        //         this.setData('setAt', 'end');
        //     } else if(atend =='start'){
        //         this.setData('setAt','start');
        //     }
        // }
        this.data.ltPropStopAtEnd && drag && Math.abs(anglediff) > 30 && (angle = anglediff < 0 ? 360 : 0);
        this.prevAngle = angle;
        if (readonly) {
            return angle;
        }
        this.changeValue(this.data.ltPropMin + (Math.abs(this.data.ltPropMax - (this.data.ltPropMin)) * (angle / 360)));
    }

    mousemove(event) {
        this.angleFromPoint(event.x, event.y, true);
    }

    mouseup() {
        document.removeEventListener('mousemove', this.move);
        document.removeEventListener('mouseup', this.up);
        delete this.move;
        delete this.up;
        this.preventClick = true;
        $L(this.$node).removeClass('lyteCircularSliderDrag');
    }

}