import { prop } from "@slyte/core";
import { Component } from "../component.js";
/**
 * Renders a radiobutton
 * @component lyte-radiobutton
 * @version 1.0.0
 * @utility focus,blur,click
 * @methods onBeforeChecked,onBeforeUnchecked,onChecked,onUnchecked,onChanged
 */

if (!window._lyteUiUtils.radio) {
	window._lyteUiUtils.radio = {};
}


class LyteRadiobuttonComponent extends Component {
    constructor() {
        super();
    }

    data() {
		return {

			/**
			 * @componentProperty {default|primary|secondary|switch|slider} ltPropType
			 * @default default
			 */

			'ltPropType': prop('string', {
				'default': window._lyteUiUtils.resolveDefaultValue('lyte-radiobutton', 'type', 'default')
			}),

			/**
			 * @componentProperty {string} ltPropName
			 */

			'ltPropName': prop('string', {
				'default': undefined
			}),

			/**
			 * @componentProperty {boolean} ltPropDisabled
			 * @default false
			 *
			 */

			'ltPropDisabled': prop('boolean', {
				'default': false
			}),

			/**
			 * @componentProperty {boolean} ltPropChecked
			 * @default false
			 *
			 */

			'ltPropChecked': prop('boolean', {
				'default': false
			}),

			/**
			 * @componentProperty {string} ltPropLabel
			 */


			'ltPropLabel': prop('string', {
				'default': undefined
			}),

			/**
			 * @componentProperty {string} ltPropValue
			 */
			'ltPropValue': prop('string', {
				'default': undefined
			}),

			/**
			 * @componentProperty {boolean} ltPropFireOnInit
			 * @default false
			 *
			 */

			'ltPropFireOnInit': prop('boolean', {
				'default': window._lyteUiUtils.resolveDefaultValue('lyte-radiobutton', 'fireOnInit', false)
			}),

			/**
			 * @componentProperty {string} ltPropLabelClass
			 */
			'ltPropLabelClass': prop('string', {
				'default': window._lyteUiUtils.resolveDefaultValue('lyte-radiobutton', 'labelClass', '')
			}),

			/**
			 * @componentProperty {string} ltPropClass
			 */

			'ltPropClass': prop('string', {
				'default': window._lyteUiUtils.resolveDefaultValue('lyte-radiobutton', 'class', '')
			}),

			/**
			 * @componentProperty {boolean} ltPropYield
			 * @version 2.2.8
			 * @default false
			 *
			 */

			'ltPropYield': prop('boolean', {
				'default': false
			}),
			'ltPropAriaRadio': prop('object', {
				'default': window._lyteUiUtils.resolveDefaultValue('lyte-radiobutton', 'ariaRadio', {})
			}),
			'ltPropFocus': prop('boolean', {
				'default': false
			}),

			'ltPropPreventFocus': prop('boolean', { 'default': false }),

			'lyteUnbound': prop('boolean', {
				'default': false
			}),

			'ltPropReadOnly': prop('boolean', {
				'default': false
			}),
			'ltPropDataTabindex': prop('string', { 'default': "" })
		};
	}

    getFromCache(keyName) {
		var cache = window._lyteUiUtils.radio,
			name = this.getData('ltPropName') || '',
			radioGroup = cache[name] || {};

		return radioGroup[keyName];
	}

    setInCache(keyName, value) {
		var cache = window._lyteUiUtils.radio,
			name = this.getData('ltPropName') || '',
			radioGroup = cache[name];

		if (radioGroup) {
			radioGroup[keyName] = value;
		}
	}

    didDestroy() {
		this.destroyCache();
		delete this.$node.focus;
		delete this.$node.blur;
		delete this.$node.click;
	}

    destroyCache() {
		var name = this.getData('ltPropName'),
			value = this.getData('ltPropValue');

		if (this.getFromCache('prev') === value) {
			this.setInCache('prev', undefined);
		}

		if (this.getFromCache('node') === this.$node.querySelector('input')) {
			this.setInCache('node', undefined);
		}

		var index = (this.getFromCache('peers') || []).indexOf(this.$node);

		if (!!~index) {
			this.getFromCache('peers').splice(index, 1);
		}
	}

    changeStyleFunction() {

		var type = this.getData('ltPropType'),
			checked = this.getData('ltPropChecked'),
			cls = this.getData('ltPropClass'),
			labelCls = this.getData('ltPropLabelClass');

		if (
			type.indexOf('slider') === -1
			&& type.indexOf('switch') === -1
			&& type.indexOf('default') === -1
			&& type.indexOf('primary') === -1
			&& type.indexOf('secondary') === -1
			&& type.indexOf('checkbox') === -1
		) {
			this.setData('ltPropType', 'default');
		}

		if (type.indexOf('default') !== -1) {
			this.setData('radioclass', 'lyteRadioBtn lyteDefault')
			this.setData('ltPropClass', cls ? cls : 'lyteRadioLayer')
			this.setData('ltPropLabelClass', labelCls ? labelCls : 'lyteRadioLabel')
		}
		else if (type.indexOf('primary') !== -1) {
			this.setData('radioclass', 'lyteRadioBtn lytePrimary')
			this.setData('ltPropClass', cls ? cls : 'lyteRadioLayer')
			this.setData('ltPropLabelClass', labelCls ? labelCls : 'lyteRadioLabel')
		}
		else if (type.indexOf('secondary') !== -1) {
			this.setData('radioclass', 'lyteRadioBtn lyteSecondary')
			this.setData('ltPropClass', cls ? cls : 'lyteRadioLayer')
			this.setData('ltPropLabelClass', labelCls ? labelCls : 'lyteRadioLabel')
		}
		else if (type.indexOf('switch') !== -1) {
			this.setData('ltPropClass', cls ? cls : 'lyteRadioSwitch')
			this.setData('ltPropLabelClass', labelCls ? labelCls : 'lyteRadioLabel')
		}
		else if (type.indexOf('slider') !== -1) {
			this.setData('ltPropClass', cls ? cls : 'lyteRadioSlider')
			this.setData('ltPropLabelClass', labelCls ? labelCls : 'lyteRadioSliderText')
		}
		else if (type.indexOf('checkbox') !== -1) {
			this.setData('ltPropClass', cls ? cls : 'lyteRadioCheckbox')
			this.setData('ltPropLabelClass', labelCls ? labelCls : 'lyteRadioCheckboxLabel')
		}
	}

    reduceOpacity() {
		if (this.getData('ltPropDisabled')) {
			this.$node.classList.add('lyteRadioDisabled');
		}
		else {
			this.$node.classList.remove('lyteRadioDisabled');
		}
	}

    init() {

		this.changeStyleFunction();
		this.setRandomId();
	}

    initCache() {
		var name = this.getData('ltPropName');

		if (!name) {
			return;
		}

		if (!window._lyteUiUtils.radio[name]) {
			window._lyteUiUtils.radio[name] = {};
		}

		if (!window._lyteUiUtils.radio[name].peers) {
			window._lyteUiUtils.radio[name].peers = [];
		}

		window._lyteUiUtils.radio[name].peers.push(this.$node);
	}

    setRandomId() {
		this.setData('randomId', 'lyte-radiobutton-label-' + window._lyteUiUtils.rbuttonId++);
	}

    didConnect() {
		this.warnUsers();
		var that = this, newAria = this.getData('ltPropAriaRadio');

		var dataIndex = this.getData('ltPropDataTabindex')
		this.$node.setAttribute('data-tabindex', dataIndex)

		this.initCache();
		this.reduceOpacity();

		this.$node.click = function () {
			var ev = new Event('click', {
				bubbles: true,
				cancelable: true
			}),
				node = that.$node,
				checked = node.ltProp('checked'),
				disabled = node.ltProp('disabled');

			if (disabled) {
				return;
			}

			node.component.clickFn = true;

			if (!checked) {
				if (node._fR) {
					// Just calling resetValues here to make things less complicated
					node.component.resetValues();
					node.component.checkFR(node);
				}
				else {
					node.ltProp('checked', true);
				}
			}

			node.component.clickFn = false;

			node.dispatchEvent(ev);
		}

		this.$node.focus = function () {
			var node = that.$node,
				input = node.querySelector('input'),
				disabled = node.ltProp('disabled');

			if (disabled) {
				return;
			}

			input.focus();
		}

		this.$node.blur = function () {
			var node = that.$node,
				input = node.querySelector('input'),
				disabled = node.ltProp('disabled');

			if (disabled) {
				return;
			}

			input.blur();
		}

		this.callMethodsOnInit(true);
		this.addAriaValues({}, newAria);
	}

    warnUsers() {
		var name = this.getData('ltPropName') || '',
			value = this.getData('ltPropValue') || '';

		if (!name) {
			console.warn('lt-prop-name attribute not present in radiobutton. It is required', this.$node);
		}

		if (!value) {
			console.warn('lt-prop-value attribute not present in radiobutton. It is required', this.$node);
		}
	}

    addAriaValues(oldAria, newAria) {
		var radio = this.getRadioWidget();

		window._lyteUiUtils.setAttribute(radio, newAria, oldAria);
	}

    getRadioWidget() {
		return this.$node.querySelector('input');
	}

    check(inp, comp) {
		if (this.getMethods('onChecked')) {
			this.executeMethod('onChecked', inp, comp, this.eventType());
		}
	}

    uncheck(inp, comp) {
		if (this.getMethods('onUnchecked')) {
			this.executeMethod('onUnchecked', inp, comp, this.eventType());
		}
	}

    beforeCheck(inp, comp) {
		if (this.getMethods('onBeforeChecked')) {
			return this.executeMethod('onBeforeChecked', inp, comp, this.eventType());
		}
	}

    beforeUncheck(inp, comp) {
		if (this.getMethods('onBeforeUnchecked')) {
			return this.executeMethod('onBeforeUnchecked', inp, comp, this.eventType());
		}
	}

    onchanged(inp, comp) {
		if (this.getMethods('onChanged')) {
			this.executeMethod('onChanged', inp, comp, this.eventType());
		}
	}

    checkCurrentRadio() {
		this.eveType = 'key';
		this.setData('ltPropChecked', true);
		this.eveType = '';
	}

    checkNextRadio() {
		var radios = this.extractAllRadios(),
			nextRadioIndex = this.getCheckableRadio(radios, 1);

		if (nextRadioIndex !== -1) {
			radios[nextRadioIndex].component.eveType = 'key';
			radios[nextRadioIndex].ltProp('checked', true);
			radios[nextRadioIndex].component.eveType = '';
		}
	}

    checkPreviousRadio() {
		var radios = this.extractAllRadios(),
			previousRadioIndex = this.getCheckableRadio(radios, -1);

		if (previousRadioIndex !== -1) {
			radios[previousRadioIndex].component.eveType = 'key';
			radios[previousRadioIndex].ltProp('checked', true);
			radios[previousRadioIndex].component.eveType = '';
		}
	}

    getCheckableRadio(radios, indexChange) {
		var currentRadioIndex = this.getIndex(radios),
			totalRadios = radios.length,
			index = currentRadioIndex;

		for (var i = 0; i < totalRadios; i++) {
			index = index + indexChange;

			if (index < 0) {
				index = totalRadios - 1;
			}
			else if (index === totalRadios) {
				index = 0;
			}

			if (!radios[index].ltProp('disabled') || index === currentRadioIndex) {
				return index;
			}
		}

		return -1;
	}

    extractAllRadios() {
		var name = this.getData('ltPropName'), i = 0, radio,
			inp = document.querySelectorAll('input[type="radio"][name="' + name + '"]'),
			result = [];

		for (; i < inp.length; i++) {
			radio = inp[i];

			while (radio.tagName !== 'LYTE-RADIOBUTTON'
				&& radio.tagName !== 'HTML'
			) {
				radio = radio.parentElement;
			}

			if (radio.tagName === 'LYTE-RADIOBUTTON') {
				result.push(radio);
			}
		}

		return result;
	}

    getIndex(result) {
		return result.indexOf(this.$node);
	}

    extractRadios() {
		var name = this.getData('ltPropName'), i = 0, tag,
			inp = this.getFromCache('peers') || [];

		for (; i < inp.length; i++) {
			tag = inp[i];

			if (tag.ltProp('checked')
				&& tag != this.$node
			) {
				return tag;
			}
		}
	}

    changeChecks(change) {
		var name = this.getData('ltPropName'),
			radio = this.extractRadios(),
			inp = radio && radio.querySelector('input'),
			comp = radio && radio.component,
			cur = this.$node.querySelector('input'),
			ret_uncheck, ret_check;

		// A checked radiobutton is checked
		// This check probably never executes because
		// observers never fire when oldValue and newValue are the same. Its just a safety check
		if (change.newValue && change.oldValue) {
			return;
		}

		// A radiobutton that is different from the currently checked radiobutton is checked
		else if (change.newValue) {
			this.setData('prevent', true);
			this.setData('ltPropChecked', false);

			// Unchecking the previously checked radiobutton and calling before uncheck callbacks
			if (radio) {
				ret_uncheck = this.beforeUncheck(cur, this);
			}

			if (ret_uncheck === false) {
				this.revertState(radio, this.$node);

				return;
			}

			ret_check = this.beforeCheck(cur, this);

			if (ret_check === false) {
				this.revertState(radio, this.$node);

				return;
			}

			// calling the uncheck callback of the previously checked radiobutton
			if (radio) {
				comp.setData('prevent', true);
				radio.ltProp('checked', false);
				comp.setData('prevent', false);
				this.uncheck(cur, this);
			}

			this.setData('ltPropChecked', true);
			this.setData('prevent', false);

			this.check(cur, this);
			this.onchanged(cur, this);
		}

		// A radiobutton is unchecked but it was not previously unchecked
		else if (!change.newValue && change.oldValue) {
			this.setData('prevent', true);
			this.setData('ltPropChecked', true);

			ret_uncheck = this.beforeUncheck(cur, this);

			if (ret_uncheck === false) {
				this.revertState(this.$node, {});

				return;
			}

			this.setData('ltPropChecked', false);
			this.uncheck(cur, this);
			this.onchanged(cur, this);
			this.setData('prevent', false);
		}

	}

    change(change) {

		var name = this.getData('ltPropName'),
			input = this.getCheckedInput();

		if (!this.getData('onChange')) {
			this.changeChecks(change);
		}
		else {
			if (!change.newValue) {
				this.uncheck(input, this.getData('second'));
			}
			else {
				this.check(input, this);
			}
		}
	}

    getCheckedInput() {
		var name = this.getData('ltPropName'), peers = this.getFromCache('peers') || [],
			input;

		for (var i = 0; i < peers.length; i++) {
			input = peers[i].querySelector('input');

			if (input.matches(':checked')) {
				return input;
			}
		}
	}

    resetValues() {
		this.setInCache('prev', undefined);
		this.setInCache('node', undefined);
	}

    fireCallbacks(change) {
		var prev = change.oldValue,
			cur = change.newValue,
			preventFocus = this.getData('ltPropPreventFocus');

		if (prev && !cur) {
			this.resetValues();
		}

		if (this.getData('prevent')) {
			return;
		}

		if (cur && !preventFocus) {
			this.$node.focus();
		}

		this.change(change);
	}

    // Returns undefined when node is undefined

    getParentRadio(node) {
		while (node
			&& node.tagName !== 'LYTE-RADIOBUTTON') {
			node = node.parentElement;
		}

		return node;
	}

    revertState(uncheckedRadio, checkedRadio) {
		var uncheckedRadioComp = (uncheckedRadio || {}).component,
			checkedRadioComp = (checkedRadio || {}).component;

		if (uncheckedRadioComp) {
			uncheckedRadioComp.setData('prevent', true);
			uncheckedRadioComp.setData('ltPropChecked', true);
			uncheckedRadio.querySelector('input').checked = true;
			uncheckedRadioComp.setData('prevent', false);
		}

		if (checkedRadioComp) {
			checkedRadioComp.setData('prevent', true);
			checkedRadioComp.setData('ltPropChecked', false);
			checkedRadio.querySelector('input').checked = false;
			checkedRadioComp.setData('prevent', false);
		}

	}

    callMethodsOnInit() {
		var foi = this.getData('ltPropFireOnInit'),
			checked = this.getData('ltPropChecked');

		if (!foi) {
			return;
		}

		if (checked) {
			var element = this.$node.querySelector('input'),
				value = element.getAttribute('value');

			this.beforeCheck(element, this);
			this.check(element, this);
			this.onchanged(element, this);
		}
	}

    checkFR(node) {

		node.component.setData('ltPropChecked', true);
		node.querySelector('input').checked = true;

		node.component.fireCallbacks({
			oldValue: false,
			newValue: true
		});
	}

    uncheckFR(node) {

		node.component.setData('ltPropChecked', false);
		node.querySelector('input').checked = false;

		node.component.fireCallbacks({
			oldValue: true,
			newValue: false
		});
	}

    eventType() {
		var isClicked = this.clicked || this.clickFn,
			key = this.eveType;

		if (isClicked) {
			return 'click';
		}

		return key ? key : 'script';
	}

    revertToPreviousState() {
		var node = this.getFromCache('node'),
			uncheckedRadio = this.getParentRadio(node),
			checkedRadio = this.$node;

		this.revertState(uncheckedRadio, checkedRadio);
		this.setInCache('node', undefined);

		// Just a safety
		this.clicked = false;
	}

    static actions() {
        return {
            preventPropagation: function () {
                if (window.event.keyCode === 32) {
                    this.preventClick = true;
                }
            },

            mup: function (event) {
                var name = this.getData('ltPropName'),
                    checkedNode = document.querySelector('input[type="radio"][name="' + name + '"]:checked'), ret_check, ret_uncheck;

                this.setData('shouldCallUnChecked', false);
                if (checkedNode) {
                    this.setInCache('prev', checkedNode.getAttribute('value'));
                    this.setInCache('node', checkedNode);
                    this.setData('shouldCallUnChecked', true);
                }

                var element = this.$node.querySelector('input'), checked = element.checked;

                if (element.disabled) {
                    return;
                }

                if (!checked) {
                    this.clicked = true;

                    if (this.getData('shouldCallUnChecked')) {
                        ret_uncheck = this.beforeUncheck(element, this);

                        if (ret_uncheck === false) {
                            this.setData('preventStateChange', true);
                            this.clicked = false;
                            return;
                        }
                    }

                    ret_check = this.beforeCheck(element, this);

                    if (ret_check === false) {
                        this.setData('preventStateChange', true);
                        this.clicked = false;
                        return;
                    }
                }
            },
            checkboxClick:function(_this,event){
            $L(_this).addClass('lyteCheckboxActive');
            },
            valueChanged: function (event) {
                var ele = event.target,
                    val = ele.getAttribute('value'),
                    prev = this.getFromCache('prev'),
                    node = this.getFromCache('node'),
                    preventStateChange = this.getData('preventStateChange'),
                    comp = node && node.parentElement.parentElement.component;

                event.stopPropagation();

                if (this.preventClick) {
                    this.preventClick = false;
                    return;
                }

                if (val === prev) {
                    return;
                }

                if (preventStateChange) {
                    this.revertToPreviousState();

                    return;
                }

                if (node) {
                    while (node.tagName !== 'LYTE-RADIOBUTTON') {
                        node = node.parentElement;
                    }

                    comp.setData('onChange', true);

                    // We are using a variable called second so that we can pass the current radiobutton's this to the callback.
                    // We won't get the current radiobutton's this in a different radiobutton's observer - we are setting ltPropChecked to false below.
                    comp.setData('second', this);

                    if (node._fR) {
                        this.uncheckFR(node);
                    }
                    else {
                        node.ltProp('checked', false);
                    }

                    comp.setData('second', undefined);

                    comp.setData('onChange', false);
                }

                node = this.getFromCache('node');
                if (node) {
                    this.setInCache('node', undefined);
                }

                this.setData('onChange', true);

                if (this.$node._fR) {
                    this.checkFR(this.$node);
                }
                else {
                    this.setData('ltPropChecked', true);
                }

                this.setData('onChange', false);
                this.onchanged(ele, this);
                this.clicked = false;
            }
        };
    }

    static observers() {
        return {
            ariaObserver: function (change) {
                var oldAria = change.oldValue,
                    newAria = change.newValue;

                this.addAriaValues(oldAria, newAria);
            }.observes('ltPropAriaRadio'),

            changeStyle: function () {
                this.changeStyleFunction()
            }.observes('ltPropType'),

            disabledChange: function () {
                this.reduceOpacity();
            }.observes('ltPropDisabled'),

            nameObserver: function () {
                this.initCache();
            }.observes('ltPropName'),

            valueChanged: function (change) {
                this.fireCallbacks(change);
            }.observes('ltPropChecked'),

            focusRadioButton: function () {
                var shouldFocus = this.getData('ltPropFocus');

                if (shouldFocus) {
                    this.$node.focus();
                }

                this.data.ltPropFocus = false;
            }.observes('ltPropFocus').on('didConnect')
        };
    }
}

document.addEventListener('keydown', function (event) {
	var keyCode = event.keyCode, node, checked, comp;

	if (keyCode === 37
		|| keyCode === 38
		|| keyCode === 39
		|| keyCode === 40
		|| keyCode === 32
	) {

		node = document.activeElement;

		if (node.tagName !== 'INPUT') {
			return;
		}

		while (node.tagName !== 'LYTE-RADIOBUTTON'
			&& node.tagName !== 'HTML'
		) {
			node = node.parentElement;
		}

		if (node.tagName === 'LYTE-RADIOBUTTON') {
			comp = node.component;
			event.preventDefault();

			switch (keyCode) {
				case 37:
				case 38:
					comp.checkPreviousRadio();
					break;
				case 39:
				case 40:
					comp.checkNextRadio();
					break;
				case 32:
					comp.checkCurrentRadio();
					break;
			}
		}
	}
});

/**
 * @syntax nonYielded
 * <lyte-radiobutton lt-prop-value="1" lt-prop-label="check me" lt-prop-name="group-1"></lyte-radiobutton>
 */

/**
 * @syntax yielded
 * <lyte-radiobutton lt-prop-value="1" lt-prop-name="group-1" lt-prop-yield="true">
 *     <template is="registerYield" yield-name="yield">
 *         check me
 *     </template>
 * </lyte-radiobutton>
 */

export { LyteRadiobuttonComponent };

