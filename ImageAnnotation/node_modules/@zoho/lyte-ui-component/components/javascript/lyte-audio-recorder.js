import { prop } from "@slyte/core";
import { Component } from "../component.js";

class LyteAudioRecorderComponent extends Component {
    constructor() {
        super();
    }

    data() {
		return {
			ltPropOptions: prop("object", { default: {} }),
			ltPropButton: prop("object", {
				default: {
					multi: { purpose: "record", disable: false },
					cancel: { purpose: "cancel", disable: true, class: 'lyteAudioRecorderDisabled' },
					stop: { purpose: "stop", disable: true, class: 'lyteAudioRecorderDisabled' }
				}
			}),
			ltPropWorkersPath: prop("string"),
			ltPropTimeLimit: prop("number"),
			ltPropCurrentTime: prop("number"),
			ltPropDisplayTime: prop("boolean", { default: false }),
			ltPropDisplayRecord: prop("boolean", { default: true }),


			recording: prop("boolean", { default: false }),
			cancel: prop("boolean", { default: false }),
			currentTime: prop("string", { default: "00:00" }),
			totalTime: prop("string"),
			hourValid: prop("boolean", { default: false }),
			multiKeyObj: prop("string")
		};
	}

    static actions() {
        return {
            controlButtons: function (_this) {
                var button = _this.getAttribute('purpose');
                switch (button) {
                    case 'record': {
                        this.record();
                        break;
                    }
                    case 'pause': {
                        this.pause();
                        break;
                    }
                    case 'resume': {
                        this.resume();
                        break;
                    }
                    case 'cancel': {
                        this.stop(true);
                        break;
                    }
                    case 'stop': {
                        this.stop();
                        break;
                    }
                }
            }
        };
    }

    didConnect() {

		var node = this.$node,
			data = this.data,
			button = data.ltPropButton;
			
		for (var key in button) {
			var purpose = button[key].purpose;
			if(purpose == 'record'){
				if(!data.ltPropDisplayRecord){
					this.$addon.objectUtils(button,"add",key,{purpose: "pause", disable: true, class: 'lyteAudioRecorderDisabled'});
					purpose = 'pause';
				}
				this.setData('multiKeyObj',key);
			}
			this.setClass(key, purpose);
		}

		if (data.ltPropDisplayTime) {
			var limit = data.ltPropTimeLimit;
			if (limit) {
				var limitVal = this.getFormTime(limit);
				this.setData("totalTime", limitVal);
				if (limitVal.length > 6) {
					this.setData("hourValid", true);
					this.setData("currentTime", "00:00:00");
				}
			}
		}

		node.record = function () {
			new Promise((res)=>{
				this.res=res;
			}).then(()=>{
				this.res = undefined;
				this.record();
			})
			node.cancel();
		}.bind(this)

		node.pause = function () {
			this.pause();
		}.bind(this)

		node.resume = function () {
			this.resume();
		}.bind(this)

		node.cancel = function () {
			this.stop(true);
		}.bind(this)

		node.stop = function () {
			this.stop();
		}.bind(this)
	}

    record() {
		var _this = this,
			data = _this.data,
			callbackCount = 0,
			curDur = 0,
			hourValid = data.hourValid,
			dispRecord = data.ltPropDisplayRecord;
		if (data.ltPropWorkersPath) {
			if (this.callBacks("onBeforeRecord") == false) {
				return;
			}
			$L.media.record({
				workletBasePath: data.ltPropWorkersPath,
				workerBasePath: data.ltPropWorkersPath,
				onStop: function (blob, buffer) {
					window._lyteUiUtils.generateThumb({
						stop: true
					});
					var options = data.ltPropOptions,
						setVal = dispRecord ? 'record' : 'pause';
					if (_this.getMethods("onStop")) {
						if (data.cancel) {
							_this.setData('cancel', false);
							_this.callBacks("onCancel");
						} else {
							_this.executeMethod("onStop", blob, buffer, _this.$node);
						}
					}
					_this.$node.querySelector(".lyteRecordingCanvas").getContext("2d").clearRect(0, 0, options.width || 350, options.height || 100);
					_this.setData('recording', false);
					_this.setData('currentTime', "00:00");
					_this.setDisable(true);
					$L(_this.$node).removeClass("lyteAudioRecording");
					$L(_this.$node).removeClass("lyteAudioPause");
					if(!_this.addRemoveClass('pause',setVal)){
						_this.addRemoveClass('resume',setVal)
					}
					_this.res && _this.res();
				},
				onProgress: function (buffer) {
					callbackCount++;
					curDur = Math.floor(callbackCount / 344);
					if (curDur != undefined && data.ltPropCurrentTime != curDur) {
						_this.setData("ltPropCurrentTime", curDur);
						if (data.ltPropDisplayTime) {
							_this.setData("currentTime", _this.getFormTime(curDur, hourValid));
						}
					}
					if (data.ltPropTimeLimit != undefined && curDur >= data.ltPropTimeLimit) {
						_this.stop();
						return;
					}
					window._lyteUiUtils.generateThumb($L.extend({
						canvas: _this.$node.querySelector(".lyteRecordingCanvas"),
						buffer: buffer,
						type: "bar",
						recording: true,
						width: 350,
						height: 100,
						margin: 2,
						defaultHeight: 2,
						fillStyle: "#8AC0F2"
					}, data.ltPropOptions));
				}
			});
			$L(this.$node).addClass("lyteAudioRecording");
			this.setData('recording', true);
			this.setDisable(false);
			dispRecord && this.addRemoveClass('record','pause');
			this.callBacks("onRecord");
		}
	}

    stop(cancel) {//format time
		if (this.data.recording) {
			var callBack = cancel ? "Cancel" : "Stop";
			if (this.callBacks("onBefore" + callBack) == false) {
				return;
			}
			cancel && this.setData('cancel', true);
			$L.media.stop()
		}else{
			this.res && this.res();
		}
	}

    resume() {
		if (this.data.recording) {
			if (this.callBacks("onBeforeResume") == false) {
				return;
			}
			$L.media.resume();
			this.addRemoveClass("resume", "pause", "lyteAudioPause", "lyteAudioRecording");
			this.callBacks("onBeforeResume")
		}
	}

    pause() {
		if (this.data.recording) {
			if (this.callBacks("onBeforePause") == false) {
				return;
			}
			$L.media.pause();
			this.addRemoveClass("pause", "resume", "lyteAudioRecording", "lyteAudioPause");
			this.callBacks("onBeforePause")
		}
	}

    retForm(num) {
		return num.toString().length == 1 ? "0" + num : num
	}

    getFormTime(time, overRide) {
		var retTime = "",
			min = Math.floor(time / 60),
			hour = Math.floor(time / 3600);
		if (hour || overRide) {
			retTime += (this.retForm(hour) + ":")
		}
		retTime += (this.retForm(min - (hour * 60)) + ":");
		retTime += this.retForm(time - (min * 60));
		return retTime;
	}

    setDisable(value) {
		var button = this.data.ltPropButton;
		for (var object in button) {
			var objValue = button[object],
				__class = value ? objValue.class+' lyteAudioRecorderDisabled' : objValue.class.replace(' lyteAudioRecorderDisabled','');
			if(objValue.purpose == 'record'){
				continue;
			}
			this.$addon.objectUtils(objValue, "add", "disable", value)
			this.$addon.objectUtils(objValue, "add", "class", __class)
		}
	}

    setClass(key, value) {
		var buttons = this.data.ltPropButton,
			camelValue = value[0].toUpperCase() + value.slice(1),
			__class = "lyteAudioRecorder" + camelValue + "Button",
			buttonVal = buttons[key],
			disClass = buttonVal.class && buttonVal.class.includes('lyteAudioRecorderDisabled') ? ' lyteAudioRecorderDisabled' : '';
		this.$addon.objectUtils(buttonVal, "add", "class", __class + disClass);
		this.$addon.objectUtils(buttonVal, "add", "title", camelValue);
	}

    addRemoveClass(cur, to, addClass, remClass) {
		var node= this.$node,
		curButton = node.querySelector('[purpose=' + cur + ']')
		addClass && $L(node).removeClass(addClass);
		remClass && $L(node).addClass(remClass);
		if (curButton) {
			curButton.setAttribute("purpose", to);
			this.setClass(this.data.multiKeyObj, to);
			return true;
		}
	}

    callBacks(name) {
		if (this.getMethods(name)) {
			return this.executeMethod(name, this.$node)
		}
	}
}

export { LyteAudioRecorderComponent };
