import { prop } from "@slyte/core";
import { Component } from "../component.js";

/**
 * Renders a grouper
 * @component lyte-grouper
 * @version 3.1.0
 */
class LyteGrouperComponent extends Component {
    constructor() {
        super();
    }

    data() {
		return {
			/** 
			 * @componentProperty {Horizontal | Vertical} ltPropAlignment=Horizontal
			 * @default Horizontal
			 */
			ltPropAlignment : prop("string", {"default" : "Horizontal"}),
			/** 
			 * @componentProperty {line | fill} ltPropAppearance=line
			 */
			ltPropAppearance : prop("string",{"default" : "line"}),
			/** 
			 * @componentProperty {string} ltPropWidth=auto
			 */
			ltPropWidth : prop("string",{"default" : "auto"}),
			// /** 
			//  * @componentProperty {array} ltPropSelectedClass
			//  */
			ltPropSelectedClass : prop("array",{"default" : []}),

			currentClass : prop("string",{"default" : ""}),
			isFocused: prop("boolean", {"default": false})
		};		
	}

    didConnect() {
		this._container = this.$node.querySelector("lyte-yield");
		this.addClassForElementInsideYield();
	}

    didDestroy() {
		delete this._container;
	}

    getContainer() {
		return this._container;
	}

    addClassToElement(element, className) {
		element.classList.add(className);
	}

    getChildrenInsideYield() {
		var container =  this.getContainer();
		return container.children;
	}

    addClassForElementInsideYield() {
		var children = this.getChildrenInsideYield();
		var className = "lyteGrouperItem";
		for(var index=0; index<children.length; index++) {
			this.addClassToElement(children[index], className);
		}
	}

    static actions() {
        return {
            grouperFocusIn : function() {
                this.setData("isFocused", true);
            },
            grouperFocusOut : function() {
                this.setData("isFocused", false);
            }
        };
    }
}
/* unwanted code 
document.addEventListener("click",function(event){
	var groupers = document.querySelectorAll("lyte-grouper"),target = event.target;
	groupers.forEach(function(node){
		var comp = node.component,
		container = comp.getContainer();
		if(container){
			if(!container.contains(target) && comp.data.currentClass){
				comp.removeOldClass(container);
			}
		}
	});
},true);

actions:{
		onclick : function(event){
			var container = this.getContainer();
			// this.removeOldClass(container);
			// this.addNewClass(event.target);
		}
	},
	classChange : function(changes){
		var oldClasses = changes.oldValue, indexOfOldClass, currentClassClass = this.data.currentClass,newClass,
		container = this.getContainer(); 
		indexOfOldClass = oldClasses.indexOf(currentClassClass);
		if(indexOfOldClass > -1){
			newClass =  this.getClass(indexOfOldClass);
			this.removeOldClass(container);
			if(newClass){
				container.classList.add(newClass);
				this.storeCurrentClassAsOld(newClass);
			}
		}
	}.observes("ltPropSelectedClass")
getClass : function(index){
		var selectedClass = this.data.ltPropSelectedClass;
		return selectedClass[index]? selectedClass[index] : selectedClass[0];
	},
		removeOldClass : function(container){
		var currentClass = this.data.currentClass;
		if(currentClass){
			container.classList.remove(currentClass);
			this.storeCurrentClassAsOld("");
		}
	},
	addNewClass : function(target){
		var container = this.getContainer(),
		children = container.children;
		for(var index=0;index<children.length;index++){
			var child  =  children[index],newClass;
			if(child.contains(target)){
				newClass = this.getClass( index );
				if(newClass){
					container.classList.add(newClass);
					this.storeCurrentClassAsOld(newClass);
				}
				break;
			} 
		}
	},
	storeCurrentClassAsOld : function(className){
		this.setData("currentClass",className);
	},
*/

export { LyteGrouperComponent };