import { prop } from "@slyte/core";
import { Component } from "../../component.js";
import $L from "@zoho/lyte-dom";

/**
 * Renders an avatar navigator
 * @component lyte-avatar-navigator
 * @version 3.6.0
 * @methods onSelect, onPrevious, onNext
 */
/**
 * @customElement lyte-avatar-navigator-item
 */


class LyteAvatarNavigatorComponent extends Component {
    constructor() {
        super();
    }

    data() {
		return {
			/**
			 * @componentProperty {array} ltPropImages
			 * @default []
			 */

			"ltPropImages": prop( 'array', { 'default': [] } ),

			/**
			 * @componentProperty {string} ltPropUrlValue
			 * @default image
			 */

			"ltPropUrlValue": prop( 'string', { 'default': 'image' } ),

			/**
			 * @componentProperty {boolean} ltPropAvatarYield
			 * @default false
			 */

			"ltPropAvatarYield": prop( 'boolean', { 'default': false } ),

			/**
			 * @componentProperty {boolean} ltPropIconYield
			 * @default false
			 */

			"ltPropIconYield": prop( 'boolean', { 'default': false } ),

			/**
			 * @componentProperty {string} ltPropImageWidth=0px
			 */

			"ltPropImageWidth": prop( 'string', { 'default': '0px' } ),

			/**
			 * @componentProperty {string} ltPropSystemValue=value
			 */

			"ltPropSystemValue": prop( 'string', { 'default': 'value' } ),

			/**
			 * @componentProperty {object} ltPropSelected={}
			 */


			"ltPropSelected": prop( 'object', { 'default': {} } ),

			/**
			 * @componentProperty {string} ltPropSelectedClass
			 * @default lyteAvatarSelectedItem
			 */

			"ltPropSelectedClass": prop( 'string', { 'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-avatar-navigator', 'selectedClass', 'lyteAvatarSelectedItem' ) } ),

			/**
			 * @componentProperty {string} ltPropPreviousIconClass
			 * @default lyteAvatarPrevIcon
			 */

			"ltPropPreviousIconClass": prop( 'string', { 'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-avatar-navigator', 'previousIconClass', 'lyteAvatarPrevIcon' ) } ),

			/**
			 * @componentProperty {string} ltPropNextIconClass
			 * @default lyteAvatarNextIcon
			 */

			"ltPropNextIconClass": prop( 'string', { 'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-avatar-navigator', 'nextIconClass', 'lyteAvatarNextIcon' ) } ),

			/**
			 * @componentProperty {string} ltPropAltValue
			 */

			"ltPropAltValue": prop( 'string', { 'default': '' } ),

			/**
			 * @componentProperty {string} ltPropAlt
			 */

			"ltPropAlt": prop( 'string', { 'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-avatar-navigator', 'alt', '' ) } ),

			/**
			 * @componentProperty {boolean} ltPropIconYield
			 * @default false
			 */


			"ltPropCyclic": prop( 'boolean', { 'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-avatar-navigator', 'cyclic', true ) } ),

			/**
			 * @componentProperty {array} ltPropImages
			 * @default []
			 */

			"ltPropDisabledList": prop( 'array', { 'default': [] } ),

			/**
			 * @componentProperty {string} ltPropTooltipValue
			 */

			"ltPropTooltipValue": prop( 'string', { 'default': '' } ),

			/**
			 * @typedef {object} tooltip
			 * @property {top|left|bottom|right} position=bottom
			 * @property {box|callout} appearance=box
			 * @property {number} margin=5
			 * @property {boolean} keeptooltip=true
			 */
			/**
			 * @componentProperty {tooltip} ltPropTooltip
			 */
			
			"ltPropTooltip": prop( 'object', { 'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-avatar-navigator', 'tooltip', 
				{ 
   					'position': 'bottom', 
   					'appearance': 'box',
   					'margin': 5,
   					'keeptooltip': true 
   				} )  
   			} ),
				/**
				 * @componentProperty {boolean} ltPropPreload=false
				 */
   			"ltPropPreload": prop( 'boolean', { 'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-avatar-navigator', 'preload', false ) } ),

   			/**
			 * @componentProperty {string} ltPropAriaLabelValue
			 */

   			"ltPropAriaLabelValue": prop( 'string', { 'default': '' } ),


			"blocks": prop( 'array', { 'default': [] } ),
			"imagesPerBlock": prop( 'number', { 'default': 0 } ),
			"displayIndex": prop( 'number' ),
			"imageHeight": prop( 'string', { 'default': '0' } ),
			"isAnimating": prop( 'boolean', { 'default': false } ),
			"rangeSet": prop( 'array', { 'default': [] } ),
			"showLeftArrow": prop( 'boolean', { 'default': true } ),
			"showRightArrow": prop( 'boolean', { 'default': true } )
		};
	}

    updateTabIndex() {
		var imageItems = $L( 'lyte-avatar-navigator-item', this.$node ),
		displayIndex = this.getData( 'displayIndex' ),
		imagesPerBlock = this.getData( 'imagesPerBlock' ),
		endIndex = displayIndex + imagesPerBlock - 1;

		imageItems.attr( 'tabindex', '-1' );
		imageItems.attr( 'aria-hidden', 'true' );

		imageItems.each( function( index, item ) {
			if( item._imageIndex >= displayIndex && item._imageIndex <= endIndex ) {
				item.setAttribute( 'tabindex', '0' );
				item.removeAttribute( 'aria-hidden' );
			}
		} );
	}

    isRTL() {
		return window._lyteUiUtils.getRTL();
	}

    didDestroy() {
		delete this.prevCurBlock;
		clearTimeout( this._tabIndexTimeoutId );
	}

    getImageWidth() {
		var imageWidth = this.getData( 'ltPropImageWidth' );

		return window.parseFloat( imageWidth || 0 );
	}

    init() {
        var lyteSelf = this;
        var that = this;

        this.$node.reset = function() {
			var displayIndex, block, imagesPerBlock, images = that.getData( 'ltPropImages' );

			that.animationQueue = [];
			that.setData( 'blocks', [] );
			that.setData( 'rangeSet', [] );
			that.deleteOtherBlocks = false;
			that.curCount = that.totalCount = 0;
			that.setData( 'isAnimating', false );
			that.preventObs = false;
			delete that.prevCurBlock;

			that.setImageDimensions();
			that.setImagesPerBlock();
			displayIndex = that.getData( 'displayIndex' );
			imagesPerBlock = that.getData( 'imagesPerBlock' )

			if( displayIndex + imagesPerBlock > images.length ) {
				displayIndex = images.length - imagesPerBlock;

				if( displayIndex < 0 ) {
					displayIndex = 0;
				}

				that.setData( 'displayIndex', displayIndex );
			}

			that.setContainerWidth();
			block = that.buildImageBlock( displayIndex );
			lyteSelf.$addon.objectUtils( block, 'add', 'translate', 0 );
			that.preloadImages();
		}
    }

    didConnect() {
		this.animationQueue = [];
		this.setup();
		this.setSelectedIndex();
	}

    setup() {
		var displayIndex, block;

		if( !this.isEmpty() ) {
			this.setImageDataType();
			this.setImageDimensions();
			this.setImagesPerBlock();
			displayIndex = this.setDisplayIndex();
			this.setContainerWidth();
			block = this.buildImageBlock( displayIndex );
			this.$addon.objectUtils( block, 'add', 'translate', 0 );
			this.preloadImages();
		}
	}

    toggleNavigation() {
		var images = this.getData( 'ltPropImages' ),
		imagesPerBlock = this.getData( 'imagesPerBlock' ), shouldEnable,
		cyclic = this.getData( 'ltPropCyclic' ),
		length = images.length,
		displayIndex = this.getData( 'displayIndex' );

		shouldEnable = imagesPerBlock < images.length;

		this.setData( 'showLeftArrow', shouldEnable );
		this.setData( 'showRightArrow', shouldEnable );	

		if( !cyclic && shouldEnable ) {
			if( displayIndex === 0 ) {
				this.setData( 'showLeftArrow', false );
				this.setData( 'showRightArrow', true );
			}
			else if( displayIndex === length - imagesPerBlock ) {
				this.setData( 'showLeftArrow', true );
				this.setData( 'showRightArrow', false );
			}
		}
	}

    isEmpty() {
		var images = this.getData( 'ltPropImages' ) || [];

		return images.length === 0;
	}

    setImageDataType() {
		var images = this.getData( 'ltPropImages' );

		if( typeof images[ 0 ] === 'string' ) {
			this.setData( 'isString', true );
		}
		else {
			this.setData( 'isString', false );
		}
	}

    setImageDimensions() {
		var imageWidth = this.getImageWidth(), item;

		this.setDummyImage();
		item = this.$node.querySelector( 'lyte-avatar-navigator-item' );

		if( imageWidth === 0 ) {
			this.setData( 'ltPropImageWidth', $L( item ).outerWidth( true ) + 'px' );
		}
		
		this.setData( 'imageHeight', $L( item ).outerHeight( true ) + 'px' );
		this.removeDummyImage();
	}

    setDummyImage() {
		var images = this.getData( 'ltPropImages' ),
		image = images[ 0 ];

		this.setData( 'dummyImage', image );
		this.setData( 'renderDummyImage', true );
	}

    removeDummyImage() {
		this.setData( 'renderDummyImage', false );
	}

    setImagesPerBlock() {
		var imageWidth = this.getImageWidth(),
		containerWidth = this.getContainerWidth(), count;

		count = Math.floor( containerWidth / imageWidth );

		this.setData( 'imagesPerBlock', count );
	}

    getContainerWidth() {
		var container;

		container = this.getContainer();
		container.style.flex = '1';
		var width = container.getBoundingClientRect().width;
		container.style.flex = 'none';

		return window.parseFloat( width );
	}

    getContainer() {
		return this.$node.querySelector( '.lyteAvatarSetCont' );
	}

    setContainerWidth() {
		var count = this.getData( 'imagesPerBlock' ),
		imageWidth = this.getImageWidth(),
		container = this.getContainer(),
		roundedWidth;

		roundedWidth = count * imageWidth;
		this.setData( 'ltPropContainerWidth', roundedWidth + 'px' );
		container.style.width = roundedWidth + 'px';
	}

    buildImageBlock(index) {
		if( !this.doesBlockExist( index ) ) {
			return this.createblock( index );
		}
		else {
			return this.getBlock( index );
		}
	}

    doesBlockExist(index) {
		return !!this.getBlock( index );
	}

    getBlock(index) {
		var blocks = this.getData( 'blocks' );

		index = !isNaN( index ) ? index : this.getData( 'displayIndex' );

		for( var i = 0; i < blocks.length; i++ ) {
			if( this.indexInBlock( blocks[ i ], index ) ) {
				return blocks[ i ];
			}
		}
	}

    createblock(index, isDisconnected, endIndex) {
		var images = this.getData( 'ltPropImages' ), rangeInfo, block = {}, arr = [], ret;

		index = !isNaN( index ) ? index : this.getData( 'displayIndex' )

		rangeInfo = this.getRange( index );
		block.startIndex = rangeInfo.startIndex;
		block.endIndex = !isNaN( endIndex ) ? endIndex :rangeInfo.endIndex

		while( index <= block.endIndex ) {
			ret = this.buildImageObject( images[ index ], index );
			arr.push( ret );
			index++;
		}

		block.images = arr;
		block.endIndex = index - 1;
		// block.translate = 0;
		block.class = 'lyteAvatarSet';

		if( !isDisconnected ) {
			this.addNodeToCircularList( block );
		}

		this.insertAtRightPosition( block );

		return block;
	}

    getRange(start) {
		var end;

		end = this.getEndIndex( start );

		return {
			startIndex: start,
			endIndex: end
		}
	}

    collapseSet() {
		var rangeSet = this.getData( 'rangeSet' );

		for( var i = 0; i < rangeSet.length; i++ ) {
			if( rangeSet[ i + 1 ] && rangeSet[ i ][ 1 ] + 1 === rangeSet[ i + 1 ][ 0 ] ) {
				rangeSet[ i ][ 1 ] = rangeSet[ i + 1 ][ 1 ];
				rangeSet.splice( i + 1, 1 );
				i--;
			}
		}
	}

    createDisconnectedBlock(index) {
		return this.createblock( index, true );
	}

    buildImageObject(image, index) {
		var isString = this.getData( 'isString' ),
		urlValue = this.getData( 'ltPropUrlValue' ),
		systemValue = this.getData( 'ltPropSystemValue' ),
		alt = this.getData( 'ltPropAlt' ),
		ariaLabelValue = this.getData( 'ltPropAriaLabelValue' ),
		tooltipValue = this.getData( 'ltPropTooltipValue' ),
		obj = {};

		if( isString ) {
			obj[ urlValue ] = image;
			obj[ systemValue ] = image;
			obj[ this.getAltValue() ] = alt || '';
			obj.id = image;
		}
		else {
			obj[ urlValue ] = image[ urlValue ];
			obj[ systemValue ] = image[ systemValue ];
			obj[ this.getAltValue() ] = this.getData( 'altValue' ) ? image[ this.getData( 'altValue' ) ] : ( alt || '' );
			obj.id = image[ systemValue ];
		}

		if( ariaLabelValue ) {
			obj[ ariaLabelValue ] = image[ ariaLabelValue ];
		}

		obj.disabled = this.isDisabled( image );
		obj._originalObj = image;
		obj.isSelected = obj[ systemValue ] === this.getSelectedValue();
		obj._imageIndex = index;

		if( tooltipValue ) {
			obj[ tooltipValue ] = image[ tooltipValue ];
		}

		return obj;
	}

    isDisabled(image) {
		var systemValue = this.getData( 'ltPropSystemValue' ),
		disabledList = this.getData( 'ltPropDisabledList' );

		for( var i = 0; i < disabledList.length; i++ ) {
			if( image[ systemValue ] === disabledList[ i ][ systemValue ] ) {
				return true;
			}
		}

		return false;
	}

    getAltValue() {
		var altValue = this.getData( 'ltPropAltValue' );

		return altValue || 'alt';
	}

    getSelectedValue() {
		var selected = this.getData( 'ltPropSelected' ),
		systemValue = this.getData( 'ltPropSystemValue' );

		if( selected ) {
			return selected[ systemValue ];
		}

		return '';
	}

    addNodeToCircularList(block) {
		var index, images = this.getData( 'ltPropImages' );

		index = block.startIndex - 1;

		if( index < 0 ) {
			index = images.length - 1;
		}

		var previous = this.getBlock( index );

		index = block.endIndex + 1;

		if( index >= images.length ) {
			index = 0;
		}

		var next = this.getBlock( index );

		if( previous ) {
			previous.next = block;
			block.previous = previous;
		}

		if( next ) {
			next.previous = block;
			block.next = next;
		}
	}

    insertAtRightPosition(block) {
		var blocks = this.getData( 'blocks' ) || [],
		i = 0;

		while( i < blocks.length && block.startIndex > blocks[ i ].startIndex ) {
			i++;
		}

		this.$addon.arrayUtils( this.getData( 'blocks' ), 'insertAt', i, block );
	}

    setDisplayIndex() {
		var sel = this.getData( 'ltPropSelected' ),
		images = this.getData( 'ltPropImages' ),
		systemValue = this.getData( 'ltPropSystemValue' ),
		imagesPerBlock = this.getData( 'imagesPerBlock' ),
		index;

		if( $L.isEmptyObject( sel ) ) {
			this.setData( 'displayIndex', 0 );

			return 0;
		}

		if( images.length <= imagesPerBlock ) {
			this.setData( 'displayIndex', 0 );

			return 0;
		}

		for( var i = 0; i < images.length; i++ ) {
			if( images[ i ][ systemValue ] === sel[ systemValue ] ) {
				break;
			}
		}

		index = i - Math.floor( imagesPerBlock / 2 );

		if( index < 0 ) {
			index = 0;
		}
		else if( index + imagesPerBlock > images.length ) {
			index = images.length - imagesPerBlock;
		}

		this.setData( 'displayIndex', index );

		return index;
	}

    // getSelectedNavItem: function( block ) { // this func is not used
    // 	var sel = this.getData( 'ltPropSelected' ),
    // 	systemValue = this.getData( 'ltPropSystemValue' ), node, id, that = this;

    // 	if( $L.isEmptyObject( sel ) ) {
    // 		return ;
    // 	}

    // 	for( var i = 0; i < block.length; i++ ) {
    // 		if( block[ i ][ systemValue ] === sel[ systemValue ] ) {
    // 			break;
    // 		}
    // 	}

    // 	if( !block[ i ] ) {
    // 		return ;
    // 	}

    // 	id = block[ i ].id;
    // 	node = $L( '[data-image-id="' + id + '"]' ).filter( function( index, item ) {
    // 		return item !== that.selectedNavItem;
    // 	} ).get( 0 );

    // 	return node;
    // },

    getPreviousIndex(index) {
		var displayIndex = !isNaN( index ) ? index : this.getData( 'displayIndex' ),
		imagesPerBlock = this.getData( 'imagesPerBlock' ),
		images = this.getData( 'ltPropImages' ),
		res;

		if( displayIndex === 0 ) {
			res = images.length - imagesPerBlock;
		}
		else if( displayIndex - imagesPerBlock < 0 ) {
			res = 0;
		}
		else {
			res = displayIndex - imagesPerBlock;
		}

		// This is just a safety check. If imagesPerBlock > images.length and currentDisplayIndex = 0. It can become negative.
		if( res < 0 ) {
			res = 0;
		}

		return res;
	}

    getNextIndex(index) {
		var displayIndex = !isNaN( index ) ? index : this.getData( 'displayIndex' ),
		imagesPerBlock = this.getData( 'imagesPerBlock' ),
		res, images = this.getData( 'ltPropImages' );

		if( displayIndex + imagesPerBlock === images.length ) {
			res = 0;
		}
		else if( displayIndex + ( 2 * imagesPerBlock ) >= images.length ) {
			res = images.length - imagesPerBlock;
		}
		else {
			res = displayIndex + imagesPerBlock;
		}

		return res;
	}

    getOutBlocks(indexOfFirstOutBlock, next, direction, previous) {
		var block = this.getBlock( indexOfFirstOutBlock ), res = [], imagesPerBlock = this.getData( 'imagesPerBlock' );

		if( this.isLongMove( direction, next, previous ) ) {
			res.push( block );

			while( ( direction === 'previous' && block.startIndex > previous ) || ( direction === 'next' && 
				block.endIndex < ( previous + imagesPerBlock - 1 )
				&& block.endIndex !== this.getData( 'ltPropImages' ).length - 1
			) ) {
				res.push( block = block[ direction ] );
			}
		}
		else {
			if( this.isBlockMovingOutAndInSimultaneously( previous, next, direction ) ) {
				// remove all blocks
				res = this.getAllBlocks( direction );
				
				return res;
			}
			else {
				while( block && !this.indexInBlock( block, next ) ) {
					res.push( block );
					block = block[ direction ];
				}
			}
		}

		return res;
		
	}

    getAllBlocks(direction) {
		var blocks = this.getData( 'blocks' ),
		asc = direction === 'previous' ? 1 : -1, res;

		res = blocks.slice( 0 );

		res.sort( function( blockA, blockB ) {
			return blockA.startIndex < blockB.startIndex ? asc : ( asc * -1 );
		} );

		return res;
	}

    isBlockMovingOutAndInSimultaneously(previous, next, direction) {
		var imagesPerBlock = this.getData( 'imagesPerBlock' );

		if( this.isMovingAcrossBoundary( next, direction ) ) {
			// think about 5 images with block count of 3 and displayIndex is 2 and next is clicked - displayIndex 2 moves out and back in
			return ( next >= previous && next < previous + imagesPerBlock ) || ( previous >= next && previous < next + imagesPerBlock );
		}
	}

    findInBlock(previous, next, direction, block) { // used to find the inBlocks for preload
		var block = block ?block :this.getBlock( previous ),
		res = [], imagesPerBlock = this.getData( 'imagesPerBlock' );

		if( this.isLongMove( direction, next, previous ) ) {
			return [];
		}
		else {
			if(this.isBlockMovingOutAndInSimultaneously( previous, next, direction ) ) {
				res.push(block[direction]);
			}
			else{
				if( this.indexInBlock( block, next ) ) {
					res.push( block );
				}
				else{
					res.push( block[direction] );
					block = block[direction];
				}
		
				while( ( ( next + imagesPerBlock - 1 ) - block.endIndex ) > 0 ) {
					block = this.getNextBlock( block, 'next' );
					res.push( block );
				}
			}
		}
		
		return res;
	}

    getInBlocks(previous, next, direction) {
		var block = this.getBlock( previous ),
		res = [], remaining, imagesPerBlock = this.getData( 'imagesPerBlock' ),
		fnName = direction === 'next' ? 'getNextBlock': 'getPreviousBlock';

		// When long moving, a block can already be present so it doesn't have to be created. But what this does is leave some space because the next might be in the middle of the created block
		if( this.isLongMove( direction, next, previous ) ) {
			res.push( block = this.buildImageBlock( next ) );

			while( ( remaining = ( next + imagesPerBlock - 1 ) - block.endIndex ) > 0 ) {
				block = this.getNextBlock( block, 'next' );
				res.push( block );
			}
		}
		else {
			if( this.isBlockMovingOutAndInSimultaneously( previous, next, direction ) ) {
				// delete all the other blocks and keep this newly created block
				this.deleteOtherBlocks = true;
				this.setData( 'rangeSet', [] );
				res.push( this.createDisconnectedBlock( next ) );
			}
			else {
				while( !this.indexInBlock( block, next ) ) {
					block = this[ fnName ]( block, direction );
				}

				res.push( block );

				while( ( remaining = ( next + imagesPerBlock - 1 ) - block.endIndex ) > 0 ) {
					block = this.getNextBlock( block, 'next' );
					res.push( block );
				}
			}
		}

		return res;
		
	}

    isLongMove(direction, next, previous) {
		var imagesPerBlock = this.getData( 'imagesPerBlock' );

		return ( direction === 'next' && next > previous + imagesPerBlock ) || ( direction === 'previous' &&  next < previous - imagesPerBlock )
	}

    isMovingToFirstIndex(next) {
		return next === 0;
	}

    isMovingToLastIndex(next) {
		var imagesPerBlock = this.getData( 'imagesPerBlock' ),
		length = this.getData( 'ltPropImages' ).length;

		return next === length - imagesPerBlock;
	}

    getNextBlock(block, direction) {
		var imagesPerBlock = this.getData( 'imagesPerBlock' ),
		length = this.getData( 'ltPropImages' ).length,
		startIndex;

		if( block[ direction ] ) {
			return block[ direction ];
		}

		if( block.endIndex + 1 >= length ) {
			startIndex = 0;
		}
		else {
			startIndex = block.endIndex + 1;
		}

		return this.buildImageBlock( startIndex );
	}

    getPreviousBlock(block, direction) {
		var imagesPerBlock = this.getData( 'imagesPerBlock' ), length = this.getData( 'ltPropImages' ).length,
		start, res;

		if( block[ direction ] ) {
			return block[ direction ];
		}

		start = this.getStartIndex( block.startIndex - 1 ); 

		return this.buildImageBlock( start );
	}

    getStartIndex(end) {
		var start, imagesPerBlock = this.getData( 'imagesPerBlock' ),
		rangeSet = this.getData( 'rangeSet' ), length = this.getData( 'ltPropImages' ).length;

		if( end === -1 ) {
			end = length - 1;
		}

		// TODO: check if previous block can start at 0 and the current calculated start can also be 0
		start = end + 1 - imagesPerBlock;

		if( start < 0 ) {
			start = 0;
		}

		for( var i = 0; i < rangeSet.length; i++ ) {
			if( end > rangeSet[ i ][ 1 ] && start <= rangeSet[ i ][ 1 ] ) {
				start = rangeSet[ i ][ 1 ] + 1;
				break;
			}
		}

		return start;
	}

    getEndIndex(start) {
		var rangeSet = this.getData( 'rangeSet' ), 
		length = this.getData( 'ltPropImages' ).length,
		end, imagesPerBlock = this.getData( 'imagesPerBlock' );

		end = start + imagesPerBlock - 1;

		if( end >= length ) {
			end = length - 1;
		}

		for( var i = 0; i < rangeSet.length; i++ ) {
			if( start < rangeSet[ i ][ 0 ] && end >= rangeSet[ i ][ 0 ] ) {
				end = rangeSet[ i ][ 0 ] - 1;
				break;
			}
		}

		rangeSet.splice( i, 0, [ start, end ] );
		this.collapseSet();

		return end;
	}

    indexInBlock(block, index) {
		return block.startIndex <= index && block.endIndex >= index;
	}

    slideOut(previous, next, blocks, direction) {
		var imagesPerBlock = this.getData( 'imagesPerBlock' ),
		imageWidth = this.getImageWidth(),
		isRTL = this.isRTL(),
		that = this, imagesToMove, offset;

		blocks.forEach( function( block ) {
			that.addAnimationClass( block );

			if( that.isMovingAcrossBoundary( next, direction ) ) {
				imagesToMove = imagesPerBlock ;
			}
			else if( that.isLongMove( direction, next, previous ) ) {
				if( direction === 'previous' && isNaN( imagesToMove ) ) {
					offset = previous - blocks[ 0 ].startIndex;
					imagesToMove = imagesPerBlock + ( offset > 0 ? offset : 0 );
				}
				else if( direction === 'next' && isNaN( imagesToMove ) ) { 
					offset = blocks[ blocks.length - 1 ].endIndex - ( previous + imagesPerBlock - 1 );
					imagesToMove = imagesPerBlock + ( offset > 0 ? offset : 0 );
				}
			}
			else {
				imagesToMove = Math.abs( previous - next );
			}

			imagesToMove = imagesToMove * ( isRTL ? -1 : 1 ) * ( direction === 'previous' ? 1 : -1 );

			that.queueAnimates( block, block.translate + ( imagesToMove * imageWidth ) );			
		} );
	}

    slideIn(next, blocks, lastBlock, direction) {
		var translateValue, imageWidth = this.getImageWidth(),
		that = this, isRTL = this.isRTL();

		blocks.forEach( function( block ) {
			if( lastBlock ) {
				that.positionBlockForAnimation( block, lastBlock, direction );
			}
			
			lastBlock = block;
			that.addAnimationClass( block );
			translateValue = ( block.startIndex - next ) * imageWidth;
			translateValue = translateValue * ( isRTL ? -1 : 1 ); 
			that.queueAnimates( block, translateValue );
		} );

		this.fireAnimations();
	}

    positionBlockForAnimation(blockToBePositioned, previousBlock, dir) {
		var isRTL = this.isRTL(),
		imageWidth = this.getImageWidth(),
		translateValue = previousBlock.translate + ( isRTL && dir === 'next' ? -( this.getBlockLength( previousBlock ) * imageWidth ) : 0 ) ,
		blockLength = this.getBlockLength( ( dir === 'previous' ) ? blockToBePositioned : previousBlock ),
		multiplier = ( ( dir === 'previous' && !isRTL ) ) ? -1 : 1,
		newValue = translateValue + ( isRTL && dir !== 'previous' ? 0 : ( multiplier * ( blockLength * imageWidth ) ) );

		this.$addon.objectUtils( blockToBePositioned, 'add', 'translate', newValue );
	}

    addAnimationClass(block) {
        var lyteSelf = this;
        var that = this;

        window.requestAnimationFrame( function() {
			var classList = block.class.trim().split( ' ' );

			classList.push( 'lyteAvatarSlideAnim' );
			classList = classList.join( ' ' );

			lyteSelf.$addon.objectUtils( block, 'add', 'class', classList );
			that.setData( 'isAnimating', true );
		} );
    }

    getBlockLength(block) {
		return block.endIndex - block.startIndex + 1;
	}

    removeAnimationClass(block) {
		var classList = block.class.trim().split( ' ' ),
		index = classList.indexOf( 'lyteAvatarSlideAnim' );

		if( !!~index ) {
			classList.splice( index, 1 );
			classList = classList.join( ' ' );
			this.$addon.objectUtils( block, 'add', 'class', classList );
		}

		this.setData( 'isAnimating', false );
	}

    removeCommon(inBlocks, outBlocks) {
		for( var i = 0; i < outBlocks.length; i++ ) {
			if( !!~inBlocks.indexOf( outBlocks[ i ] ) ) {
				outBlocks.splice( i, 1 );
				i--;
			}
		}
	}

    queueAnimates(block, value) {
		this.animationQueue.push( { block: block, value: value } );
	}

    fireAnimations() {
        var lyteSelf = this;
        var that = this;

        window.requestAnimationFrame( function() {
			window.requestAnimationFrame( function() {
				that.animationQueue.forEach( function( animationObj ) {
					lyteSelf.$addon.objectUtils( animationObj.block, 'add', 'translate', animationObj.value );
				} );

				that.animationQueue = [];
			} );
		} );
    }

    removeBlock(block) {
		var blocks = this.getData("blocks");
		this.$addon.arrayUtils(blocks,"removeAt",blocks.indexOf(block),1);
	}

    getEndIndexForPreload(start) {
		var imagesPerBlock = this.getData( 'imagesPerBlock' );
		var end;
		var length = this.getData( 'ltPropImages' ).length,
		end = start + imagesPerBlock - 1;

		if( end >= length ) {
			end = length - 1;
		}
		return end;
	}

    availableBlock(startIndex, endIndex) { // used to find the particular block 
		var increment = startIndex;
		var block;
		var returnValue=false;
		while(increment <= endIndex){
			block = this.getBlock(increment);
			if(!block){
				break;
			}
			if(block.startIndex === startIndex &&  block.endIndex === endIndex){
				returnValue = block;
				break;
			}
			increment++;
		}
		return returnValue;
	}

    checkConditionBeforeRemove(block) { // checking the condition before remove
		var imageWidth = this.getImageWidth(),
		imagesPerBlock = this.getData( 'imagesPerBlock' );
		var max =  imageWidth*(imagesPerBlock);
		var min = -imageWidth*((block.endIndex - block.startIndex)+1);
		if(block.translate  ===  undefined || 
		block.translate >= max || block.translate <= min  ){
			return true;
		}
	}

    getBlockChain(blocks, altblock) { //if the inBlock are [[0,1][2,3]] it returns with [0,3]
		if(!blocks.length){
			blocks = [altblock]
		}
		var startIndex=blocks[0].startIndex,endIndex=blocks[0].endIndex;
		for(var index=1;index<blocks.length;index++){
			var block =  blocks[index];
			if(block.startIndex<startIndex){
				startIndex = block.startIndex;
			}
			if(block.endIndex>endIndex){
				endIndex = block.endIndex;
			}
		}
		return{
			startIndex : startIndex,
			endIndex : endIndex
		}
	}

    getEndIndexForPrevBlock(blockChain, startIndex, endIndex) {
		if(endIndex >= blockChain.startIndex && endIndex <= blockChain.endIndex && startIndex<blockChain.startIndex){
			while(blockChain.startIndex != endIndex){
				--endIndex;
			}
			return --endIndex;
		}
		return endIndex;
	}

    getStartIndexForNextBlock(blockChain, startIndex, endIndex) {
		if(startIndex >= blockChain.startIndex && startIndex <= blockChain.endIndex && blockChain.endIndex<endIndex){
			while(blockChain.endIndex != startIndex){
				++startIndex;
			}
			return ++startIndex;
		}
		return startIndex;
	}

    getInAndOutBlocks(prevCurValue, curValue, direction) {
		var blocks = Array.from(this.getData("blocks"));
		var outBlocks= [], inBlocks;
		var prevCurBlock =  direction?this.prevCurBlock[direction]:this.prevCurBlock;
		inBlocks =  this.findInBlock(prevCurValue,curValue,direction,prevCurBlock);
		for(var index=0;index<blocks.length;index++){
			if(inBlocks.indexOf(blocks[index])<0){
				if(this.checkConditionBeforeRemove(blocks[index],direction)){
					this.removeBlock(blocks[index]);
				}
				else{
					outBlocks.push(blocks[index]);
				}
			}
		}
		return {
			outBlocks : outBlocks,
			inBlocks : inBlocks
		}
	}

    connectParentChildBlocks(parent, child, direction) {
		parent[direction] =  child;
		child.next = parent;
		child.previous =  parent;
	}

    prevBlockisReusable(block, inBlocks, direction) {
		var prevCurBlock = direction?this.prevCurBlock[direction]:this.prevCurBlock;
		if(block && ((inBlocks.indexOf(block) < 0  && (direction === "previous" && this.isCompleteBlock(block.startIndex,block.endIndex)))
		|| (direction === "next" && block === prevCurBlock))){
			return true;
		}
		return false;
	}

    nextBlockisReusable(block, inBlocks, direction) {
		var prevCurBlock = direction?this.prevCurBlock[direction]:this.prevCurBlock;
		if(block && ((inBlocks.indexOf(block) < 0  && (direction === "next" && this.isCompleteBlock(block.startIndex,block.endIndex)))
		|| (direction === "previous" && block === prevCurBlock))){
			return true;
		}
		return false;
	}

    isCompleteBlock(startIndex, endIndex) {
		var imagesPerBlock = this.getData( 'imagesPerBlock' );
		if(endIndex-startIndex === imagesPerBlock-1){
			return true;
		}
		return false;
	}

    setPreviousBlock(startIndex, curblock, inBlocks, direction, blockChain) {
		var endIndex = this.getEndIndexForPreload(startIndex);
		endIndex = this.getEndIndexForPrevBlock(blockChain,startIndex,endIndex);
		var prevBlock = this.availableBlock(startIndex,endIndex);
		if(this.prevBlockisReusable(prevBlock,inBlocks,direction)){
			this.connectParentChildBlocks(curblock,prevBlock,"previous");
		}
		else{
			var tempBlock;
			this.setData("rangeSet",[]);
			tempBlock = this.createblock( startIndex,true,endIndex);
			direction = direction? direction:"previous";
			this.connectParentChildBlocks(curblock,tempBlock,"previous");
		}
	}

    setNextBlock(startIndex, curblock, inBlocks, direction, blockChain) {
		var endIndex = this.getEndIndexForPreload(startIndex);
		startIndex = this.getStartIndexForNextBlock(blockChain,startIndex,endIndex);
		var nextBlock = this.availableBlock(startIndex,endIndex);
		if(this.nextBlockisReusable(nextBlock,inBlocks,direction)){
			this.connectParentChildBlocks(curblock,nextBlock,"next");
		}
		else{
			var tempBlock;
			this.setData("rangeSet",[]);
			tempBlock = this.createblock(startIndex,true,endIndex);
			direction = direction?direction: "next";
			this.connectParentChildBlocks(curblock,tempBlock,"next");
		}
	}

    preloadImages(prevCurValue, direction) {
		var cur = this.getData( 'displayIndex' ),
		preload = this.getData( 'ltPropPreload' ),
		cyclic = this.getData( 'ltPropCyclic' ),
		next = this.getNextIndex( cur ),
		previous = this.getPreviousIndex( cur ),
		length = this.getData( 'ltPropImages' ).length,
		imagesPerBlock = this.getData( 'imagesPerBlock' ), lastBlock;
		if( length < imagesPerBlock || !preload ) {
			return ;
		}
		var outBlocks=[], inBlocks=[];
		var firstBlock, lastBlock;
		if(direction){ // this check for stop calling in didConnect
			var BlockInfo = this.getInAndOutBlocks(prevCurValue,cur,direction);
			if(BlockInfo.inBlocks.length === 0){
				BlockInfo.inBlocks =  [this.createDisconnectedBlock(cur)];
			}
			outBlocks = BlockInfo.outBlocks;
			inBlocks = BlockInfo.inBlocks;
			firstBlock = inBlocks[0];
			lastBlock = inBlocks[inBlocks.length-1];
		}
		else{
			firstBlock = this.getBlock(cur);
			lastBlock = this.getBlock(cur);
		}
		var blockChain = this.getBlockChain(inBlocks,firstBlock);
		if( (cyclic || ( cur !== 0 && !cyclic ) )) {
			this.setPreviousBlock(previous,firstBlock,inBlocks,direction,blockChain);
		}
		if( cyclic || ( cur !== ( length - imagesPerBlock ) && !cyclic ) ) {
			this.setNextBlock(next,lastBlock,inBlocks,direction,blockChain);
		}
		if( direction === 'previous' ) {
			// this.sort( inBlocks );
			inBlocks.reverse();
			this.sort( outBlocks );
		}
		this.prevCurBlock = {previous:firstBlock,next:lastBlock};
		return{
			inBlocks : inBlocks,
			outBlocks:outBlocks
		}
	}

    sort(arr) {
		arr.sort( function( a, b ) {
			if( a.startIndex > b.startIndex ) {
				return 1;
			}
			else if( a.startIndex < b.startIndex ) {
				return -1;
			}
			else {
				return 0;
			}
		} )
	}

    removeSelectedClass() {
		var sel = this.getData( 'ltPropSelectedClass' );
		var previousItems =  $L("."+sel,this.$node);
		if(previousItems.length) {
			for(var index=0;index<previousItems.length;index++){
				previousItems[index].ltProp( 'selectedClass', '' );
			}
		}
	}

    addSelectedClass(navItem) {
		var sel = this.getData( 'ltPropSelectedClass' );

		if( navItem ) {
			var imageId = navItem.getAttribute("data-image-id");
			var selectedItems = $L("[data-image-id='"+imageId+"']",this.$node);
			for(var index=0;index<selectedItems.length;index++){
				selectedItems[index].ltProp( 'selectedClass', sel );
			}
		}
	}

    toggleSelectedClass(oldValue, newValue, preventClassRemove) {

		// TODO: Is this required?
		if( !preventClassRemove ) {
			this.removeSelectedClass();
		}

		this.addSelectedClass( this.getNavItem( newValue ) );
	}

    getNavItem(sel) {
		var systemValue = this.getData( 'ltPropSystemValue' ),
		val = sel[ systemValue ];

		return this.$node.querySelector( '[data-image-id="' + val + '"]' );
	}

    fireOnSelect(event, navItem) {
		var sel = this.getData( 'ltPropSelected' );

		if( this.getMethods( 'onSelect' ) ) {
			this.executeMethod( 'onSelect', event, sel, navItem );
		}
	}

    fireNavigationCallback(event, direction) {
		if( direction === 'previous' ) {
			if( this.getMethods( 'onPrevious' ) ) {
				this.executeMethod( 'onPrevious', event, this, this.isVisible() );
			}
		}
		else {
			if( this.getMethods( 'onNext' ) ) {
				this.executeMethod( 'onNext', event, this, this.isVisible() );
			}
		}
	}

    isVisible() {
		var selIndex = this.selectedIndex,
		displayIndex = this.getData( 'displayIndex' ), 
		imagesPerBlock = this.getData( 'imagesPerBlock' );

		if( !isNaN( selIndex ) ) {
			return selIndex >= displayIndex && selIndex < displayIndex + imagesPerBlock;
		}

		return false;
	}

    isMovingAcrossBoundary(next, direction) {
		return ( direction === 'previous' && this.isMovingToLastIndex( next ) ) || ( direction === 'next' && this.isMovingToFirstIndex( next ) );
	}

    getAnimatingBlocks(next, previous, direction, indexOfFirstOutBlock) {
		var outBlocks, inBlocks;

		outBlocks = this.getOutBlocks( indexOfFirstOutBlock, next, direction, previous );
		inBlocks = this.getInBlocks( previous, next, direction );

		if( direction === 'previous' ) {
			inBlocks.reverse();
			outBlocks.reverse();
		}

		this.removeCommon( inBlocks, outBlocks );

		this.curCount = 0;
		this.totalCount = inBlocks.length + outBlocks.length;

		return {
			outBlocks: outBlocks,
			inBlocks: inBlocks
		}
	}

    animateBlocks(next, previous, inBlocks, outBlocks, direction) {
		var lastBlock = direction === 'previous' ? outBlocks[ 0 ] : outBlocks[ outBlocks.length - 1 ];
		//var preload = this.getData("ltProPreload");

		this.slideIn( next, inBlocks, lastBlock, direction );
		this.slideOut( previous, next, outBlocks, direction );
	}

    setSelectedIndex() {
		var images = this.getData( 'ltPropImages' ) || [],
		sel = this.getData( 'ltPropSelected' ), i;

		if( sel ) {
			for( i = 0; i < images.length; i++ ) {
				if( images[ i ] === sel ) {
					this.selectedIndex = i;
					break;
				}
			}
		}
	}

    moveToSelected(event, next, previous, direction, indexOfFirstOutBlock) {
		var blocksInfo, imagesPerBlock = this.getData( 'imagesPerBlock' );

		if( this.getData( 'ltPropPreload' ) ) {
			blocksInfo = this.preloadImages( previous, direction );
		}
		else{
			blocksInfo = this.getAnimatingBlocks( next, previous, direction, indexOfFirstOutBlock );
		}

		this.animateBlocks( next, previous, blocksInfo.inBlocks, blocksInfo.outBlocks, direction );
		this.fireNavigationCallback( event, direction );
	}

    selectItem(event) {
		var target = event.target,
		navItem = $L( target ).closest( 'lyte-avatar-navigator-item' ).get( 0 ),
		oldValue = this.getData( 'ltPropSelected' ), newValue ;

		if( !navItem ) {
			return ;
		}

		if( navItem.hasAttribute( 'disabled' ) ) {
			return ;
		}

		
		this.preventObs = true;
		this.setData( 'ltPropSelected', newValue = navItem.ltProp( 'image' )._originalObj );
		this.toggleSelectedClass( oldValue, newValue );
		this.preventObs = false;
		this.fireOnSelect( event, navItem );
	}

    navigatePrevious(event) {
		if( this.getData( 'isAnimating' ) ) {
			return ;
		}

		var previous = this.getData( 'displayIndex' ),
		imagesPerBlock = this.getData( 'imagesPerBlock' ), 
		next = this.getPreviousIndex(), blocksInfo, inBlocks, outBlocks, direction = 'previous';

		this.setData( 'displayIndex', next );
		// this.preloadImages(direction);
		if(this.getData("ltPropPreload")){
			blocksInfo = this.preloadImages(previous, direction);
		}
		else{
			blocksInfo = this.getAnimatingBlocks( next, previous, direction, previous + imagesPerBlock - 1 );
		}
		this.animateBlocks( next, previous, blocksInfo.inBlocks, blocksInfo.outBlocks, direction );
		
		this.fireNavigationCallback( event, direction );
	}

    navigateNext(event) {
		if( this.getData( 'isAnimating' ) ) {
			return ;
		}

		var previous = this.getData( 'displayIndex' ), 
		next = this.getNextIndex(), outBlocks, inBlocks, blocksInfo, direction = 'next';

		this.setData( 'displayIndex', next );
		if(this.getData("ltPropPreload")){
			blocksInfo = this.preloadImages(previous, direction);
		}
		else{
			blocksInfo = this.getAnimatingBlocks( next, previous, direction, previous );
		}
		this.animateBlocks( next, previous, blocksInfo.inBlocks, blocksInfo.outBlocks, direction );
		this.fireNavigationCallback( event, direction );
	}

    static actions() {
        return {

            // TODO: Think about merging the two navigates into a single function
            navigatePrevious: function( event ) {
                this.navigatePrevious( event );
            },

            navigateNext: function( event ) {
                this.navigateNext( event );
            },

            navigatePreviousOnKey: function( event ) {
                var keyCode = event.keyCode,
                SPACE_KEY = 32,
                ENTER_KEY = 13;

                if( keyCode === SPACE_KEY || keyCode === ENTER_KEY ) {
                    this.navigatePrevious( event );
                }
            },

            navigateNextOnKey: function( event ) {
                var keyCode = event.keyCode,
                SPACE_KEY = 32,
                ENTER_KEY = 13;

                if( keyCode === SPACE_KEY || keyCode === ENTER_KEY ) {
                    this.navigateNext( event );
                }
            },

            removeClass: function( event, block ) {
                var blocks = this.getData( 'blocks' ), ind;
                var preload = this.getData("ltPropPreload");
                this.removeAnimationClass( block );
                this.curCount++;
                if( !preload && this.deleteOtherBlocks ) {
                    if( this.curCount === this.totalCount ) {
                        this.curCount = this.totalCount = 0;
                        this.deleteOtherBlocks = false;
                        this.$addon.arrayUtils( blocks, 'removeAt', 0, blocks.length - 1 );
                    }
                }
            },

            selectItemOnKey: function( event ) {
                var keyCode = event.keyCode,
                SPACE_KEY = 32,
                ENTER_KEY = 13;

                if( keyCode === SPACE_KEY || keyCode === ENTER_KEY ) {
                    this.selectItem( event );
                }
            },

            selectItem: function( event ) {
                this.selectItem( event );
            }
        };
    }

    static observers() {
        return {
            displayIndexObserver: function() {
                var that = this;
                // wait for blocks to render
                clearTimeout( this._tabIndexTimeoutId );

                this._tabIndexTimeoutId = setTimeout( function() {
                    that.updateTabIndex();
                }, 0 );  

            }.observes( 'displayIndex' ),

            toggleNavigationObserver: function() {
                this.toggleNavigation();
            }.observes( 'displayIndex' ),

            selectedObserver: function( change ) {
                this.setSelectedIndex();

                if( this.preventObs ) {
                    return ;
                }

                var previous = this.getData( 'displayIndex' ),
                images = this.getData( 'ltPropImages' ),
                next = this.setDisplayIndex(),
                imagesPerBlock = this.getData( 'imagesPerBlock' ),
                direction, event = {};

                if( images.length > imagesPerBlock ) {
                    if( previous > next ) {
                        direction = 'previous';
                        this.moveToSelected( event, next, previous, direction, previous + imagesPerBlock - 1 );
                    }
                    else if( previous < next ) {
                        direction = 'next';
                        this.moveToSelected( event, next, previous, direction, previous );
                    }
                }

                this.toggleSelectedClass( change.oldValue, change.newValue );
            }.observes( 'ltPropSelected' ),

            imagesObserver: function() {
                this.animationQueue = [];
                this.setData( 'blocks', [] );
                this.setData( 'rangeSet', [] );
                this.deleteOtherBlocks = false;
                this.curCount = this.totalCount = 0;
                this.setData( 'isAnimating', false );
                this.preventObs = false;
                delete this.prevCurBlock;

                this.setData( 'showLeftArrow', true );
                this.setData( 'showRightArrow', true );
                this.setup();
                this.toggleNavigation();
            }.observes( 'ltPropImages.[]' )
        };
    }
}

/**
 * @syntax nonYielded
 *<lyte-avatar-navigator style="width:300px;height:100px;" lt-prop-images='[{ "name": "https://images.unsplash.com/photo-1530092285049-1c42085fd395?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8Mnx8d2hpdGUlMjBmbG93ZXJ8ZW58MHx8MHx8fDA%3D&w=1000&q=80","value": "white"},{ "name": "https://hips.hearstapps.com/hmg-prod/images/types-of-garden-flowers-purple-allium-1674847068.jpeg","value": "purple"},{ "name": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR6-k5Trb0iy28JGvvI-5tUHs0G_LrFBqoxNA&usqp=CAU","value": "blue"},{ "name": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTAnDgUqPnErS6MQeq_ZdE5qBA6axBNw_Jokg&usqp=CAU","value": "pink"}]' lt-prop-url-value="name" lt-prop-system-value="value" lt-prop-image-width="100px">
 *</lyte-avatar-navigator>
 */

/**
* @syntax 
* @attribute ltPropAvatarYield=true
* @attribute ltPropIconYield=true
* <lyte-avatar-navigator style="width:300px;height:100px;" lt-prop-icon-yield="true" lt-prop-avatar-yield="true" lt-prop-image-width="100px" lt-prop-images='[{ "name": "https://images.unsplash.com/photo-1530092285049-1c42085fd395?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8Mnx8d2hpdGUlMjBmbG93ZXJ8ZW58MHx8MHx8fDA%3D&w=1000&q=80","value": "white"},{ "name": "https://hips.hearstapps.com/hmg-prod/images/types-of-garden-flowers-purple-allium-1674847068.jpeg","value": "purple"},{ "name": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR6-k5Trb0iy28JGvvI-5tUHs0G_LrFBqoxNA&usqp=CAU","value": "blue"},{ "name": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTAnDgUqPnErS6MQeq_ZdE5qBA6axBNw_Jokg&usqp=CAU","value": "pink"}]' lt-prop-url-value="name" lt-prop-system-value="value">
* 	<template is="registerYield" yield-name="previousIconYield">
*  	<i class="leftArrow"></i>
* 	</template>
* 	<template is="registerYield" yield-name="avatarYield">
* 		<lyte-avatar-navigator-item lt-prop-image={{lyteImage}}></lyte-avatar-navigator-item>
*  </template>
* 	<template is="registerYield" yield-name="nextIconYield">
*  	<i class="rightArrow"></i>
*	</template>
* </lyte-avatar-navigator>
*/

/**
 * @syntax 
 * @attribute ltPropAvatarYield=true
 * <lyte-avatar-navigator style="width:300px;height:100px;" lt-prop-avatar-yield="true" lt-prop-image-width="100px" lt-prop-images='[{ "name": "https://images.unsplash.com/photo-1530092285049-1c42085fd395?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8Mnx8d2hpdGUlMjBmbG93ZXJ8ZW58MHx8MHx8fDA%3D&w=1000&q=80","value": "white"},{ "name": "https://hips.hearstapps.com/hmg-prod/images/types-of-garden-flowers-purple-allium-1674847068.jpeg","value": "purple"},{ "name": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR6-k5Trb0iy28JGvvI-5tUHs0G_LrFBqoxNA&usqp=CAU","value": "blue"},{ "name": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTAnDgUqPnErS6MQeq_ZdE5qBA6axBNw_Jokg&usqp=CAU","value": "pink"}]' lt-prop-url-value="name" lt-prop-system-value="value">
 * 	<template is="registerYield" yield-name="avatarYield">
 *      <lyte-avatar-navigator-item lt-prop-image={{lyteImage}}></lyte-avatar-navigator-item>
 *   </template>
 *</lyte-avatar-navigator>
 */

/**
* @syntax 
* @attribute ltPropIconYield=true
* <lyte-avatar-navigator style="width:300px;height:100px;" lt-prop-icon-yield="true" lt-prop-image-width="100px" lt-prop-images='[{ "name": "https://images.unsplash.com/photo-1530092285049-1c42085fd395?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8Mnx8d2hpdGUlMjBmbG93ZXJ8ZW58MHx8MHx8fDA%3D&w=1000&q=80","value": "white"},{ "name": "https://hips.hearstapps.com/hmg-prod/images/types-of-garden-flowers-purple-allium-1674847068.jpeg","value": "purple"},{ "name": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR6-k5Trb0iy28JGvvI-5tUHs0G_LrFBqoxNA&usqp=CAU","value": "blue"},{ "name": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTAnDgUqPnErS6MQeq_ZdE5qBA6axBNw_Jokg&usqp=CAU","value": "pink"}]' lt-prop-url-value="name" lt-prop-system-value="value">
* 	<template is="registerYield" yield-name="previousIconYield">
*     <i class="leftArrow"></i>
*  </template>
* 	<template is="registerYield" yield-name="nextIconYield">
*     <i class="rightArrow"></i>
*  </template>
*</lyte-avatar-navigator>
*/

export { LyteAvatarNavigatorComponent };