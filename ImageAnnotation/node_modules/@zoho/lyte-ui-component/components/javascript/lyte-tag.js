import { prop } from "@slyte/core";
import { Component } from "../component.js";

import $L from "@zoho/lyte-dom";

class LyteTagComponent extends Component {
    constructor() {
        super();
    }

    data() {
		return {
			'ltPropOptions': prop( 'array', { 'default': [] } ),

			'ltPropUserValue': prop( 'string', { 'default': 'name' } ),

			'ltPropSystemValue': prop( 'string', { 'default': 'value' } ),

			'ltPropDescriptionValue': prop( 'string', { 'default': '' } ),

			'ltPropSearchKeys': prop( 'array', { 
				'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-tag', 'searchKeys', [] ) 
			} ),

			'ltPropSelectedList': prop( 'array', { 'default': [] } ),

			'ltPropDelimiters': prop( 'array', { 
				'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-tag', 'delimiters', [ ',', 'Enter' ] ) 
			} ),

			'ltPropNoResult': prop( 'string', { 
				'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-tag', 'noResult', window._lyteUiUtils.i18n( 'no.results.found' ) ) 
			} ),

			'ltPropDropdown': prop( 'object', { 
				'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-tag', 'dropdown', {} ) 
			} ),

			'ltPropPlaceholder': prop( 'string', { 
				'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-tag', 'placeholder', '' ) 
			} ),

			// ltPropEvent can be: input or click
			'ltPropEvent': prop( 'string', {
				'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-tag', 'event', 'input' )
			} ),

			'ltPropCaseSensitive': prop( 'boolean', { 
				'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-tag', 'caseSensitive', true )
			} ),

			'ltPropAddNewItems': prop( 'boolean', {
				'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-tag', 'addNewItems', true )
			} ),

			'ltPropBoxYield': prop( 'boolean', {
				'default': false
			} ),

			'ltPropButtonYield': prop( 'boolean', {
				'default': false
			} ),

			'ltPropExternalSearch': prop( 'boolean', { 
				'default': false 
			} ),

			'ltPropPreventDuplicate': prop( 'boolean', { 
				'default': false 
			} ),

			'ltPropType': prop( 'string', {
				'default': 'dropdown'
			} ),

			'ltPropDisabled': prop( 'boolean', {
				'default': false
			} ),

			'ltPropAutoComplete': prop( 'boolean', { 
				'default': true
			} ),

			'ltPropDuplicateClass': prop( 'string', {
				'default': ''
			} ),

			'ltPropOpenWhenEmpty': prop( 'boolean', {
				'default': false
			} ),

			'ltPropPreventInputFocus': prop( 'boolean', {
				'default': false
			} ),
			'standardizedList': prop( 'array', {
				'default': []
			} ),

			'standardizedOptions': prop( 'array', {
				'default': []
			} ),

			'randId': prop( 'number', {
				'default': 0
			} )
		};		
	}

    init() {
		var that = this;
		/*
			These two utils will try to infer type of the data from user and build standardized array that can be used instead of both types
			Two types - string and object
		*/
		this.$node.updateOptions = function( optionsArr ) {
			that.updateArray( optionsArr, 'standardizedOptions' );
		}

		this.$node.updateList = function( selectedList ) {
			that.updateArray( selectedList, 'standardizedList' ); 
		}

		this.$node.clearInput = function() {
			that.clearInput();
		}
	}

    didConnect() {
		var that = this;

		this.setInputWidthBasedOnPlaceHolder();
		this.getDropBox().classList.add( 'lyteTagDropdown' );
		this.toggleDropIcon();

		this.$node.reset = function() {
			that.setData( 'ltPropSelectedList', [] );
			that.setData( 'standardizedList', [] );
		}
	}

    updateArray(array, variableToStoreInside) {
		if( !this.typeInferred ) {
			this.inferType( array );
		}

		if( !this.typeInferred ) {
			return ;
		}

		this.standardizeObject( array, variableToStoreInside ); 
	}

    setInputWidthBasedOnPlaceHolder() {
		var placeholder = ( this.getData( 'ltPropPlaceholder' ) || '' ).trim(),
		input = this.getInput();

		if( placeholder.length === 0 ) {
			this.setInputWidthForZeroContent();
		}
		else {
			input.style.width = placeholder.length + 'ch';
		}
	}

    setInputWidthForZeroContent() {
		var input = this.getInput();

		input.style.width = '5ch';
	}

    toggleDropIcon() {
		var options = this.getData( 'standardizedOptions' ) || [];

		if( options.length === 0 ) {
			this.getDropdown().classList.add( 'lyteTagRemoveIcon' );
		}
		else {
			this.getDropdown().classList.remove( 'lyteTagRemoveIcon' );
		}
	}

    filterItems(value) {
		if( this.isInputType() ) {
			return ;
		}

		var visibleItems = this.getVisibleItems( value );

		this.hideItems();
		this.showItems( visibleItems );
		this.toggleNoResults();
	}

    hideItems() {
		var box = this.getDropBox(),
		items = box.querySelectorAll( 'lyte-drop-item' ),
		groups = box.querySelectorAll( 'lyte-drop-group' );

		items.forEach( function( item ) {
			item.classList.add( 'lyteTagHidden' );
		} );

		groups.forEach( function( group ) {
			group.classList.add( 'lyteTagGroupHidden' );
		} );
	}

    showItems(resultArray) {
		var that = this;

		resultArray = resultArray || this.getDropBox().querySelectorAll( 'lyte-drop-item' );

		resultArray.forEach( function( item ) {
			item.classList.remove( 'lyteTagHidden' );
			that.showOptGroup( item );
		} );
	}

    showOptGroup(item) {
		var parent = item.parentElement;

		if( item.classList.contains( 'lyteDropdownActive' ) ) {
			return ;
		}

		if( parent && parent.tagName === 'LYTE-DROP-GROUP' ) {
			parent.classList.remove( 'lyteTagGroupHidden' );
		}
	}

    getVisibleItems(value) {
		var result = this.filterOptions( value ), visibleItems = [], that = this;

		result.forEach( function( arrItem ) {
			visibleItems.push( that.getDropItem( arrItem ) );
		} ); 

		return visibleItems;
	}

    filterOptions(value) {
		var options = this.getData( 'standardizedOptions' ) || [], that = this;

		return this.linearize( options ).filter( function( option ) {
			return that.isValid( option, value );
		} );
	}

    linearize(options) {
		var res = [];

		for( var i = 0; i < options.length; i++ ) {
			if( this.isOptGroup( options[ i ] ) ) {
				res = res.concat( options[ i ][ this.getOptGroupKey( options[ i ] ) ] );
			}
			else {
				res.push( options[ i ] );
			}
		}

		return res;
	}

    isOptGroup(group) {
		if( typeof group === 'string' ) {
			return false;
		}

		group = group || {};

		return Object.keys( group ).length === 1;
	}

    isValid(option, value) {
		var keys = this.getData( 'ltPropSearchKeys' ) || [], that = this;

		if( keys.length === 0 ) {
			keys.push( this.getData( 'ltPropUserValue' ) );
		}

		return keys.some( function( key ) {
			return that.doesMatch( option[ key ], value );
		} );
	}

    doesMatch(objectValue, value) {
		objectValue = this.resolveCase( objectValue );
		value = this.resolveCase( value );

		return !!~objectValue.indexOf( value );
	}

    resolveCase(str) {
		var isCaseSensitive = this.getData( 'ltPropCaseSensitive' );

		if( !isCaseSensitive ) {
			str = ( str || '' ).toLowerCase();
		}

		return str;
	}

    getDropItem(arrItem) {
		var sysValue = this.getData( 'ltPropSystemValue' ),
		dataValue = arrItem[ sysValue ];

		return this.getDropBox().querySelector( 'lyte-drop-item[data-value="' + dataValue + '"]' );
	}

    toggleNoResults() {
		if( this.hasVisibleItems() ) {
			this.hideNoResults();
		}
		else {
			this.showNoResults();
		}
	}

    hasVisibleItems() {
		return this.getDropBox().querySelectorAll( 'lyte-drop-item:not(.lyteTagHidden):not(.lyteDropdownActive)' ).length > 0;
	}

    showNoResults() {
		this.getDropdown().showNoResults();
	}

    hideNoResults() {
		this.getDropdown().hideNoResults();
	}

    addToSelected(sel) {
		var sysValue = this.getData( 'ltPropSystemValue' ),
		userValue = this.getData( 'ltPropUserValue' );

		if( !this.shouldAddTag( sel[ sysValue ], sel[ userValue ] ) ) {
			return ;
		}

		this.preventListObserver = true;
		this.pushIntoList( sel );

		// Manually add to standardized list because we have prevented inference observer which causes entire list re render

		this.addToStandardizedList( sel );
		this.preventListObserver = false;

		return true;
	}

    pushIntoList(sel) {
		var stringType = this.getData( 'stringType' ),
		sysValue = this.getData( 'ltPropSystemValue' ),
		valueToPush = stringType ? sel[ sysValue ] : sel;

		this.$addon.arrayUtils( this.getData( 'ltPropSelectedList' ), 'push', valueToPush );
	}

    addToStandardizedList(sel) {
		this.$addon.arrayUtils( this.getData( 'standardizedList' ), 'push', sel );
	}

    clearInput() {
		var input = this.getInput(), that = this;

		input.value = '';

		setTimeout( function() {
			that.filterItems( '' );	
		}, 0 );
	}

    filterAndBuildTags(isBlur) {
		var tags = this.getTags(),
		length = tags.length, that = this;

		if( !isBlur 
			&& length === 1 
			&& !this.isDelimiter( this.lastTypedChar() ) 
		) {
			this.filterItems( tags[ 0 ] );
		}
		else {
			tags.forEach( function( tag, index )  {
				that.filterItems( tag );
				that.buildTag( tag );
			} );

			this.showItems();
			this.toggleNoResults();
		}
	}

    buildTagWithoutFilter(isBlur) {
		var tags = this.getTags(), that = this;

		if( isBlur || this.isDelimiter( this.lastTypedChar() ) ) {
			tags.forEach( function( tag ) {
				that.buildTag( tag );
			} );

			this.showItems();
			this.toggleNoResults();
		}
	}

    getTags() {
		var rdelimiter = this.buildDelimiterRegex(),
		value = this.getInputValue(), result = [];

		value.split( rdelimiter ).forEach( function( item ) {
			item = item.trim();

			if( item.length ) {
				result.push( item );
			}
		} );

		return result;
	}

    buildDelimiterRegex() {
		var separators = this.getData( 'ltPropDelimiters' ) || [],
		res = '[';

		separators.forEach( function( item ) {

			if( item.toLowerCase() === 'enter' ) {
				item = '\n';
			}
			res += item;
		} );

		res += ']'

		return new RegExp( res, 'g' );
	}

    isDelimiter(key) {
		var delimiters = this.getData( 'ltPropDelimiters' );

		return !!~delimiters.indexOf( key );
	}

    lastTypedChar() {
		return this.getNonTrimmed().slice( -1 );
	}

    getNonTrimmed() {
		return this.getInput().value;
	}

    buildTag(value) {
		var box = this.getDropBox(),
		// TODO: Maybe this has something to do with lyteDropdownSelection
		firstItem = this.getHighLightedItem(),
		userValue = this.getData( 'ltPropUserValue' ),
		shouldBuildItem = this.getData( 'ltPropAddNewItems' ),
		canAutoComplete = this.getData( 'ltPropAutoComplete' ),
		isAlreadySelected, isManuallyBuilt = false,
		sel;

		if( firstItem && ( canAutoComplete || !this.isAutoCompleted( firstItem, value ) ) ) {
			sel = this.getObjFromOptions( firstItem );
		}
		else if( shouldBuildItem ) {
			sel = this.buildObjManually( value );
			isManuallyBuilt = true;
		}

		if( sel ) {
			isAlreadySelected = this.isAlreadySelected( sel[ userValue ] );

			if( this.addToSelected( sel ) ) {
				/* You can only add a duplicate item through observer or by typing in a duplicate item.
				You can't select an already selected item - so don't have to add in  onitemselected */
				this.addDuplicateItemInfo( sel, isAlreadySelected );
				this.callAddMethod( sel, isAlreadySelected );

				if( isManuallyBuilt ) {
					this.fireOnChange( this.getDropdown().ltProp( 'selected' ), null );
				}
			}

			/* We need to reposition dropdown because items that are not present in the options list can be added and that would not fire the setCss
			No more mutationObserver to detect these changes */
			this.repositionDropdown();
		}

		this.clearInput();
	}

    addDuplicateItemInfo(obj, isAlreadySelected) {
		var duplicateClass = this.getData( 'ltPropDuplicateClass' ),
		addedTag;

		if( duplicateClass && isAlreadySelected ) {
			addedTag = this.getAddedTagElement( obj );

			addedTag.classList.add( duplicateClass );
			addedTag.setAttribute( 'data-duplicate', 'true' );
		}
	}

    isAutoCompleted(item, value) {
		var itemObj = this.getObjFromOptions( item ) || {},
		userValue = this.getData( 'ltPropUserValue' );

		return itemObj[ userValue ] !== value;
	}

    getObjFromOptions(item) {
		var options = this.getData( 'standardizedOptions' ),
		dataValue = item.getAttribute( 'data-value' );

		return this.findObjInArray( options, dataValue );
	}

    findObjInArray(arr, value) {
		arr = arr || [];
		value = ( value || '' ).trim();

		var sysValue = this.getData( 'ltPropSystemValue' );

		for( var i = 0; i < arr.length; i++ ) {

			if( this.isOptGroup( arr[ i ] ) ) {
				var ret = this.findObjInArray( arr[ i ][ this.getOptGroupKey( arr[ i ] ) ], value );

				if( ret ) {
					return ret;
				}
			}

			else if( ( arr[ i ][ sysValue ] + "" ) === value ) {
				return arr[ i ];
			}
		}
	}

    getOptGroupKey(arr) {
		return Object.keys( arr || {} )[ 0 ];
	}

    buildObjManually(value) {
		var userValue = this.getData( 'ltPropUserValue' ),
		sysValue = this.getData( 'ltPropSystemValue' ), obj = {};

		if( this.getMethods( 'onTagCreation' ) ) {
			obj = this.executeMethod( 'onTagCreation', value );
		}
		else {
			obj[ userValue ] = value;
			obj[ sysValue ] = value + this.generateId();
		}

		return obj;
	}

    generateId() {
		var id = this.getData( 'randId' );

		this.setData( 'randId', id + 1 );
		
		return id;
	}

    repositionDropdown() {
		this.getDropdown().resetPosition();
	}

    toggleDropdown() {
		var value = this.getInputValue();

		if( value.length === 0 ) {
			this.hideDropdown();
		}
		else {
			this.showDropdown();
		}
	}

    showDropdown() {
		if( this.getData( 'ltPropEvent' ) !== 'input' ) {
			return ;
		}

		this.getDropdown().open();
	}

    hideDropdown() {
		if( this.getData( 'ltPropEvent' ) !== 'input' ) {
			return ;
		}

		this.getDropdown().close();
	}

    setInputWidth() {
		var value = this.getInputValue(),
		placeholder = ( this.getData( 'ltPropPlaceholder' ) || '' ).trim(),
		input = this.getInput();

		if( value.length < placeholder.length ) {
			this.setInputWidthBasedOnPlaceHolder();
		}
		else if( value.length === 0 ) {
			this.setInputWidthForZeroContent();
		}
		else {
			input.style.width = ( value.length + 1 ) + 'ch';
		}
	}

    getDropBox() {
		return this.getDropdown().component.getDropBox();
	}

    getDropdown() {
		return this.$node.querySelector( 'lyte-dropdown' );
	}

    focusInput() {
		this.getInput().focus();
	}

    getInput() {
		return this.$node.querySelector( '.lyteDropdownTextField' ) || this.$node.querySelector( '.lyteTagTextField' );
	}

    getInputValue() {
		return this.getInput().value.trim();
	}

    getHighLightedItem() {
		return this.getDropBox().querySelector( 'lyte-drop-item.lyteDropdownSelection:not(.lyteTagHidden):not(.lyteDropdownActive)' ) || this.getDropBox().querySelector( 'lyte-drop-item:not(.lyteTagHidden):not(.lyteDropdownActive)' );
	}

    inferType(arr) {
		var firstItem = ( arr || [] )[ 0 ], key;

		if( !firstItem ) {
			return ;
		}

		if( this.isOptGroup( firstItem ) ) {
			key = this.getOptGroupKey( firstItem );
			firstItem = firstItem[ key ];
		}

		this.setData( 'stringType', typeof firstItem === 'string' );
		this.typeInferred = true;
	}

    standardizeObject(arr, variableToStoreInside) {
		var options = arr || [], res = [], userValue = this.getData( 'ltPropUserValue' ),
		sysValue = this.getData( 'ltPropSystemValue' ), obj;


		if( !this.getData( 'stringType' ) ) {
			this.setData( variableToStoreInside, this.cloneArray( arr ) );
			return ;
		}

		for( var i = 0; i < options.length; i++ ) {
			if( this.isOptGroup( options[ i ] ) ) {
				res[ this.getOptGroupKey( options[ i ] ) ] = this.standardize( options[ i ][ this.getOptGroupKey( options[ i ] ) ] );
			}
			else {
				obj = {};
				obj[ userValue ] = options[ i ];
				obj[ sysValue ] = options[ i ];

				res.push( obj );
			}
		}

		this.setData( variableToStoreInside, res ); 

	}

    cloneArray(arr) {
		return arr.slice( 0 );
	}

    standardize(arr) {
		var userValue = this.getData( 'ltPropUserValue' ), sysValue = this.getData( 'ltPropSystemValue' ), res = [], obj;

		arr = arr || [];

		for( var i = 0; i < arr.length; i++ ) {
			obj = {};
			obj[ userValue ] = arr[ i ][ userValue ];
			obj[ sysValue ] = arr[ i ][ sysValue ];

			res.push( obj );
		}

		return res;
	}

    searchAvailableOptions(event) {
		var that = this,
		// TODO: Fix this with ARIA
		isBlur = event.type === 'blur' /* && ( event.relatedTarget && event.relatedTarget.tagName !== 'LYTE-DROP-BODY' ) */;

		setTimeout( function() {
			that.filterAndBuildTags( isBlur );
			that.toggleDropdown();
		}, 0 );
		

		this.setInputWidth();
	}

    makeApiRequest(event) {
		var that = this,
		// TODO: Fix this with ARIA
		isBlur = event.type === 'blur',
		promise;

		if( this.getMethods( 'onInput' ) ) {
			promise = this.executeMethod( 'onInput', event );
		}

		promise.then( function() {
			that.buildTagWithoutFilter( isBlur );
			that.toggleDropdown();
		} );

		this.setInputWidth();
	}

    isAlreadySelected(typedLabel) {
		typedLabel = ( typedLabel || '' ).trim();

		var selectedList = this.getData( 'standardizedList' ) || [],
		userValue = this.getData( 'ltPropUserValue' );

		for( var i = 0; i < selectedList.length; i++ ) {
			if( selectedList[ i ][ userValue ] === typedLabel ) {
				return selectedList[ i ];
			}
		}
	}

    shouldAddTag(dataValue, typedLabel) {
		var preventDuplicates = this.getData( 'ltPropPreventDuplicate' ),
		parentWantsToPrevent;

		if( this.getMethods( 'onBeforeAdd' ) ) {
			parentWantsToPrevent = this.executeMethod( 'onBeforeAdd', dataValue ) === false;
		}

		if( parentWantsToPrevent || ( preventDuplicates && this.isAlreadySelected( typedLabel ) ) ) {
			if( this.getMethods( 'onItemRejected' ) ) {
				this.executeMethod( 'onItemRejected', typedLabel );
			}

			return false;
		}

		return true;
	}

    callAddMethod(obj, isAlreadySelected) {
		var stringType = this.getData( 'stringType' ),
		sysValue = this.getData( 'ltPropSystemValue' ),
		valueToPass = stringType ? obj[ sysValue ] : obj;

		if( this.getMethods( 'onAdd' ) ) {
			this.executeMethod( 'onAdd', valueToPass, this.getAddedTagElement( obj ), !!isAlreadySelected );
		}
	}

    getAddedTagElement(addedItem) {
		var sysValue = this.getData( 'ltPropSystemValue' ),
		dataValue = addedItem[ sysValue ],
		selectedItems = this.$node.querySelectorAll( 'li[data-value]' );

		for( var i = selectedItems.length - 1; i > -1; i-- ) {
			if( selectedItems[ i ].getAttribute( 'data-value' ) === ( dataValue + '' ) ) {
				return selectedItems[ i ];
			}
		}
	}

    callRemoveMethod() {
		var stringType = this.getData( 'stringType' ),
		userValue = this.getData( 'ltPropUserValue' ),
		isAlreadySelected = this.isAlreadySelected( this.removedItemLabel );

		if( this.getMethods( 'onRemove' ) ) {
			this.executeMethod( 'onRemove', this.removedItem, !!isAlreadySelected );
		}
	}

    removeLastSelectedItem() {
		var selectedItems = this.$node.querySelectorAll( '[data-value]' );

		if( selectedItems.length === 0 ) {
			return ;
		}

		selectedItems[ selectedItems.length - 1 ].querySelector( 'lyte-tag-remove' ).click();
	}

    isInputType() {
		return this.getData( 'ltPropType' ) === 'input';
	}

    removeFromList() {
		// TODO: Think about immutability and how you can leverage it to reduce the code here
		var removedItem = this.removedItem,
		selectedList = this.getData( 'ltPropSelectedList' ) || [],
		stringType = this.getData( 'stringType' ),
		index;


		for( var i = 0; i < selectedList.length; i++ ) {
			if( selectedList[ i ] === removedItem ) {
				index = i;
				break;
			}
		}

		if( !isNaN( index ) ) {
			this.preventListObserver = true;
			this.$addon.arrayUtils( selectedList, 'removeAt', index, 1 );

			// We are not going to use the observer to sync our standardizedList and ltPropSelectedList(inferenceObserver does it)
			// because that sync destroys all the elements and creates a new list
			// Lyte.arrayUtils( this.getData( 'standardizedList' ), 'removeAt', index, 1 );
			this.preventListObserver = false;
		}
	}

    addToList(obj) {
		var stringType = this.getData( 'stringType' );


		this.preventListObserver = true;
		this.pushIntoList( obj );
		this.preventListObserver = false;
	}

    searchItems(event) {
		/*
			Don't make an api request when user blurs out of input. Just search existing options and select a value
		*/
		var makeRequest = this.getData( 'ltPropExternalSearch' ) && event.type !== 'blur';

		if( makeRequest ) {
			this.makeApiRequest( event );
		}
		else {
			this.searchAvailableOptions( event );
		}
	}

    changeDuplicateInfo(itemThatGotRemoved) {
		var duplicateRemoved = itemThatGotRemoved.getAttribute( 'data-duplicate' ) === 'true',
		labelThatGotRemoved = itemThatGotRemoved.textContent.trim(),
		firstDuplicateElement;
		
		if( duplicateRemoved ) {
			return ;
		}

		firstDuplicateElement = this.firstDuplicateElement( labelThatGotRemoved );

		this.removeDuplicateInfo( firstDuplicateElement );
	}

    removeDuplicateInfo(item) {
		var duplicateClass = this.getData( 'ltPropDuplicateClass' );

		if( !item ) {
			return ;
		}

		item.removeAttribute( 'data-duplicate' );

		if( duplicateClass ) {
			item.classList.remove( duplicateClass );
		}
	}

    firstDuplicateElement(labelThatGotRemoved) {
		var selectedItems = this.$node.querySelectorAll( 'li[data-value]' );

		for( var i = 0; i < selectedItems.length; i++ ) {
			if( selectedItems[ i ].textContent.trim() === labelThatGotRemoved ) {
				return selectedItems[ i ];
			}
		}
	}

    fireOnChange(curSelected, dropItem) {
		if( this.getMethods( 'onChange' ) ) {
			this.executeMethod( 'onChange', curSelected, dropItem );
		}
	}

    static actions() {
        return {
            fireOnClick: function( event ) {
                if( this.getMethods( 'onInputClick' ) ) {
                    this.executeMethod( 'onInputClick', event );
                }
            },
            searchItemsOnBlur: function( event ) {
                if( !window._lyteUiUtils._lyteTag.ignoreBlur ) {
                    this.searchItems( event );
                }

                window._lyteUiUtils._lyteTag.ignoreBlur = false;
            },

            searchItemsOnInput: function( event ) {
                if( this.getMethods( 'onInput' ) ) {
                    this.executeMethod( 'onInput', event );
                }
                
                this.searchItems( event );
            },

            handleOtherKeys: function( event ) {
                var key = event.key,
                value = this.getInputValue(),
                highLightedItem = this.getHighLightedItem();

                // TODO: Need to remove key === 'Enter'
                if( ( key === ' ' || key === 'Enter' ) && this.isDelimiter( key ) && !highLightedItem && value.length !== 0 ) {
                    this.buildTag( this.getInputValue() );
                    event.preventDefault();
                }
            }
        };
    }

    static methods() {
        return {
            fireOnChange: function( event, curSelected, dropdownThisRef, dropItem ) {
                this.fireOnChange( curSelected, dropItem );
            },

            storeRemovedItem: function( event, removedValue ) {
                var stringType = this.getData( 'stringType' ),
                obj = this.findObjInArray( this.getData( 'standardizedList' ), removedValue ),
                sysValue = this.getData( 'ltPropSystemValue' ),
                userValue = this.getData( 'ltPropUserValue' );

                this.removedItem = stringType ? obj[ sysValue ] : obj;
                this.removedItemLabel = obj[ userValue ];
            },
            // Fired only when the user selects an item from the list with the mouse or keyboard
            validate: function( event, dataValue, totalSelected, dropdownComponent, dropItem ) {
                this._isAlreadySelected = this.isAlreadySelected( dropItem.textContent.trim() );

                return this.shouldAddTag( dataValue, dropItem.textContent.trim() );
            },

            onItemSelected: function( event, selectedValue, totalSelected, dropComponent, dropItem ) {
                var selectedObj = this.findObjInArray( this.getData( 'standardizedOptions' ), selectedValue );

                this.addToList( selectedObj );
                this.toggleNoResults();
                this.clearInput();
                this.hideDropdown();
                this.callAddMethod( selectedObj, this._isAlreadySelected );
            },

            onItemRemoved: function( event, currentRemovedItem, totalSelected, dropdownComponent, removalMethod, dropItem ) {
                this.changeDuplicateInfo( dropItem );
                this.removeFromList();
                this.toggleNoResults();
                this.clearInput();
                this.hideDropdown();
                this.callRemoveMethod();
            },

            preventOpen: function( event ) {
                var preventOpenThroughCallback,
                preventInputFocus = this.getData( 'ltPropPreventInputFocus' );

                if( !preventInputFocus ) {
                    this.focusInput();
                }

                if( this.isInputType() ) {
                    return false;
                }

                if( this.getMethods( 'onBeforeShow' ) ) {
                    preventOpenThroughCallback = this.executeMethod( 'onBeforeShow', event ) === false;
                }

                if( preventOpenThroughCallback ) {
                    return false;
                }
                
                if( this.getData( 'ltPropEvent' ) !== 'input' ) {
                    return ;
                }

                var value = this.getInputValue(),
                options = this.getData( 'standardizedOptions' ),
                openWhenEmpty = this.getData( 'ltPropOpenWhenEmpty' );

                if( value.length === 0 || ( options.length === 0 && !openWhenEmpty ) ) {
                    return false;
                }
            }
        };
    }

    static observers() {
        return {
            addDisabledClass: function() {
                var disabled = this.getData( 'ltPropDisabled' );

                if( disabled ) {
                    this.$node.classList.add( 'lyteTagDisabled' );
                }
                else {
                    this.$node.classList.remove( 'lyteTagDisabled' );
                }

            }.observes( 'ltPropDisabled' ).on( 'didConnect' ),

            // TODO: Fix these crappy inference algorithms

            selectedTypeInference: function() {
                if( this.preventListObserver ) {
                    return ;
                }

                if( this.stopSelectedStandardization ) {
                    return ;
                }

                this.$node.updateList( this.getData( 'ltPropSelectedList' ) );

                this.stopSelectedStandardization = true;
            }.observes( 'ltPropSelectedList.[]' ).on( 'init' ),

            optionsTypeInference: function() {
                if( this.stopOptionsStandardization ) {
                    return ;
                }

                this.$node.updateOptions( this.getData( 'ltPropOptions' ) );

                this.stopOptionsStandardization = true;
            }.observes( 'ltPropOptions.[]' ).on( 'init' ),

            toggleIcon: function() {
                this.toggleDropIcon();
            }.observes( 'ltPropOptions.[]' )
        };
    }
}

window._lyteUiUtils._lyteTag = {
	isTagItemClicked: function( element ) {
		var box = $L( element ).closest( 'lyte-drop-box' ).get( 0 ),
		dropdown, tag; 

		if( box ) {
			dropdown = box.origindd;
			tag = $L( dropdown ).closest( 'lyte-tag' ).get( 0 );
		}

		if( tag ) {
			return true;
		}

		return false;
	}
};

document.addEventListener( 'mousedown', function( event ) {
	var target = event.target;

	_lyteUiUtils._lyteTag.ignoreBlur = _lyteUiUtils._lyteTag.isTagItemClicked( target );
}, true );
export { LyteTagComponent };