import { prop } from "@slyte/core";
import { Component } from "../component.js";
import $L from "@zoho/lyte-dom";

/**
 * This component is used to get hand written inputs and convert them to images
 * @component lyte-signature
 * @utility refresh,clear,downloadAsImage,reset,resetQueue
 * @methods onBeforeDrawSelect,onDrawSelect,onDrawMove,onDrawEnd,onBeforeDownload,onUndoRedoQueueUpdate
 * @version 3.17.0
 */

class LyteSignatureComponent extends Component {
    constructor() {
        super();
    }

    data() {

		var default_values = window._lyteUiUtils.getDefault( 'lyte-signature' );

		return {
			/**
			 * @componentProperty {colorString} ltPropInsertStroke='#000000'
			 * @version 3.17.0
			 */			
			ltPropInsertStroke : prop( 'string', { default : default_values.insertStroke || "#000000" }),
			/**
			 * @componentProperty {number} ltPropInsertLineWidth=1
			 * @version 3.17.0
			 */				
			ltPropInsertLineWidth : prop( 'number', { default : default_values.insertLineWidth || 1 }),
			/**
			 * @componentProperty {string} ltPropFileName='sample_sign'
			 * @version 3.17.0
			 */				
			ltPropFileName : prop( 'string', { default : default_values.fileName || "sample_sign" }),
			/**
			 * @componentProperty {boolean} ltPropDontModifyCurrent=false
			 * @version 3.17.0
			 */				
			ltPropDontModifyCurrent : prop( 'boolean', { default : default_values.dontModifyCurrent || false }),
			/**
			 * @componentProperty {string} ltPropImageUrl=''
			 * @version 3.17.0
			 */				
			ltPropImageUrl : prop( 'string', { default : default_values.imageUrl || "" } ),
			/**
			 * @componentProperty {boolean} ltPropUndoRedo=false
			 * @version 3.17.0
			 */				
			ltPropUndoRedo : prop( 'boolean', { default : default_values.undoredo || false } ),
			/**
			 * @componentProperty {Insert | Erase} ltPropMode='Insert'
			 * @version 3.17.0
			 */				
			ltPropMode : prop( 'string', { default : default_values.mode || 'Insert' } ),
			/**
			 * @componentProperty {colorString} ltPropEraseStroke='white'
			 * @version 3.17.0
			 */			
			ltPropEraseStroke : prop( 'string', { default : default_values.eraseStroke || "white" }),
			/**
			 * @componentProperty {number} ltPropEraseLineWidth=3
			 * @version 3.17.0
			 */				
			ltPropEraseLineWidth : prop( 'number', { default : default_values.eraseLineWidth || 5 }),

			showImage :  prop( 'boolean', { default : true } ),
			undoQueue : prop( 'array', { default : [] } ),
			redoQueue : prop( 'array', { default : [] } )
		};		
	}

    didConnect() {
		this._canvas = this.$node.children[ 0 ];
		this._context = this._canvas.getContext( '2d' );
		this.set_dimension();

		this.$node.refresh = this.set_dimension.bind( this );
		this.$node.clear = this.clear.bind( this );
		this.$node.downloadAsImage = this.download.bind( this );
		this.$node.reset = this.reset.bind( this );
		this.$node.resetQueue = this.resetQueue.bind( this );

	}

    reset() {
		this.setData( 'showImage', true );
		this.set_dimension();
		this.resetQueue();
	}

    resetQueue() {
		this.data.undoQueue = [];
		this.data.redoQueue = [];
		this.call_queueUpdate();
	}

    clear() {
		var canvas = this._canvas;
		this._context.clearRect( 0, 0, canvas.width, canvas.height );
	}

    download() {
		var canvas = this._canvas;
		var a = document.createElement( 'a' );
		a.download = this.data.ltPropFileName;
		a.href = canvas.toDataURL( "image/png" );

		a.style.position = 'absolute';

		if( this.getMethods( 'onBeforeDownload' ) ){
			if( this.executeMethod( 'onBeforeDownload', a, this.$node ) == false ){
				return;
			}
		}
		this.$node.appendChild( a );
		a.click();
		a.remove();
	}

    didDestroy() {
		this.remove_events();

		[ '_canvas', '_context', 'refresh', 'clear', 'downloadAsImage', 'reset', 'resetQueue' ].forEach( function( item ){
			delete this[ item ];
		}.bind( this ) );
	}

    set_dimension() {
		var canvas = this._canvas,
		_this = this;

		$L.fastdom.measure( function(){
			var bcr = canvas.getBoundingClientRect();

			$L.fastdom.mutate( function(){
				canvas.setAttribute( 'width', bcr.width );
				canvas.setAttribute( 'height', bcr.height );	
				_this.include_image();
			});

		});
	}

    include_image() {
		var img = this.$node.querySelector( 'img' );
		if( img ){
			var loadFn = function(){
				var ctx = this._context,
				canvas = this._canvas;
				ctx.drawImage( img, 0, 0, canvas.width, canvas.height );
				this.setData( 'showImage', false );
			}.bind( this );

			if( img.complete ){
				loadFn();
			} else{
				img.onload = loadFn;
			}
		}
	}

    getEvent(evt) {
		var touches = evt.touches || [ evt ];

		if( touches.length > 1 ){
			return;
		}

		return touches[ 0 ];
	}

    mousemove(ev) {
		var evt = this.getEvent( ev );
		if( !evt ){
			return;
		}
		this._moved = true;
		var coor = this.get_coordinate( evt ),
		ctx = this._context,
		mode = this.data.ltPropMode,
		stroke = this.data[ 'ltProp' + mode + 'Stroke'];

		ctx.lineWidth = this.data[ 'ltProp' + mode + 'LineWidth' ];

		ctx.lineTo( coor.x, coor.y );

		if( stroke ){
			ctx.stroke();
			ctx.strokeStyle = stroke;
		}

		if( this.getMethods( 'onDrawMove' ) ){
			this.executeMethod( 'onDrawMove', ev, this.$node );
		}
		ev.preventDefault();
	}

    remove_events() {
		if( this._move ){
			[ { name : 'mousemove', evt : this._move }, { name : 'mouseup', evt : this._up }, { name : 'touchmove', evt : this._move }, { name : 'touchend', evt : this._up } ].forEach( function( item ){
				document.removeEventListener( item.name, item.evt, true );
			}.bind( this ));

			delete this._move;
			delete this._up;
		}
	}

    mouseup(evt) {
		this.remove_events();
		if( this._moved && this.data.ltPropUndoRedo ){
			var canvas = this._canvas;
			this.push_to_queue( this._context.getImageData( 0, 0, canvas.width, canvas.height ) );
		}
		if( this.getMethods( 'onDrawEnd' ) ){
			this.executeMethod( 'onDrawEnd', evt, this._moved, this.$node );
		}
		delete this._moved;
	}

    push_to_queue(obj) {
		this.data.undoQueue.push( obj );
		this.data.redoQueue.splice( 0 );

		this.call_queueUpdate();
	}

    call_queueUpdate() {
		var callback_name = 'onUndoRedoQueueUpdate';
		if( this.getMethods( callback_name ) ){
			this.executeMethod( callback_name, this.data.undoQueue, this.data.redoQueue, this.$node );
		}
	}

    get_coordinate(evt) {
		var bcr = this.$node.getBoundingClientRect();
		return{
			x : evt.clientX - bcr.left,
			y : evt.clientY - bcr.top
		};
	}

    undo(evt) {
		var undo = this.data.undoQueue,
		redo = this.data.redoQueue;

		var current = undo.pop(),
		last_before = $L( undo ).get( -1 );

		if( current ){
			redo.push( current );
			this.render( last_before, evt );
		}
	}

    redo(evt) {
		var redo = this.data.redoQueue,
		current = redo.pop();

		if( current ){
			this.data.undoQueue.push( current );
			this.render( current, evt );
		}

	}

    render(to_render, evt) {
		this.clear();
		if( to_render ){
			this._context.putImageData( to_render, 0, 0 );
		}
		evt.preventDefault();
		this.call_queueUpdate();

		return ;
	}

    static actions() {
        return {
            mousedown : function( evt ){
                var ev = this.getEvent( evt ),
                namemove = "mousemove",
                nameup = "mouseup";

                if( ev ){
                    if( ev != evt ){
                        namemove = 'touchmove';
                        nameup = 'touchend';
                    }
                } else {
                    return;
                }

                if( this.getMethods( 'onBeforeDrawSelect' ) ){
                    if( this.executeMethod( 'onBeforeDrawSelect', evt, this.$node ) == false ){
                        return;
                    }
                }

                var coor = this.get_coordinate( ev ),
                ctx = this._context;

                ctx.beginPath();

                ctx.moveTo( coor.x, coor.y );

                this._move = this.mousemove.bind( this );
                this._up = this.mouseup.bind( this );

                document.addEventListener( namemove, this._move, true );
                document.addEventListener( nameup, this._up, true );

                if( this.getMethods( 'onDrawSelect' ) ){
                    this.executeMethod( 'onDrawSelect', evt, this.$node );
                }
                if( namemove == 'touchmove' ){
                    evt.preventDefault();
                }
            },

            keydown : function( evt ){
                if( this.data.ltPropUndoRedo ){
                    var keycode = evt.which || evt.keyCode,
                    is_meta = evt.metaKey != void 0 ? evt.metaKey : evt.ctrlKey;

                    if( keycode == 90 && is_meta ){
                        if( evt.shiftKey ){
                            this.redo( evt );
                        } else {
                            this.undo( evt );
                        }
                    }
                }
            }
        };
    }

    static observers() {
        return {
            lineObs : function( arg ){
                if( this.data.ltPropDontModifyCurrent ){
                    return;
                }

                var ctx = this._context,
                obj = {
                    ltPropInsertStroke : "strokeStyle",
                    ltPropInsertLineWidth : "lineWidth"
                };

                ctx[ obj[ arg.item ] ] = arg.newValue;
                ctx.stroke();
            }.observes( 'ltPropInsertLineWidth', 'ltPropInsertStroke' )
        };
    }
}

/**
 * @syntax nonYielded
 * <lyte-signature></lyte-signature>
 */

export { LyteSignatureComponent };