import { prop } from "@slyte/core";
import { Component, LyteUiComponentComponentRegistry } from "../component.js";

import $L from "@zoho/lyte-dom";

window.dtslctscroll = function(evt) {
	if( evt && evt.type == 'resize' && window._lyteUiUtils.isMobile ) {
		return;
	}
	var drops = document.querySelectorAll( 'lyte-drop-box:not(.lyteDropdownHidden)' )
	for( var i = 0; i < drops.length; i++ ){
		var opendrop = drops[ i ];
		if( opendrop && opendrop.origindd && opendrop.origindd.parent ){
			var cmp = opendrop.origindd.parent.component;
			evt.type == "orientationchange" ?  setTimeout( cmp.setCss.bind( cmp ), 500 ) : $L.fastdom.measure( cmp.setCss.bind( cmp ) );
		}
	}
};

/**
 * This component is used to select a date or a range of date from the given options
 * @component lyte-dateselect
 * @version 1.0.5
 * @dependency lyte-dropdown
 *  components/lyte-dropdown.js
 *  theme/compiledCSS/default/ltr/lyte-ui-dropdown.css
 * @dependency lyte-calendar
 *  components/lyte-calendar.js
 *  theme/compiledCSS/default/ltr/lyte-ui-calendar.css
 * 	plugins/lyte-moment.js
 * @dependency lyte-daterangepicker
 *  components/lyte-daterangepicker.js
 *  theme/compiledCSS/default/ltr/lyte-ui-daterangepicker.css
 * @methods beforeRender,afterRender,onBeforeShow,onShow,onBeforeHide,onHide,onSelect
 * @import lyte-dropdown
 * @ignoreMethods
 * @ignoreProperties
 * @ignoreUtilities
 */

class LyteDateselectComponent extends Component {
    constructor() {
        super();
    }

    init() {
		this.getMethods( 'beforeRender' ) && this.executeMethod( 'beforeRender', this.$node )
		this.$node.toggle = function(){
			this._drop.toggle();
		}.bind( this );
	}

    removeTempUnSelection() {
		var dropdown = this.$node.querySelector( 'lyte-dropdown' ),
		box = dropdown.getDropBox(),
		item = box.querySelector( '.lyteDateSelectTempSelection' );

		if( item ) {
			item.classList.remove( 'lyteDateSelectTempSelection' );
		}
	}

    removeTempSelection() {
		var dropdown = this.$node.querySelector( 'lyte-dropdown' ),
		box = dropdown.getDropBox(),
		item = box.querySelector( '.lyteDateSelectPrevTempSelection' );

		if( item ) {
			item.classList.remove( 'lyteDateSelectPrevTempSelection' );
		}
	}

    data() {

		var default_values = window._lyteUiUtils.getDefault( 'lyte-dateselect' );

		return {
			// data for date range picker and calendar
		   /**
			* @experimental shortMonthNames
			*/
			shortMonthNames : prop( "array" , { "default" : [ 'Jan', 'Feb', 'Mar', 'Apr', 'short.may', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' ]}),
		   /**
			* @experimental longMonthNames
			*/
			longMonthNames : prop( "array", { 
				'default': [
				'January',
				'February',
				'March',
				'April',
				'May',
				'June',
				'July',
				'August',
				'September',
				'October',
				'November',
				'December' 
				]
			} ),
		   /**
			* @componentProperty {object} ltPropStartDateObject
			* @version 1.0.5
			*/			
			ltPropStartDateObject : prop( "object" ),
		   /**
			* @componentProperty {object} ltPropEndDateObject
			* @version 1.0.5
			*/
			ltPropEndDateObject : prop("object"),
		   /**
			* @componentProperty {dateString} ltPropStartDate=''
			* @version 1.0.5
			*/
			ltPropStartDate : prop( "string", { "default" : default_values.startDate || "" } ),
		   /**
			* @componentProperty {dateString} ltPropEndDate=''
			* @version 1.0.5
			*/
			ltPropEndDate : prop( "string", { "default" : default_values.endDate || "" } ),
		   /**
			* @componentProperty {dateString} ltPropCurrentDate=''
			* @version 1.0.5
			*/
			ltPropCurrentDate : prop( "string", { "default" : default_values.currentDate || "" } ),
		   /**
			* @componentProperty {boolean} ltPropCalendarYield=false
			* @version 1.0.5
			*/
			ltPropCalendarYield : prop( "boolean", { default : default_values.calendarYield || false } ),
		   /**
			* @componentProperty {object} ltPropCalendar={"headerType":"dropdown","fillRows":false}
			* @version 1.0.5
			* @component lyte-calendar
			*/
			ltPropCalendar : prop( "object", { default : default_values.calendar || { headerType : "dropdown", fillRows : false } } ),
		   /**
			* @componentProperty {object} ltPropDateRangePicker={"monthHeaderFormat":"MMMM YYYY"}
			* @version 1.0.5
			* @component lyte-daterangepicker
			*/
			ltPropDateRangePicker : prop( "object", { default : default_values.dateRangePicker || { monthHeaderFormat : "MMMM YYYY" } } ),
		   /**
			* @componentProperty {boolean} ltPropItemYield=false
			* @version 1.0.5
			*/
			ltPropItemYield : prop( "boolean", { default : default_values.itemYield || false } ),

			// dateselect props
		   /**
			* @componentProperty {string} ltPropSelected=today
			* @version 1.0.5
			*/
			ltPropSelected : prop("string", { default : default_values.selected || 'today'}),
		   /**
		    * @typedef {object} dateSelectOptions
		    * @property {boolean} today=true
		    * @property {boolean} yesterday=true
		    * @property {boolean} last7days=true
		    * @property {boolean} last30days=true
		    * @property {boolean} thisWeek=true
		    * @property {boolean} thisMonth=true
		    * @property {boolean} specificDate=true
		    * @property {boolean} customRange=true
		    */
		   /**
			* @componentProperty {dateSelectOptions} ltPropOptions
			* @version 1.0.5
			*/
			ltPropOptions : prop( "object", { default : default_values.options || {
				today :  true,
				yesterday : true,
				last7days : true,
				last30days : true,
				thisWeek : true,
				thisMonth : true,
				specificDate : true,
				customRange : true
			}}),
		   /**
			* @componentProperty {string} ltPropDropdownWrapperClass=''
			* @version 1.0.5
			*/
			ltPropDropdownWrapperClass : prop( "string", { default : default_values.dropdownWrapperClass || '' } ),
		   /**
			* @componentProperty {object} ltPropDropdown
			* @version 1.0.5
			* @default {}
			* @component lyte-dropdown
			*/
			ltPropDropdown : prop( "object", { default : default_values.dropdown || {} } ),
		   /**
			* @componentProperty {string} ltPropDisplayValue=''
			* @version 1.0.5
			*/
			ltPropDisplayValue : prop( "string", { default : default_values.displayValue || '' } ),
		   /**
			* @componentProperty {boolean} ltPropButtonYield=false
			* @version 1.0.5
			*/
			ltPropButtonYield : prop( "boolean", { default : default_values.buttonYield || false } ),
		   /**
			* @componentProperty {string} ltPropCalendarWrapperClass=''
			* @version 1.0.5
			*/
			ltPropCalendarWrapperClass : prop( "string", { default : default_values.calendarWrapperClass || '' } ),
		   /**
			* @componentProperty {boolean} ltPropFooterYield=false
			* @version 3.10.0
			*/			
			ltPropFooterYield : prop( "boolean", { default : default_values.footerYield || false } ),
		   /**
			* @componentProperty {boolean} ltPropI18n=false
			* @version 3.10.0
			*/
			ltPropI18n : prop( "boolean", { default : default_values.i18n || false } ),
		   /**
		    * @typedef animeDef
		    * @property {Fade|Scale|Slide} dropdown=Fade
		    * @property {Fade|Scale|Slide} calendar=Fade
		    */

		   /**
			* @componentProperty {animeDef} ltPropAnimation
			* @version 3.14.0
			*/
			ltPropAnimation : prop( "object", { default : default_values.animation || {
				dropdown : "Fade", // Scale, Slide
				calendar : "Fade"
			} } ),
		   /**
			* @componentProperty {boolean} ltPropNavigation=false
			* @version 3.50.0
			*/
			ltPropNavigation : prop( "boolean", { default : default_values.navigation || false } ),
			/**
			* @componentProperty {dateString} ltPropBeforeCurrentDate=''
			* @version 1.0.5
			*/
			ltPropBeforeCurrentDate : prop("string", { default : default_values.beforeCurrentDate || '' } ),
			/**
			* @componentProperty {dateString} ltPropAfterCurrentDate=''
			* @version 1.0.5
			*/
			ltPropAfterCurrentDate : prop("string", { default : default_values.afterCurrentDate || '' } ), 

			// system data

		   /**
			* @experimental pos
			*/
			pos : prop( "string", { default : '' } ),
		   /**
			* @experimental prevSel
			*/
			prevSel : prop( "string", { default : '' } ),
		   /**
			* @experimental opend
			*/
			opend : prop( "boolean",  { default : false } ),

			randomId : prop( "string", { default : "lyteDateSelect_" + parseInt( Math.random() * 1e6 ) } ),

			dateSelected : prop( "boolean", { default : false } ),

			calNavigation : prop( "boolean", { default : false } ),
			rangeNavigation : prop( "boolean", { default : false } ),
			preventKeydown : prop( "boolean" ),
			bfrAftrCurrentDate : prop("string"),
			itemMap : prop( "object", { default : { 
				before : 'lyteDsBeforeCal',
				after : 'lyteDsBeforeCal'
			 } } )

		};		
	}

    selectValue(dat) {
		// if( !this.data.ltPropButtonYield ){
			// var val = this.data.ltPropOptions[ dat ];
			// var oriDisp = val.constructor == Boolean ? _lyteUiUtils.i18n( dat ) : val;
			this.setData( 'ltPropDisplayValue', this.getVal( dat ) )
		// }
	}

    didConnect() {
		this._drop = this.$node.querySelector( 'lyte-dropdown' );
		this._drop.parent = this.$node;
		
		var com = this._drop.component,
		data = this.data;

		this._cmp = com.childComp ? com.childComp : this._drop.querySelector( 'lyte-drop-box' )
		this._end = this.tranEnd.bind( this );
		this._indend = this.tranEnd1.bind( this );

		this._opentrans = this.opentrans.bind( this );

		this._caldiv = this.$node.querySelector( '.dateSelectcal' ) 
		window._lyteUiUtils.appendChild( document.body, this._caldiv );
		this.checkCurrentDate();
		// if( !data.ltPropButtonYield ){
			this.setData( 'ltPropDisplayValue', this.getVal( data.ltPropSelected ) )
		// }
		if( !document._dateselectResize ){
			document._dateselectResize = true;

			[ 'resize', 'scroll', 'orientationchange' ].forEach( function( item ){
				window.addEventListener( item, window.dtslctscroll );
			});
		}
		this.$node.toggle = function( ev, tp ){
			this._drop.toggle( ev, tp )
		}.bind( this );

		this._drop.updateButtonAria( 'aria-labelledby', data.randomId );

		this.getMethods( 'afterRender' ) && this.executeMethod( 'afterRender', this.$node );

		$L.fastdom.measure( function(){
			this._dir = window._lyteUiUtils.getRTL();
			if( this._dir ) {
				$L.fastdom.mutate( function(){
						this._caldiv.classList.add( 'lyteRTL' )
				}.bind( this ) )
			}
		}.bind( this ) )
	}

    didDestroy() {
		document.body.removeChild( this._caldiv );
		if( document._dateselectResize && document.querySelectorAll( 'lyte-dateselect' ).length == 0 ){
			delete document._dateselectResize;
			[ 'resize', 'scroll', 'orientationchange' ].forEach( function( item ){
				window.removeEventListener( item, window.dtslctscroll );
			});
		}
		delete this._caldiv; delete this._cmp; delete this._drop; delete this.$node.toggle;
	}

    getVal(sel) {
		if( !sel ){
			return "";
		}
		var val = this.data.ltPropOptions[ sel ], oridisp = val.constructor == Boolean ? window._lyteUiUtils.i18n( sel ) :  val ;
 		if( [ 'specificDate', 'customRange', 'before', 'after' ].indexOf( sel ) == -1 ){
			return oridisp;
		} else if( sel == 'specificDate' ){
			return this.i18_date( this.data.ltPropCurrentDate, this.data.ltPropCalendar.format || "MM/DD/YYYY" ) || oridisp;
		} else if( sel == 'customRange' ) {
			var format = this.data.ltPropDateRangePicker.format || "MM/DD/YYYY",
			s = this.i18_date( this.data.ltPropStartDate, format ), e = this.i18_date( this.data.ltPropEndDate, format );
			return ( s && e ) ? ( s + ' - ' + e ): oridisp;
		}else if( sel == 'before' ){
			let date = (this.i18_date( this.data.ltPropBeforeCurrentDate, this.data.ltPropCalendar.format || "MM/DD/YYYY" )) ;
			return date ?  window._lyteUiUtils.i18n('before') + " - " + date : oridisp;
		}else if( sel == 'after' ){
			let date = (this.i18_date( this.data.ltPropAfterCurrentDate, this.data.ltPropCalendar.format || "MM/DD/YYYY" ));
			return date ? window._lyteUiUtils.i18n('after') + " - " + date : oridisp;
		}
		// return _lyteUiUtils.i18n( s );
	}

    resolveConflicts(format) {
		var match = /(\bd\b|\bdd\b|\bddd\b|\bdddd\b)/.exec( format ),
		index = ( match || {} ).index,
		matchLength = ( match || [] )[ 0 ].length || 0;

		if( !isNaN( index ) ) {
			return format.substring( 0, index + matchLength ) + ( format.substring( index + matchLength ) || '' ).toUpperCase();
		}

		return format.toUpperCase();
	}

    isConflictingFormat(format) {
		var rdate = /(\bd\b|\bdd\b|\bddd\b|\bdddd\b)/ig,
		match = format.match( rdate ) || [];

		return match.length > 1;
	}

    getRelevantFormat(format) {

		if( this.isConflictingFormat( format ) ) {
			return this.resolveConflicts( format );
		}

		return format.toUpperCase();
	}

    i18_date(date, format) {

		format = this.getRelevantFormat( format );

		if( date && $L.moment && this.data.ltPropI18n ){
			var cb = function( value, converted, format ){
				if( this.getMethods( 'onI18n' ) ){
					/**
					  * @methods onI18n
					  * @version 3.10.0
					  */
					return this.executeMethod( 'onI18n', value, converted, format );
				}
				return converted;
			}.bind( this );
			return $L.moment( date, format ).i18N( format, cb );
		}
		return date;
	}

    opentrans(evt) {
		$L( this._cmp ).removeClass( 'lyteDateselectAnimationHappening' );
		this._cmp.removeEventListener( 'transitionend', this._opentrans, true );
		delete this._drop.component._preventSetcss;

		this.setup_navigation();

		if( this.getMethods( 'onAnimationEnd' ) ){
			this.executeMethod( 'onAnimationEnd', this.$node );
		}
	}

    setup_navigation() {
		var __data = this.data,
		__selected = __data.ltPropSelected;

		if( __data.ltPropNavigation ){
			if( __selected == "specificDate" ){
				this.setData( 'calNavigation', true );
			} else if( __selected == "customRange" ){
				this.setData( 'rangeNavigation', true );
			}
		}
	}

    tranEnd(evt) {
		if( this._cmp ){
			this._cmp.removeEventListener( 'transitionend', this._end, true );
			$L( this._cmp ).removeClass( 'lyteDateselectAnimationHappening' ).css( this.getValue( 1, 'dropdown', this._cmp ) );
		}

		if( this._el ){
			this._el.classList.add( 'lyteDropdownHidden' );
			delete this._el;
		}
		if( this._res ){
			this._res( true );
			this._caldiv.classList.add( 'lyteDropdownHidden' );
			this.callRevert();
			delete this._res;
		}
		// this.hidedropdown();
	}

    tranEnd1(evt) {
		if( this._el ){
			this._el.removeEventListener( 'transitionend', this._indend, true );
			$L( this._el ).removeClass( 'lyteDateselectAnimationHappening' );
			this._el.classList.add( 'lyteDropdownHidden' );
			delete this._el;
		}
		if( this._new ){
			this._new( true );
			delete this._new;
		}

		// this.hidedropdown();
	}

    hidedropdown() {
		var caldiv = this._caldiv;
		if( caldiv ){
			var dropdown = Array.from( caldiv.getElementsByTagName( 'lyte-dropdown' ) );

			dropdown.forEach( function( item ){
				item.close();
			});
		}
	}

    hideele(elem) {
		elem.addEventListener( 'transitionend', this._indend, true );
		$L( elem ).addClass( 'lyteDateselectAnimationHappening' );

		this._el = elem;
		
		if( this.data.ltPropAnimation.dropdown ){
			$L( elem ).css( this.getValue( 0, 'calendar', elem ) );
		} else{
			this._indend();
		}
	}

    getValue(value, type, elem) {
		var animation = this.data.ltPropAnimation[ type ];

		if( animation == 'Fade' ){
			return {
				opacity : value
			}
		} else if( animation == 'Scale' ){
			return{
				transform : "scaleY(" + value + ')'
			}
		} else if(  animation == 'Slide' ){
			var obj = {
				height : value ? ( elem.__height ) : 0,
				transform : ""
			};

			if( $L( this._caldiv ).hasClass( 'lyteDateselectUp' ) ){
				// obj.transform = 'translateY(' + ( !value ? elem.__height : 0 ) + 'px)';

				// obj.transform = value ? '' : ( 'translateY(' + elem.__height + 'px)' );
			}

			return obj;
		}
		return {};
	}

    checkSelected(selected) {
		if( selected === 'specificDate' ){
			return this.data.ltPropCurrentDate;
		}else if( selected === 'customRange' ){
			return this.data.ltPropStartDate;
		}else if( selected === 'before' ){
			return this.data.ltPropBeforeCurrentDate;
		}else if( selected === 'after' ){
			return this.data.ltPropAfterCurrentDate;
		}

		return true;
	}

    openele() {
		var sel = this.data.ltPropSelected,
		fn = function(){
			this.setCss();
			this.setup_navigation();
		}.bind( this );

		this.checkCurrentDate();

		if( [ 'specificDate', 'customRange', 'before', 'after' ].indexOf( sel ) != -1 ) {
			this._caldiv.classList.remove( 'lyteDropdownHidden' );
			var el = this._caldiv.querySelector( '.' + this.getClass(sel) );
			el.classList.remove( 'lyteDropdownHidden' );
			if( this.data.ltPropAnimation.calendar == 'Slide' ){
				$L.fastdom.measure( function(){
					el.__height = this._caldiv.__height = el.children[ 0 ].getBoundingClientRect().height;
					$L.fastdom.mutate( function(){
						$L( el ).css( 'transitionDuration', '0s' ).css( this.getValue( 0, 'calendar', el ) );
						// $L.fastdom.measure( this.setCss.bind( this ) );
						setTimeout( function(){
							$L( el ).css( 'transitionDuration', '' );
							fn();
						}.bind( this ), 20 );
					}.bind( this ) );
				}.bind( this ));
			} else {
				$L( el ).css( this.getValue( 0, 'calendar', el ) );
				$L.fastdom.measure( fn );
			}
		}
	}

    static methods() {
        return {
            keepTickOnCalendarSelection: function( event, previousSelected, dropdown, item, currentSelected ) {
                var dropdown = this.$node.querySelector( 'lyte-dropdown' ),
                box = dropdown.getDropBox(),
                selectionTickRetainedItem = box.querySelector( '.lyteDateSelectPrevTempSelection' ),
                previousItem;

                /* If some item is made to retain the selection tick, don't change anything in dropdown since it has to retain it till the end of dropdown's open*/
                if( selectionTickRetainedItem ) {
                    return ;
                }

                previousItem = dropdown.getItem( previousSelected );

                if( ( currentSelected === 'specificDate' || currentSelected === 'customRange' || currentSelected === 'before' || currentSelected === 'after' ) && previousItem && this.checkSelected(previousSelected)) {
                    previousItem.classList.add( 'lyteDateSelectPrevTempSelection' );
                }
            },

            rangenavigate : function( cb ){

                var args = arguments;

                if( this.getMethods( cb ) ){
                    this.executeMethod.apply( this, args );
                }

                if( this.data.ltPropAnimation.calendar == 'Slide' ){
                    var datepicker = args[ 3 ].$node;
                    $L.fastdom.measure( function(){
                        var height = datepicker.getBoundingClientRect().height;
                        $L.fastdom.mutate( function(){
                            $L( datepicker.parentNode ).css( 'height', height );
                        });
                    });
                }
            },

            bfSw : function( arg1, arg2 ){
                var ret;
                if( this.getMethods( 'onBeforeShow' ) ){
                    ret = this.executeMethod( 'onBeforeShow', arg1, arg2 )
                }
                if( !this.data.opend && ret != false ) {
                    this.setData( 'opend', true );
                    return new Promise( function( res ){
                        window.requestAnimationFrame( res );
                    })
                }
                return ret;
            },
            sw : function( arg1, arg2 ){

				var __data = this.data;

				if( __data.ltPropDateRangePicker.maxDiff != void 0 ){
					this.__initial_start = __data.ltPropStartDate;
					this.__initial_end = __data.ltPropEndDate;
				}

                this._drop.component._preventSetcss = !this._drop.ltProp( 'freeze' );

                this.getMethods( 'onShow' ) && this.executeMethod( 'onShow', arg1, arg2 );

                var body = arg2.childComp;
                
                $L( body ).addClass( 'lyteDateselectAnimationHappening' ).css( 'transitionDuration', '0s' ).css( this.getValue( 0, 'dropdown', body ) );

                this.setData( 'preventKeydown', true );
                
                setTimeout( function(){ // request animation frame causes issue in ff
                    $L( body ).css( 'transitionDuration', '' );
                    this.openele();

                    body.addEventListener( 'transitionend', this._opentrans, true );

                    $L.fastdom.mutate( function(){
                        $L( body ).css( this.getValue( 1, 'dropdown', body ) );	
                    }.bind( this ) ); 
                }.bind( this ), 20 );
            },
        
            bfHde : function( arg1, arg2 ){

                delete this._callonchange;

                if( this._prevent || this._caldiv.contains( ( arg1 || {} ).target ) ){
                    delete this._prevent;
                    return false;
                }
                var ret;
                if( this.getMethods( 'onBeforeHide' ) ){
                    ret = this.executeMethod( 'onBeforeHide', arg1, arg2 )
                }
                if( ret != false ){
                    return new Promise( function( res, rej ){
                        this._res = res;
                        var animation = this.data.ltPropAnimation || {},
                        el = this._caldiv.querySelector('.specificDate:not(.lyteDropdownHidden),.customRange:not(.lyteDropdownHidden),.lyteDsBeforeCal:not(.lyteDropdownHidden)');

                        this._el = el;

                        // this.hidedropdown();

                        if( animation.dropdown ){
                            arg2.childComp.addEventListener( 'transitionend', this._end, true );
                            $L( arg2.childComp ).addClass( 'lyteDateselectAnimationHappening' );
                            if( el ) {
                                $L( el ).css( this.getValue( 0, 'calendar', el ) );
                            }
                            $L( arg2.childComp ).css( this.getValue( 0, 'dropdown', arg2.childComp ) );
                        } else{
                            this._end();
                        }
                    }.bind( this ) )
                }
                return ret;
            },
            
            hde : function( arg1, arg ){
                var data = this.data,
                __rest = this._rest,
                __selected = data.ltPropSelected,
                fn = function(){
                    var rangepicker = data.ltPropDateRangePicker,
                    cal_div = this._caldiv;

                    if( rangepicker.maxDiff != void 0 && cal_div ){
                        var dom = cal_div.getElementsByTagName( 'lyte-daterangepicker' )[ 0 ],
						__comp = dom.component;

						__comp.__frm_init = true;

						dom.ltProp({
							startDate : data.ltPropStartDate || this.__initial_start || "",
							endDate : data.ltPropEndDate || this.__initial_end || "",
							minDate : rangepicker.minDate || "",
							maxDate : rangepicker.maxDate || ""
						});

						delete __comp.__frm_init;

                    }
                }.bind( this );

                this.removeTempUnSelection();
                this.removeTempSelection();

                this.setData( 'preventKeydown', false );

                if( !__rest && data.prevSel ){
                    this.setData( 'ltPropSelected', __selected = data.prevSel );
                    // if( !this.data.ltPropButtonYield ){
                        this.setData( 'ltPropDisplayValue', this.getVal( __selected ) );
                    // }
                }else if( !__rest && !data.prevSel && /specificdate|customrange|before|after/i.test( __selected) ){
                    
                    let clr = function(){
                        this.setData( 'ltPropSelected',  '' );
                        this.setData( 'ltPropDisplayValue', '' );
                    }.bind(this);
                    
                    if( __selected == 'specificData' && !data.ltPropCurrentDate ){
                        clr();
                    }else if( __selected == 'customRange' && !data.ltPropStartDate ){
                        if( !this.__initial_end ){
							clr();
						}	
                    }else if( __selected == 'before' && !data.ltPropBeforeCurrentDate ){
                        clr();
                    }else if( __selected == 'after' && !data.ltPropAfterCurrentDate ){
                        clr();
                    }
                }else if( __rest && /customRange/i.test( __selected ) ){
                    fn();
                }

                if( data.dateSelected ){
                    this.setData( 'dateSelected', false );
                    fn();
                }

                delete this._rest;
				delete this.__initial_start;
				delete this.__initial_end;
                data.prevSel = ''; 
                this.resetValue();
                if( data.ltPropAnimation.dropdown == 'Slide' ){
                    $L( this._cmp ).css( 'height', '' );
                }

                if( this.getMethods( 'onHide' ) ){
                    return this.executeMethod( 'onHide', arg1, arg )
                }
                
            },
            dateselected : function( event ){
                this.selected( event, true )
            },

            dateselected1 : function( event , flag ){
                this.selected( event , void 0, flag )
            },

            optSel : function( evt, dat, com, itm ){
                this.removeTempUnSelection();

                if( [ 'specificDate', 'customRange', 'before', 'after' ].indexOf( dat ) != -1 ){
                    !itm.classList.contains( 'lyteDateSelectPrevTempSelection' ) && itm.classList.add( 'lyteDateSelectTempSelection' );
                    this._prevent = true;
                    return
                }
                this.selectValue( dat );
                this.getMethods('onSelect') && this.executeMethod( 'onSelect', evt, this.$node, dat, itm );

                if( this._callonchange ){
                    var cb = "onChange";

                    /**
                      * @methods onChange
                      * @version 3.40.0
                      */

                    this.getMethods( cb ) && this.executeMethod( cb, evt, this.$node, dat, itm );
                }

                this._rest = true;
            },
            posChange : function( pos ){
                var addClass = 'removeClass'
                if( /up/i.test( pos ) ){
                    addClass = 'addClass';
                }
                $L( this._cmp )[ addClass ]( 'lyteDateselectUp' );
                $L( this._caldiv )[ addClass ]( 'lyteDateselectUp' );
            },

            startChange : function( arg ){
                var cb = 'onStartDateChanged';

                if( this.getMethods( cb ) ){
                    this.executeMethod( cb, arg );
                }
            }
        };
    }

    resetValue() {
		if( this.data.ltPropSelected != 'specificDate' ) {
			this.setData( 'ltPropCurrentDate', '' );
		}
		if( this.data.ltPropSelected != 'customRange' ){
			this.setData( 'ltPropStartDate', '' );
			this.setData( 'ltPropEndDate', '' );
		}

		if( this.data.ltPropSelected != 'before' ){
			this.setData( 'ltPropBeforeCurrentDate', '' );
		}
		if( this.data.ltPropSelected != 'after' ){
			this.setData( 'ltPropAfterCurrentDate', '' );
		}
	}

    callRevert() {
		var selected = this.data.ltPropSelected,
		calendar = this._caldiv.querySelector( '.specificDate lyte-calendar' ),
		daterange = this._caldiv.querySelector( '.customRange lyte-daterangepicker' );

		if( selected == 'customRange' ){
			daterange.revertToSelected();
			if( calendar ){
				calendar.revertToToday();
			}
		} else {
			if( selected == 'specificDate' ){
				calendar.revertToSelected();
			} else {
				if( calendar ){
					calendar.revertToToday();
				}
			}
			if( daterange ){
				daterange.revertToToday();
			}
		}
	}

    setCss(obj) {
		function rtlfunc( lft, bcr, ww ){
			if( this._dir ) {
				if( bcr ) {
					if( lft == 'right' ) {
						return ww - bcr.left;
					}
					return ww - bcr.right;
				} else if( lft == 'left' ) {
					return 'right';
				} 
			}
			return bcr ? bcr[ lft ] : 'left';
		}
		var y = window.pageYOffset || document.documentElement.scrollTop,
		body = this._caldiv, par = this._cmp,
		bbcr = body.getBoundingClientRect(),
		bcr = { left : bbcr.left, right : bbcr.right, width : bbcr.width, height : body.__height || bbcr.height }, 
		__bcr = par.getBoundingClientRect(),
		parcr = { left : __bcr.left, right : __bcr.right, width : __bcr.width, height : par.__height, top : parseFloat( par.style.top ) - y, bottom : parseFloat( par.style.top ) - y + par.__height },
		wwidth = window.innerWidth,
		x = ( window.pageXOffset || document.documentElement.scrollLeft ) * ( this._dir ? - 1: 1 ),
		selEl = par.querySelector( 'lyte-drop-item[selected = "true"]' ),
		__selBcr = selEl.getBoundingClientRect(),
		selBcr = { bottom : __selBcr.bottom - ( __bcr.top - parcr.top ) },
		arrow = selEl.querySelector( '.dateArrow' ),
		arbcr = arrow ? arrow.getBoundingClientRect() : { width : 0 },

		newLeft = rtlfunc.call( this, 'left', parcr, wwidth ) + parcr.width + arbcr.width / 2 + x,
		rgtLft = rtlfunc.call( this, 'left', parcr, wwidth ) - arbcr.width / 2 - bcr.width + x,
		newTop = par.style.top,
		newBottom = par.style.bottom,
		pos;

		if( parseFloat( newTop ) + bcr.height < selBcr.bottom + y ){
			newTop = ( y + selBcr.bottom - bcr.height ) + 'px';
		}
		if( newLeft + bcr.width < wwidth + x ) {
			pos = 'right';
		} else {
			if( rgtLft > x ){
				newLeft = rgtLft;
				pos = 'left';
			} else {
				if( wwidth - rtlfunc.call( this, 'right', parcr, wwidth ) > rtlfunc.call( this, 'left', parcr, wwidth ) ){
					pos = 'right'
				} else {
					newLeft = rgtLft;
					pos = 'left'
				}
			}
		}
		$L.fastdom.mutate( function(){
			body.style[ rtlfunc.call( this, 'left' ) ] = newLeft + 'px';
			body.style.top = newTop;
			body.style.bottom = newBottom;
			var elem = this._caldiv.getElementsByClassName( this.getClass(this.data.ltPropSelected) )[ 0 ];
			if( elem ){
				$L( elem ).css( this.getValue( 1, 'calendar', elem ) );
			}
			this.setData( 'pos', pos )
		}.bind( this ))
	}

    selected(evt, flag, flag1) {

		var data = this.data,
			selected = this.data.ltPropSelected;

		this.removeTempUnSelection();
		this.checkCurrentDate(true);

		// if( !data.ltPropButtonYield ){
			this.setData( 'ltPropDisplayValue', this.getVal( data.ltPropSelected ) );
		// }

		var cb = 'onSelect',
		cb1 = 'onChange',
		args = [ cb, evt, this.$node ]

		if(flag1 === true){
			if( selected == 'before' ){
				args.push( 'before', data.bfrAftrCurrentDate );
			}else if( selected == 'after' ){
				args.push( 'after', data.bfrAftrCurrentDate );
			}
		}else if( flag ){
			args.push( "customRange", data.ltPropStartDate, data.ltPropEndDate );
		} else{
			args.push( 'specificDate', data.ltPropCurrentDate );
		}

		if( selected == 'before' ){
			this.setData( "ltPropBeforeCurrentDate" , this.data.bfrAftrCurrentDate );
		}

		if( selected == 'after' ){
			this.setData( "ltPropAfterCurrentDate" , this.data.bfrAftrCurrentDate );
		}

		if( this.getMethods( cb ) ){
			this.executeMethod.apply( this, args ); 
		}

		if( this._callonchange  && this.getMethods( cb1 ) ){
			args.shift();
			args.unshift( cb1 );
			this.executeMethod.apply( this, args );
		}

		this._rest = true
		this._drop.toggle()
	}

    getClass(className) {
		let classMap = this.data.itemMap;

		return classMap.hasOwnProperty( className ) ? classMap[ className ] : className;
	}

    checkCurrentDate(flag) {
		var selected = this.data.ltPropSelected;

		if( flag ){
			selected == 'before' && this.setData( 'ltPropBeforeCurrentDate' , this.data.bfrAftrCurrentDate );
			selected == 'after' && this.setData( 'ltPropAfterCurrentDate' , this.data.bfrAftrCurrentDate );
		}else{
			this.setData( 'bfrAftrCurrentDate', 
						   selected =='before' ? this.data.ltPropBeforeCurrentDate : 
						   selected == 'after' ? this.data.ltPropAfterCurrentDate : '' );
		}

		
	}

    static observers() {
        return {
            selectedObs : function( arg ){

                this.hidedropdown();

                var __newvalue = arg.newValue;

                if( __newvalue && this._cmp && !this._cmp.classList.contains( 'lyteDropdownHidden' ) ) {
                     var oldAn = [ 'specificDate', 'customRange', 'before', 'after' ].indexOf( arg.oldValue ) != -1 ? this._caldiv.querySelector( '.' + this.getClass(arg.oldValue) ) : null,
                     newAn = [ 'specificDate', 'customRange', 'before', 'after' ].indexOf( arg.newValue ) != -1 ? this._caldiv.querySelector( '.' + this.getClass(__newvalue) ) : null;
                     if( newAn ) {
                        if( oldAn ) {
                            var prm = new Promise( function( res, rej ){
                                this._new = res;
                                this.hideele( oldAn );
                            }.bind( this ) );
                            Promise.resolve( prm ).then( function(){
                                $L.fastdom.mutate( this.openele.bind( this ) );
                            }.bind( this ))
                        } else{
                            this.openele()
                        }
                        this.data.prevSel = this.data.prevSel || arg.oldValue
                     }
                } else if( __newvalue && ( ( this._cmp && this._cmp.classList.contains( 'lyteDropdownHidden' ) ) || [ 'specificDate', 'customRange' ].indexOf( __newvalue ) != -1 ) ){
                    this.selectValue( __newvalue );
                } else if( !__newvalue ){
                    this.selectValue( "" );
                    this.$node.ltProp({
                        startDate : "",
                        endDate : "",
                        currentDate : ""
                    });
                }

                this._callonchange = true;

                // this.resetValue();
            }.observes( 'ltPropSelected' ),

            animation_obs : function(){
                var animation = this.data.ltPropAnimation;
                
                $L( this._caldiv )
                .removeClass( 'lyteDateselectAnimate' )
                .addClass( animation.calendar != 'Fade' ? 'lyteDateselectAnimate' : '' )
                .css( {
                    transform : "",
                    opacity : ""
                } );

                $L( this._cmp )
                .removeClass( 'lyteDateselectAnimate' )
                .addClass( animation.dropdown != 'Fade' ? 'lyteDateselectAnimate' : '' )
                .css( {
                    transform : "",
                    opacity : ""
                } );

            }.observes( 'ltPropAnimation.{}', 'ltPropAnimation' ).on( 'didConnect' ),

            currentDateObs : function(){
                this.checkCurrentDate();
            }.observes( 'ltPropBeforeCurrentDate' , 'ltPropAfterCurrentDate' ),

            calendar_obs : function( arg ){
                this._callonchange = true;
            }.observes( 'ltPropStartDate', 'ltPropEndDate', 'ltPropCurrentDate' )
        };
    }
}

LyteUiComponentComponentRegistry.registerHelper("changeClass",function( className, _this ){
	let data = [ 'customRange', 'specificDate', 'before', 'after' ];

	if( data.indexOf( className ) != -1 ){
		return (['before', 'after'].indexOf( className ) != -1 ? 'lyteDs' + className.charAt(0).toUpperCase() + className.slice(1) : className ) + " lyteDS_SecondaryOptItem";
	}else{
		return className;
	}
				
	
});
/**
 * @syntax nonYielded
 * <lyte-dateselect></lyte-dateselect>
 */

/**
 * @syntax Button Yield
 * @attribute ltPropButtonYield=true
 * <lyte-dateselect lt-prop-button-yield = true>
 * 	<template is = "registerYield" yield-name = "buttonYield">
 * 		Drop button name
 * 	</template>
 * </lyte-dateselect>
 */

/**
 * @syntax Item yield
 * @attribute ltPropItemYield=true
 * <lyte-dateselect lt-prop-item-yield = true>
 * 	<template is = "registerYield" yield-name = "item">
 * 		Item yield {{itemValue}}
 * 	</template>
 * </lyte-dateselect>
 */

/**
 * @syntax Calendar yield
 * @attribute ltPropCalendarYield=true
 * <lyte-dateselect lt-prop-calendar-yield = true>
 * 	<template is = "registerYield" yield-name = "footer">
 * 		calendar footer yield
 * 	</template>
 * </lyte-dateselect>
 */

/**
 * @syntax Footer and item yield
 * @attribute ltPropCalendarYield=true
 * @attribute ltPropItemYield=true
 * <lyte-dateselect lt-prop-calendar-yield = true lt-prop-item-yield = true>
 * 	<template is = "registerYield" yield-name = "footer">
 * 		calendar footer yield
 * 	</template>
 * 	<template is = "registerYield" yield-name = "item">
 * 		Item yield {{itemValue}}
 * 	</template>
 * </lyte-dateselect>
 */

/**
 * @syntax Footer and button yield
 * @attribute ltPropCalendarYield=true
 * @attribute ltPropButtonYield=true
 * <lyte-dateselect lt-prop-calendar-yield = true lt-prop-button-yield = true>
 * 	<template is = "registerYield" yield-name = "footer">
 * 		calendar footer yield
 * 	</template>
 * 	<template is = "registerYield" yield-name = "buttonYield">
 * 		Drop button name
 * 	</template>
 * </lyte-dateselect>
 */

/**
 * @syntax Button, item and calendar yield
 * @attribute ltPropCalendarYield=true
 * @attribute ltPropButtonYield=true
 * @attribute ltPropItemYield=true
 * <lyte-dateselect lt-prop-calendar-yield = true lt-prop-item-yield = true lt-prop-button-yield = true>
 * 	<template is = "registerYield" yield-name = "footer">
 * 		calendar footer yield
 * 	</template>
 * 	<template is = "registerYield" yield-name = "buttonYield">
 * 		Drop button name
 * 	</template>
 * 	<template is = "registerYield" yield-name = "item">
 * 		Item yield {{itemValue}}
 * 	</template>
 * </lyte-dateselect>
 */
export { LyteDateselectComponent };