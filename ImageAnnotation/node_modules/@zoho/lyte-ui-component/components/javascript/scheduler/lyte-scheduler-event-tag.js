import { appendChild } from "@slyte/component";
import { prop } from "@slyte/core";
import { Component } from "../../component.js";

class LyteSchedulerEventTagComponent extends Component {
    constructor() {
        super();
    }

    data() {
		return {
			'ltPropEvent' : prop('object',{default: {}})
		};		
	}
	didConnect() {
		var id = this.$node.dataset.id;
		var scheduler  =  $L(this.$node).closest('lyte-scheduler')[0].component;
		var events = scheduler.getData('ltPropManipulatedEvent');
		var eventData = $u.findWhere(events,{'id':id});
		var format = scheduler.getData('ltPropFormat');
		var startDate = $L.moment(eventData.start, format);
		var curr_date = $L.moment(this.$node.parentElement.dataset.date,'DD-MM-YYYY');
		var view = scheduler.getData('ltPropSchedulerView');
		var startDiv =  this.$node.parentElement;
		var isMultiView = scheduler.getData('ltPropMultiUserView');
		var _this = this;
		var event_tag  = $L('[data-id="'+ eventData.id +'"]')[0]
		var startDiv =  event_tag.parentElement;
		if( !scheduler.getData('ltPropMultiUserView')){
			_this.$node.style.position ='absolute';
			if( eventData.allDayEvent || view === 'month' ){
				_this.setSchedulerEvents(_this.$node,scheduler,eventData,format,startDiv,curr_date,isMultiView,view);
			}else{
				_this.fixTimeLineEvent(eventData,startDate,format,scheduler,view,startDiv);
			}
		}else if(view === 'day' && scheduler.getData('ltPropMultiUserView')){
			_this.$node.style.position ='absolute';
			var endDate = $L.moment(eventData.end,format);
			var start_time = startDate.format('hh') + ':00 ' + startDate.format('A');
			var end_time = endDate.format('hh') + ':00 ' + endDate.format('A');
			var user = scheduler.$node.querySelector('[data-userid="'+eventData.userid+'"]');
			var time_division = 60 / scheduler.getData('ltPropTimeLine');
			var startTimeDiv = $L('[data-time="'+ start_time +'"]',user)[0];
			if(startTimeDiv){
				var startTimeDiv_width = startTimeDiv.offsetWidth / time_division;      			        		
				if(startDate.format('DD-MM-YYYY') === scheduler.getData('startDateOfView')){
					var parent_div = user.querySelector('[data-time="'+start_time+'"]');
					var starttimeDivision = startDate.get('minutes') / scheduler.getData('ltPropTimeLine');
					if(!parent_div.contains(_this.$node)){
						parent_div.appendChild(_this.$node);
					}
					_this.$node.style.top = startTimeDiv.offsetHeight +'px';
					_this.$node.style.left = starttimeDivision * startTimeDiv_width + 'px';
				}else{
					var parent_div = user.querySelectorAll('.scheduler-event-div')[0];
					if(!parent_div.contains(_this.$node)){
						parent_div.appendChild(_this.$node);
					}
				}
				if(endDate.format('DD-MM-YYYY') === scheduler.getData('startDateOfView')){
					var endTimeDiv =user.querySelector('[data-time="'+end_time+'"]')
					_this.$node.style.width =  ( endTimeDiv.getBoundingClientRect().left - _this.$node.getBoundingClientRect().left ) +  (endDate.get('minutes') / scheduler.getData('ltPropTimeLine')  ) * startTimeDiv_width + 'px';
				}else{
					_this.$node.style.width = user.getBoundingClientRect().right -  _this.$node.getBoundingClientRect().left  + 'px';
				}
				var height = 0;
				var events = $L('lyte-scheduler-event-tag',scheduler.$node);
				var cs =  window.getComputedStyle(startTimeDiv);
				var height  = parseInt(cs.maxHeight);
				if( height < (event_tag.offsetHeight + event_tag.parentElement.offsetHeight )  ){
					var prev  = event_tag.previousElementSibling;
					if(!prev.classList.contains('schedulerhide') && ( $L('.lyteSchedulerEventMoreBtn',startTimeDiv)[0].getBoundingClientRect().bottom  < event_tag.parentElement.getBoundingClientRect().bottom) ){
						prev.classList.add('schedulerhide');
						this.hideoverlayEvents($L(prev).closest('td')[0],prev,prev,scheduler);
					}
					event_tag.classList.add('schedulerhide');
					this.hideoverlayEvents($L(event_tag).closest('td')[0],event_tag,eventData,scheduler);
				}else{
					var startDiv = this.$node.parentElement;
					this.addHeightToDate(Math.round(_this.$node.offsetWidth/startDiv.offsetWidth),event_tag.offsetHeight + parseInt(window.getComputedStyle(event_tag).marginTop),startDiv.dataset.time,user,'time',scheduler);	
				}
			}
		}else if(view == 'week'){
			_this.$node.style.position ='absolute';
			_this.setSchedulerEvents(_this.$node,scheduler,eventData,format,startDiv,curr_date,isMultiView,view);
		}else{
			var date_td = scheduler.$node.querySelector('.lyteSchedulerDate').children[0];
			var cs =  window.getComputedStyle(date_td);
			var width = _this.$node.offsetWidth;
			var height  = parseInt(cs.maxHeight);
			if( height <  ( _this.$node.getBoundingClientRect().bottom - startDiv.getBoundingClientRect().top   )   ){
				var prev  = _this.$node.previousElementSibling;
				if(!prev.classList.contains('schedulerhide') && ( $L('.lyteSchedulerEventMoreBtn',startDiv)[0].getBoundingClientRect().top) < (prev.getBoundingClientRect().bottom )){
					prev.classList.add('schedulerhide');
					this.hideoverlayEvents($L(prev).closest('td')[0],prev,prev,scheduler);
				}
				_this.$node.classList.add('schedulerhide')
				this.hideoverlayEvents(startDiv,_this.$node,eventData,scheduler);
			}
		}
		if(!_this.$node.dataset.id){
			_this.$node.dataset.id = _this.$node.getAttribute('id');
		}
	}
	fixTimeLineEvent(eventData,startDate,format,scheduler,view,startDiv){
		var endDate = $L.moment(eventData.end,format);
		var start_time = startDate.format('hh:mm A');
		var end_time = endDate.format('hh:mm A');
		var startTimeDiv =  scheduler.$node.querySelector('[data-time="'+start_time+'"]');
		var timelineInterval = scheduler.getData('ltPropTimeLine');
		if(startTimeDiv){
			var header_height = 0;
			if(view == 'day'){
				header_height = scheduler.$node.querySelector('.lyteSchedulerDayViewAllDayRow').offsetHeight;
			}
			var min = endDate.format('mm');
			var timelineMin = min % timelineInterval === 0 ? min / timelineInterval :  (min / timelineInterval) + 1 ;
			end_time = endDate.format('hh') + ":" + ("0" + timelineInterval * timelineMin).slice(-2) + ' ' + endDate.format('A');
			var endTimeDiv = scheduler.$node.querySelector('[data-time="'+end_time+'"]');
			this.$node.style.top =  startTimeDiv.getBoundingClientRect().top - startTimeDiv.offsetParent.getBoundingClientRect().top + parseInt(window.getComputedStyle(startTimeDiv.querySelector('td')).borderTopWidth) - header_height + 'px';
			this.$node.style.position = 'absolute';
			this.$node.style.height = (endTimeDiv.getBoundingClientRect().top )  - startTimeDiv.getBoundingClientRect().top - parseInt(window.getComputedStyle(endTimeDiv.querySelector('td')).borderTopWidth) + 'px';
		}

		if(startDiv.children ){
			this.setWidthForTimeLine(startDiv.children,_this.$node,startDiv,scheduler);
		}
	}
	setSchedulerEvents(event_tag,scheduler,eventData,format,startDiv,curr_date,isMultiView,view){
		var user;
		event_tag  = this.$node;
		var curr_pos = $L(event_tag).closest('.scheduler-event-div')[0];
		var startDiv =  event_tag.parentElement;
		if(view == 'week'){
			user = scheduler.$node.querySelector('[data-userid="'+eventData.userid+'"]');
			event_tag.style.top = startDiv.offsetHeight +  parseInt(window.getComputedStyle(event_tag).marginTop) +'px';
		}
		var divPosition = $L(event_tag).closest('.scheduler-event-div')[0].dataset.date;
		if(eventData.end){
			var endDate = $L.moment(eventData.end, format);
			var cs = window.getComputedStyle(event_tag);
		
			var isinBetween = scheduler.isinBetween(curr_date.format('DD-MM-YYYY'),divPosition,endDate.format('DD-MM-YYYY'));
			var date_td =  $L(event_tag).closest('.lyteSchedulerDate')[0];
			if(isinBetween){
				var cs = window.getComputedStyle(date_td);
				var interval = scheduler.getEventInterval(divPosition,endDate.format('DD-MM-YYYY')) + 1 ;
				var width = (interval * date_td.offsetWidth) - 2 * parseInt(cs.paddingRight);
				if( (width + event_tag.getBoundingClientRect().left)  > (scheduler.$node.getBoundingClientRect().left + scheduler.$node.offsetWidth) ){
					width =   (scheduler.$node.getBoundingClientRect().right) - ( event_tag.getBoundingClientRect().left) - parseInt(cs.paddingRight);
				}
				event_tag.style.top = startDiv.offsetHeight +  parseInt(window.getComputedStyle(event_tag).marginTop) + parseInt(cs.paddingTop)  + 'px';
				event_tag.style.width = ( ( width ) /  date_td.offsetWidth) * 100 + '%';

			}else{
				var width = event_tag.offsetWidth;
				event_tag.style.top = startDiv.offsetHeight +  parseInt(window.getComputedStyle(event_tag).marginTop) + parseInt(window.getComputedStyle(date_td).paddingLeft)   + 'px';
			}
		}
		event_tag.style.left = parseInt(window.getComputedStyle(date_td).paddingLeft) +'px';
		var cs =  window.getComputedStyle(curr_pos);
		var height  = parseInt(cs.maxHeight);
		if( height <  (event_tag.offsetHeight + event_tag.parentElement.offsetHeight )   && ( isMultiView || view == 'month' )  ){
			var prev  = event_tag.previousElementSibling;
			$L('.lyteSchedulerEventMoreBtn',date_td)[0].classList.remove('lyteSchedulerEventMoreBtnHide');
			if(!prev.classList.contains('schedulerhide') && ($L('.lyteSchedulerEventMoreBtn',date_td)[0].getBoundingClientRect().top - curr_pos.getBoundingClientRect().top ) <= (event_tag.parentElement.offsetHeight )){
				prev.classList.add('schedulerhide');
				this.hideoverlayEvents($L(prev).closest('td')[0],prev,prev,scheduler);
			}
			event_tag.classList.add('schedulerhide');
			this.hideoverlayEvents($L(event_tag).closest('td')[0],event_tag,eventData,scheduler);
		}else{
			this.addHeightToDate(Math.round(width/startDiv.offsetWidth),event_tag.offsetHeight + parseInt(window.getComputedStyle(event_tag).marginTop),curr_date.format('DD-MM-YYYY'),user,undefined,scheduler);
		}
	}
	addHeightToDate( interval, event_height, startDay, user ,selector, scheduler){
		var curr_date = startDay;
		var format =  scheduler.getData('ltPropFormat');
		format = (format.split(' '))[0];
		for(var index = 0; index < (interval); index++){
			user =  user ? user : $L('.lyteSchedulerViewMainTable',scheduler.$node)[0];
			selector = selector ? selector : 'date';
			var date_div = user.querySelector('[data-'+ selector +'="'+curr_date+'"]');
			if(date_div){
				date_div.style.height = date_div.getBoundingClientRect().height + event_height + 'px';
			}
			if(selector == 'date'){
				curr_date = $L.moment(startDay,format).add((index+1),"date").format(format);
			}else{
				curr_date = $L.moment(startDay,'hh:mm A').add((index+1),'hours').format('hh:mm A');
			}
		}
	}
	hideoverlayEvents(position_elem, event_div, item,scheduler){
		var bottom_event = position_elem.querySelector('.lyteSchedulerEventMoreBtn');

		if(position_elem.querySelectorAll('.schedulerhide').length){
			var map = scheduler.getData('hiddenObj') || [];
			var start_date = position_elem.children[0].dataset.date ? position_elem.children[0].dataset.date : scheduler.component.getData('startDateOfView');
			map[start_date] = map[start_date] ? map[start_date] : [];
			if(!map[start_date].includes(item)){
				map[start_date].push(item)
			}
			this.setData('hiddenObj',map)
			if(!bottom_event.children.length){
				var link_to =  document.createElement('a');
				var innerText = '+' + position_elem.querySelectorAll('.schedulerhide').length +' more';
				link_to.appendChild(document.createTextNode(innerText));
				bottom_event.appendChild(link_to);
			}else{
				var link_to = bottom_event.children[0];
				link_to.innerHTML = '';
				var innerText = '+' + position_elem.querySelectorAll('.schedulerhide').length +' more';
				link_to.appendChild(document.createTextNode(innerText));

			}
		}else{
			if(bottom_event){
				bottom_event.innerHTML = '';
			}
			
		}
	}
	setWidthForTimeLine(date_div,event_div,parent,scheduler) {
		
		var interset = [];
		var _this = this;
		for(var index = 0 ; index < date_div.length ; index++){
			if(date_div[index] !== event_div && this.isTimeOverlap(date_div[index],event_div)){
				var z_index = date_div[index].style.zIndex ? date_div[index].style.zIndex : 1;
				event_div.style.zIndex = ++z_index;
				interset.push(date_div[index]);
			}
		}
		interset.push(event_div);
		var prevElem;
		var prevSetted = {};
		interset.forEach(function(event,index){
			var width =  'calc(' + 100 / interset.length + '% - '+( 5 + (5/interset.length))+'px)';
			if(index == ( interset.length - 1 )){
				interset[index].style.right = '5px';
			}
			event.style.width = width;
			event.style.left = prevElem ? (prevElem.offsetLeft + prevElem.offsetWidth + 5 +'px') : 5 +'px';
			prevElem = event;
			var SettedEvent = $L('lyte-scheduler-event-tag[lyte-rendered]',scheduler.$node);
			for(var index = 0; index< SettedEvent.length ; index++){
				if(SettedEvent[index] !== event_div && SettedEvent[index] !== event && _this.isTimeOverlap(event, SettedEvent[index]) && !interset.includes(SettedEvent[index])){
					prevSetted[event.dataset.id] = prevSetted[event.dataset.id] ? prevSetted[event.dataset.id] : [];
					prevSetted[event.dataset.id].push(SettedEvent[index]);
				}
			}
			
		})
		this.ResetWidth(prevSetted, scheduler);
	}
	ResetWidth(prevSetted, scheduler){
		var keys = Object.keys(prevSetted);
		for(var index = 0 ; index < keys.length; index++){
			var interset = $L('[data-id="'+ keys[index] +'"]',scheduler.$node)[0];
			var events = prevSetted[keys[index]];
			var related =  interset;
			var precentage = ( interset.offsetWidth / interset.parentElement.offsetWidth ) * 100;
			for(var _index = 0 ; _index < events.length; _index++){
				var event = events[_index];
				event.style.left =  related.offsetLeft + related.offsetWidth + 5 + 'px';
				event.style.width = 'calc(' + (100 - precentage)/ events.length + '% - '+ ( 5 + 5 /(events.length+1) ) + 'px)';
				related = event;
			}
		}
		
	}
	isTimeOverlap(item,event_div){
		var item_offset = item.getBoundingClientRect();
		var event_offset = event_div.getBoundingClientRect();
		if((item_offset.top <= event_offset.top && item_offset.bottom >= event_offset.top)  || 
			(event_offset.bottom >= item_offset.top && event_offset.bottom <= item_offset.bottom) ){
			return true;
		}
	}
    static actions() {
        return {
            // Functions for event handling
        };
    }

    static methods() {
        return {
            // Functions which can be used as callback in the component.
        };
    }
}

export { LyteSchedulerEventTagComponent };
