import { prop } from "@slyte/core";
import { Component, LyteUiComponentComponentRegistry } from "../../component.js";
import $L from "@zoho/lyte-dom";

class LyteAnnotatorItemComponent extends Component {
    constructor() {
        super();
    }

    init() {
		var __data = this.data,
		opacity,
		item = __data.ltPropItem;

		__data.className =  '.' + this.$node.className.split( ' ' )[ 0 ];
		if( opacity = ( __data.opacity = item.opacity ) ){
			this.update_opacity();
			__data.sliderArr[ 0 ].value = opacity.value;
		}

		if( __data.type == "font" ){
			var values = item.values;

			this.setData({
				fontMin : values[ 0 ],
				fontMax : $L( values ).get( -1 )
			});
		}

		this.check_selected( item.selected );
	}

    check_selected(selected) {
		var arr,
		__data = this.data,
		ns = "values";

		switch( __data.type ){
			case 'fill' : 
			case 'stroke' : {
				ns = "colors";
			}	
			break;
		}

		arr = __data.ltPropItem[ ns ];

		( arr || [] ).forEach( function( item ){
			var __value = item.value;
			
			if( __value == selected || ( !selected && __value == "none" ) ){
				this.active( item );
			}
		}.bind( this ) );
	}

    get_style(selected) {
		if( selected ){
			switch( this.data.type ){
				case 'fill' : 
				case 'stroke' : 
				case 'color' : {
					return 'background:' + selected;
				}
				break;
				case 'border' : {
					return 'border-top-width:' + selected + 'px';
				}
				case 'dashed' : {
					return 'border-top-width:' + parseFloat( selected.split( ',' )[ 0 ] ) / 2 + 'px';
				}
				break;
			}
		} 
		return "";
	}

    update_opacity() {
		var __data = this.data,
		opacity = __data.opacity.value,
		selected = __data.ltPropItem.selected;

		this.setData( 'opacityStyle', ( selected ? 'background:' + selected + ";" : "" ) + ( "opacity:" + opacity + ";" ) );
	}

    data() {
		var boolean = 'boolean',
		object = 'object',
		string = 'string',
		boolean = 'boolean',
		array = 'array',
		number = 'number';

		return {
			ltPropItem : prop( object ),
			className : prop( string ),
			show : prop( boolean ),
			hasSubmenu : prop( boolean, true ),
			opacity : prop( object ),
			itemClass : prop( string ),
			itemStyle : prop( string ),
			showElem : prop( string ),
			opacityStyle : prop( string ),
			opacityDisable : prop( string ),

			refresh : prop( boolean, false ),

			type : prop( string ),

			active : prop( object ),

			sliderArr : prop( array, { default : [{
				value : 0
			}] } ),

			fontMin : prop( number ),
			fontMax : prop( number )
		};		
	}

    toggle(ns) {
		$L( this.$node ).parent()[ ns + 'Class' ]( 'lyteAnnotatorPopOpened' );
	}

    active(item) {
		var prev = this.data.active,
		Lo = this.$addon.objectUtils;

		if( prev ){
			Lo( prev, 'add', 'active', '' );
		}

		Lo( item, 'add', 'active', 'lyteEditorAnnotatorActive' );

		this.setData( 'active', item );
	}

    static actions() {
        return {
            applyfill : function( item ){
                this.executeMethod( 'onApply', item );
                this.active( item );
                return false;
            }
        };
    }

    static methods() {
        return {

            beforeSelect : function(){
                var __data = this.data,
                newValue;

                if( __data.type == "font" ){
                    newValue = __data.ltPropItem.selected;
                    this.throwEvent( 'fontSelect' );
                } else {
                    newValue = __data.opacity.value;
                }

                this.__value = newValue;
            },

            select : function( hand, value ){
                var prev = this.__value,
                cur = value.value,
                __data = this.data,
                item = __data.ltPropItem,
                is_text = __data.type == "font";

                if( prev == void 0 ){
                    if( is_text ){
                        prev = item.selected;
                        this.throwEvent( 'fontSelect' );
                    } else {
                        prev = __data.opacity.value;
                    }
                }

                if( is_text ){
                    cur += ( item.suffix || "px" );
                }

                if( prev == cur ){
                    return;
                }

                this.throwEvent( 'opacityUpdate', __data.type, prev, cur );
                delete this.__value;
            },

            change : function( hand, value ){
                var data = this.data,
                prev = data.opacity,
                cur = value.value,
                __type = data.type,
                is_text = __type == "font",
                ns = "opacity";

                if( prev == cur ){
                    return;
                }

                if( is_text ){
                    ns = 'font';
                } else {
                    this.$addon.objectUtils( data.opacity, 'add', 'value', cur );
                }

                this.throwEvent( ns + 'Change', __type, cur );
            },

            beforeShow : function(){
                this.toggle('add' );
            },

            beforeClose : function(){
                this.toggle('remove' );
            },

            show : function(){
                window.requestAnimationFrame( function(){
                    this.setData( 'refresh', true );
                }.bind( this ) );
            }
        };
    }

    static observers() {
        return {
            obs : function(){
                var __data = this.data,
                selected = __data.ltPropItem.selected,
                op_class = 'lyteAnnotatorOpacityDisabled';

                this.setData( {
                    itemClass : 'lyteAnnotatorInnerSpan' + ( __data.hasSubmenu ? ' lyteAnnotatorHasSubMenu' : '' ) + ( selected ? ' lyteAnnotatorSelected' : '' ),
                    itemStyle : this.get_style( selected ),
                    opacityDisable :  selected ? '' : op_class
                });

                $L( this.$node )[ ( selected ? 'remove' : 'add' ) + 'Class' ]( op_class );

                if( __data.opacity ) {
                    this.update_opacity();
                }

                if( __data.type == 'font'&& selected  ){
                    this.$addon.objectUtils( __data.sliderArr[ 0 ], 'add', 'value', parseFloat( selected ) )
                }

            }.observes( 'ltPropItem.selected' ).on( 'init' ),

            opacity_obs : function( arg ){
                var data = this.data.sliderArr[ 0 ],
                __new = arg.newValue;

                if( data != __new ){
                    this.$addon.objectUtils( data, 'add', 'value', parseFloat( __new ) );
                }

                this.update_opacity();
                this.setData( 'refresh', true );
            }.observes( 'opacity.value' )
        };
    }
}

LyteUiComponentComponentRegistry.registerHelper( 'lyteAnnotatorColor', function( item, is_active ){
	return 'lyteAnnotatorColorContainer ' + ( is_active ? is_active + ' ' : '' ) + 'lyteAnnotator_' + item.name.replace( /\s/g, '_' ).toLowerCase();
});

LyteUiComponentComponentRegistry.registerHelper( 'lyteAnnotatorOther', function( item, is_active ){
	return 'lyteAnnotator' + this.$node.component.data.type + 'Container ' + ( is_active ? is_active + ' ' : '' ) + 'lyteAnnotator_' + ( item.name || '' ).replace( /\s/g, '_' ).toLowerCase();
});

LyteUiComponentComponentRegistry.registerHelper( 'lyteAnnotatorStyle', function( item ){
	return this.$node.component.get_style( item.value );
});
export { LyteAnnotatorItemComponent };
