import { prop } from "@slyte/core";
import { Component, objectUtils } from "@slyte/component";
import $L from "@zoho/lyte-dom";

class LyteDateFilterComponent extends Component {
    constructor() {
        super();
    }

    init() {
		var __data = this.data;
		__data.isSearch = Object.keys( __data.ltPropOptions ).length >= __data.ltPropSearchCount;
		__data.hideFirst = __data.hideSecond = 'lyteSearchHidden';

		if(window._lyteUiUtils.lyteUiIsEmpty(__data.ltPropCondition)){
			this.setData( 'ltPropCondition', { input : "", start : -Infinity, end : Infinity, isNeg : false, isValid : false, value : "", label : "", type : "date" } );
		}else{
			this.updateInitialConditions();
		}
	}

    updateInitialConditions() {

		let condition = this.data.ltPropCondition;

		this.setData( 'ltPropTempCondition', condition );
		this.setData( 'selected', condition.value );
		
		if( this.data.renderFirst ){ this.setData( 'first', condition.start ) }
		if( this.data.renderSecond ){ this.setData( 'second', condition.end ) }
		
	}

    data() {
		var __string = "string",
		__array = "array",
		__object = "object",
		__boolean = "boolean",
		__number = 'number';

		return {
			ltPropCondition : prop( __object ),
			ltPropTempSelected : prop( __object ),
			ltPropPlaceholder : prop( __string, { default : "None" } ),
			ltPropOptions : prop( __object, { default : {
				today : window._lyteUiUtils.i18n( 'today', 'listview.filter', "Today" ),
				till_yesterday : window._lyteUiUtils.i18n( 'till.yesterday', 'listview.filter', "Till yesterday" ),
				unscheduled : window._lyteUiUtils.i18n( 'unscheduled', 'listview.filter', "Unscheduled" ),
				yesterday : window._lyteUiUtils.i18n( 'yesterday', 'listview.filter', "Yesterday" ),
				tomorrow : window._lyteUiUtils.i18n( 'tomorrow', 'listview.filter', "Tomorrow" ),
				next_7_days : window._lyteUiUtils.i18n( 'next.7.days', 'listview.filter', "Next 7 days" ),
				this_week : window._lyteUiUtils.i18n( 'this.week', 'listview.filter', "This week" ),
				this_month : window._lyteUiUtils.i18n( 'this.month', 'listview.filter', "This month" ),
				last_week : window._lyteUiUtils.i18n( 'last.week', 'listview.filter', "Last week" ),
				last_month : window._lyteUiUtils.i18n( 'last.month', 'listview.filter', "Last month" ),
				is : window._lyteUiUtils.i18n( 'is', 'listview.filter', "Is" ),
				is_not : window._lyteUiUtils.i18n( 'not.is', 'listview.filter', "Is not" ),
				between : window._lyteUiUtils.i18n( "between", "listview.filter", "Between" ),
				less_than : window._lyteUiUtils.i18n( 'less.than', 'listview.filter', "Less than" ),
				greater_than : window._lyteUiUtils.i18n( 'greater.than', 'listview.filter', "Greater than" ),
				less_than_or_equal : window._lyteUiUtils.i18n( "less.than.or.equal", "listview.filter", "Less than or equal" ),
				greater_than_or_equal : window._lyteUiUtils.i18n( "greater.than.or.equal", "listview.filter", "Greater than or equal" ),
				not_between : window._lyteUiUtils.i18n( "not.between", "listview.filter", "Not between" ),
				is_empty : window._lyteUiUtils.i18n( "is.empty", "listview.filter", "Is empty" ),
				is_not_empty : window._lyteUiUtils.i18n( "is.not.empty", "listview.filter", "Is not empty" )
			} } ),

			ltPropFormat : prop( __string, { default : "MM-DD-YYYY" } ),
			ltPropNoMatch : prop( __string, { default : window._lyteUiUtils.i18n( 'no.results.found', void 0, 'No Results Found' ) } ),

			ltPropSearchCount : prop( __number, { default : 8 } ),

			ltPropReset : prop( __boolean, { default : false } ),

			selected : prop( __string, { default : "" } ),
			renderFirst : prop( __boolean ),
			renderSecond : prop( __boolean ),
			display : prop( __string ),
			noResult : prop( __boolean ),

			isSearch : prop( __boolean ),

			first : prop( __string, { default : "" } ),
			second : prop( __string, { default : "" } ),
			isNeg : prop( __boolean, { default : false } ),
			hideFirst : prop( __string ),
			hideSecond : prop( __string )
		};		
	}

    update_value(startValue, endValue) {
		var __data = this.data,
		condition = __data.ltPropTempCondition,
		moment = $L.moment(),
		fns = {},
		Lc = objectUtils,
		selected = __data.selected,
		inf = Infinity,
		isValid = !!selected,
		input = "",
		__format = __data.ltPropFormat;

		// var returned_obj = this.temp( startValue, endValue, selected , __format );
		var returned_obj = window._lyteUiUtils.dateFilterValue( startValue, endValue , selected , __format );

		startValue = returned_obj.start;
		endValue = returned_obj.end;
		isValid = returned_obj.isValid;
		input = returned_obj.input;

		// switch( selected ){
		// 	case 'is' : 
		// 	case 'is_not' : {
		// 		moment = $L.moment( new Date( startValue ) )
		// 		input = "{{start}}";
		// 	}
		// 	case 'today' : {
		// 		fns.end = [ { name : "endOf", args : [ 'day' ] } ];
		// 		fns.start = [ { name : "startOf", args : [ 'day' ] } ];
		// 	}
		// 	break;
		// 	case 'till_yesterday' : {
		// 		fns.end = [ 
		// 			{ name : "startOf", args : [ 'day' ] },
		// 			{ name : "subtract", args : [ 1, 'milliseconds' ] } 
		// 		];
		// 	}
		// 	break;
		// 	case 'yesterday' : {
		// 		fns.end = [ 
		// 			{ name : "startOf", args : [ 'day' ] },
		// 			{ name : "subtract", args : [ 1, 'milliseconds' ] } 
		// 		];

		// 		fns.start = [ { name : "startOf", args : [ 'day' ] } ];

		// 	}
		// 	break;
		// 	case 'tomorrow' : {
		// 		fns.start = [ 
		// 			{ name : "endOf", args : [ 'day' ] },
		// 			{ name : "add", args : [ 1, 'milliseconds' ] } 
		// 		];

		// 		fns.end = [ { name : "endOf", args : [ 'day' ] } ];
		// 	}
		// 	break;
		// 	case 'next_7_days' : {
		// 		fns.start = [ 
		// 			{ name : "endOf", args : [ 'day' ] },
		// 			{ name : "add", args : [ 1, 'milliseconds' ] } 
		// 		];

		// 		fns.end = [ { name : "add", args : [ 7, 'day' ] } ];
		// 	}
		// 	break;
		// 	case 'this_week' : {
		// 		fns.start = [ 
		// 			{ name : "startOf", args : [ 'week' ] }
		// 		];
				
		// 		fns.end = [ { name : "endOf", args : [ 'week' ] } ];
		// 	}
		// 	break;
		// 	case 'this_month' : {
		// 		fns.start = [ 
		// 			{ name : "startOf", args : [ 'month' ] }
		// 		];
				
		// 		fns.end = [ { name : "endOf", args : [ 'month' ] } ];
		// 	}
		// 	break;
		// 	case 'last_week' : {
		// 		fns.end = [ 
		// 			{ name : "startOf", args : [ 'week' ] },
		// 			{ name : "subtract", args : [ 1, 'milliseconds' ] } 
		// 		];
				
		// 		fns.start = [ { name : "startOf", args : [ 'week' ] } ];
		// 	}
		// 	break;
		// 	case 'last_month' : {
		// 		fns.end = [ 
		// 			{ name : "startOf", args : [ 'month' ] },
		// 			{ name : "subtract", args : [ 1, 'milliseconds' ] } 
		// 		];
				
		// 		fns.start = [ { name : "startOf", args : [ 'month' ] } ];
		// 	}
		// 	break;
		// 	case 'less_than' : {
		// 		moment = $L.moment( new Date( startValue ) )
		// 		fns.end = [ { name : "subtract", args : [ 1, 'milliseconds' ] } ];
		// 		startValue = -inf;

		// 		input = "< {{start}}";
		// 	}
		// 	break;
		// 	case 'greater_than' : {
		// 		moment = $L.moment( new Date( startValue ) )
		// 		fns.end = [ { name : "add", args : [ 1, 'seconds' ] } ];
		// 		endValue = inf;
		// 		input = "> {{start}}";
		// 	}
		// 	case 'less_than_or_equal' : {
		// 		endValue = startValue;
		// 		startValue = -inf;
		// 		input = "<= {{start}}";
		// 	}
		// 	break;
		// 	case 'greater_than_or_equal' : {
		// 		endValue = inf;
		// 		input = " >= {{start}}";
		// 	}
		// 	break;
		// 	case 'between' : 
		// 	case 'not_between' : {
		// 		if( !( isValid = ( startValue != -inf && endValue != inf ) ) ){
		// 			moment = $L.moment( new Date( 'invalid' ) );
		// 		}
		// 		input = "{{start}} < && {{end}} >";
		// 	}
		// 	break;
		// }

		// if( !moment.validate() ){
		// 	startValue = startValue == -inf ? -inf : startValue;
		// 	endValue = endValue == inf ? inf : endValue;
		// 	isValid = false;
		// } else {
		// 	for( var key in fns ){
		// 		var __value = fns[ key ],
		// 		__length = __value.length,
		// 		final;

		// 		for( var i = 0; i < __length; i++ ){
		// 			var __cur = __value[ i ];
		// 			 moment[ __cur.name ].apply( moment, __cur.args );
		// 		}

		// 		final = moment.format();

		// 		if( key == 'start' ){
		// 			startValue = final;
		// 		} else {
		// 			endValue = final;
		// 		}

		// 		input = input.replace( '{{' + key + "}}", moment.format( __format ) );
		// 	}
		// }

		Lc( condition, 'add', 'start', startValue );
		Lc( condition, 'add', 'end', endValue );
		Lc( condition, 'add', 'isValid', isValid );
		Lc( condition, 'add', 'input', input );
		Lc( condition, 'add', 'class', condition.isValid ? 'lyteListFilterSelected' : '' );
	}

    static methods() {
        return {
            search : function( arg ){
                this.setData( 'noResult', arg.length == 0 );
            }
        };
    }

    static observers() {
        return {
            condn_obs : function( arg ){
                this.setData( 'selected', arg.newValue.value || "" );
            }.observes( 'ltPropCondition' ),

            reset_obs : function( arg ){
                if( arg.newValue ){
                    this.setData( arg.item, false );
                    this.setData( 'selected', "" );
                }
            }.observes( 'ltPropReset' ),

            selected_obs : function( arg ){
                var selected = arg.newValue,
                renderFirst = false,
                renderSecond = false,
                isNeg = false,
                display = selected ? "${" + selected.toUpperCase() + "}" : "",
                __data = this.data,
                hiddenclass = 'lyteSearchHidden',
                condition = __data.ltPropTempCondition,
                Lc = objectUtils,
                inf = Infinity,
                ns = "lyteDateFilter_";

                $L( this.$node ).addClass( ns + selected ).removeClass( ns + arg.oldValue );

                switch( selected ){
                    case 'is' : {
                        renderFirst = true;
                        display = "";
                    }
                    break;
                    case 'is_not' : {
                        renderFirst = true;
                        isNeg = true;
                        display = "";
                    }
                    break;
                    case 'is_empty' : {
                        isNeg = true;
                    }
                    break;
                    case 'between' : {
                        renderFirst = renderSecond = true;
                        display = "";
                    }
                    break;
                    case 'not_between' : {
                        isNeg = renderFirst = renderSecond = true;
                        display = "";
                    }
                    break;
                    case 'less_than' :
                    case 'greater_than' :
                    case 'less_than_or_equal' :
                    case 'greater_than_or_equal' : {
                        renderFirst = true;
                        display = "";
                    }
                    break;
                    case 'in_the_last' : {
                        window.render_drop = true;
                        display = "";
                    }
                    break;
                }

                Lc( condition, 'add', 'start', -inf );
                Lc( condition, 'add', 'end', inf );
                Lc( condition, 'add', 'isValid', false );
                Lc( condition, 'add', 'class', '')

                this.setData({
                    renderFirst : renderFirst ,
                    renderSecond : renderSecond ,
                    display : display,
                    first : "",
                    second : "",
                    hideFirst : renderFirst ? '' : hiddenclass,
                    hideSecond : renderSecond ? '' : hiddenclass
                });

                if( display ){
                    this.update_value( -inf, inf );
                }

                Lc( condition, 'add', 'isNeg', isNeg );
                Lc( condition, 'add', 'type', 'date' );

                Lc( condition, 'add', 'value', selected );
                Lc( condition, 'add', 'label', __data.ltPropOptions[ selected ] || "" );

            }.observes( 'selected' ),

            start_end_obs : function( arg ){
                var item = arg.item,
                value = arg.newValue,
                __data = this.data,
                format = __data.ltPropFormat,
                condition = __data.ltPropTempCondition,
                inf = Infinity,
                is_first = item == "first",
                newValue = is_first ? -inf : inf;

                if( __data.display ){
                    return;
                }

                if( value ){
                    var moment = $L.moment( value, format );

                    if( moment.validate() ){
                        newValue = moment.format();
                    }
                }

                this.update_value( is_first ? newValue : condition.start, is_first ? condition.end : newValue );
            }.observes( 'first', 'second' )
        };
    }
}

export { LyteDateFilterComponent };
