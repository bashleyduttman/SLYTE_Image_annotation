import {LyteListviewUtilsMixin} from "/mixins/lyte-listview-utils.js"
import { prop } from "@slyte/core";
import { Component, LyteUiComponentComponentRegistry } from "../../../component.js";
import $L from "@zoho/lyte-dom";

class LyteListviewComponent extends Component {
    constructor() {
        super();
    }

    modify_content(arr, ignore) {
		var final = [],
		obj,
		__data = this.data,
		__fake_data = __data.fakeHeaderData,
		fake_enabled = __data.ltPropSubHeaders,
		overall = 0;

		arr.forEach( function( item ){
			final.push( obj = {} );
			obj.data = item;

			var __column = item.columns;

			if( __column ){
				obj.columns = this.modify_content( __column, true );

				var sum = 0,
				min_sum = 0;

				if( !ignore ){
					__column.forEach( function( __item ){
						var __minWidth = __item.minWidth,
						__width = Math.max( __item.width, __minWidth );

						sum += __width;
						min_sum += __minWidth;
					});

					if( fake_enabled ){
						__fake_data.push( {
							width : sum,
							minWidth : min_sum,
							data : item,
							hasChildren : true
						});
					}
					overall += sum;
				}
			} else if( !ignore ){
				var __minWidth = item.minWidth,
				__width = Math.max( item.width, __minWidth );

				overall += __width;

				if( fake_enabled ){
					__fake_data.push({
						width : __width,
						minWidth : __minWidth,
						data : item
					});
				}
			}

		}.bind( this ));

		if( !ignore ){
			this.setData( 'overallWidth', overall + 'px' );
		}

		return final;
	}

    init(ignore_header) {
		var __data = this.data,
		fn = this.modify_content.bind( this );

		if( __data.ltPropPagination ){
			var perpage = __data.ltPropPerpage,
			content = __data.ltPropContent.length;
			__data.pageLimit = Math.ceil( content / perpage );
		} else {
			__data.renderContent = __data.ltPropContent;
		}

		if( !ignore_header ){
			var new_header = fn( __data.ltPropHeader );

			this.reset_content_boolean();
			this.setData( 'headerData', new_header );
		}

		this.currentPage();
	}

    reset_content_boolean() {
		var __data = this.data,
		headerData = __data.ltPropHeader,
		final = [];

		__data.ltPropContent.forEach( function(){
			var row_data = [];
			headerData.forEach( function( item ){
				var columns = item.columns;
				if( columns ){
					var __inn = [];

					columns.forEach( function(){
						__inn.push( false );
					});

					row_data.push( __inn );
				} else {
					row_data.push( false );
				}
			});
			final.push( row_data );

		});

		this.setData( 'renderingBoolean', final );
	}

    reset(index) {
		var __data = this.data,
		renderingBoolean = __data.renderingBoolean,
		row_data = [];

		__data.headerData.forEach( function( item ){
			var columns = item.columns;
			if( columns ){
				var __inn = [];

				columns.forEach( function(){
					__inn.push( false );
				});

				row_data.push( __inn );
			} else {
				row_data.push( false );
			}
		});

		this.$addon.arrayUtils( renderingBoolean, 'replaceAt', index, [ row_data ] );
	}

    data() {

		var __array = "array",
		__string = "string",
		__boolean = "boolean",
		__object = "object",
		__number = "number";

		return {
			ltPropContent : prop( __array, { default : [] } ),
			ltPropHeader : prop( __array, { default : [] } ),
			ltPropColumnLazyLoading : prop( __boolean, { default : false } ),
			ltPropTable : prop( __object, { default : { 
					infiniteScroll : true,
					preventScrollbar : false, 
					contentLength : 10,
					stickyTable : true
				}
			}),

			ltPropData : prop( __array, { default : [] } ),
			ltPropSelected : prop( __array, { default : [] } ),
			ltPropSubHeaders : prop( __boolean, { default : false } ),
			ltPropPagination : prop( __boolean, { default : false } ),

			ltPropDisplayMessage : prop( __string, { default : "Showing {0} - {1} of {2}" } ),

			ltPropPerpage : prop( __number, { default : 5 } ),

			fakeHeaderData : prop( __array, { default : [] } ),
			overallWidth : prop( __string, { default : "auto" } ),

			headerData : prop( __array, { default : [] } ),
			renderingBoolean  : prop( __array, { default : [] } ),

			checkAll : prop( __boolean, { default : false } ),
			pageLimit : prop( __number, { default : 1 } ),
			currentPage : prop( __number, { default : 1 } ),
			startRecord : prop( __number, { default : 0 } ),
			endRecord : prop( __number, { default : 0 } ),

			disableLeft : prop( __boolean, { default : true } ),
			disableRight : prop( __boolean, { default : false } ),

			renderTable : prop( __boolean, { default : true } )
		};		
	}

    fix_unfix(cell, __add) {
		var __index = parseInt( cell.getAttribute( 'index' ) ),
		__elem = this.$node.getElementsByClassName( 'lyteListFakeHeader' )[ 0 ];

		__elem.children[ __index ].classList[ __add ]( 'lyteListFixed' );
	}

    static methods() {
        return {
            fix : function( cell ){
                this.fix_unfix( cell, 'add' );
            },

            unfix : function( cell ){
                this.fix_unfix( cell, 'remove' );
            },

            onHeaderCheck : function( input, comp, evt ){
                var lyteSelf = this;
                if( this.__ignore ){
                    return;
                }
                if( evt && evt.type ){
                    var __data = this.data,
                    content = __data.ltPropContent,
                    selected = __data.ltPropSelected;

                    content.forEach( function( item, index ){
                        if( !item.checked ){
                            lyteSelf.$addon.objectUtils( item, 'add', 'checked', true );

                            var __index = selected.indexOf( index );
                            if( __index == -1 ){
                                lyteSelf.$addon.arrayUtils( selected, 'push', index );
                            }
                        }
                    }.bind( this ));
                }
            },

            onHeaderUnCheck : function( input, comp, evt ){
                var lyteSelf = this;
                if( this.__ignore ){
                    return;
                }
                if( evt && evt.type ){
                    var __data = this.data,
                    content = __data.ltPropContent,
                    selected = __data.ltPropSelected;

                    content.forEach( function( item, index ){
                        if( item.checked ){
                            lyteSelf.$addon.objectUtils( item, 'add', 'checked', false );
                            
                            var __index = selected.indexOf( index );
                            if( __index + 1 ){
                                lyteSelf.$addon.arrayUtils( selected, 'removeAt', __index );
                            }
                        }
                    }.bind( this ));
                }
            },

            onCheck :  function( input, comp, evt ){
                var node = comp.$node,
                __data = this.data,
                selected = __data.ltPropSelected,
                cell = node.closest( 'lyte-td' ),
                rowIndex = parseFloat( cell.getAttribute( "row-index" ) ) + __data.startRecord - 1;

                if( selected.indexOf( rowIndex ) == -1 ){
                    this.$addon.arrayUtils( selected, 'push', rowIndex );
                }

                if( selected.length == __data.ltPropContent.length ){
                    this.__ignore = true;
                    this.setData( 'checkAll', true );
                    delete this.__ignore;
                }
            },

            onUnCheck : function( input, comp, evt ){
                var node = comp.$node,
                __data = this.data,
                selected = __data.ltPropSelected,
                cell = node.closest( 'lyte-td' ),
                rowIndex = parseFloat( cell.getAttribute( "row-index" ) ) + __data.startRecord - 1,
                __index = selected.indexOf( rowIndex );

                ( __index + 1 ) && this.$addon.arrayUtils( selected, 'removeAt', __index );

                var cell_index = parseFloat( cell.getAttribute( 'index' ) );
                this.__ignore = true;
                this.setData( 'checkAll', false );
                delete this.__ignore;
            }	
        };
    }

    resize_move(evt) {
		this.__moved = true;

		var clientX = evt.clientX,
		cell = this.__cell,
		xInc = clientX - this.__clientX,
		__index = parseInt( cell.getAttribute( 'index' ) ),
		fake_cell,
		list,
		fake_data = this.data.fakeHeaderData[ __index ],
		cells = Array.from( this.$node.getElementsByTagName( 'lyte-th' ) ).filter( function( item ){
			return parseInt( item.getAttribute( 'index' ) ) == __index;
		}),
		call_raf,
		__bcr = this.$node.getBoundingClientRect(),
		is_rtl = window._lyteUiUtils.getRTL(),
		scroll_elem = this.$node.getElementsByClassName( 'lyteTableScroll' )[ 0 ],
		table = scroll_elem.parentNode.component;

		if( cell.classList.contains( 'lyteListFakeCell' ) ){
			fake_cell = cell;
			if( fake_data.hasChildren ){
				list = cells;
			} else {
				cell = cells[ 0 ];
			}
		} else {
			fake_cell = this.$node.getElementsByClassName( 'lyteListFakeHeader' )[ 0 ].children[ __index ];
		}

		if( xInc > 0 && Math.abs( clientX - ( __bcr[ is_rtl ? 'left' : 'right' ] - ( table._rightFixedWidth || 0 ) ) ) <= 1 ){
			call_raf = 1;
		} else if( xInc < 0 && Math.abs( clientX - ( __bcr[ is_rtl ? 'right' : 'left' ] + ( table._fixedWidth || 0 ) ) ) <= 1 ){
			call_raf = -1;
		}

		var fn = function( __cell ){
			var __style = __cell.style,
			__minWidth = parseFloat( __style.minWidth ),
			__maxWidth = parseFloat( __style.maxWidth ),
			__width = parseFloat( __style.width ),
			__newWidth = __width + xInc;

			if( __newWidth > __maxWidth ){
				xInc = __width - __maxWidth;
				__newWidth = __maxWidth;
			}

			if( __newWidth < __minWidth ){
				xInc =  __minWidth - __width;
				__newWidth = __minWidth;
			}

			return __newWidth;
		},
		raf = window.requestAnimationFrame,
		sL = scroll_elem ? scroll_elem.scrollLeft : 0;

		if( list ){
			cells.forEach( fn );

			var new_inc = xInc / cells.length;

			cells.forEach( function( item ){
				var __style = item.style;
				__style.width = ( parseFloat( __style.width ) + new_inc ) + 'px';
			});
		} else {
			cell.style.width = fn( cell ) + 'px';
		}

		fake_cell.style.width = ( parseFloat( fake_cell.style.width ) + xInc ) + 'px';
		this.setData( 'overallWidth', parseFloat( this.data.overallWidth ) + xInc + 'px' );

		window.cancelAnimationFrame( this._raf );

		if( call_raf ){
			scroll_elem.scrollLeft = sL + 10 * call_raf;
			this._raf = raf( this.resize_move.bind( this, { clientX : clientX } ) );

			clientX -= ( 10 * call_raf );
		}

		this.__clientX = clientX;
	}

    resize_up(evt) {
		var doc = document,
		__remove = "removeEventListener",
		isTch = evt.type == "touchend";

		doc[ __remove ]( isTch ? 'touchmove' : 'mousemove', this.__move, true );
		doc[ __remove ]( isTch ? 'touchend' : 'mouseup', this.__up, true );

		if( this.__moved ){
			var cb = "onResizeEnd";
			this.getMethods( cb ) && this.executeMethod( cb, evt, this.__cell );

			window.cancelAnimationFrame( this._raf );
			delete this._raf;
			delete this.__moved;
		}

		delete this.__clientY;
		delete this.__cell;
		delete this.__move;
		delete this.__up;
	}

    currentPage() {
		var __data = this.data,
		__new = __data.currentPage,
		left = false,
		right = false,
		perpage = __data.ltPropPerpage,
		finishedCount = ( __new - 1 ) * perpage,
		table = this.$node.getElementsByTagName( 'lyte-table' )[ 0 ];

		if( __new == 1 ){
			left = true;
		} else if( __new == __data.pageLimit ) {
			right = true;
		}

		table && table.scrollTable( 0, 0 );

		this.setData({
			disableLeft : left,
			disableRight : right,
			startRecord : finishedCount + 1,
			endRecord : Math.min( finishedCount + perpage, __data.ltPropContent.length )
		});
	}

    static actions() {
        return {

            first : function(){
                this.setData( 'currentPage', 1 );
            },

            last : function(){
                this.setData( 'currentPage', this.data.pageLimit );
            },

            prev : function(){
                this.setData( 'currentPage', this.data.currentPage - 1 );
            },

            next : function(){
                this.setData( 'currentPage', this.data.currentPage + 1 );
            },

            resize : function( evt ){
                var target = evt.target,
                doc = document,
                __add = "addEventListener",
                isTch = evt.type == "touchstart",
                cb = "onResizeSelect";

                if( this.getMethods( cb ) && this.executeMethod( cb, evt, this.__cell ) == false ){
                    return;
                }

                this.__clientX = evt.clientX;
                this.__clientY = evt.clientY;

                this.__cell = target.closest( 'lyte-th,.lyteListFakeCell' );

                doc[ __add ]( isTch ? 'touchmove' : 'mousemove', this.__move = this.resize_move.bind( this ), true );
                doc[ __add ]( isTch ? 'touchend' : 'mouseup', this.__up = this.resize_up.bind( this ), true );

                evt.preventDefault();
            },

            rowUpdate : function( index ){
                var tbody = this.$node.getElementsByTagName( "lyte-tbody" )[ 0 ],
                tr = tbody.children[ index ],
                elems = tr.getElementsByClassName( 'lyteListviewIntersection' ),
                row_index = parseInt( tr.getAttribute( 'row-index' ) );
                
                this.reset( row_index );

                Array.from( elems ).forEach( this.addToIntersection.bind( this ) );
            },

            intersectionSet : function( cell, left, accumulatedWidth ){
                if( this.data.ltPropSubHeaders ){
                    var __index = parseInt( cell.getAttribute( 'index' ) ),
                    __elem = this.$node.getElementsByClassName( 'lyteListFakeHeader' )[ 0 ];
                    __elem.children[ __index ].style[ left ] = accumulatedWidth + 'px';
                }
            }
        };
    }

    renderNode(elem) {
		var cell = elem.parentNode;

		if( !cell ){
			return;
		}

		var index = parseInt( cell.getAttribute( "index" ) ),
		row_index = parseInt( cell.getAttribute( "row-index" ) ),
		data_name = cell.getAttribute( 'data-name' ),
		inner_index = parseInt( cell.getAttribute( "inner_index" ) ),
		__data = this.data;

		switch( data_name ){
			case 'headerData' : 
			case 'fakeHeaderData' :{
				var __cell = __data[ data_name ][ index ];

				if( !isNaN( inner_index ) ){
					__cell = __cell.columns[ inner_index ];
				}

				this.$addon.objectUtils( __cell, 'add', 'render', true );
			}
			break;
			case "ltPropContent" : { 
				var __cell = __data.renderingBoolean[ row_index ];

				if( !isNaN( inner_index ) ){
					__cell = __cell[ index ];
					index = inner_index;
				}

				this.$addon.arrayUtils( __cell, 'replaceAt', index, true );
			}
			break;
		}
	}

    static observers() {
        return {
            headerObs : function( arg ){
                this.init( true );
                this.destroy_ins();
                this.create_ins();
            }.observes( 'ltPropHeader' ),

            contentObs : function(){
                this.reset_content_boolean();
                this.destroy_ins();
                this.create_ins();
            }.observes( 'ltPropContent', 'ltPropContent.[]' ),

            currentObs : function( arg ){
                this.currentPage();
            }.observes( 'currentPage' )
        };
    }

    includes() {
        return [LyteListviewUtilsMixin];
    }
}

// LyteUiComponentComponentRegistry.registerHelper( 'listStyle', function( __data ){
// 	var str = '',
// 	__width = __data.width,
// 	__minWidth = __data.minWidth;

// 	if( __width != void 0 ){
// 		if( __width < __minWidth ){
// 			__width = __minWidth;
// 		}
// 		str += ( "width:" + __width + 'px;' );
// 	}

// 	if( __minWidth != void 0 ){
// 		str += ( "min-width:" + __minWidth + 'px;' );
// 	}

// 	if( __data.maxWidth != void 0 ){
// 		str += ( "max-width:" + __data.maxWidth + 'px;' );
// 	}

// 	return str;
// });

// LyteUiComponentComponentRegistry.registerHelper( 'checkListResize', function( __data ){
// 	var ret = false;

// 	__data.columns.every( function( item ){
// 		return !( ret = !!item.resizable );
// 	});

// 	return ret;
// });

// LyteUiComponentComponentRegistry.registerHelper( 'listDisplay', function( msg, total, start, end ){
// 	return msg.replace( '{0}', start ).replace( '{1}', end ).replace( '{2}', total );
// });
export { LyteListviewComponent };