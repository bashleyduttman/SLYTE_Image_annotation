import { prop } from "@slyte/core";
import { Component, LyteUiComponentComponentRegistry } from "../../component.js";
import $L from "@zoho/lyte-dom";
// import { DefaultEditor } from "@zoho/lyte-ui-editor/components/helpers/editor-default";

class LyteCommentComponent extends Component {
    constructor() {
        super();
    }

	// lookups(){
	// 	return [ { lyteUiEditor : DefaultEditor } ];
	// }

    didConnect() {
		this.$node.resetTime = this.reset_time.bind( this );
	}

    init() {
		var str = '',
		data = this.data;

		if( data.ltPropVoiceNote ){
			str = "lyteNoteVoiceNoteComment";
		} else if( data.ltPropCheckIn ){
			str = "lyteNoteCheckinComment";
		}

		this.setData( 'commentType', str );

		if( data.ltPropEditorProps.emoji && data.ltPropEmoji && data.ltPropEmoji.length ){
			this.setData( 'firstReaction', data.ltPropEmoji[ 0 ] );
		}
	}

    preview_obs_check() {
		var data = this.data.ltPropAttachments || [],
		obj = {
			image : "photo"
		},
		_utils = this.$addon.objectUtils,
		frame_arr = [ "pdf", "video", "audio" ];

		data.forEach( function( item ){
			var _type = ( item.fileType || "image" ).toLowerCase(),
			_value = obj[ _type ];

			if( !_value ){
				if( frame_arr.indexOf( _type ) != -1 ){
					_value = "iframe/" + _type;
				} else{
					_value = "custom/" + _type;
				}
			}

			_utils( item, "add", "ctype", _value );
		}.bind( this ) );
	}

    reset_time() {
		var data = this.data,
		time = data.ltPropCreatedTime,
		str,
		callback = 'onTimeConversion';

		if( !time ){
			return;
		}

		if( this.getMethods( callback ) ){
			var str = this.executeMethod( callback, time, 'comment' );

			this.setData( 'createdTime', str );
		}
	}

    convert_to_string(value) {
		var ret;
		try{
			var json = JSON.parse( value ),
			ret = this.$lyteUiEditor.jsonToString(json, this.data.ltPropTextEditor);
		}catch( e ){
			ret = value;
		}
		return ret;
	}

    convertback_mention(text) {
		return text.replace(  /@\[(.+?):(.+?)\]/g, function( final, match1, match2 ){
			return '<span data-method = "onMentionClick" data-mouseover = "onMentionEnter" data-mouseout = "onMentionLeave" class = "lyteCommentUserMention" data-id = "' + match2 + '">' + match1 + '</span>'
		})

		// regex used in crm - shank

		.replace( /([\w](['A-Za-z0-9._%\-+]*@[A-Za-z0-9-]+(\.[a-zA-Z0-9-]{1,22}){0,9}\.[a-zA-Z]{2,22}))/g, '<a class = \'lyteNoteEmail\' href = \'mailto:$1\'>$1</a>' );

		// took this from https://stackoverflow.com/questions/3809401/what-is-a-good-regular-expression-to-match-a-url

		// .replace( /(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]+\.[^\s]{2,}|www\.[a-zA-Z0-9]+\.[^\s]{2,})/g, '<a class = \'lyteNoteLink\' href = \'$1\' target = \'_blank\'>$1</a>' );
	}

    checkcount(text, count) {
		if( count == Infinity ){
			return text;
		}

		 var ret = this.$lyteUiEditor.limitFilter(text, count, true);

		 if( count == ret.length ){
		 	var text = ret.html,
		 	index = text.lastIndexOf( "</" + ( ret.tag || "p" ) + ">" );

		 	if( index == -1 ){
		 		index = count;
		 	}
		 	
		 	return text.slice( 0, index ) + '...<span data-method = "more" class = "lyteCommentMoreString">' + this.data.ltPropText.more + '</span>' + text.slice( index );
		 }

		return ret.html;
	}

    data() {
		return {
			ltPropImage : prop( "string", { default : '' } ),

			ltPropHeader : prop( "array", { default : [] } ),

			ltPropEdit: prop( "boolean", { default : true } ),

			ltPropDelete : prop( "boolean", { default : true } ),

			ltPropEmoji : prop( "array", { default : [] } ),

			ltPropFooter : prop( "array", { default : [] } ),

			ltPropCreatedTime : prop( "string", { default : '' } ),

			ltPropValue : prop( "string", { default : "", hideAttr : true } ),

			ltPropEditMode : prop( "boolean", { default : false } ),

			ltPropReply : prop( "array", { default : [] } ),

			ltPropButtons : prop( "array", { default : [], hideAttr : true } ),

			ltPropCount : prop( "number", { default : 250 } ),

			ltPropTextEditor : prop( "object", { default : {} } ),

			ltPropEditorPanel : prop( "object", { default : {} } ),

			ltPropFileUpload : prop( "object", { default : {} } ),

			ltPropAttachments : prop( "array", { default : [] } ),

			ltPropStyle : prop( "object", { default : {} } ),

			ltPropEditorAnimation : prop( "string", { default : 'fade' } ),

			ltPropTooltipConfig : prop( "string", { default : '{}' } ),

			ltPropText : prop( "object", { default : {
					fileUpload : window._lyteUiUtils.i18n( "upload.file", "note", "File upload" ),
					storage : window._lyteUiUtils.i18n( "storage", "note", "Storage" ),
					more : window._lyteUiUtils.i18n( "more", "note", "More" )
			} } ),

			ltPropVoiceNote : prop( "object" ),

			ltPropCheckIn : prop( "object" ),

			ltPropPin : prop( "boolean", { default : false } ),

			ltPropPinnedComment : prop( "boolean", { default : false } ),

			ltPropReplyYield : prop( "boolean", { default : false } ),

			ltPropEditorProps : prop( "object", { default : {
			        background : true,
			        attachment : true,
			        emoji : true,
			        editorpanel : true
			    } 
			}),

			ltPropImageText : prop( "string", { default : "" } ),

			// systemData
			
			createdTime : prop( "object", { default : {} } ),

			sanitizer : prop( "object", {}),

			value : prop( "string", { default : '', hideAttr : true } ),

			height : prop( "number", { default : 0 } ),

			commentType : prop( "string" ),

			isReacted : prop( "boolean" ),

			moreOptions : prop( "boolean" ),

			firstReaction : prop( "object" ),

			id : prop( "string", { default : "" } ),
			dataIndex : prop( "string", { default : "" } )
		};
	}

    static actions() {
        return {
            comment_click : function( evt, name ){
                var method_name = this.get_method_name( evt.target, name || 'data-method' );
                if( method_name ){
                    switch( method_name.method ){
                        case 'more' : {
                            return this.more();
                        }
                        break;
                        default : {
                            this.throwEvent( 'common_action', method_name.method, evt, method_name.target, this.$node );
                        }
                    }
                }
            },

            cancel : function( editor ){
                this.throwEvent( 'cancel_comment', editor, this.$node );
                return false;
            },

            save : function( editor ){
                this.throwEvent( 'update_comment', editor, this.$node );
                return false;
            },

            mouseenter : function( _this, index ){
                if( index == 0 ){
                    this._timeout = setTimeout( function(){
                        this.throwEvent( 'show_emoji', _this );
                    }.bind( this ), 500);
                }
            },

            mouseleave : function(){
                this.didDestroy();
            },

            download : function( evt, _this ){

                if( this.getMethods('onBeforeCommentDownload') ){
                    let data = this.data

                    let id = evt.target.parentElement && evt.target.parentElement.id;

                    let ret = this.executeMethod( 'onBeforeCommentDownload', data.id, data.ltPropAttachments, id, evt, this.$node );
                    
                    if( ret === false ){ 
                        window.event.preventDefault();
                        return ret; 
                    }
                }

                evt.stopPropagation();
                evt.stopImmediatePropagation();
                return false;
            },

            error : function(){
                if( this.data.ltPropImageText ){
                    this.setData('ltPropImage' , '');
                }
            }
        };
    }

    more() {
		this.setData( 'ltPropCount', Infinity );
	}

    didDestroy() {
		clearTimeout( this._timeout );
		delete this._timeout;
	}

    static methods() {
        return {
            onTimeConversion : function(){
            },
            onTrigger : function( value, position, editor ){
                if( this.getMethods( 'onTrigger' ) ){
                    return this.executeMethod( 'onTrigger', value, position, editor );
                }
            },

            modeswitch : function( value, _editor ){
                if( !value ){
                    var cls = 'lyteEditorHide';
                    $L( _editor ).addClass( cls ).next().removeClass( cls );
                }
            },

            beforeDownload : function(){
                if( this.getMethods( 'onBeforeCommentDownload' ) ){
                    return this.executeMethod( 'onBeforeCommentDownload', arguments[0], arguments[1], arguments[2] );
                }
            }
        };
    }

    get_method_name(target, name) {

		var fn  = function( elem, query ){
			if( elem.closest ){
				return elem.closest( query );
			}
			return $L( elem ).closest( query ).get( 0 );
		},
		comment = fn( target, 'lyte-comment' );

		if( comment == this.$node ){
			var element = fn( target, '[' + name + ']:not([' + name + '=""])' );

			if( element ){
				return{
					method : $L( element ).attr( name ),
					target : element
				}
			}
		}
	}

    static observers() {
        return {
            obs : function(){
                if( this.data.ltPropPinnedComment ){
                    return;
                }
                this.reset_time();
            }.observes( 'ltPropCreatedTime' ).on( 'init' ),

            preview_obs : function(){
                if( this.data.ltPropPinnedComment ){
                    return;
                }
                this.preview_obs_check();
            }.observes( 'ltPropAttachments.[]' ).on( "init" ),

            emoji_obs : function(){
                var __data = this.data;

                if( __data.ltPropPinnedComment || !__data.ltPropEditorProps.emoji ){
                    return;
                }
                var emoji = __data.ltPropEmoji;

                if( emoji && emoji.length ){
                    this.setData( 'isReacted', emoji.length > 1 || emoji[ 0 ].count );
                }
            }.observes( 'ltPropEmoji.[]', 'firstReaction.count' ).on( 'init' ),

            more_options : function(){
                if( this.data.ltPropPinnedComment ){
                    return;
                }
                var data = this.data;
                this.setData( 'moreOptions', data.isReacted || data.ltPropPin || data.ltPropDelete || data.ltPropEdit );
            }.observes( 'isReacted', 'ltPropPin', 'ltPropEdit', 'ltPropDelete' ).on( 'init' ),

            edit_modeobs : function( arg ){
                if( this.data.ltPropPinnedComment ){
                    return;
                }

                var is_edit = this.data.ltPropEditMode;

                if( is_edit ){
                    var hgt = $L( '.lyteEditorContent', this.$node ).get( 0 ).offsetHeight;
                    this.setData( 'height', hgt );

                    this.setData( 'render', !0 );

                    var cls_name = "lyteEditorHide",
                    editor = $L( 'lyte-note-editor', this.$node ).eq( 0 );

                    editor.removeClass( cls_name ).next().addClass( cls_name );

                } 

            }.observes( 'ltPropEditMode' ).on( 'didConnect' ),

            convert_mention : function(){
                this.setData( 'value', this.checkcount( this.convertback_mention( this.convert_to_string( this.data.ltPropValue ) ), this.data.ltPropPinnedComment ? Infinity : this.data.ltPropCount ) );
            }.observes( 'ltPropValue', 'ltPropCount' ).on( 'init' )
        };
    }
}


LyteUiComponentComponentRegistry.registerHelper( 'lyteNoteStyle', function( background, border ){

	if( !background ){
		return "";
	}

	var obj;
	
	if( border && background ){
		obj = {
			background : background,
			border : border
		}
	} else{
		if( background.constructor == String ){
			return "background:" + background;
		}
		obj = {
			background : background.background,
			border : background.border
		}
	}

	return this.$lyteUiEditor.inlineStyle(obj);
});

LyteUiComponentComponentRegistry.registerHelper( 'lyteUiCommentEmoji', function( className, selected, count ){
	var str = className || '';

	if( selected ){
		str += ' lyteEmojiSelected';
	}

	if( count != void 0 ){
		str += ( ' lyte_emoji_reactions_' + count );
	}

	return str.trim();
});
export { LyteCommentComponent };