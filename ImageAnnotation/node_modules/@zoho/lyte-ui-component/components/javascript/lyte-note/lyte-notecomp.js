import { prop } from "@slyte/core";
import { Component } from "../../component.js";
import $L from "@zoho/lyte-dom";
import { Sanitizer } from "@slyte/component";

// import { LyteUiEditorAddon } from "@zoho/lyte-ui-editor/addon.js";
/**
 * This component is used to create note view
 * @component lyte-notecomp
 * @version 4.0.0
 * @dependency lyte-popover
 * 	components/lyte-popover.js
 * 	components/lyte-wormhole.js
 *  theme/compiledCSS/default/ltr/lyte-ui-popover.css
 * @dependency lyte-button
 * 	components/lyte-button.js
 *  theme/compiledCSS/default/ltr/lyte-ui-button.css
 * @dependency lyte-checkbox
 * 	components/lyte-checkbox.js
 *  theme/compiledCSS/default/ltr/lyte-ui-checkbox.css
 * @dependency lyte-menu
 * 	components/lyte-menu.js
 *  theme/compiledCSS/default/ltr/lyte-ui-menu.css
 * @dependency lyte-colorpicker
 * 	components/lyte-colorpicker.js
 *  theme/compiledCSS/default/ltr/lyte-ui-colorpicker.css
 * @dependency lyte-colorbox
 * 	components/lyte-colorbox.js
 *  theme/compiledCSS/default/ltr/lyte-ui-colorbox.css
 * @dependency lyte-fileupload
 * 	components/lyte-fileupload.js
 *  theme/compiledCSS/default/ltr/lyte-ui-fileupload.css
 * @dependency lyte-messagebox
 * 	components/lyte-messagebox.js
 *  theme/compiledCSS/default/ltr/lyte-ui-messagebox.css
 * @dependency lyte-voicenote
 * 	components/lyte-voicenote.js
 *  theme/compiledCSS/default/ltr/lyte-ui-voicenote.css
 * @dependency lyte-emoji
 * 	components/lyte-emoji.js
 *  theme/compiledCSS/default/ltr/lyte-ui-emoji.css
 * @dependency lyte-comment
 * 	components/lyte-note/lyte-comment.js
 * @dependency lyte-note-editor
 * 	components/lyte-note/lyte-note-editor.js
 * @methods onTimeConstruction, onCommentUnpin, onViewReaction,onCommentDelete,onCommentPin, onCommentEdit, onEmojiSelect, onTrigger, onCommentCancel, onMainCommentCancel, onMainCommentSave, onButtonClick, onBeforeSend, onSuccess, onFailure, onError, onBeforeRemove, onEditorPaste
 * @utility removeAllFiles, getBackground, setBackground, viewReactions 
 */

class LyteNotecompComponent extends Component {
    constructor() {
        super();
    }

	// lookups(){
	// 	return [ LyteUiEditorAddon ];
	// }
	// addRegistries(){
	// 	return [ this.$lyteUiEditorAddon.$component ]
	// }

    init() {
		var __id = this.$node.id || ( "lyteNote_" +  Date.now() );
		this.data.id = ( this.$node.id = __id );
	}

    data() {
			return {

				// comment

				/**
				 * @componentProperty {array} ltPropComments
				 * @default []
				 * @version 4.0.0
				 */

				ltPropComments : prop( "array", { default : [] } ),
				/**
				 * @componentProperty {boolean} ltPropEditMode=false
				 * @version 4.0.0
				 */				
				ltPropEditMode : prop( "boolean", { default : false } ),
				/**
				 * @componentProperty {object} ltPropPopover
				 * @default { "freeze" : false , "wrapperClass" : "lyteNoteEmojiPopover","type" : "box", "showCloseButton" : false}
				 * @component lyte-popover
				 * @version 4.0.0
				 */		
				ltPropPopover : prop( "object", { default : { 
					freeze : false ,
					wrapperClass : 'lyteNoteEmojiPopover',
					type : 'box',
					showCloseButton : false
				} } ),
				/**
				 * @componentProperty {object} ltPropColorPicker
				 * @default {"freeze":false,"wrapperClass":"lyteNoteBgSwitchPopover","type":"box","showCloseButton":false,"noFillButton":true}
				 * @component lyte-colorpicker
				 * @version 4.0.0
				 */					
				ltPropColorPicker : prop( "object", { default : { 
					freeze : false ,
					wrapperClass : 'lyteNoteBgSwitchPopover',
					type : 'box',
					showCloseButton : false,
					noFillButton : true
				} } ),
				/**
				 * @componentProperty {string} ltPropButtons='[{"text":"Cancel","method":"cancel","properties":{"size":"small"}},{"text":"Save","method":"save","properties":{"appearance":"primary","size":"small"}}]'
				 * @version 4.0.0
				 */					

				ltPropButtons : prop( "string", { default : '[{"text":"' + window._lyteUiUtils.i18n( 'note', 'cancel', 'Cancel' ) + '","method":"cancel","properties":{"size":"small"}},{"text":"' + window._lyteUiUtils.i18n( 'note', 'save', 'Save' ) + '","method":"save","properties":{"appearance":"primary","size":"small"}}]', hideAttr : true } ),
				/**
				 * @componentProperty {object} ltPropTooltipConfig
				 * @default { "position" : "bottom" }
				 * @component lyte-tooltip ltPropTooltipConfig
				 * @version 4.0.0
				 */	

				ltPropTooltipConfig : prop( "object", { default : { position : "bottom" } } ),
				/**
				 * @componentProperty {string} ltPropAvatar=''
				 * @version 4.0.0
				 */	

				ltPropAvatar : prop( "string", { default : '' } ),
				/**
				 * @componentProperty {object} ltPropTextEditor
				 * @default  { "wordStyle": { "whiteSpace":"break-spaces" }, "placeholder":"Add a note ...", "checkbox":{"prevent":true} }
				 * @version 4.0.0
				 */	
				ltPropTextEditor : prop( "object", { default : { wordStyle : {
						whiteSpace: "break-spaces"
					},
					placeholder : window._lyteUiUtils.i18n( 'note', 'add.note', 'Add a note ' ) + "...",
					checkbox : {
						prevent : true
					}
				} } ),
				/**
				 * @componentProperty {object} ltPropEditorPanel
				 * @default { "tooltipConfig":{"position":"bottom"},"moreIcon":false,"icons":[{"class":"formatting","subIcons":[{"type":"switch","name":"bold","display":"","functionName":"toggleWordClass","arguments":["fontWeight","bold"],"title":"bold","active":false},{"type":"switch","name":"italic","display":"","functionName":"toggleWordClass","arguments":["fontStyle","italic"],"title":"italic","active":false},{"type":"switch","name":"underline","display":"","functionName":"toggleWordClass","arguments":["textDecoration","underline"],"title":"underline","active":false},{"type":"switch","name":"strike","display":"","functionName":"toggleWordClass","arguments":["textDecoration","line-through"],"title":"strike","active":false}]},{"class":"formatting","subIcons":[{"type":"switch","name":"ul","display":"","functionName":"list","selected":"","arguments":["{{selected}}"],"title":"ul","active":false},{"type":"switch","name":"decimal","display":"","functionName":"ordered","selected":"","arguments":["3"],"title":"ol","active":false},{"type":"anchor","name":"anchor","display":"","functionName":"toggleWordClass","arguments":["lyteEditorAnchor"],"title":"anchor","active":false}]},{"class":"colorpicker","subIcons":[{"type":"colorpicker","name":"color","display":"","selected":"black","functionName":"toggleWordClass","arguments":["color","{{selected}}"],"title":"color","active":false},{"type":"colorpicker","name":"bg","display":"","selected":"white","functionName":"toggleWordClass","arguments":["backgroundColor","{{selected}}"],"title":"background","active":false}]},{"class":"clearformatting","subIcons":[{"type":"switch","name":"clear","display":"","functionName":"clearFormat","title":"clear format","arguments":[""],"action":false}]}]}
				 * @version 4.0.0
				 */					

				ltPropEditorPanel : prop( "object", { default : {
					tooltipConfig : {
						position : "bottom"
					},
					moreIcon : false,
					icons : [
								{
									class : "lyteUIEditorPanelTextFormat",
									subIcons : [
										{
											type : "switch",
											name : "bold",
											display : '',
											functionName : "toggleWordClass",
											arguments : [ 'fontWeight', 'bold' ],
											title : window._lyteUiUtils.i18n( "bold", "note", "bold" ),
											active : false
										},
										{
											type : "switch",
											name : "italic",
											display : '',
											functionName : "toggleWordClass",
											arguments : [ 'fontStyle', 'italic' ],
											title : window._lyteUiUtils.i18n( "italic", "note", "italic" ),
											active : false
										},
										{
											type : "switch",
											name : "underline",
											display : '',
											functionName : "toggleWordClass",
											arguments : [ 'textDecoration', 'underline' ],
											title : window._lyteUiUtils.i18n( "underline", "note", "underline" ),
											active : false
										},
										{
											type : "switch",
											name : "strike",
											display : '',
											functionName : "toggleWordClass",
											arguments : [ 'textDecoration', 'line-through' ],
											title : window._lyteUiUtils.i18n( "strike", "note", "strike" ),
											active : false
										}
									]
								},
								{
									class : "lyteUIEditorPanelList",
									subIcons : [
										{
											type : "switch",
											name : "ul",
											display : "",
											functionName : "list",
											selected : "",
											arguments : [ '{{selected}}' ],
											title : window._lyteUiUtils.i18n( "ul", "note", "ul" ),
											active : false
										},
										{
											type : "switch",
											name : "decimal",
											display : "",
											functionName : "ordered",
											selected : "",
											arguments : [ '3' ],
											title : window._lyteUiUtils.i18n( "ol", "note", "ol" ),
											active : false
										},
										{
											type : "anchor",
											name : "anchor",
											display : "",
											functionName : "toggleWordClass",
											arguments : [ 'lyteEditorAnchor' ],
											title : window._lyteUiUtils.i18n( "anchor", "note", "anchor" ),
											active : false
										}
									]
								},
								{
									class : 'lyteUIEditorPanelColorpicker',
									subIcons : [
										{
											type : "colorpicker",
											name : "color",
											display : "",
											selected : "black",
											functionName : "toggleWordClass",
											arguments : [ 'color', '{{selected}}' ],
											title : window._lyteUiUtils.i18n( "color", "note", "color" ),
											active : false
										},
										{
											type : "colorpicker",
											name : "bg",
											display : "",
											selected : "white",
											functionName : "toggleWordClass",
											arguments : [ 'backgroundColor', '{{selected}}' ],
											title : window._lyteUiUtils.i18n( "background", "note", "background" ),
											active : false
										}
									]
								},
								{
									class : 'lyteUIEditorClearformatting',
									subIcons : [
										{
											type : "switch",
											name : "clear",
											display : "",
											functionName : "clearFormat",
											title : window._lyteUiUtils.i18n( "clear.format", "note", "clear format" ),
											arguments : [ '' ],
											action : false
										}
									]
								}				
							]
				} } ),
				/**
				 * @componentProperty {Object[]} ltPropColors
				 * @default [{"background":"#DDF2D9","border":"1px solid #A9E198"},{"background":"#CEF7F8","border":"1px solid #97E4E3"},{"background":"#F8DDCE","border":"1px solid #F5B388"},{"background":"#F5E5FA","border":"1px solid #E3B2EE"},{"background":"#F8DCEA","border":"1px solid #F39BBF"},{"background":"#fff","border":""}]
				 * @version 4.0.0
				 */	
				ltPropColors : prop( "array", { default : [
					{
					      background: '#DDF2D9',
					      border: '1px solid #A9E198'
					},
					{
					      background: '#CEF7F8',
					      border: '1px solid #97E4E3'
					},
					{
					      background: '#F8DDCE',
					      border: '1px solid #F5B388'
					},
					{
					      background: '#F5E5FA',
					      border: '1px solid #E3B2EE'
					},
					{
					      background: '#F8DCEA',
					      border: '1px solid #F39BBF'
					},
					{
					      background: '#fff',
					      border: ''
					}
				] } ),
				/**
				 * @componentProperty {object} ltPropFileUpload
				 * @default {"filesCount":5,"totalFilesSize":"20MB","thumb":true,"appearance":"Btn","ajax":{"url":"/imageupload"}}
				 * @component lyte-fileupload
				 * @version 4.0.0
				 */					

				ltPropFileUpload : prop( "object", { default : { filesCount : 5, totalFilesSize : '20MB', thumb : true, appearance : "Btn", ajax : { url : "/imageupload" } } } ),
				/**
				 * @componentProperty {string} ltPropEditorAnimation='slide'
				 * @version 4.0.0
				 */	

				ltPropEditorAnimation : prop( "string", { default : 'slide' } ),
				/**
				 * @componentProperty {object} ltPropEmojiProps
				 * @default {}
				 * @component lyte-emoji
				 * @version 4.0.0
				 */
				ltPropEmojiProps : prop( "object", { default : {} } ),
				/**
				 * @componentProperty {string} ltPropUploadInfoMessage
				 * @version 4.0.0
				 */
				ltPropUploadInfoMessage : prop( "string" ),
				/**
				 * @componentProperty {string} ltPropEmptyInfoMessage
				 * @version 4.0.0
				 */
				ltPropEmptyInfoMessage : prop( "string" ),

				/**
				 * @typedef textObj
				 * @property {string} fileUpload=File upload
				 * @property {string} storage=Storage
				 * @property {string} limit=Limit 5 files
				 * @property {string} smileyIcon=smileys
				 * @property {string} attachFiles=Attach files
				 * @property {string} noteBackground=Note background
				 * @property {string} more=More
				 * @property {string} failureMessage=Attachment failed
				 * @property {string} retryText=Retry
				 * @property {string} noPreviewMessage=Sorry, No preview is available for this format
				 * @property {string} thumbnailIndex={{index}} of {{total}}
				 * @property {string} noResult=No results found
				 * @property {string} all=All
				 * @property {string} editAlertHeader=Discard the changes in the current note?
				 * @property {string} editAlertMessage=You will lose any unsaved changes in your note
				 * @property {string} keepEditing=Cancel
				 * @property {string} continue=Discard
				 * @property {string} delete=Delete
				 * @property {string} pin=Pin
				 * @property {string} unpin=Unpin
				 * @property {string} edit=Edit
				 * @property {string} viewReactions=View reactions
				 * @property {string} pinnedBy=Pinned by <span class = \"lyteNotePinnedBy\">{{0}}</span>
				 */

				/**
				 * @componentProperty {textObj} ltPropText
				 * @version 4.0.0
				 */

				ltPropText : prop( "object", { default : {
					fileUpload : window._lyteUiUtils.i18n( "upload.file", "note", "File upload" ),
					storage : window._lyteUiUtils.i18n( "storage", "note", "Storage" ),
					limit : window._lyteUiUtils.i18n( "limit.files", "note", "( Limit {{0}} files )" ).replace( '{{0}}', 5 ),
					smileyIcon : window._lyteUiUtils.i18n( "smileys", "note", "smileys" ),
					attachFiles : window._lyteUiUtils.i18n( "attach.files", "notes", "Attach files" ),
					noteBackground : window._lyteUiUtils.i18n( "note.background", "notes", "Note background" ),
					more : window._lyteUiUtils.i18n( "more", "note", "More" ),
					failureMessage : window._lyteUiUtils.i18n( 'Attachment failed', 'fileupload', "Attachment failed" ), 
					retryText : window._lyteUiUtils.i18n( 'retry', "fileupload", "Retry" ),
					noPreviewMessage : window._lyteUiUtils.i18n( "no.preview", "note", "Sorry, No preview is available for this format" ),
					thumbnailIndex : window._lyteUiUtils.i18n( "of", "note", "{{index}} of {{total}}" ),
					noResult : window._lyteUiUtils.i18n( "no.results.found", void 0, "No results found" ),
					all : window._lyteUiUtils.i18n( "all", "note", "All" ),
					editAlertHeader : window._lyteUiUtils.i18n( 'discard.header', "note", "Discard the changes in current note?" ),
					editAlertMessage : window._lyteUiUtils.i18n( "discard.message", "note", "You will lose any unsaved changes in your note" ),
					keepEditing : window._lyteUiUtils.i18n( "cancel", "note", "Cancel" ),
					continue : window._lyteUiUtils.i18n( "discard", "note", "Discard" ),
					delete : window._lyteUiUtils.i18n( "delete", "note", "Delete" ),
					pin : window._lyteUiUtils.i18n( "pin", "note", "Pin" ),
					unpin : window._lyteUiUtils.i18n( "unpin", "note", "Unpin" ),
					edit : window._lyteUiUtils.i18n( "edit", "note", "Edit" ),
					viewReactions : window._lyteUiUtils.i18n( "view.reaction", "note", "View reactions" ),
					pinnedBy : window._lyteUiUtils.i18n( "pinned.by", "note", "Pinned by <span class = \"lyteNotePinnedBy\">{{0}}</span>" )
				} } ),
				/**
				 * @componentProperty {number} ltPropScrollDuration=400
				 * @version 4.0.0
				 */				

				ltPropScrollDuration : prop( "number", { default : 400 } ),
				/**
				 * @componentProperty {string} ltPropReaction='{}'
				 * @version 4.0.0
				 */	
				ltPropReaction : prop( "string", { default : '{}' } ),
				/**
				 * @componentProperty {boolean} ltPropEditAlert=true
				 * @version 4.0.0
				 */
				ltPropEditAlert : prop( "boolean", { default : true } ),
				/**
				 * @componentProperty {string} ltPropUserId
				 * @version 4.0.0
				 */
				ltPropUserId : prop( "string" ),
				/**
				 * @componentProperty {number} ltPropMaxTooltipNames=6
				 * @version 4.0.0
				 */
				ltPropMaxTooltipNames : prop( "number", { default : 6 } ),
				/**
				 * @componentProperty {array} ltPropPinnedComments
				 * @default []
				 * @version 4.0.0
				 */
				ltPropPinnedComments : prop( "array", { default : [] } ),
				/**
				 * @componentProperty {boolean} ltPropAddNewComment=true
				 * @version 4.0.0
				 */
				ltPropAddNewComment : prop( "boolean", { default : true } ),
				/**
				 * @componentProperty {boolean} ltPropReplyYield=false
				 * @version 4.0.0
				 */
				ltPropReplyYield : prop( "boolean", { default : false } ),
				/**
				 * @typedef editorProps
				 * @property {boolean} background=true
				 * @property {boolean} attachment=true
				 * @property {boolean} emoji=true
				 * @property {boolean} editorpanel=true
				 */

				/**
				 * @componentProperty {editorProps} ltPropEditorProps
				 * @version 4.0.0
				 */
				ltPropEditorProps : prop( "object", { default : {
				        background : true,
				        attachment : true,
				        emoji : true,
				        editorpanel : true
				    } 
				}),
				/**
				 * @componentProperty {boolean} ltPropTitleYield=false
				 * @version 4.0.0
				 */				

				ltPropTitleYield : prop( "boolean", { default : false } ),
				ltPropAlert : prop( "string" , { default : "" } ),

				ltPropCommentsCommonHeaderYield : prop( "boolean", { default : false } ),
				ltPropCommentsCommonFooterYield : prop( "boolean", { default : false } ),
				ltPropOptionsMenuProperties : prop( "object", { default : undefined } ),

				// system

				popoverShow : prop( "boolean", { default : false } ),

				bgSwitch : prop( "boolean", { default : false } ),

				messageShow : prop( "boolean", { default : false } ),

				message : prop( "string", { default : "" } ),

				fileDate : prop( "string" ),

				fileTime : prop( "string" ),

				fileSize : prop( "string" ),

				isImage : prop( "boolean" ),

				isNoPreview : prop( "boolean" ),

				previewType : prop( "string" ),

				thumbnails : prop( "array", { default : [] } ),

				thumbnailValue : prop( "string" ),

				thumbIndex : prop( "number" ),

				prevIconClass : prop( "string" ),

				nextIconClass : prop( "string" ),

				renderView : prop( "boolean", { default : false } ),

				currentComment : prop( "object", { default : {} } ),

				showViewArray : prop( "boolean", { default : false } ),

				previewDate : prop( "object", { default : {} } ),

				editAlertRender : prop( "boolean" ),

				alertShow : prop( "boolean" ),

				hovercardShow : prop( "boolean", { default : false }),

				hoverEmoji : prop( "object", { default : {} } ),

				isDelete : prop( "boolean" ),
				isPin : prop( "boolean" ),
				isEdit : prop( "boolean" ),
				isReact : prop( "boolean" ),
				isPinned : prop( "boolean" ),

				pinShow : prop( "boolean" ),
				pin : prop( "object" ),

				sanitizer : prop( "object", {
					default : {
						attr : new Sanitizer( { ADD_URI_SAFE_ATTR : [ "style" ], ALLOWED_STYLE : "ALL", STYLE_VALIDATION : false })
					}
				}),

				id : prop( "string" )
		};
	}

    clear_cbox() {
		delete this.__comment;
		delete this.__index;
		this.setData( 'thumbnails', [] );
	}

    clear_alert() {
		delete this.__promeditor;
		delete this.__promcomment;
		delete this.__executeArg;
	}

    didDestroy() {
		this.clear_cbox();
		this.clear_alert();

		clearTimeout( this.__pintime );
	}

    didConnect() {
		this.$node.removeAllFiles = this.removeAllFiles.bind( this );

		this.$node.getBackground = function( editor ){
			var note_comp = $L( editor ).closest( 'lyte-note-editor' ).get( 0 ),
			obj = {};

			[ 'background', 'border' ].forEach( function( item ){
				obj[ item ] = note_comp.ltProp( item );
			});

			return obj;
		};

		this.$node.setBackground = function( editor, obj ){
			$L( editor ).closest( 'lyte-note-editor' ).get( 0 ).ltProp( obj );
		};

		this.$node.viewReactions = this.viewReactions.bind( this );
	}

    viewReactions(comment_obj) {
		this.setData( 'renderView', true );
		this.setData( 'currentComment', comment_obj );
		this.setData( 'showViewArray', true );
	}

    get_element(selector) {
		if( !selector || selector.constructor == String ){
			return $L( selector ? ( '#' + selector ) : ( ".lyteNoteMainComment" ), this.$node );
		}
		return $L( selector ).closest( '.lyteNoteEditorWrapper' );
	}

    removeAllFiles(editor) {

		if( this.data.ltPropEditorProps.attachment ){
			var file = this.get_element( editor ).find( 'lyte-fileupload' ).get( 0 ),
			queueList = file.component.data.queueList,

			files = queueList.map( function( item ){
				return item.id;
			});

			files.forEach( function( item ){
				file.removeUpload( item );
			});
		}
	}

    setup_file_data(comment, index) {
		var attachments = comment.ltProp( 'attachments' ),
		 current = attachments[ index ],
		 time = comment.ltProp( 'createdTime' ),
		 ctype = current.ctype,
		 arrow_class = 'lyteColorboxHideVisibility';

		 if( time ){
		 	 this.setData( 'previewDate', this.timeConversion( time, 'colorbox' ) );
		 }

		 this.setData( 'fileSize', window._lyteUiUtils.lyteUiFileSize( current.size, '', 1 ) );

		 this.setData( 'isImage', ctype == 'photo' );

		 this.setData( 'previewType', $L( ctype.split( '/' ) ).get( -1 ) );
		 this.setData( 'isNoPreview', /^custom/i.test( ctype ) );

		 this.setData( 'thumbnailValue', this.get_thumb_index( index, attachments ) );

		 this.setData( 'thumbIndex', index );

		 this.setData( 'prevIconClass', index == 0 ? arrow_class : '' );
		 this.setData( 'nextIconClass', ++index == attachments.length ? arrow_class : '' );
	}

    get_thumb_index(index, attachments) {
		return this.data.ltPropText.thumbnailIndex.replace( "{{index}}", ++index ).replace( "{{total}}", attachments.length );
	}

    timeConversion() {
		var name = 'onTimeConversion';
		if( this.getMethods( name ) ){
			var arg = Array.from( arguments );
			arg.unshift( name );
			return this.executeMethod.apply( this, arg );
		}
	}

    construct_react(obj, id, count) {
		var arr = [],
		_reacted = obj.reacted,
		_index,
		i = 0;

		if( obj.selected ){
			_reacted.every( function( item, index ){
				if( item.id == id ){
					arr.push( 'you' /*item.name*/ );
					_index = index;
					return false;
				}
				return true;
			});
			count--;
		}

		while( true ){
			if( i == _index && ++i ){
				continue;
			}

			if( _reacted[ i ] == void 0 ){
				break;
			}

			arr.push( _reacted[ i++ ].name );

			if( arr.length == count ){
				arr.push( '+' + ( _reacted.length - count ) + 'more...' );
				break;
			}
		}
		return arr;
	}

    static methods() {
        return {

            pinHide : function(){
                $L( '.lyteNotePinOrigin', this.$node ).removeClass( 'lyteNotePinOrigin' );
                this.setData( 'pin', {} );
            },

            unpinSelect : function(){
                var cb = 'onCommentUnpin',
                args = arguments;

                if( this.getMethods( cb ) ){
                    var elem = args[ 3 ],
                    comment = this.$node.querySelector( 'lyte-comment#' + elem.parentNode.id );
                    return this.executeMethod( cb, args[ 1 ], elem, comment, this.get_comment_index( comment ) );
                }
            },

            optionsMenuSelect : function( type, evt, menu, element ){
                var cb,
                data = this.data;

                switch( type ){
                    case 'view' : {
                        if( data.isReact ){
                            cb = 'onViewReaction';
                        }
                    }
                    break;
                    case 'delete' : {
                        if( data.isDelete ){
                            cb = "onCommentDelete";
                        }
                    }
                    break;
                    case 'pin' : {
                        if( data.isPin ){
                            if( data.isPinned ){
                                cb = "onCommentUnpin";
                            } else{
                                cb = "onCommentPin";
                            }
                        }
                    }
                    break;
                    case 'edit' : {
                        var args = [ 'onCommentEdit', evt, element,  element.closest( 'lyte-comment' ) ];
                        
                        if( this.close_all_comments() || this.make_main_draft() ){
                            this.__executeArg = args;
                            return;
                        }
                        return this.execute( Array.from( args ) );
                    }
                    break;
                }

                if( cb && this.getMethods( cb ) ){
                    var comment = element.closest( 'lyte-comment' );
                    return this.executeMethod( cb, evt, element, comment, this.get_comment_index( comment ) );
                }
            },

            beforeCloseOptionsMenu : function( menu ){
                $L( menu.element ).closest( 'lyte-comment' ).removeClass( 'lyteNoteOptionsMenuOpened' );
            },

            beforeOpenOptionsMenu : function(){
                var comment = arguments[ 2 ].closest( 'lyte-comment' ),
                data = comment.component.data;

                $L( comment ).addClass( 'lyteNoteOptionsMenuOpened' );

                this.setData({
                    isDelete : 	data.ltPropDelete,
                    isPin : data.ltPropPin,
                    isEdit : data.ltPropEdit,
                    isReact : data.isReacted,
                    isPinned : this.data.ltPropPinnedComments.findIndex( function( item ){
                        return item.id == comment.id;
                    }) != -1
                });
            },

            hoverHide : function(){
                $L( '.lyteNoteHoverOrigin', this.$node ).removeClass( 'lyteNoteHoverOrigin' );
                this.setData( 'hoverEmoji', {} );
            },

            hovercard_show : function( evt, element, comment, comment_data ){
                var $element = $L( element ), 
                index = Number( $element.parent().attr( 'data-index' ) ),
                data = comment_data.sectionArray[ comment_data.sectionIndex ],
                current_emoji = data.emoji[ index ],
                count = this.data.ltPropMaxTooltipNames,
                id = this.data.ltPropUserId;

                $element.addClass( 'lyteNoteHoverOrigin' );

                this.setData( 'hoverEmoji', {
                    name : current_emoji.name,
                    reacted : this.construct_react( current_emoji, id, count )
                });

                this.setData( 'hovercardShow', true );
            },

            close_comment : function(){
                return this.close_all_comments();
            },

            cboxClose : function(){
                this.clear_cbox();
            },	

            cboxBeforeOpen : function(){
                this.setup_file_data( this.__comment, this.__index );
            },

            cboxNavigate : function(){
                this.setup_file_data( this.__comment, arguments[ 2 ] - 1 );
            },

            timeConversion : function(){
                return this.timeConversion.apply( this, arguments );
            },

            emojiselect : function( obj ){
                var origin = $L( '.lyte_note_origin_elem', this.$node );

                if( origin.hasClass( 'lyteNoteSmileyIcon' ) ){
                    var editor = origin.closest( '.lyteNoteEditorWrapper' ).find( 'lyte-texteditor' ).get( 0 );
                    
                    editor.insertHTML( obj.encode );
                    editor.focus();

                } else {
                    var callback = 'onEmojiSelect';
                    if( this.getMethods( callback ) ){
                        this.executeMethod( callback, obj, this.get_comment_index( $L( '.lyte_note_origin_elem' ).closest( 'lyte-comment' ).get( 0 ) ) );
                    }
                }
                this.setData( 'popoverShow', false );
            },

            onTrigger : function( value, position, editor ){
                if( this.getMethods( 'onTrigger' ) ){
                    return this.executeMethod( 'onTrigger', value, position, editor );
                }
            },

            colorPickerSelect : function(){
                $L( '.lyte_note_bgswitch_elem', this.$node ).closest( 'lyte-note-editor' ).get( 0 ).ltProp( 'background', arguments[ 1 ].hex );
                this.setData( 'bgSwitch', false );
            },

            onBeforeCommentDownload : function(){
                if( this.getMethods( 'onBeforeDownload' ) ){
                    return this.executeMethod( 'onBeforeDownload' , arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]  );
                }
            }
        };
    }

    get_comment_index(comment, prev) {

		var index = this.get_comment_index_fork( comment, prev ),
		format = this.get_correct_data( index, this.data.ltPropComments ); 

		index.sectionArray = format.array;
		index.sectionIndex = format.index;

		return index;
	}

    get_comment_index_fork(comment, prev) {
		var jobj = $L( comment ),
		obj = {
			node : comment,
			index : parseInt( jobj.attr( 'data-index' ) )
		},
		parent_comment = jobj.parent().closest( 'lyte-comment' ).get( 0 );

		if( prev ){
			obj.child = prev;
		}

		if( parent_comment ){
			return this.get_comment_index_fork( parent_comment, obj );
		}
		return obj;
	}

    find_index(array, key, value) {
		var index = -1;

		array.every( function( item, _index ){

			if( item[ key ] == value ){
				index = _index;
			}

			return index == -1;
		});

		return index;
	}

    preview_click() { 
		var arg = arguments,
		comment = arg[ 3 ],
		image = $L( arg[ 2 ] ),
		index = Number( image.attr( "data-index" ) ),
		attachments = comment.ltProp( "attachments" ),
		colorbox = $L( this.$node ).children().get( -1 );

		this.__comment = comment;
		this.__index = index;

		this.setData( 'thumbnails', attachments );

		colorbox.ltProp( "selectors", [ "." + comment.id +"_preview" ] );

		return false;
	}

    get_files(editor) {
		if( this.data.ltPropEditorProps.attachment ){
			var file = $L( editor ).closest( '.lyteNoteEditorWrapper' ).find( 'lyte-fileupload' ).get( 0 ),
			queueList = file.component.data.queueList,
			fn = function( name ){
				return queueList.filter( function( item ){
					return item.status == name;
				});
			};

			return[ fn( "success" ), fn( "uploading" ), fn( "failure" ) ]; 
		}
		return [ [], [], [] ];
	}

    /*
		Recursive function for finding exact data for comment / reply

		data format will be 

		{
			node : comment / reply element,
			index : comment / reply index,
			child : {
				// same set. inner most child is the comment to be altered
			}
		}
	*/

    get_correct_data(data, array) {
		if( data.child ){
			return this.get_correct_data( data.child, array[ data.index ].reply );
		} 
		return {
			array : array,
			index : data.index
		};
	}

    make_main_draft() {
		if( this.data.ltPropEditMode ){
			var editor_comp = $L( 'lyte-note-editor', this.$node ).eq( 0 ),
			text_editor = editor_comp.find( 'lyte-texteditor' ).get( 0 ),
			files = this.get_files( text_editor ),
			isEmpty = text_editor.getData( 'showPlaceholder' ),
			is_zero = function( arr ){
				return arr.length == 0;
			},
			_this = this,
			draft_need = !( isEmpty && is_zero( files[ 0 ] ) && is_zero( files[ 1 ] ) && is_zero( files[ 2 ] ) ),
			fn = function(){
				_this.$node.ltProp( 'editMode', false ); 
			};

			if( draft_need ){
				// if( _this.data.ltPropEditAlert ){
				// 	this.render_edit_alert( text_editor );
				// 	return true;
				// } else {
					editor_comp.get( 0 ).setData( 'draftMode', true );
					fn();
				// }
			} else {
				fn();
			}
		}
	}

    render_edit_alert(editor) {
		this.setData( 'editAlertRender', true );
		this.setData( 'alertShow', true );
		this.__promeditor = editor;
	}

    close_all_comments(arg) {
		var _this = this,
		ret;

		( arg || _this.data.ltPropComments ).every( function( item ){
			if( item.editmode ){
				var comment = $L( '#' + item.id, _this.$node ),
				editor = comment.find( 'lyte-texteditor' ).get( 0 );

				if( _this.data.ltPropEditAlert ){ 
					_this.__promcomment = comment;
					_this.render_edit_alert( editor );
					ret = true;
				} else {
					_this.call_cancel( editor, comment );
				}
			}

			if( _this.close_all_comments( item.reply || [] ) ){
				ret = true;
			}
			return !ret;
		}); 

		return ret;
	}

    call_cancel(editor, comment, name) {
		return this.execute( [ name || 'onCommentCancel', editor, this.get_comment_index( comment ) ].concat( this.get_files( editor ) ) );
	}

    get_scrolltop(wrapper, comment) {
		var sH = wrapper.scrollHeight,
		oH = wrapper.offsetHeight,
		oT = comment.offsetTop,
		elems = Array.from( wrapper.querySelectorAll( '.lyteNotePinnedComment' ) ),
		off = 0,
		max_scroll = sH - oH;

		elems.forEach( function( item ){
			off += item.offsetHeight;
		});

		return Math.min( oT - off - 10, max_scroll );
	}

    static actions() {
        return {

            pinEnter : function( _this, evt ){
                var fn = function(){
                    
                    var index = Number( $L( _this ).addClass( 'lyteNotePinOrigin' ).attr( 'data-index' ).replace( 'pin_', '' ) ),
                    obj = this.data.ltPropPinnedComments[ index ].pinnedBy,
                    time = ( this.timeConversion( obj.pinnedTime, 'pin' ) || { display : "" } ).display,
                    cb = "onTimeConversion";

                    this.setData( 'pin',{
                        message : this.data.ltPropText.pinnedBy.replace( "{{0}}", obj.name ),
                        time : time
                    });
                    this.setData( 'pinShow', true );
                }.bind( this );
                
                if( this.data.pinShow ){
                    this.__pintime = setTimeout( fn, 500 );
                } else {
                    fn();
                }
            },

            pinned : function( evt, fake_comment, data ){
                var comment = $L( 'lyte-comment#' + data.id, this.$node ).get( 0 );

                if( $L( evt.target ).hasClass( 'lyteNoteUnpinIcon' ) ){
                    return;
                }

                $L.fastdom.measure( function(){
                    var wrapper = $L( this.$node ).children( '.lyteNoteCommentWrapper' ),
                    cls_name = "lyteNotePinnedCommentClick",
                    fn = function( _evt ){
                        $L( _evt.currentTarget ).removeClass( cls_name ).off( {
                            animationend : fn,
                            transitionend : fn	
                        });
                    };
                    wrapper.scrollTo( { top : this.get_scrolltop( wrapper.get( 0 ), comment ) }, {
                        duration : this.data.ltPropScrollDuration,
                        onAfter : function(){
                            $L( comment ).addClass( cls_name ).on( {
                                animationend : fn,
                                transitionend : fn	
                            });
                        }.bind( this )	
                    });
                }.bind( this ));
            },

            keepedit : function(){
                this.setData( 'alertShow', false );
                this.__promeditor.focus();
                this.clear_alert();
            },

            continue : function(){
                this.setData( 'alertShow', false );
                
                var exe_arg = this.__executeArg,
                comment = this.__promcomment,
                editor = this.__promeditor;

                if( comment ){
                    this.call_cancel( editor, comment );
                }

                if( exe_arg ){
                    if( !comment ){
                        this.execute( [ 'onMainCommentCancel', editor, this.$node ].concat( this.get_files( editor ) ) )
                    }
                    this.execute( Array.from( exe_arg ) );
                } else {
                    this.$node.ltProp( 'editMode', true );
                }
                this.clear_alert();
            },

            enter : function( _this ){
                var $this = $L( _this );

                $this.attr( 'lt-prop-title', _this.scrollWidth > _this.offsetWidth ? $this.text() : '' );
            },

            thumbClick : function( index ){
                $L( this.$node ).children().get( -1 ).open( index + 1 );
                this.setup_file_data( this.__comment, index );
            },

            save : function( editor ){
                return this.execute( [ 'onMainCommentSave', editor, this.$node ].concat( this.get_files( editor ) ) );
            },

            cancel : function( editor ){
                return this.execute( [ 'onMainCommentCancel', editor, this.$node ].concat( this.get_files( editor ) ) )
            },

            other : function( editor, evt ){
                return this.execute( [ 'onButtonClick', editor, evt, this.$node ].concat( this.get_files( editor ) ) )
            },

            common_action : function( name ){

                switch( name ){
                    case 'onPreviewClick' : {
                        return this.preview_click.apply( this, arguments );
                    }
                    break;
                    // case 'onCommentEdit' : {
                    // 	if( this.close_all_comments() || this.make_main_draft() ){
                    // 		this.__executeArg = arguments;
                    // 		return;
                    // 	}
                    // }
                    default : {
                        return this.execute( Array.from( arguments ) );
                    }
                }
            },

            update_comment : function( editor, comment ){
                return this.call_cancel( editor, comment, 'onCommentSave' );
            },

            cancel_comment : function(){
                return this.call_cancel.apply( this, arguments );
            },

            show_emoji : function( elem ){
                this.show_emoji( elem );
            },

            bg_switch : function( editor ){
                var colors = this.data.ltPropColors,
                $editor = $L( editor ),
                elem = $editor.parent().children( '.lyteNoteBgSwitcher' );

                if( colors ){
                    var note = $editor.closest( 'lyte-note-editor' ).get( 0 ),
                    _color = note.ltProp( 'background' ),
                    index = this.find_index( colors, 'background', _color ),
                    final = colors[ ( index + 1 ) % colors.length ];

                    [ 'background', 'border' ].forEach( function( item ){
                        note.ltProp( item, final[ item ] );
                    });

                } else {
                    var __classname = 'lyte_note_bgswitch_elem';

                    $L( '.' + __classname, this.$node ).removeClass( __classname );
                    elem.addClass( __classname );

                    this.setData( 'bgSwitch', true );
                }
                return false;
            },

            show_smiley : function( editor ){
                this.show_emoji( $L( editor.parentNode.parentNode ).find( '.lyteNoteSmileyIcon' ).get( 0 ) );
                return false;
            },

            file_before_send : function(){
                return this.execute_file_method( arguments, 3, 'onBeforeSend' );
            },

            file_success : function(){
                return this.execute_file_method( arguments, 2, 'onSuccess' );
            },

            file_failure : function(){
                return this.execute_file_method( arguments, 2, 'onFailure' );
            },

            file_remove : function(){
                return this.execute_file_method( arguments, 2, 'onRemove' );
            },

            file_before_remove : function(){
                return this.execute_file_method( arguments, 2, 'onBeforeRemove' );
            },

            on_editor_paste : function(){
                return this.execute_file_method( arguments, 2, 'onEditorPaste' );
            },

            onAfterInput : function( name ){
                return this.execute_file_method( arguments, 3, name, true );
            },

            onWordChange : function( name ){
                return this.execute_file_method( arguments, 4, name, true );
            },

            onCursorChange : function( name ){
                return this.execute_file_method( arguments, 4, name, true );
            }
        };
    }

    execute_file_method(args, index, name, __ignore) {

		var args = Array.from( args ),
		comment = $L( args[ index ] ).closest( 'lyte-comment', this.$node ).get( 0 );

		if( comment ){
			args.push( this.get_comment_index( comment ) );
		}

		!__ignore && args.unshift( name );

		if( this.getMethods( name ) ){
			this.executeMethod.apply( this, args );
		}
		return false;
	}

    show_emoji(elem) {
		if( this.data.popoverShow ){
			return;
		}

		var __classname = 'lyte_note_origin_elem';

		$L( '.' + __classname ).removeClass( __classname );
		$L( elem ).addClass( __classname );
		this.setData( 'popoverShow', true );
	}

    execute(__arg) {
		var name = __arg.shift();

		if( /commentsave/i.test( name ) ){
			if( this.should_prevent.apply( this, __arg ) ){
				return;
			}
		}

		return this.execute_file_method( __arg, 2, name );
	}

    should_prevent(editor, notecomp, success, uploading) {
		var html = editor.getHTML(),
		message;

		if( !html.replace( '<br>', '' ) ){
			message = 'Empty';
		}

		if( uploading.length ){
			message = 'Upload';
		}

		if( message ){
			var value = this.data[ 'ltProp' + message + 'InfoMessage' ];

			if( value ){
				this.setData( 'message', value );
				this.setData( 'messageShow', true );
				return 1;
			}
		}
	}

    static observers() {
        return {
            comments_obs : function( arg ){
                if( arg.insertedItems ){
                    var index = arg.index,
                    wrapper = $L( this.$node ).children( '.lyteNoteCommentWrapper' ),
                    comment = wrapper.children().get( this.data.ltPropPinnedComments.length + index ),
                    _top = this.get_scrolltop( wrapper.get( 0 ), comment );

                    wrapper.scrollTo( { top : _top }, {
                        duration : this.data.ltPropScrollDuration,
                        onAfter : function(){
                            $L( comment ).addClass( "lyteNoteNewComment" );
                        }.bind( this )	
                    } );

                }
            }.observes( 'ltPropComments.[]' ),

            emoji_obs : function(){
                if( !this.data.popoverShow ){
                    $L( $L( 'lyte-popover.lyteNoteEmojiPopover', this.$node ).get( 0 ).component.actualModalDiv ).find( 'lyte-emoji' ).get( 0 ).resetValue();
                }
            }.observes( 'popoverShow' )
        };
    }
}


/**
 * @syntax nonYield
 * <lyte-notecomp lt-prop-comments = []></lyte-notecomp>
 */


/**
 * @syntax Pinned comment yield
 * @attribute ltPropPinnedComments
 * <lyte-notecomp lt-prop-comments = []>
 *   <template is = "registerYield" yield-name = "lyte-pinned-note">
 *       <div class="notePinMessage"></div>
 *   </template>
 * </lyte-notecomp>
 */

/**
 * @syntax Checkin yield
 * @attribute ltPropCheckIn=true
 * <lyte-notecomp lt-prop-comments = []>
 *   <template is = "registerYield" yield-name = "lyte-note-checkin">
 *        your content
 *   </template>
 * </lyte-notecomp>
 */

/**
 * @syntax Reply header yield
 * @attribute ltPropReplyYield=true
 * <lyte-notecomp lt-prop-comments = []>
 *   <template is = "registerYield" yield-name = "lyte-reply-header">
 *        your content
 *   </template>
 * </lyte-notecomp>
 */

/**
 * @syntax Reply footer yield
 * @attribute ltPropReplyYield=true
 * <lyte-notecomp lt-prop-comments = []>
 *   <template is = "registerYield" yield-name = "lyte-reply-footer">
 *        your content
 *   </template>
 * </lyte-notecomp>
 */

/**
 * @syntax Comment title yield
 * @attribute ltPropTitleYield
 * <lyte-notecomp lt-prop-comments = []>
 *   <template is = "registerYield" yield-name = "lyte-comment-title">
 *        your content
 *   </template>
 * </lyte-notecomp>
 */

export { LyteNotecompComponent }; 