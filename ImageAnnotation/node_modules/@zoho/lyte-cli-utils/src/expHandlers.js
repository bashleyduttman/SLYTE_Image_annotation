"use strict";
var expHandlers = {
	checkForError : function(errorMsg,node,isIgnore) {
		this.message = errorMsg;
		this.node = node;
		return this;
	},

	handleCallExpression : function(node,isIgnore,escape){
		var output = "";
		var callee = node.callee;
		if(callee.type == "MemberExpression") {
			throw new this.checkForError("Only helper function calls are allowed",callee);
		}
		var name = callee.name;
		if(name) {			
			output += name+"(";
		} else {
			output += this.getValueBasedOnType(callee,isIgnore)+"(";
		}
		output += this.handleCallArguments(node,isIgnore).toString();
		output += ")";
		return output;
	},

	handleCallArguments : function(node,isIgnore,escape){
			var output = [];
			var forArg = node.arguments;
			for(var k=0;k<forArg.length;k++){
				if(forArg[k].type == "CallExpression"){
						output.push(this.handleCallExpression(forArg[k],isIgnore));
				} else {
					output.push(this.getValueBasedOnType(forArg[k],isIgnore,escape));
				}
			}
			return output.toString();
	},
	handleMemberExpression : function(node,isIgnore,output){
		var val ="";
		var object = node.object;
		var name = object.name;
		if(name){
			val += name;
		}else if(object.type == "CallExpression"){
			val += this.getValueBasedOnType(object,isIgnore);
		}else {
			val += this.getValueBasedOnType(object,isIgnore);
		}
		var property = node.property;
		if(node.computed ) {			
			val += "["+this.getValueBasedOnType(property,isIgnore)+"]";
		}
		else if(property.name){
			val += "." + property.name;
		}
		return val;
	},

	getValueBasedOnType : function(node,isIgnore,switchcase,output,escape){
		switch(node.type){
			case "Identifier":
				return node.name;
			case "ThisExpression" : 
				return "this";
			case "Literal":
			case "StringLiteral":
				var value = node.value;
				var raw = node.raw;
				if(escape){
					return  raw.replace(/"/g,'\\"');
				}
				if(typeof value != "boolean" && typeof value != "number") {
					if(switchcase) {
						return value.replace(/\ /g,'&#32;');
					} else if(!isIgnore) {
					 	return raw.replace(/\"/g,'&quot;');
					} else {
						return raw;
					}
					// return "'"+node.value+"'";
				}
				return value;
			case "NumericLiteral":
			case "BooleanLiteral":
				return node.value;
			case "ObjectExpression":
				return this.handleObjectExpression(node,isIgnore,output);
			default : 
				return this.handleConditionStmt(node,isIgnore,output);
		}
	},

	handleObjectExpression: function(node,isIgnore){
		var obj = []; 
		var prop = node.properties;
		prop.forEach(function(item){
			obj.push(this.getValueBasedOnType(item.key,isIgnore)+":"+this.getValueBasedOnType(item.value,isIgnore));
		});
		return "{"+obj.toString()+"}";
	},
	
	handleConditionStmt : function(node,isIgnore){ 
		var output = "";
		var type = node.type;
		if(type == "LogicalExpression" || type == "BinaryExpression" || type =="AssignmentExpression"){
			output += "expHandlers(";
			output += this.handleConditionStmt(node.left,isIgnore);
			output += ",'" + this.checkOperator(node.operator,isIgnore)+"',";
			output += this.handleConditionStmt(node.right,isIgnore);
			output += ")";
		} else if(type == "CallExpression"){
			output += this.handleCallExpression(node,isIgnore);
		} else if(type == "Literal"){
			output += this.getValueBasedOnType(node,isIgnore);
		} else if(type === "MemberExpression"){
			var memberVal = this.handleMemberExpression(node,isIgnore);
			output += memberVal;
		} else if(type == "UpdateExpression"){
			var val = this.getValueBasedOnType(node.argument,isIgnore);
			output += "expHandlers("+val+",";
			output += this.getValueBasedOnOperation(node,isIgnore)+",";
			var prefix = node.prefix;
			if(prefix == false) {
				output += "\"postfix\"";
			} else if(prefix == true) {
				output += "\"prefix\"";
			}
			output += ')';
		} else if(type == "Identifier") {
			output += node.name;
		} else if(type == "ThisExpression") {
			output += "this";
		} else if(type == "UnaryExpression") {
			output += "expHandlers("+this.getValueBasedOnType(node.argument,isIgnore)+",'" + node.operator +"')";
		} else if(type == "ConditionalExpression") {
			output += "expHandlers(";
			output += this.handleConditionStmt(node.test,isIgnore);
			output += ",'" +this.checkOperator("?:",isIgnore)+"'";
			output += ","+this.handleConditionStmt(node.consequent,isIgnore)+',';
			output += this.handleConditionStmt(node.alternate,isIgnore);
			output += ")";
		}		
		return output;
	},

	checkOperator : function(operator,isIgnore) {
		if(operator == ">") {
			operator = isIgnore ? ">" : '&gt;';
		} else if(operator ==">="){
			operator = isIgnore ? ">=" : '&gt;=';
		} else if(operator == "?:") {
			operator = isIgnore ? "?:" : '&#63;&#58;';
		}
		return operator;
	},

	getValueBasedOnOperation : function(node,isIgnore,output) {
		if(node.operator) {
			return ("'"+node.operator+"'");
		}
	},

	handleExpression : function(node,isIgnore,output) {
		var fnbody = node.body;
		var fnVal;
		var type;
		for(var i=0; i< fnbody.length; i++) {
			fnVal = fnbody[i];
			type = fnVal.type;
			switch(type) {
				case "BlockStatement" : 
					output = this.handleExpression(fnVal,isIgnore);
					break;
				case "ExpressionStatement" :
					var expression = fnVal.expression;
					var exfnBodyType = expression.type;

					if(exfnBodyType == "CallExpression"){
						output = this.handleCallExpression(expression,isIgnore);
					} else if(exfnBodyType == "Identifier" || exfnBodyType === "ThisExpression") {
						output = this.getValueBasedOnType(expression,isIgnore);
					} else if(exfnBodyType == "MemberExpression") {
						output = this.handleMemberExpression(expression,isIgnore);
					} else {
						output = this.handleConditionStmt(expression,isIgnore);
					}
				    break;
				case "IfStatement" :
					output = this.handleConditionStmt(fnVal.test,isIgnore);
					break;
				case "SwitchStatement" :
					output = this.handleConditionStmt(fnVal.discriminant,isIgnore);
					break;	
			}
		}
		return output;
	}	
};
if(typeof module !== "undefined") {
	module.exports = expHandlers;	
}
