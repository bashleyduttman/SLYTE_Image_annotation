const chalk = require("chalk");
const readline  = require("readline");
let {commonCliUtils} = require("./utils");
class Spinner {
	constructor(options) {
        this.spinnerColor  = options.color || 'blue';
        this.succeedColor = options.succeedColor || 'green';
        this.failColor = options.failColor || 'red';
		if(commonCliUtils.isUnicodeSupported()) {
			this.failurePrefix =  '✖';
        	this.successPrefix =  '✓';
		} else {
			this.successPrefix = '√',
			this.failurePrefix = '×'
		}
		
		this.spinnerType = options.spinnerType || {
			frames : ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'], 
			interval: 80
		}
		this.currentInterval = null;
		this.lineCount = 0;
		this.stream = process.stdout;
		this.currentFrameIndex = 0;
		this.spinners = {};
		
	}
	add(name,options = {}) {
		if(!options.text) {
			options.text =  name
		}
		let spinnerProperties = {
			text :  options.text,
			status : 'incomplete'
		}
		this.spinners[name] = spinnerProperties;
		this.updateSpinnerState();
	}
	succeed(name, options = {}) {
        var text = this.spinners[name].text;
		this.spinners[name] = {
			text : options.text || text,
			status  : "succeed"
		}
		this.updateSpinnerState();
		return this.spinners[name];
	}
	update(name, options = {}) {
		if(this.spinners[name]) {
			this.spinners[name] = {
				text : options.text || name,
				status  : "incomplete"
			}
			this.updateSpinnerState();
			return this.spinners[name];
		}
	}
	fail(name, options = {}) {
		var text;
		if(this.spinners[name]) {
			text = this.spinners[name].text;
		}
       
		this.spinners[name] = {
			text : options.text || text,
			status  : "fail"
		}
		this.updateSpinnerState();
		return this.spinners[name];
	}
	updateSpinnerState() {
		clearInterval(this.currentInterval);
		this.currentInterval = this.loopStream();
		this.checkIfActiveSpinners();
	}
	checkIfActiveSpinners() {
		if (!this.hasActiveSpinners()) {
			this.setStreamOutput();
			readline.moveCursor(this.stream, 0, this.lineCount);
			clearInterval(this.currentInterval);
			this.spinners = {};
		}  
	}
	loopStream() {
		const {frames ,interval} = this.spinnerType;
		return setInterval(() => {
			this.setStreamOutput(frames[this.currentFrameIndex]);
			this.currentFrameIndex = this.currentFrameIndex === frames.length - 1 ? 0 : ++this.currentFrameIndex
		}, interval);       
	}
	setStreamOutput(frame = '') {
		let output = '';
		const linesLength = [];
		var allSpinners = Object.values(this.spinners);
        let succeedColor = this.succeedColor;
        let failedColor = this.failColor;
        let successPrefix = this.successPrefix;
        let failurePrefix = this.failurePrefix;
		allSpinners.forEach(function(spinner) {
			let status = spinner.status;
			let text = spinner.text;
			let prefixLength = 0;
			let line;
			if(status == "incomplete") {
				prefixLength += frame.length + 1;
				line = `${chalk.blue(frame)} ${chalk.blue(text)}`
			} else if(status == "succeed") {
				prefixLength += successPrefix + 1;
				line = `${chalk[succeedColor](successPrefix)} ${chalk[succeedColor](text)}`;	
			} else if(status == "fail") {
				prefixLength += failurePrefix + 1;
				line = `${chalk[failedColor](failurePrefix)} ${chalk[failedColor](text)}`;
			}
			linesLength.push(text+prefixLength);
			output+= line+"\n";
		}.bind(this));
		this.writeStream(this.stream, output, linesLength);
		this.lineCount = linesLength.length;
	}
	hasActiveSpinners() {
		return !!Object.values(this.spinners).find(({ status }) => status === 'incomplete');
	}
	writeStream(stream, output, rawLines) {
		readline.clearScreenDown(stream);
		stream.write(output);
		readline.moveCursor(stream, 0, -rawLines.length);
	}
}


module.exports = Spinner;
