let t = require("@babel/types");
let returnNode =  function(node,location) {
    node.loc = location;
    return node;
}
module.exports = {
    importDeclaration : function(specifiers, source,location) {
        return returnNode(t.importDeclaration(specifiers, source),location)
    },
    importSpecifier : function(local,imported,location) {
        return returnNode(t.importSpecifier(local,imported),location);
    },
    ifStatement : function(test, consequent, alternate,location) {
        return returnNode(t.ifStatement(test, consequent, alternate),location);
    },
    exportDefaultDeclaration: function(declaration,loc) {
        return returnNode(t.exportDefaultDeclaration(declaration),loc);
    },
    numericLiteral : function(value,location) {
        return returnNode(t.numericLiteral(value),location);
    },
    importNamespaceSpecifier: function(local,location) {
        return returnNode(t.importNamespaceSpecifier(local),location);
    },
    importDefaultSpecifier : function(local,location){
        return returnNode(t.importDefaultSpecifier(local),location);
    },
    classDeclaration : function(id, superClass, body, decorators,location) {
        return returnNode(t.classDeclaration(id, superClass, body, decorators),location);
    },
    classBody : function(body,location) {
        return returnNode( t.classBody(body),location)
    },
    classProperty : function(key, value, typeAnnotation, decorators, computed, static,location) {
        return returnNode(t.classProperty(key, value, typeAnnotation, decorators, computed, static),location)
    },
    exportDefaultDeclaration : function(declaration,location) {
        return returnNode(t.exportDefaultDeclaration(declaration),location);
    },
    exportNamedDeclaration : function(declaration,specifiers,source){
        return returnNode(t.exportNamedDeclaration(declaration, specifiers, source));
    },
    exportSpecifier : function(local,exported){
        return returnNode(t.exportSpecifier(local, exported));
    },
    classMethod : function(kind, key, params, body, computed, static, generator, async,location) {
        return returnNode(t.classMethod(kind, key, params, body, computed, static, generator, async),location);
    },
    super : function(){
        return returnNode(t.super());
    },
    program : function(body, directives, sourceType, interpreter,location) {

        return returnNode(t.program(body, directives, sourceType, interpreter),location);
    },
    file : function(program,comments,tokens,location) {
        return returnNode(t.file(program, comments, tokens),location);
    },
    memberExpression : function(object,property,computed,optional,location){
       return returnNode(t.memberExpression(object,property,computed,optional),location);
    },
    assignmentExpression : function(operator,left,right,location) {
        return returnNode(t.assignmentExpression(operator,left,right),location);
    },
    callExpression : function(callee,args,location){
        return returnNode(t.callExpression(callee,args),location);
    },
    _import : function(location) {
        return returnNode(t.import(),location)
    },
    identifier : function(name,location) {
        return returnNode(t.identifier(name),location);
    },
    returnStatement : function(argument,location) {
        return returnNode(t.returnStatement(argument),location);
    },
    stringLiteral : function(name,location) {
        return returnNode(t.stringLiteral(name),location);
    },
    booleanLiteral : function(name,location) {
        return returnNode(t.booleanLiteral(name),location);
    },
    newExpression : function(callee,args,location) {
        return returnNode(t.newExpression(callee, args),location);
    },
    expressionStatement : function(expression,location){
        return returnNode(t.expressionStatement(expression),location);
    },
    variableDeclaration : function(kind, declarations,location) {
        return returnNode(t.variableDeclaration(kind, declarations),location);
    },
    variableDeclarator : function(id,init,location) {
        return returnNode(t.variableDeclarator(id,init),location);
    },

    objectProperty : function(key, value, computed, shorthand, decorators,location) {
        return returnNode(t.objectProperty(key, value, computed, shorthand, decorators),location);
    },
    objectPattern : function(properties,location) {
        return returnNode(t.objectPattern(properties),location);
    },
    functionExpression : function(id, params, body, generator, async,location) {
        return returnNode(t.functionExpression(id, params, body, generator, async),location);
    },
    objectExpression : function(properties,location) {
        return returnNode(t.objectExpression(properties),location);
    },

    variableDeclaration : function(kind, declarations,location)  {
        return returnNode(t.variableDeclaration(kind,declarations),location);
    },

    blockStatement : function(body, directives,location) {
        return returnNode(t.blockStatement(body,directives),location);
    },

    logicalExpression : function(operator,left,right,location) {
        return returnNode(t.logicalExpression(operator,left,right),location);
    },

    arrayExpression : function(elements,location) {
        return returnNode(t.arrayExpression(elements),location);
    },

    thisExpression : function(location) {
        return returnNode(t.thisExpression(),location);
    },

    _super : function(location) {
        return returnNode(t.super(),location);
    }

}