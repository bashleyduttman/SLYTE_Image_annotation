var path = require('path');
var fs = require('fs'),
    htmlMinifier = require("html-minifier").minify,
    terser = require("terser"),
    Concat =  require("concat-with-sourcemaps"),
    sourceMap  = require("source-map"),
    CleanCSS = require("clean-css"),
    table = require('table');
let fileTypeFnMap = {".js" : "minifyJs", ".css" :  "minifyCss", ".html" : "minifyHtml"},
    extToApplyBeforeCompilation = {".js" : "js",".html" : "html",".css" :"css",".txt" : "txt"},
    isExistInIgnoreArray = function(ignoreFolderLists,filePath) {
        for(var i = 0 ; i < ignoreFolderLists.length ;i++) {
            if(filePath.indexOf(ignoreFolderLists[i]) != -1) {
                return true;
            } 
        }
        return false;
    },
    
    checkForMinifyErrorInSourceFiles = function(fn,sourceFileList,callback,to,cssMinify) {
        let sourceFileListLen = sourceFileList.length;
        let fileManipulation = utils.fileManipulation;
        let cb = function(index,msg){
            if(index == sourceFileListLen-1) {
                callback(new Error(msg),to);
            }
        };
        let msg = "Error occur in the minification of "+to+"\n\t";
        let index  = 0;
        sourceFileList.forEach(function(file) { 
            if(fileManipulation.fileExist(file)){
                fn["minify"](fileManipulation.readSync(file,'utf-8')).catch(function(err){
                    if(cssMinify) {
                        msg +="Syntax error in the file "+file;
                        err.forEach(function(e) {
                            msg+=e;
                        });
                    } else {
                        msg += "Syntax error in the file "+file+" at line no : "+err.line+'\n\t'; 
                    }
                    cb(index++,msg);
                }).then(function(){
                    cb(index++,msg);
                });
            } else {
                cb(index++,msg);
            }
        });
    },
    checkTheExtOfFile = function(file,ext,extLen) {
        var strLen = file.length;
        return file.indexOf(ext,strLen - extLen);
    }, 
    predictLineNo = function(str,position) {
        var tempString = str.substring(0, position);
        var tempStringArray = tempString.split('\n');
        var lastLine = tempStringArray[tempStringArray.length-1];
        if(lastLine.trim().length) {
            return tempStringArray.length;
        } 
        return tempStringArray.length-1;
    };
/*variable for fileManipulation */
let  fingerPrintOpt,systemLog,userLog,es6Path,production,sourceMapFlag,commonObj;
let utils = {
    stringManipulation : {
        pluralize : function(str) {
            return str+(this.isUpperCase(str) ? "S" : "s");
        },
        
        isUpperCase : function(str) {
            return str == str.toUpperCase() ? true : false;
        },
        
        escapeSpecialChar : function(content){
            return JSON.stringify(content);
        },
        
        replaceSpecialCharWithHTML : function(str) {
            return str.replace(/>/g,"&gt;").replace(/>=/g,"&gt;=").replace(/</g,"&lt;").replace(/<=/g,"&lt;=").replace(/\"/g,'&quot;');
        }
    },
    fileManipulation : {
        init : function(options) {
            fingerPrintOpt = options.fingerPrint;
            systemLog = options.log.system;
            userLog = options.log.user;
            sourceMapFlag = options.sourceMap;
            production = options.production;
            commonObj = utils.commonObj;
            es6Path = options.es6Path;
        },

        validateFile : function(file) {
            return file.indexOf('.') && !file.includes('.orig') && !file.includes(".rej") && !file.includes(".DS_store");
        },

        access : function(file,callback) {
            fs.access(file,fs.constants.F_OK,function(err){
                err ? callback(new Error(err)) : callback();
            });
        },
        
        fileExist : function(file) {
            return fs.existsSync(file);
        },

        rename : function(oldPath,newPath,callback){
            fs.rename(oldPath,newPath,function(err){
                if(err){
                    callback(new Error(err));
                }else{
                    callback();
                }
            });

        },

        lstatSync : function(file) {    
            return fs.lstatSync(file);      
        },
    
        lstat : function(file,callback) {
            fs.lstat(file,function(err,stats){
                if(err) {
                    callback(new Error(err));
                } else {
                    callback(null,stats);
                }
            });
        },
        
        mkdir : function(dir,callback) {
            fs.mkdir(dir,{recursive : true},function(err) {
                err ? callback(new Error(err)) : callback();
            });
        },
        
        mkdirSync : function(dir) {
            fs.mkdirSync(dir,{recursive : true});
        },
        
        readdirSync : function(folder) {
            return fs.readdirSync(folder);
        },

        readdir : function(file,callback) {
            fs.readdir(file,function(err,files){
                err ? callback(new Error(err)) : callback(null,files)
            });
           
        },
    
        truncate : function(file) {     
            if(this.validateFile(file)) {
                var dir = path.parse(file).dir;     
                this.mkdirSync(dir);            
                this.writeSync(file,'');
            } else {
                //console.log(chalk.red(file +' is not a valid file.'));
            }
        },

        writeSync : function(file,content,options){

            if(options) {
                if(typeof options == "object") {
                    fs.writeFileSync(file,content,options); 
                } else {
                    fs.writeFileSync(file,content);
                }
            } else {            
                fs.writeFileSync(file,content);
            }
        },

        write : function(file,data,callback) {

            fs.writeFile(file,data,function(err) {
                if(err) {
                    callback(new Error(err));
                } else {
                    callback();
                }
            });
        },

        append : function(file,data,callback) {
            fs.appendFile(file,data,function(err){
                err ? callback(new Error(err)) : callback();
            });
        },

        appendSync : function(fileName,content,options){
            if(this.validateFile(fileName)) {               
                if(typeof options == "object") {
                    fs.appendFileSync(fileName,content,options);
                } else {                    
                    fs.appendFileSync(fileName,content);    
                }                       
            }
        },

        readSync : function(file,type) {
            type  = type || "utf-8"
            if(fs.existsSync(file)) {
                return fs.readFileSync(file,type);  
            }  
            throw new Error("No such file or directory "+file)
            
            // console.log('There is no file named ' +file);
        },
    
        read : function() {
            fs.readFile.apply(null,arguments);
        },

        createReadStream : function() {
            return fs.createReadStream.apply(null,arguments);
        },

        createWriteStream : function(){
            return fs.createWriteStream.apply(null,arguments);
        },

        remove : function(file,callback) {
            let removeTheFile = function(file,callback) {
                fs.unlink(file,callback);
            };
            let self = this;
            let removeCount = 0;
            let len;
            let allFilesIterated = false;
            let cb = function(err,isDir) {
                if(allFilesIterated){
                    if(removeCount == len) {
                        if(err) {
                            callback(err);
                        } else {
                            if(isDir) {
                                self.removeSync(file,true);
                            } 
                            callback();
                        }
                    }
                }
            };
            
            self.lstat(file,function(err,stats){
                if(err) {
                    callback(err);
                } else {
                    if(stats.isDirectory()) {
                        self.getFilesList(file,null,function(err,items) {
                            if(err) {
                                cb(err);
                            } else {
                                allFilesIterated = true;
                                len = items.length;
                                cb(err,true);
                            }
                        },function(item) {
                            removeTheFile(item,function(err) {                                  
                                removeCount++;
                                cb(err,true);
                            });
                        });
                    } else {
                        removeTheFile(file,callback);
                    }
                }
            });
    
        },

        removeSync : function(file,permitFlag){  
            if(this.fileExist(file)) {          
                if(!permitFlag){
                    if(process.env.PRODUCTION) {
                        console.log("Files don't have permission to delete");
                    } else {
                        permitFlag = this.prompt('The '+file+' to be going to deleted , Are you sure to continue ?? Y/N');
                    }
                }
            }
            if(permitFlag){ 
                // try {
                //     if(process.platform == "win32") {
                //         execSync('rmdir /q /s '+file);
                //     } else {
                //         execSync('rm -rf '+file);
                //     }
                // } catch(e) {
                    var deleteFolderRecursive = function(filePath) {
                        this.readdirSync(filePath).forEach(function(file){
                            var curPath = filePath + path.sep + file;
                            if(this.lstatSync(curPath).isDirectory()) { // recurse
                                deleteFolderRecursive.call(this,curPath);
                            } else { // delete file
                                fs.unlinkSync(curPath);
                            }
                        }.bind(this));
                        fs.rmdirSync(filePath);
                        
                    };
                    if(this.fileExist(file)) {
                        if(this.lstatSync(file).isDirectory()){
                            deleteFolderRecursive.call(this,file);
                        } else {    
                            fs.unlinkSync(file);    
                        }    
                    }
            //     }
            }
        },

        getFilesList : function(dir,validationFn,done,callback,throwError) {
            let self = this;
            var results = [];
            validationFn = validationFn || function() { return true; };
            callback  = callback || function(){};
            self.readdir(dir, function(err, list) {
                if (err)  { return done(err,[]) };
                var pending = list.length;
                if (!pending) { return done(null, results) };
                list.forEach(function(file) {
                    if(self.validateFile(file)) {
                        file = path.join(dir, file);
                        self.lstat(file, function(err, stat) {
                            if (err) { return done(err,[]) };
                            if(stat.isSymbolicLink()) {
                                if(validationFn(file)) {
                                    callback(file,true);
                 
                                    results.push(file);
                                }
                                completedCheck(true);
                            } else {
                                if (stat.isDirectory()) {
                                    self.getFilesList(file,validationFn,function(err, res) {
                                        if (err) { return done(err,[]) };
                                        results = results.concat(res);
                                        completedCheck();
                                    },callback);
                                } else {
                                    if(validationFn(file)) {
                                        callback(file,null,dir);
                                        results.push(file);
                                    } else {
                                        if(throwError) {
                                            callback(file,"Not an valid File")
                                        }
                                    }
                                    completedCheck();
                                }
                            }
                        });
                    } else {
                       
                        completedCheck();
                    }
                });
                function completedCheck(isSymbolicLink) {

                    if (!--pending) {
   
                        done(null, results,isSymbolicLink);
                    }
                }
            });
        },
    
        getFilesListSync : function(from,ignoreArr) {
            if(!ignoreArr){
                ignoreArr = [];
            }
            var files = [];
            if(this.fileExist(from)) {
                this.readdirSync(from).forEach(function(file) {
                    if(!ignoreArr.includes(file)){
                        var fromPath = path.join(from,file);
                        if(this.validateFile(fromPath)) {
                            if(this.lstatSync(fromPath).isDirectory()) {     
                                files.push.apply(files,this.getFilesListSync(fromPath));         
                            }else{
                                if(!files.includes(fromPath)){
                                    files.push(fromPath);
                                }
                            }
                        }
                    }
                }.bind(this));   
            }
            return files;  
        },

        copyWithSymbolicLink : function(obj,callback) {
            let file = obj.src;
            let copyTo = obj.dist;      
            this.mkdir(path.parse(copyTo).dir,function(err){
                if(err) {
                    callback(err);
                } else {
                    fs.symlink(file,copyTo,function(err){
                        callback(err,copyTo);
                    }); 
                }
            }.bind(this));
        },
    
        copy : function(options,obj,callback) {
            let file = obj.src;
            let copyTo = obj.dist;
            let self = this;
            let fileExt = self.getTheFileExt(file),
                errorOccurs = false;
            var beforeCompilation = obj.beforeCompilation,
                afterCompilation = obj.afterCompilation,	
			    compilation = obj.compilation,
                returnValue;
            
            if(extToApplyBeforeCompilation[fileExt]) {
                self.read(file,function(err,data){
                    
                    if(err) {
                        callback(new Error(err));
                        return;
                    }
                    
                    data = data.toString();         
                    commonObj.fileOriginalContent[file] = data;
                    if(beforeCompilation) {  
                        try {   
                            returnValue = beforeCompilation.call({
                                data : data,
                                file : file
                            });
                            let code;
                            if(returnValue.code) {
                                code = returnValue.code;
                                let map = returnValue.map;
                                if(map != "undefined" && typeof map == "string") {
                                    callbackValue[copyTo+'.map'] = map;
                                }
                            } else {
                                code = returnValue;
                            }
                            if(code != data) {
                                data = (code != undefined && code != null) ? code : data;
                            }
                        } catch(e) {
                            errorOccurs = true;
                            e.message = "Error occur while running beforeCompilation function for the file  \n"+file+"\n "+e.message;
                            callback(e);
                        }
                    }
                    if(!errorOccurs) {
                        if(compilation) {	
                            var returnObj = compilation(options,data,file,"registerClosure");	
                            if(returnObj.error) {	
                                callback(returnObj.error);	
                            } else {	
                                data = returnObj.content;
                                
                            }	
                        }	
                        	
                       // callback();
                        self.customFsWriteFn(options,data,copyTo,afterCompilation,obj.minify,callback);
                    }
                });  
            } else {
                var copyToObj = path.parse(copyTo);
                self.mkdir(copyToObj.dir,function(err) {
                    if(err) {
                        callback(err);
                    } else {
                        if(afterCompilation) {
                            self.read(file,function(err,data){
                                var result = afterCompilation.call({file : copyToObj,data : data});
                                copyTo = result.file;
                                self.write(copyTo,data,callback);
                            })
                        } else {
                            fs.copyFile(file,copyTo,function(err){
                                err ? callback(new Error(err)) : callback();
                            });
                        }
                    }
                });
            }                   
        },

        concat : function(options,obj,convertToAsyncAndAwait) { 
            let errorClass = utils.errorClass,
                minify = obj.minify,
                transpileOpt = options.transpile,
                outputFolder = options._appOutputFolder,
                self = this,
                toFolder = obj.dist,
                afterCompilation = obj.afterCompilation,
                fileArray = obj.src,
                callback = function(err) {
                    if(err) { 
                        obj.callback(err)
                    } else {
                        if(completedState.es5File && (completedState.es6File == undefined || completedState.es6File)){
                            obj.callback();
                        }   
                    }       
                },
                es6FileArray = [],
                completedState = {
                    es5File : false
                },
                setContent = function(to,toFolderObj,content,sourceMap,callback,sourceFileArray){
                    minify ? self.minify(options,{
                            src : to,
                            dist : to,
                            content : content
                    },callback,sourceFileArray) : self.mkdir(toFolderObj.dir,function(err) {
                        err ?  callback(err) : self.write(to,content,function(err) {
                            err ?  callback(err) : ((sourceMap && toFolderObj.ext == ".js") ? self.write(to+'.map',commonObj.fileContent[to+'.map'],callback) :callback());
                        });
                    });     
                },
                concat = new Concat(sourceMapFlag,toFolder,'\n'), 
                cb = function(to,toFolderObj,incremental,len,type,nextCall) {
                    if(incremental == len) {
                        let distcontent = concat.content.toString();
                        if(afterCompilation) {
                            distcontent = afterCompilation(options,distcontent,to).content;
                        }
                        commonObj.fileContent[to] = distcontent;
                        let callToWrite = function(mapContent) {
                            if(sourceMapFlag && toFolderObj.ext == ".js") {
                                distcontent = distcontent + '\n//# sourceMappingURL='+toFolderObj.name+toFolderObj.ext+".map";
                                commonObj.fileContent[to+'.map'] = JSON.stringify(JSON.parse(mapContent || concat.sourceMap));                                                              
                            }
                            if(transpileOpt) {
                                transpileOpt = false;
                                let es6DistPath = toFolder.replace(outputFolder,es6Path);
                                concat = new Concat(sourceMapFlag,es6DistPath,'\n'),
                                completedState.es6File = false;
                                iterateTheFileArray(es6FileArray,transpileOpt,"es6File",es6DistPath);
                            }
                            setContent(to,toFolderObj,distcontent,sourceMapFlag,function(err) {                                 
                                completedState[type] = true;
                                callback(err,to);                                   
                            },fileArray);
                        }                       
                        systemLog({msg :"Consolidated file created in the "+path.relative(options.root,to)+'\n',timestamp : new Date().getTime(),type :"INFO"});   
                     
                        if(convertToAsyncAndAwait && toFolderObj.ext == ".js") {
                            try {                              
                                let lintOptions = sourceMapFlag ?  {
                                    content : distcontent,
                                    dist : toFolder,
                                    sourceMapFileName : toFolder,
                                    sourceMap : sourceMapFlag,
                                    sourceMapContent : concat.sourceMap
                                } : { 
                                    content : distcontent,
                                    dist : toFolder
                                };
                                                
                                let result = self.convertToAsyncAndAwait(lintOptions);
                                distcontent = result.code;
                                callToWrite(result.map);
                            } catch(e) {
                                callback(e,to);
                            }
                        } else {
                            callToWrite();
                        }
                    } else {
                        nextCall(incremental);
                    }
                },
                concatFn = function(value,callback)  {
                    let map;

                    let content = value.source;
                    let fullPath = value.sourceFile;
                    let file = path.relative(outputFolder,fullPath);                    
                    if(sourceMapFlag && file.includes(".js")) {                                                     
                        self.getFileContent.call(self,fullPath+'.map',function(err,prevMapContent) {                 
                            if(err) {
                                map = new sourceMap.SourceMapGenerator({
                                    file : file,
                                    sourceRoot : outputFolder,  
                                });
                                map = JSON.parse(map);
                                map.sources = [file];
                                map.sourcesContent = [content];
                                map.sourceRoot =  outputFolder;      
                                concat.add(file,content,map);
                                callback();
                            } else {                                            
                                sourceMap.SourceMapConsumer.with(JSON.parse(prevMapContent), null, consumer => {                            
                                    map = JSON.parse(sourceMap.SourceMapGenerator.fromSourceMap(consumer));
                                    concat.add(file,content,map);
                                    callback(); 
                                });
                            }
                        });                     
                    } else {                                            
                        concat.add(file,content);
                        callback();
                    }
                },
                handleWarnings = function(message) {
                    errorClass.handleWarnings(options,{
                        message :message,
                        userLog : userLog,
                        systemLog : systemLog
                    },options.verbose);
                },
                iterateTheFileArray = function(fileArray,transpileOpt,type,toFolder) {
                    let incremental = 0;
                    let length = fileArray.length;
                    let toFolderObj = path.parse(toFolder),
                        toFolderExt = toFolderObj.ext,
                        toFolderExtLen = toFolderExt.length;
                    if(toFolderExt) {
                        if(length) {
                            let nextCall = function(inc) {
                                loopFn(fileArray[inc]);
                            }
                            let callbackFn = function() {
                                incremental++;            
                                cb(toFolder,toFolderObj,incremental,length,type,nextCall)
                            }
                            let loopFn = function(file) {
                                if(toFolder != file) {
                                    if(checkTheExtOfFile(file,toFolderExt,toFolderExtLen) != -1) {
                                        self.getFileContent.call(self,file,function(err,fileData){
                                            if(err) {
                                                handleWarnings("Warning : file not found "+file);
                                                callbackFn();
                                            } else {
                                                if(transpileOpt) {
                                                    es6FileArray.push(file.replace(outputFolder,es6Path));
                                                }   
                                                concatFn({
                                                    source : fileData,
                                                    sourceFile: file
                                                },function() {
                                                    callbackFn();
                                                });             
                                            }
                                        });
                                    } else {
                                        handleWarnings(file+" file with not valid ext found while consolidating the file "+toFolder);
                                        callbackFn();
                                    }
                                } else {
                                    completedState.es5File = true;
                                    callback(new Error("Destination file :"+path.relative(options.root,toFolder)+". Source and destination file should not be in the same location for consolidation"));            
                                }
                            }
                            loopFn(fileArray[0]);
                        } else {
                            completedState.es5File = true;
                            callback();
                        }
                    } else {
                        callback(new Error("Destination should be a file\n.Key "+toFolder+' not contain the extension'));            
                    }
                    
                }
            iterateTheFileArray(fileArray,transpileOpt,'es5File',toFolder)
        },

        minify : function(options,obj,callback,sourceFileArray) {   
            var from = obj.src,
                to = obj.dist,
                content = obj.content,
                toCall,
                toObj = path.parse(to),
                extTo = toObj.ext,
                self = this,
                extFrom = self.getTheFileExt(from),
                callMinify = function() {
                    if(toCall = fileTypeFnMap[extTo]) {
                        self[toCall].call(self,options,to,content,callback,sourceFileArray);
                    } else {         
                        self.mkdir(toObj.dir,function(err) {
                            err ? callback(err) : self.write(to,content,callback);
                        });
                    }
                };
            if(extFrom != extTo) {
                callback(new Error("Error in the minification of the file"+to+"\n"+"Mismatch in the extension of src and dist file"));
                return;
            }   
            if(content) {
                callMinify();
            } else {
                if(from != to) {
                    self.read(from,'utf-8',function(err,data){
                        if(err)  {
                            callback(err) 
                        } else {
                            content = data;
                            callMinify();
                        }
                    });
                } else {
                    callback();
                }
            }
            
        },

        minifyJs : function(options,to,content,callback,sourceFileList)    {       
            let outputFolder = options._appOutputFolder,
                relativeToPath = path.relative(outputFolder,to),
                mapString = '',
                fnScopeMapContent,
                mapFilePath = to+'.map',
                uglifyEsOptions = {},
                code = {},
                sourceMapFlag = options.sourceMap;
            code[relativeToPath] = content;
            var callTerserFn = function() {
                var self = this;
                options.minifyCount++;
                terser.minify(code,uglifyEsOptions).then(function(result){
                    let code = result.code;
                    let map = result.map;
                    self.mkdir(toObj.dir,function(err){   
                        if(err) {
                            callback(err);
                            return;
                        }   
                        if(fingerPrintOpt) {
                            to = self.generateFingerPrint(options,toObj,code);
                            if(sourceMapFlag) {
                                mapFilePath = self.generateFingerPrint(options,mapFilePath,map.toString());
                            }
                        }           
                        self.write(to,result.code,function(err){        
                            err ? callback(err) : (sourceMapFlag ?  self.append(to,mapString,function(err){
                                err ? callback(err) :  self.write(mapFilePath,map.toString(),callback);
                            }) : callback(null)); 
                        });
                    });                 
                }).catch(function(err){
                    let errFileName = err.filename;
                    if(fnScopeMapContent){
                        sourceMap.SourceMapConsumer.with(JSON.parse(fnScopeMapContent),null,function(consumer){
                            var originalFileObj = consumer.originalPositionFor({
                                line: err.line,
                                column: err.col
                            });
                            if(originalFileObj.source) {
                                var msg = "Error occur in the minification of "+errFileName+"\n\t Syntax error in the file "+originalFileObj.source+" at line no :"+originalFileObj.line; 
                                callback(new Error(msg),to);
                            } else {
                                checkForMinifyErrorInSourceFiles(terser,sourceFileList,callback,to);
                            }
                        });
                    } else {
                        if(sourceFileList) {
                            checkForMinifyErrorInSourceFiles(terser,sourceFileList,callback,to);
                        } else {
                            callback(new Error(err),to);
                        }
                    }
                });
            };
            let toObj = path.parse(to);
            if(sourceMapFlag) {
                mapString = '\n//# sourceMappingURL='+toObj.name+toObj.ext+".map";
                let sourceMapOptions = {};
                sourceMapOptions.includeSources = true ;            
                this.getFileContent.call(this,mapFilePath,function(err,mapContent){
                    fnScopeMapContent = mapContent;
                    if(!err) {
                        sourceMapOptions.content = mapContent;
                    }
                    uglifyEsOptions.sourceMap = sourceMapOptions;
                    callTerserFn.call(this);
                }.bind(this));
            } else {
                callTerserFn.call(this);
            }
        },

        getFileContent : function(filePath,callback) {
            let commonObj = utils.commonObj;
            var content = commonObj.fileOriginalContent[filePath];
            if(content) {
                callback(null,content);
            } else {
                this.read(filePath,'utf-8',function(err,data) {
                    commonObj.fileOriginalContent[filePath] = data;
                    err ? callback(err) : callback(null,data);
                })
            }
        },

        minifyCss : function(options,to,data,callback,sourceFileList) {
            var cleanCSSOptions = {
                level : {
                    2 : {
                        mergeAdjacentRules: true,
                        removeDuplicateRules: true
                    }
                }
            }
            var cleanCssDef = new CleanCSS(cleanCSSOptions);
            options.minifyCount++;
            cleanCssDef.minify(data,function(err,result) {
                
                if(err) {
                    if(sourceFileList) {
                        cleanCSSOptions.returnPromise = true;
                        checkForMinifyErrorInSourceFiles(new CleanCSS(cleanCSSOptions),sourceFileList,callback,to,true);
                    } else {
                        var errStr = 'Error occur in the minification of the file '+to+"\n";
                        err.forEach(function(e){
                            errStr+=e;
                        })
                        callback(new Error(errStr),to);
                    }
                } else { 
                    let styleStr = result.styles
                    let toObj = path.parse(to);
                    fingerPrintOpt && (to = this.generateFingerPrint(options,toObj,styleStr));
                    this.mkdir(toObj.dir,function(error){
                        error ? callback(error) : this.write(to,styleStr,callback);
                    }.bind(this));
                }
            }.bind(this)); 
        },

        minifyHtml : function(options,to,min,callback) {       
            try {
                min = htmlMinifier(min);
                fingerPrintOpt && (to = this.generateFingerPrint(options,to,min));
                var toObj = path.parse(to);
                this.mkdir(toObj.dir,function(err){
                    err ?  callback(err) : this.write(to,min,callback);
                }.bind(this));
            } catch(e) {
                callback(e);
            }   
        },

        getTheFileExt : function(fileName) {
            // return fileName.substring((fileName.lastIndexOf(".") -1 >>> 0) + 1);
            return path.parse(fileName).ext;
        },
        
        merge_array : function(array,array1) {
            array1.forEach(function(e) {
                if(array.indexOf(e) == -1) {
                    array.push(e);
                }
            });
        },
    
        merge_object : function(obj,obj1){
            var objVal;
            var obj1Val;
            for(var key in obj1) {
                objVal = obj[key];
                obj1Val = obj1[key];
                let arrayType = Array.isArray(objVal);
                if(objVal && typeof objVal == 'object' && !arrayType) {
                    this.merge_object(objVal,obj1Val);
                } else {
                    if(arrayType) {
                        obj1Val.push.apply(obj1Val,objVal)
                    }
                    obj[key] = obj1Val;
                }
            }
        },

        pushIfNotExist : function(array,value) {
            if(!array.includes(value)) {
                array.push(value);
            }
        },
        transpileFn : function(options,obj,callback) {
            let file = obj.src,
                copyTo = obj.dist,
                content = obj.content,  
                outputFolder = options._appOutputFolder,
                minify = obj.minify,
                beforeCompilation = obj.beforeCompilation,
                self = this,
                afterCompilation  = obj.afterCompilation;   
            let wrapperCbFn = function(err) {
                if(err){
                    callback(err);
                } else {
                    let distes6Path = copyTo.replace(outputFolder,es6Path);
                    obj.dist = distes6Path;
                    if(beforeCompilation) {
                        result = beforeCompilation.call({
                            file : file,
                            data : content
                        })
                        content = result;
                    }
                    content ? self.customFsWriteFn(options,content,distes6Path,afterCompilation,minify,callback) : self.copy(options,obj,callback);
                }
            };
            let transpileCall = function(data,file) {
                try {
                    data = self.transpileUtil({
                        transpileOptions : options.transpileOpt,
                        file : file,
                        content : data,
                        beforeCompilation : beforeCompilation
                    },true);
                    self.customFsWriteFn(options,data,copyTo,afterCompilation,minify,wrapperCbFn);
                } catch(e) {
                    wrapperCbFn(e);
                }               
            };
            if(self.getTheFileExt(file) == ".js") {
                if(!(isExistInIgnoreArray(options.ignoreFoldersFromTranspile || [],file))) {
                    if(content) {
                        transpileCall(content);
                    } else {
                        self.read(file,function(err,data){
                            if(err) {
                                wrapperCbFn(err);
                            } else {
                                data = data.toString();
                                transpileCall(data,file);
                            }
                        });
                    }
                } else {
                    content ? self.customFsWriteFn(options,content,copyTo,afterCompilation,minify,wrapperCbFn): self.copy(options,obj,wrapperCbFn);
                }
            } else {
                content ?  self.customFsWriteFn(options,content,copyTo,afterCompilation,minify,wrapperCbFn) : self.copy(options,obj,wrapperCbFn);           
            }
        },
        customFsWriteFn : function(options,data,copyTo,afterCompilation,minify,callback) {
            var copyToObj = path.parse(copyTo);
            if(afterCompilation) {
                var result;
                result = afterCompilation.call({
                    data : data,
                    file : copyToObj
                });
                if(result.data != data) {
                    let newData = result.data;
                    data = (newData  != undefined && newData  != null) ? newData : data;
                }
                copyTo = result.file;
            }
           
            copyToObj = path.parse(copyTo);
            this.mkdir(copyToObj.dir,function(err) {
                if(err) {
                    callback(err);
                    return;
                }
                minify ? this.minify(options,{
                    src : copyTo,
                    content : data,
                    dist : copyTo
                },callback) : this.write(copyTo,data,callback);
            }.bind(this));
        },
        generateFingerPrint : function(options,file,code) {
            let resultOfFingerPrint  = this.fingerPrintFn(file,code,options.fingerPrintKeyRelativeTo);          
            options.fingerPrintMapping[resultOfFingerPrint.originalPath] = resultOfFingerPrint.hashPath; 
            return resultOfFingerPrint.absoluteHashPath;
        },

        prompt : function(question,color){      
            if(!color){
                color ="blue";
            }
            var chalk = require("chalk");
            var readLineSync = require('readline-sync');
            var result = readLineSync.question(chalk[color](question));
            if(result.toUpperCase() == 'YES'||result.toUpperCase() == 'Y') {
                return true;
            }else if(result.toUpperCase() == 'NO'||result.toUpperCase() == 'N') {
                return false;
            }else{
                return result;
            }
        },

       
    },
    errorClass : {
        createErrorObj : function(options,obj) {

            const {codeFrameColumns} = require("@babel/code-frame");
            let msg = '';
            var pushingTheErrorObj = function(file,message,location,sourceCode,tag){
                options.errorObj[file] = options.errorObj[file] || [];
                let line,column;
                let l = location && location.start;
                if(l) {
                    line = l.line;
                    column =  l.column;
                }
               
                var formattedSourceCode = '';
                if(sourceCode && location){
                    formattedSourceCode = codeFrameColumns(sourceCode,location,{linesBelow : 4});
                }
                let obj = {
                    message : message,
                    line : line,
                    column : column,
                    tag : tag,
                    source : formattedSourceCode,
                    level : "error"
                }
                
                options.errorObj[file].push(obj);
                return "ERROR in "+file+" at "+(line? line : '')+(column ? (':'+column): '')+"\n"+message+"\n"+formattedSourceCode+"\n";;
            };
            var result = obj.errMsg || obj.message;
            
            if(Array.isArray(result)){  
                result.forEach(function(report){
                    if(report.messages.length){
                        report.messages.forEach(function(message){
                            msg+=pushingTheErrorObj(report.filePath,message.message,{start : { line : message.line,column : message.column}},report.source,message.tag);
                        });
                    }
                });
            } else {
                var file = obj.file;
                if(file){
                    msg+=pushingTheErrorObj(file,result,obj.loc,obj.sourceCode,obj.tag);
                }
            }

            return msg;
        
    },

    handleWarnings : function(options,obj,disableLogs) {  
        var level = obj.level;
        var warningLevel = options.showWarningLevel || level;
        obj.systemLog({msg : obj.message,type :"WARNING",_zl_timestamp: new Date().getTime()});
        if(warningLevel != level) {         
            return;
        }
        if(options.production && level == 2) {
            return;
        }
        if(!disableLogs) {
            if(obj.tableDisplay) {
                // commonObj.groupLogMessage[options.root][obj.commonContent].msg.push(obj.tableContent);
            } else {
                options.warningsCount++;
                obj.userLog({msg :obj.message,color:"yellow"});
            }
        }

    },
    
    handleErrors: function(options,obj,reject,resolve,alwaysExit,toWrite) {  
        options.errorCount++; 
        if(toWrite == undefined) {
            toWrite = true;
        }
        var message = obj.message;   
        let prod = options.production;
        let fromWebpack = obj.fromWebpack;
        obj.systemLog({msg : message,throwable : obj.stack,type : "SEVERE",_zl_timestamp:obj._zl_timestamp});  
        let webpackProcessing = function(result,prod) {
            let srcCopyAppDir = options._cli.src.default.copyAppDir;
            let returnSourceCode = function(filePath,lineNumber) {
                let file = path.isAbsolute(filePath) ? filePath : path.join(srcCopyAppDir,filePath)
                let source = commonObj.compiledFileContent[file];
                if(!source) {
                    source = commonObj.fileOriginalContent[file];
                } 
                if(typeof source == "object") {
                    source = source.compiledCode;
                }
                let str;
                if(source) {
                    let sourceArray = source.split("\n");
                    str ='';
                    for(let i =0,len = lineNumber; i <= len;i++) {
                        str = str+sourceArray[i]+"\n";
                    }
               
                }
                return str;
                
            }
            let msg= '';
            result.forEach(function(report) {
                let error = report.error;
                let message = error.message
                let line = error.line;
                let column = error.column
                let filePath =error.file || report.module.resource

                let obj = {
                    message : message,
                    file : filePath
                }
                let loc = report.loc;
                if(line) {
                    // let locArray = report.loc.split('-');
                    // let line = locArray[0].split(':');
                    obj.loc = {
                        start : {
                            line : line,
                            column : column
                        }
                    },
                    obj.sourceCode = prod ?  undefined : returnSourceCode(filePath,line)
                } else if(loc) {
                    obj.sourceCode = prod ? undefined : returnSourceCode(filePath,loc.start.line)
                    obj.loc = loc;
                }
                // let source = report.module._source._value;
                
                // let {line,column} = loc;
                msg += this.createErrorObj(options,obj);
                // return+= "ERROR in "+filePath+" "+loc+"\n"+message+"\n"
            }.bind(this))
            return msg;
        }
        if(prod || !options.watch || alwaysExit) {
            if(fromWebpack) {
                obj.message = webpackProcessing.call(this,obj.errMsg,prod);
                reject(obj)
            } else {
                
                reject(obj);
            }
        }  else {
            if(toWrite) {
                if(fromWebpack) {
                    obj.userLog({msg : webpackProcessing.call(this,obj.errMsg,prod),color:"red"});
                } else {
                
                    let message = obj.message;
                    let returnVal = this.createErrorObj(options,obj);
                    if(!message) {
                        message = returnVal;
                    }
                    // console.log(obj.stack);
                    obj.userLog({msg : message,color:"red"});
                }
            }
            if(resolve) {
                resolve(obj);
            }
        } 
        // if(!options.watch || alwaysExit) {
        //     reject(obj);
        // } else {
        //     if(message) {
        //         obj.userLog({msg : message,color:"red"});
        //     }
        //     let prod = options.production
        //     var result = obj.errMsg || obj.message;
        //     if(obj.fromWebpack) {
        //         if(prod) {
        //             let msg = "";
        //             result.forEach(function(report){
        //                 // let error = report.error;
        //                 let filePath = report.moduleName;
        //                 // let source = report.module._source._value;
                       
        //                 let loc = report.loc;
        //                 let message = report.message;
        //                 // let {line,column} = loc;
        //                 msg+= "ERROR in "+filePath+" "+loc+"\n"+message+"\n"
                       
                       
        //             });
                    
        //             obj.userLog({msg : msg,color:"red"});
        //         } else {
        //             obj.userLog({msg : this.createErrorObj(options,obj),color:"red"});
        //         }
        //     } else {
        //         if(prod) {
        //             this.createErrorObj(options,obj);
        //         }
        //     }
    
            
        //     if(resolve) {
        //         resolve(obj);
        //     }
        // }
    }
    },
    commonCliUtils : {
        getPort : function(options) {
            let net = require("net");
            let port = options ? options.port : undefined;
            const checkAvailablePort = function(port,resolve,callback) {
                const server = net.createServer();
                server.unref();
                server.on('error',function(err){
                    callback(err,resolve)
                });
                server.listen(port, () => {
                    const {port} = server.address();
                    server.close(() => {
                        resolve(port);
                    });
                });
            }
            return new Promise(function(resolve,reject) {
                let errorCallback = function(err,resolve) {
                    checkAvailablePort(0,resolve,function() {
                        if(err) {
                            reject(err);
                        }
                    });
                }
                port ? checkAvailablePort(port,resolve,errorCallback) : checkAvailablePort(0,resolve,errorCallback)
            })
        },
        isUnicodeSupported : function() {
            let platform = process.platform;
            if(platform == "win32") {
                return Boolean(process.env.CI)
                || Boolean(process.env.WT_SESSION) // Windows Terminal
                || Boolean(process.env.TERMINUS_SUBLIME) // Terminus (<0.2.27)
                || process.env.TERM_PROGRAM === 'Terminus-Sublime'
                || process.env.TERM_PROGRAM === 'vscode'
                || process.env.TERM === 'xterm-256color'
                || process.env.TERM === 'alacritty'
                || process.env.TERMINAL_EMULATOR === 'JetBrains-JediTerm';
            } else {
                return true;
            }
        },
        camelCaseCompName : function(compName,splitChar) {
			let splitStr = compName.split(splitChar);
			let finalStr ="";
			for(let k =0 ;k<splitStr.length;k++){
				let val = splitStr[k];
				finalStr += val.charAt(0).toUpperCase() + val.substring(1);
			}
			return finalStr;
		},
        returnErrorObject : function(err) {
            if(typeof err != "object") {
                let e = err;
                err = {};
                err.message = e;
            }
            err.userLog = userLog;
            err.systemLog = systemLog;                     
            err._zl_timestamp  = new Date().getTime(); 
            return err;
        },
        loopedTheArrayAddMapping : function(array,srcFileName,ob) {
            let {originalLineOffset,generatedLineOffset,sourceMapObj} = ob;
            array.forEach(function() {
                sourceMapObj.addMapping({
                    source : srcFileName,
                    original : {
                        line : ++originalLineOffset,
                        column : 0
                    },
                    generated : {
                        line : ++generatedLineOffset,
                        column :  0
                    }
                })
            })
           return (ob = {originalLineOffset,generatedLineOffset,sourceMapObj});
        },
        constructMappingForComponents : function(beforeStr,template,afterStr,sourceFileName,distFileName,originalSource,callback) {
            try {
                let data = '';
                let sourceMapObj = new sourceMap.SourceMapGenerator({
                    file : distFileName
                });
                let originalLineOffset = 0,generatedLineOffset = 0;
                let ob = {sourceMapObj,generatedLineOffset,originalLineOffset};
                ({ sourceMapObj,generatedLineOffset,originalLineOffset } = this.loopedTheArrayAddMapping(beforeStr.split("\n"),sourceFileName,ob));
                template.split('\n').forEach(function(){
                    sourceMapObj.addMapping({
                        source : sourceFileName,
                        original : {
                            line : originalLineOffset,
                            column : 0
                        },
                        generated : {
                            line : ++generatedLineOffset,
                            column : 0
                        }
                    })
                });
                ({sourceMapObj} =  this.loopedTheArrayAddMapping(afterStr.split("\n"),sourceFileName,{sourceMapObj,generatedLineOffset,originalLineOffset}));
                data += beforeStr+"\n"+template+afterStr;
                sourceMapObj.setSourceContent(sourceFileName,originalSource);
                callback(null,data,sourceMapObj.toString());
            } catch(e){
                callback(e);
            } 
        },
        minifyHTMLContent : function(content) {
            if(!(content.includes("<pre ") || content.includes("<pre>"))) {
                content = content.replace(/\r?\n|\r/g,' ').replace(/\s+/g,' ');
            } else {
                var count = 0;
                var preContentArr = [];
                var matchingReturn = function(html) {
                    var match= [null];
                    match[0] = html.indexOf('<pre '); 
                    match[1] = html.indexOf('<pre>');
                    return match[0] == -1 ? ( match[1] == -1 ? null : match[1]) : ( match[1] == -1 ? match[0] : (match[0] < match[1] ?  match[0] : match[1]));
                }
                var preTagRemover = function(html,nextIndex) {
                    var startIndex = nextIndex || matchingReturn(html);
                    var endIndex = html.indexOf('</pre>')+6;
                    var preContent = html.substring(startIndex+4,endIndex);
                    var remContent = html.substring(endIndex);
                    var nextPreIndex,
                        nextEndIndex;
                    while((nextPreIndex = matchingReturn(preContent))) {
                        preContent = preContent.substring(nextPreIndex+4,endIndex);
                        nextEndIndex = remContent.indexOf('</pre>')+6;
                        endIndex = endIndex+nextEndIndex;
                        remContent = remContent.substring(nextEndIndex);
                    }
                    preContent = html.substring(startIndex,endIndex);
                    preContentArr.push(preContent);
                    html = html.replace(preContent,'<<<_pre'+count+'>>>');
                    if((nextIndex = matchingReturn(html))) {
                        count++;
                        return preTagRemover(html,nextIndex);
                    } 
                    return html;
                    
                };
                content = preTagRemover(content);
                content = content.replace(/\r?\n|\r/g,' ').replace(/\s+/g,' ')
                for(var index = 0;index<=count;index++) {
                    content = content.replace('<<<_pre'+index+'>>>',preContentArr[index]);
                }
            }
            return content;	
        },
        createAnHTMLObject : function(options,errorObj) {
            var htmlObj ='',
            styleData = utils.fileManipulation.readSync(path.join(options.cliRoot,"lib","webSocket","error-page.css"),'utf-8')
            
            htmlObj += `<html><head><style>`+styleData+`</style>
            </head><body>`+
            `<div class="lyteErrorPageContainer">
            <div class="errorBoxWrap">`;	
            var str =''	;
            for(var fileName in errorObj) {
                str += `<div class="lyteErrorBox">
                <div> <span class="FileNameLabel">`+fileName+`</span></div>`
                errorObj[fileName].forEach(function(value,index) {
                    str += `<div class="messageList"> <span class="errorNo">`+(index+1)+`</span>`;
                    str += `<span class="mainErrorMsg">`+value.message+`</span>`;
                    if(value.line) {
                        str+=` in line number `+value.line;
                    }
                    if(value.column) {
                        str+=`:`+value.column;
                    }
                    if(value.tag) {
                        str+=`=> `+value.tag.replace(/\</g,'&lt').replace(/\>/g,'&gt')+"";
                    }
                    if(value.source) {
                        str+=`<div class="errorPreWrap"><pre class="errorCode">`+value.source.replace(/\</g,'&lt').replace(/\>/g,'&gt')+`</pre></div>`
                    }
                    str +='</div>'	
                })
                str+='</div>'
            }
            htmlObj += str;
            htmlObj += `</div></div>`		
            htmlObj+`</body></html>`;
    
            return htmlObj;
        },
        convertStringToCamelCase : function(input) {
            const preserveCamelCase = (string, locale) => {
                let isLastCharLower = false;
                let isLastCharUpper = false;
                let isLastLastCharUpper = false;
                for (let i = 0; i < string.length; i++) {
                    const character = string[i];	
                    if (isLastCharLower && /[\p{Lu}]/u.test(character)) {
                        string = string.slice(0, i) + '-' + string.slice(i);
                        isLastCharLower = false;
                        isLastLastCharUpper = isLastCharUpper;
                        isLastCharUpper = true;
                        i++;
                    } else if (isLastCharUpper && isLastLastCharUpper && /[\p{Ll}]/u.test(character)) {
                        string = string.slice(0, i - 1) + '-' + string.slice(i - 1);
                        isLastLastCharUpper = isLastCharUpper;
                        isLastCharUpper = false;
                        isLastCharLower = true;
                    } else {
                        isLastCharLower = character.toLocaleLowerCase(locale) === character && character.toLocaleUpperCase(locale) !== character;
                        isLastLastCharUpper = isLastCharUpper;
                        isLastCharUpper = character.toLocaleUpperCase(locale) === character && character.toLocaleLowerCase(locale) !== character;
                    }
                }
            
                return string;
            };
            const postProcess = (input) => {
                return input.replace(/[_.\- ]+([\p{Alpha}\p{N}_]|$)/gu, (_, p1) => p1.toLocaleUpperCase(locale))
                    .replace(/\d+([\p{Alpha}\p{N}_]|$)/gu, m => m.toLocaleUpperCase(locale));
            };
            
            
            let locale = 'en-US'
            if (input.length === 1) {
                return input.toLocaleLowerCase(locale);
            }
        
            const hasUpperCase = input !== input.toLocaleLowerCase(locale);
        
            if (hasUpperCase) {
                input = preserveCamelCase(input,locale)
            }
        
            input = input.replace(/^[_.\- ]+/, '');
            input = input.toLocaleLowerCase();
            return postProcess(input);	
        },
    
        tryCatch : function(fn,optName,package) {
            try {
                fn();
            } catch(e) {
                throw (optName ? new Error("Dependencies of "+optName+' named '+package+' missing.\nInstall the dependencies using npm') : e);
            }
        },

        convertHTMLToJS : function(options,obj,callback) {
            let fileName = obj.htmlFile,
                name = obj.name,
                concatenatedString = function(filePath) {
                    return "/*--System generated component concatenation "+filePath+"---*/\n"
                },
                lyteFilePath = obj.lyteFilePath,
                fileContent = obj.htmlContent;	
            var data = fileContent.replace(/forEach\s+\(.*?}\)/g,"$&"+";"),
                reg = /<\s*%|%\s*>|<\s*!\s*-\s*-/g;	 
            let errorCallback = function(type,line){
                let err = new Error("Unexpected "+type+" parenthesis in "+path.relative(options.root,fileName)+" at the line number "+line);
                err.line = line;
                err.errMsg = "Unexpected "+type+" parenthesis";
                err.file = fileName;
                err.timestamp = new Date().getTime();
                callback(err);
            };     
            let escapeSpecialChar = utils.stringManipulation.escapeSpecialChar;
            let minifyHTMLContent = this.minifyHTMLContent;

            if(data.includes("<%") || data.includes("%>")) {
                if(data.includes("<!--")) {
                    let dataWithoutComment = data.replace(/<!--(.|\s)*?-->/g,'');
                    if(!dataWithoutComment.includes("<%") && !dataWithoutComment.includes("%>")) {
                        callback(null,{
                            htmlContent : minifyHTMLContent(data)
                        });
                        return;
                    }
                }
                
                var lastIndex = 0,
                    match,
                    matchedIndex,
                    loopCnt = 0,
                    stack = [],
                    content,
                    functionSyntax = "function "+name.replace(/-/g,'$')+"(){ ";
                    functionSyntax += "\n\t";
                
                while(match = reg.exec(data))  {  
                    matchedIndex = match.index;					
                    content = data.substring(lastIndex,matchedIndex);				
                    if(match[0] == "<%" || match[0] == "<!--") { 				
                        if(match[0] != "<!--") {										
                            if(stack.length != 0) {
                                errorCallback("opening",predictLineNo(fileContent,matchedIndex)+1);
                                return;
                            }
                            stack.push("<%");
                        }        	           	
                        if(loopCnt == 0 ) {
                            functionSyntax += 'var str=';
                        } else {
                            functionSyntax += '\nstr +=';
                        }
                        content = escapeSpecialChar(content);
                        functionSyntax +=  content +";";	              
                    } else  {            	
                        if(match[0] == "%>") {
                            if(stack.length != 1) {
                                errorCallback("closing",predictLineNo(fileContent,matchedIndex))
                                return;
                            }
                            stack.pop();
                        }	
                        functionSyntax += content;
                    }
                    if(match[0] == "<!--") {					
                        reg.lastIndex = lastIndex = data.indexOf("-->",match.index)+"-->".length; 
                    } else {
                        lastIndex = match.index + 2;
                    }			
                    loopCnt++;
                }	
                if(stack.length != 0) {
                    errorCallback("opening",predictLineNo(fileContent,matchedIndex));
                    return;
                }

                content = data.substring(lastIndex);
                if(content) {   
                    if(loopCnt == 0 ) {
                        functionSyntax += 'var str=';
                    } else {
                        functionSyntax += '\nstr +=';
                    }
                    functionSyntax += escapeSpecialChar(content) +";";
                }
                functionSyntax += "}";            
                functionSyntax = concatenatedString(lyteFilePath)+functionSyntax;
                callback(null,{
                    functionSyntax : functionSyntax,
                    htmlContent : ''
                });
            } else {
                callback(null,{
                    htmlContent : minifyHTMLContent(data)
                });
            }
        },
        checkAnyKeyInObj : function(obj) {
            var anyKeyExist = false;
            for(let key in obj) {
                anyKeyExist = true;
                break;
            }
            return anyKeyExist;
        },

        returnDiffPairsInObj : function(obj,obj1) {
            var newObj = {
                deletedKeys : [],
                newPairsInObj : {}
            };
            var isEqual;
            function compareTheValues(array,array1) {
                if(typeof array == "string") {
                    return array == array1 ? true : false;
                } else {
                    var lengthOfArray = array.length;
                    var lengthOfArray1 = array1.length;
                    var baseArray;
                    var checkWith;
                    if(lengthOfArray >= lengthOfArray1) {
                        baseArray = array;
                        checkWith = array1;
                    } else {
                        baseArray = array1;
                        checkWith = array;
                    }
                    for(var index = 0,len = baseArray.length;index<len;index++) {
                        if(!checkWith.includes(baseArray[index])) {
                            return false;
                        }
                    }
                    return true;
                }
            }
            let key;
            for(key in obj) {
                if(obj1[key]) {
                    isEqual = compareTheValues(obj[key],obj1[key]);
                    if(!isEqual){
                        newObj.newPairsInObj[key] = obj1[key];
                    }
                } else {
                    newObj.deletedKeys.push(key);
                }
            }
    
            for(key in obj1) {
                if(obj[key]) {
                    isEqual = compareTheValues(obj[key],obj1[key]);
                    if(!isEqual){
                        newObj.newPairsInObj[key] = obj1[key];
                    }
                } else {
                    newObj.newPairsInObj[key] = obj1[key];
                }
            }
            return newObj;
        },	

        checkForLyte : function(options,module) {
            var srcBuild = path.join(options.root,"build","build.js");
            switch(module) {
                case "app" :
                    return utils.fileManipulation.fileExist(srcBuild) ? true : false;
                case "addon":
                case "engine":  
                    return require(srcBuild)[module] ? true : false;      
            }
        },
        validateHelperName : function(name) {
            let check = ['-','+','*','/','%','?','=','!']
            for(let index = 0,len = check.length;index <len;index++) {
                if(name.includes(check[index])) {
                    return false;
                }
            }
            return true;
        },

        validateComponentName : function(name) { /*component and test name should follow the rules that doesn't contain number capital and should be hypenated*/
            var reg = /([a-z][a-z0-9]*(-[a-z0-9]+)+)/;
            var matched = name.match(reg);
            return (matched && matched[0] == name);
        },
        
        validateWidgetName : function(name) { /*component and test name should follow the rules that doesn't contain number capital and should be hypenated*/
            var reg = /([a-z0-9])*(\-([a-z0-9])*)?/;
            var matched = name.match(reg);
            return (matched && matched[0] == name);
        },
        validateForSpecialCharacters : function(name){
            var reg = /([a-zA-Z0-9-_]+)*/;
            var matched = name.match(reg);
            return (matched && matched[0] == name);
        },
        isReservedKeyword : function(name) {
            let nonAllowedCharacters = [
                "break","case","catch","continue","debugger",
                "default","delete", "do", "else",
                "finally","for","function","if", "in",
                "instanceof", "new", "return",
                "switch", "this", "throw", "try",
                "typeof", "var", "void", "while",
                "with","class","const","enum",
                "export","extends","import","super",
                "implements","interface","let","package",
                "private","protected","public","static","yield",
                "true","false","null"
            ];
            return nonAllowedCharacters.includes(name)
        },
        replaceSpecialChar : function(name) {
            let allowedChars = ['-'];
            for(let i =0,len  = allowedChars.length;i< len;i++){
                let iAllowChars = allowedChars[i];
                // if(name.includes(iAllowChars)) {
                    name = this.camelCaseCompName(name,iAllowChars);
                // }
                
            }
            return name;
        },
        validateFolderName : function(name){
            if(this.isReservedKeyword(name)) {
                throw new Error("Name should not contain reserved keywords");
            } else {
                if(this.validateForSpecialCharacters(name)){
                    return true;
                } else { 
                    throw new Error("Special characters are not allowed in the folder name");  
                }
            }
        },
        validatePackageName : function(name,options) {
            if(this.isReservedKeyword(name)) {
                throw new Error("Name should not contain reserved keywords");
            } else {
                let reg = /([a-z0-9_-]+)*/;
                let matched = name.match(reg);
                let isMatch = (matched && matched[0] == name);
                if(isMatch) {
                    return true;
                } else {
                    options.log.user({color : 'yellow',msg: 'The package name does not follow the npm naming convention'});
                    return false;
                    //throw new Error("Invalid app name .App name should follow npm naming convention")
                }
            }
        },
        validateClassName : function(name){
            
            if(this.isReservedKeyword(name)) {
                throw new Error("Name should not contain reserved keywords");
            } else {
                if(this.validateForSpecialCharacters(name)){
                    return this.replaceSpecialChar(name);
                } else { 
                    throw new Error("Name should not contain the special characters except hyphen and underscore")   
                }
            }
        },
        validateWidgetComponentName : function(name,namespace) {
            if(name.startsWith(namespace)) {
                return true;
            }
            return false;
        },
        checkForAlreadyExistence : function(baseFolder,moduleName,module) {
            var fileManipulation = utils.fileManipulation;
            var srcFolderModule = baseFolder[module];
            if(fileManipulation.fileExist(srcFolderModule)) {
                var fileList = fileManipulation.getFilesListSync(srcFolderModule);
                for(var index = 0 ;index < fileList.length ;index++) {
                    if(moduleName == path.parse(fileList[index]).name) {
                        return true;
                    }
                }
                return false;
            } 
            return false;
        },
        validateModuleName :  function(value,defaultModules) { /*for generate and destroy command */
            // var modules =  ["route","component","helper","model","adapter","mixin","serializer","test","theme","blueprint"];
            if(defaultModules.includes(value)) {
                return true;
            } 
            return false;
        },
        removeEmptyFolder : function(dir,baseRoute,options) {
            var base;
            var fileManipulation = utils.fileManipulation;
            let registry = options.registry || "default";
            base = baseRoute ? path.relative(process.cwd(),options._cli.src[registry][baseRoute]) :  path.relative(process.cwd(),options.root);
            dir = path.relative(process.cwd(),dir);
            dir = dir.split(path.sep);
            dir.pop();
            if(dir = dir.join(path.sep)) {
                if(dir != base) {
                    if(fileManipulation.fileExist(dir)) {
                        var file;
                        if(file = fs.readdirSync(dir)) {				
                            if(!file.length) {							
                                fileManipulation.removeSync(dir,true);
                                this.removeEmptyFolder(dir,baseRoute,options);
                            }
                            return;
                        }
                    }
                }
            }
        },
        consoletable : function(table,row,column) {
            return table(row,column);
        },
        checkForAlreadyExistAndPushValueInObj  : function(obj,key,newPairs) {                                                
            if(!obj.keys.includes(key)) {
                obj.keys.push(key);
                for(let map in newPairs){
                    obj[map].push(newPairs[map]);
                }
            }
        },
    },
    
    cliSpinner : function(obj) {
        let consoletable = utils.commonCliUtils.consoletable;
        let chalk ={};
        let Multispinner;
        let pushTheLog = [];
        let logPrinting = function(options) {
           
            if(options.fromCommandLine) {
                printLogs(pushTheLog)
            } else {
                !options.inapp && printLogs(pushTheLog);
            }
        }

        let allDone = true,
            printLogs = function(logStack) {		
                var color;
                var msg,fn;
                var stack;
                var callback;
                var i,len;
                for(i = 0, len = logStack.length; i<len; i++){
                    msg = logStack[i].msg;
                    fn = logStack[i].row;
                    column = logStack[i].column;
                    color = logStack[i].color || 'blue';
                    callback = logStack[i].callback;
                    console.log(chalk[color](msg || fn && console.table(fn,column)));
                    if(stack = logStack[i].stack) {
                        console.log(stack);
                    }
                    if(callback){
                        callback();
                    }
                }
                userLogs = [];
            };
        
        if((obj.production)) { 		
            let chalkColor = ["red",'yellow','blue','grey','green','cyan',"white"];
            let length = chalkColor.length;
            for(let i =0;i<length;i++) {
                chalk[chalkColor[i]] = function(msg) {
                    return msg;
                }
            }
            let tableObj = table.table;
            let getBorderCharacters =  table.getBorderCharacters;
            console.table = function(msg) {
                var keysLen = msg[0].length;
                var width = Math.floor(process.stdout.columns/keysLen)-10;
                if(width <=0) {
                    width = 1;
                }
                let config  = {
                    columnDefault : {
                        width :  width
                    },
                    border: getBorderCharacters('void')
                }
                return consoletable(tableObj,msg,config);
            }
        } else {
            Multispinner = require('./spinner');
            let tableObj = table.table;
            chalk = require("chalk");
            console.table = function(msg) {
                var keysLen = msg[0].length;
                var width = Math.floor(process.stdout.columns/keysLen)-10;
                let config  = {
                    columnDefault : {
                        width :  width
                    }
                }
                return consoletable(tableObj,msg,config);
            }
        }
        return {
            startSpinner : function(spinnerInfo,options) {
                let module = spinnerInfo.module
                if(module) {
                    if(options.multispinner) {
                        allDone = false;
                        options.multispinner.add(module,{
                            text: spinnerInfo.msg
                        })
                    } else {
                        if(options.production || options.nospinner) {
                            allDone = false;						
                            options.multispinner =  {
                                spinners : {},
                                success : function(mod) {
                                    let incompleteState = false;
                                    let thisSpinnerObj = this.spinners;
                                    let key;
                                    thisSpinnerObj[mod].status ="success";									
                                    for(key in thisSpinnerObj) {
                                        if(thisSpinnerObj[key].status == "incomplete") {
                                            incompleteState = true;
                                        }
                                    }
                                    if(!incompleteState) {
                                        allDone = true;
                                        logPrinting(options);
                                    }	
                                },
                                error : function(mod,err) {
                                    this.spinners[mod].status = "error";						
                                    allDone=true;
                                    printLogs(pushTheLog,groupWarnings);
                                    options.reject(err || new Error("Lyte build failed"));
                                },
                                add : function(mod)  {
                                    this.spinners[mod] =  {
                                        status : "incomplete",
                                        text : mod
                                    }
                                },
                                update : function() {}
                            };
                            options.multispinner.add(module);						
                        } else { 
                            var spinner = new Multispinner({color: 'blue', succeedColor: 'green',failColor : 'red',frames: ['‚†ã', '‚†ô', '‚†π', '‚†∏', '‚†º', '‚†¥', '‚†¶', '‚†ß', '‚†á', '‚†è'], interval: 80 });					
                            allDone = false;
                            options.multispinner = spinner
                            options.multispinner.add(module,{
                                text : spinnerInfo.msg
                            })
                            
                            options.multispinner.success = function(mod) {
                                spinner.succeed(mod);
                                if(!spinner.hasActiveSpinners()) {
                                    allDone = true;
                                    logPrinting(options);
                                    userLogs = [];
                                }
                            }
                            options.multispinner.error = function(mod) {
                                spinner.fail(mod);
                                if(!spinner.hasActiveSpinners()) {
                                    allDone = true;
                                    logPrinting(options);
                                    userLogs = [];
                                }
                            }						
                        }
                    }
                } else {
                    if(allDone) {
                        printLogs([spinnerInfo]);
                    } else {
                        pushTheLog.push(spinnerInfo);
                    }
                }
            }
        }
        
    },
    classToCustomClassFn : function(pBody,obj,superClass,nodeExpression,noChangeInClassName) {
        let body = pBody.body;
        let id = pBody.id
        let name = id.name;
        let arg1 = nodeExpression.identifier("arg1");
        let overrides = nodeExpression.identifier("overrides");
        let elements = obj;
        if(!elements.length) {
            if(superClass) {
                elements = [superClass]
            }
        }
        let newBodyNode = [];
        let a;
        if(noChangeInClassName) {
            a = id;
        } else {
            a = nodeExpression.identifier(name+"Class")
        }
        let newSuperclass = nodeExpression.callExpression(nodeExpression.identifier("getClass"),[nodeExpression.arrayExpression(elements),arg1])
        newBodyNode.push(nodeExpression.classDeclaration(a,newSuperclass,body));
        newBodyNode.push(nodeExpression.returnStatement(nodeExpression.callExpression(overrides,[a])));
        return nodeExpression.variableDeclaration("let",[
            nodeExpression.variableDeclarator(
                id,
                nodeExpression.callExpression(
                    nodeExpression.identifier("createCustomClass"),
                    [nodeExpression.functionExpression(null,[arg1,overrides],nodeExpression.blockStatement(newBodyNode,[]),false,false)]
                )
            )
        ])
    },
    commonObj : {
        fileOriginalContent : {},
        compiledFileContent : {},       
    }

}
module.exports = utils;
