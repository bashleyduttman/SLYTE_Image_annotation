var idbObj = {}, qLen, qTemp, pK, module;

self.onmessage = function(event){
    var q = event.data, idb;
    if(q.tolyteidb){
        idb = idbObj[q.name];
        if(q.type != "open" && !idb){
            self.postMessage({lyteidb:true,pause:true,schema:q.schema,type:q.type});
        }
        else if(q.type == "push"){
            qLen = qTemp = 0;
            module = q.module;
            pK = undefined;
            var data = q.data;
            if(!Array.isArray(data)){
                data = [data];                    
            }
            pK = q.pK;
            qLen = data.length;
            data.forEach(function(item, index){
                qProcess(item,item.type);
            });
        }
        else{
            qProcess(q, q.type);
        }
    }
};

function processed(obj){
    if(++qTemp == qLen){
        getAll({schema:obj.schema, name:obj.name}).then(function(res){
            var pks = [];
            var data = res.data || [];
            var pKs = pK.split(',');
            data.forEach(function(item){
                var pkVal;
                if(pKs.length > 1){
                    pkVal = {};
                    pKs.forEach(function(itm, idx){
                        pkVal[itm] = item[itm];
                    });
                }
                else{
                    pkVal = item[pK];
                }
                pks.push(pkVal);
            });
            self.postMessage({lyteidb:true, qProcess:"completed4",data:pks});
        });
    }
}

function qProcess(obj, type){
    if(obj.queryCache == true && obj.type === "getCachedData" && ( !obj.queryParams || (obj.queryParams && Object.keys(obj.queryParams).length == 0)) ){
        if(obj.req == "getAll"){
            obj.type = "_getAll";
        }
        else if(obj.req == "getEntity"){
            obj.type = "_get";
        }
    }
    switch(obj.type){
        case "getCachedData":
        {
            getCachedData(obj).then(function(res){
                self.postMessage({lyteidb:true, schema:obj.schema,type:obj.type,queryParams:obj.queryParams,code:200,data:res, req:obj.req, key:obj.key});
            },function(){
                self.postMessage({lyteidb:true, schema:obj.schema,type:obj.type,queryParams:obj.queryParams,code:400, req:obj.req, key:obj.key});                
            });
            break;
        }
        case "pushPayload":{
            if(!obj.data[obj.schema]){
                var data = obj.data;
                obj.data = {};
                obj.data[obj.schema] = data;
            }
        }
        case "getAll":
        case "getEntity":
        case "push": {
            push(obj,obj.type).then(function(){
                processed(obj);
            },function(){
                processed(obj);
            });
            break;
        }
        case "open": {
            openIDB(obj);
            break;
        }   
        case "create": {
            addMultiple(obj).then(function(){
                processed(obj);
            },function(){
                processed(obj);
            });
            break;
        }
        case "createEntity": {
            addData(obj).then(function(){
                processed(obj);
            },function(){
                processed(obj);
            });
            break;
        }   
        case "delete": {
            deleteMultiple(obj).then(function(){
                processed(obj);
            },function(){
                processed(obj);
            });
            break;
        }
        case "destroyEntity":
        case "deleteEntity": {
            deleteData(obj).then(function(){
                processed(obj);
            },function(){
                processed(obj);
            });
            break;
        }   
        case "update":{
            updateMultiple(obj).then(function(){
                processed(obj);
            },function(){
                processed(obj);
            });
            break;
        }
        case "updateEntity":{
            updateData(obj).then(function(){
                processed(obj);
            },function(){
                processed(obj);
            });
            break;
        }
        case "_get":{
            obj.processKey = true;
            getData(obj).then(function(res){
                getCachedMeta(obj).then(function(meta){
                    if(res.data == undefined){
                        self.postMessage({lyteidb:true, schema:obj.schema,type:obj.type,queryParams:obj.queryParams,code:400,req:obj.req, key:obj.key});                                    
                    }
                    else{
                        var resp = {};
                        resp[obj.schema] = res.data;
                        if(meta){
                            resp.meta = meta
                        }
                        self.postMessage({lyteidb:true, schema:obj.schema,type:obj.type,queryParams:obj.queryParams,code:200,data:resp,req:obj.req,  key:obj.key});
                    }    
                }, function(){
                    if(res.data == undefined){
                        self.postMessage({lyteidb:true, schema:obj.schema,type:obj.type,queryParams:obj.queryParams,code:400,req:obj.req, key:obj.key});                                    
                    }
                    else{
                        var resp = {};
                        resp[obj.schema] = res.data;
                        self.postMessage({lyteidb:true, schema:obj.schema,type:obj.type,queryParams:obj.queryParams,code:200,data:resp,req:obj.req,  key:obj.key});
                    }    
                });
            },function(){
                self.postMessage({lyteidb:true, schema:obj.schema,type:obj.type,queryParams:obj.queryParams,code:400,req:obj.req,  key:obj.key});                
            });
            break;
        }
        case "_getAll":{
            getAll(obj).then(function(res){
                getCachedMeta(obj).then(function(meta){
                    if(Array.isArray(res.data) && !res.data.length){
                        self.postMessage({lyteidb:true, schema:obj.schema,type:obj.type,queryParams:obj.queryParams,code:400,req:obj.req});                                    
                    } else{
                        var resp = {};
                        resp[obj.schema] = res.data;
                        if(meta){
                            resp.meta = meta
                        }
                        self.postMessage({lyteidb:true, schema:obj.schema,type:obj.type,queryParams:obj.queryParams,code:200,data:resp, req:obj.req});
                    }
                }, function(){
                    if(Array.isArray(res.data) && !res.data.length){
                        self.postMessage({lyteidb:true, schema:obj.schema,type:obj.type,queryParams:obj.queryParams,code:400,req:obj.req});                                    
                    } else{
                        var resp = {};
                        resp[obj.schema] = res.data;
                        self.postMessage({lyteidb:true, schema:obj.schema,type:obj.type,queryParams:obj.queryParams,code:200,data:resp, req:obj.req});
                    }
                });
            },function(){
                self.postMessage({lyteidb:true, schema:obj.schema,type:obj.type,queryParams:obj.queryParams,code:400, req:obj.req});                
            });
            break;
        }
        case "close":{
            var idb = idbObj[obj.name];
            idb.close();
            break;
        }
        default:{
            self.postMessage({lyteidb:true, msg:"No such actions defined "+obj.type, data:obj.data})
            break;
        }
    }
}

function getCachedMeta(obj){
    return new Promise(function(resolve, reject){
        var module = obj.schema;
        var qP = obj.queryParams;
        var type = obj.req;
        var key = obj.key;
        getData({schema:"__meta",key:module,name:obj.name}).then(function(res){
            if(res.data == undefined){
                return reject();
            }
            var cachedQ = res.data.cache;
            cachedQ = cachedQ[type];
            var index = checkWithQp(cachedQ,obj,key), meta;
            if(index != -1){
                var q = cachedQ[index];
                if(type == "findRecord"){
                    if(q.key && key && q.key == key){
                        meta = q.meta;
                    }
                    else{
                        return reject();
                    }
                }
                else{
                    meta = q.data.meta;
                }
                return resolve(meta);
            }
            else{
                return reject();
            }
        });    
    });
}

function getCachedData(obj){
    return new Promise(function(resolve, reject){
        var module = obj.schema;
        var qP = obj.queryParams;
        var type = obj.req;
        var key = obj.key;
        getData({schema:"__meta",key:module,name:obj.name}).then(function(res){
            if(res.data == undefined){
                return reject();
            }
            var cachedQ = res.data.cache;
            cachedQ = cachedQ[type];
            var index = checkWithQp(cachedQ,obj);
            if(index != -1){
                var q = cachedQ[index], vals;
                if(type == "findRecord"){
                    if(q.key && key && q.key == key){
                        vals = [q.data];
                        // meta = q.meta;
                    }
                    else{
                        return reject();
                    }
                }
                else{
                    vals = q.data[module];
                }
                // if(type == "findRecord" && !Array.isArray(vals)){
                    //     vals = [vals];
                    // }
                if(vals && vals.length){
                    var len = vals.length, i=0, result = [];
                    vals.forEach(function(itm,idx){
                        getData({schema:module,key:itm,processKey:true,name:obj.name}).then(function(msg){
                            result[idx] = msg.data;
                            if(++i == len){
                                var retObj = {};
                                if(type == "findRecord"){
                                    retObj[obj.schema] = result[0];
                                    if(q.meta !== undefined){
                                        retObj.meta = q.meta;
                                    }
                                }
                                else{
                                    retObj[obj.schema] = result;
                                    if(q.data && q.data.meta){
                                        retObj.meta = q.data.meta;
                                    }
                                }
                                return resolve(retObj);
                            }
                        });
                    });
                }
                else{
                    var retObj = {};
                    if(type == "findRecord"){
                        retObj[obj.schema] = {};
                        if(q.meta !== undefined){
                            retObj.meta = q.meta;
                        }
                    }
                    else if(type == "findAll"){
                        retObj[obj.schema] = [];
                        if(q.data && q.data.meta){
                            retObj.meta = q.data.meta;
                        }
                    }
                    return resolve(retObj);
                }
            }
            else{
                return reject();
            }
        });    
    });
}

function checkAndRemoveCachedData(obj, removeMetaAlone){
    return new Promise(function(resolve, reject){
        var module = obj.schema, 
        qP = obj.queryParams, 
        key = obj.key;
        getData({schema:"__meta",key:module,name:obj.name}).then(function(res){
            if(res.data == undefined){
                return reject();
            }
            var cQ = res.data.cache, cachedQ, changed = false;
            for(var ckey in cQ){
                cachedQ = cQ[ckey];
                var type = ckey;
                var cQlen = cachedQ.length;
                for(var j=cQlen-1;j>=0;j--){
                        var q = cachedQ[j], vals;
                        if(type == "findRecord"){
                            if(q.key && key && q.key == key){
                                cachedQ.splice(j, 1);
                                changed = true;
                            }
                            else{
                                return reject();
                            }
                        }
                        else if(type == "findAll"){
                            vals = q.data[module], valsLen = vals.length, keyLen = Object.keys(key).length;
                            for(var i=0;i<valsLen;i++){
                                var k=0;
                                for(var vkey in key){
                                    if(key[vkey] && vals[i][vkey] === key[vkey]){
                                        k++;
                                    }
                                }    
                                if(k === keyLen){
                                    cachedQ.splice(j, 1);
                                    changed = true;
                                    break;
                                }
                            }
                        }
                }
            }
            if(changed){
                updateData({schema:"__meta",data:res.data, key:module, name:obj.name}).then(function(){
                    return resolve();                
                },function(){
                    self.console.error("error adding ",msg.data);
                    return reject();
                });  
            }
            else{
                return resolve();
            }
        });    
    });
}

function postMsg(msg){
    self.postMessage(msg);
}

function getPk(pK, data){
    var pkArr = pK.split(",");
    var pKval;
    if(pkArr.length>1){
        pKval = {};
        pkArr.forEach(function(itm){
            pKval[itm] = data[itm];
        });
    }
    else if(pkArr.length == 1){
        pKval = {}
        pKval[pkArr[0]] = data[pkArr[0]];
    }
    return pKval;
}

function push(obj,type){
    return new Promise(function(resolve, reject){
        var data = obj.data, 
        len = data.length, 
        i = 0, 
        module = obj.schema, 
        idb = idbObj[obj.name];
        checkAndInsert(module,obj.data,idb).then(function(res){
            if(type == "pushPayload"){
                return resolve();
            }
            else{
                getData({schema:"__meta",key:module, name:obj.name}).then(function(msg){
                    var rObj = {};
                    rObj.queryParams = obj.queryParams;
                    var rData = rObj.data = obj.data;
                    if(type == "findRecord"){
                        rObj.key = obj.key;
                        rObj.data = getPk(pK, rObj.data[module]);
                        if(obj.meta){
                            rObj.meta = obj.meta;
                        }
                    }
                    else{
                        var kLen = rData[module].length;
                        for(var k=0;k<kLen;k++){
                            rData[module][k] = getPk(pK, rData[module][k])
                        }
                    }
                    if(msg.data == undefined){
                        var result = {};
                        result.module = module;  
                        result.cache = {};  
                        result.cache[type] = result.data || [];
                        checkQpAndPush(result.cache[type], rObj, rObj.key);  
                        addData({schema:"__meta",data:result,name:obj.name}).then(function(){
                            return resolve();                
                        },function(){
                            self.console.error("error adding ",result);
                        });          
                    }
                    else{
                        msg.data.cache[type] = msg.data.cache[type] || [];
                        checkQpAndPush(msg.data.cache[type], rObj, rObj.key);
                        // msg.data.cache[type].push(rObj);     
                        updateData({schema:"__meta",data:msg.data, key:module, name:obj.name}).then(function(){
                            return resolve();                
                        },function(){
                            self.console.error("error adding ",msg.data);
                        });                        
                    }
                }, function(){
                    resolve();
                });
            }
        },function(){
            reject();
        });
    });
}

function checkQpAndPush(arr, data){
    if(data && !Array.isArray(data)){
        data = [data];
    }
    data.forEach(function(item, index){
        var res = checkWithQp(arr, item)
        if(res == -1){
            arr.push(item);
        }
        else{
            arr[res] = item;
        }
    });
}

function checkWithQp(arr, data, key){
    var ind = -1; 
    arr = arr || [];
    var len = arr.length;
    var qp2 = data.queryParams || {};
    for(var i=0; i< len; i++){
        if(key === undefined || (data.req == "findRecord" && key !== undefined && arr[i].key == key)){
            var qp1;
            qp1 = arr[i].queryParams || {};
            if(qp1 == qp2){
                ind = i;
                break;
            }
            var qp1L = Object.keys(qp1).length;
            var qp2L = Object.keys(qp2).length;
            if(qp1L != qp2L){
                continue;
            }        
            var j=0;
            for(var k in qp1){
                if(qp1[k] == qp2[k]){
                    j++;
                }
            }
            if(j == qp1L){
                ind = i;
                break;
            }
        }
    }
    return ind;
}

function checkAndInsert(module, arr, idb){
    var res = [], failed = false;
    return new Promise(function(resolve, reject){
        arr = arr[module];
        arr = arr || [];
        if(!Array.isArray(arr)){
            arr = [arr];
        }
        var arrLen = arr.length, 
        i=0;
        if(arr.length){
            open(idb.name, idb.version).then(function(oObj){
                idb = oObj.idb;
                var obs = idb.transaction([module],"readwrite").objectStore(module), key;
                if(obs.indexNames.contains("pk")){
                    obs = obs.index("pk");
                }
                arr.forEach(function(item, index){
                    if(typeof obs.keyPath == "string"){
                        key = item[obs.keyPath];
                    }
                    else if(Array.isArray(obs.keyPath)){
                        var _arr = [];
                        obs.keyPath.forEach(function(itm){
                            _arr.push(item[itm]);
                        });
                        key = _arr;
                    }
                    getData({schema:module,key: key, name:idb.name}).then(function(res){
                        var resData = res.data;
                        if(resData == undefined){
                            addData({schema:module,data:item, name:idb.name}).then(function(){
                                i++;
                                if(i == arrLen){
                                    if(failed){
                                        return reject();
                                    }else{
                                        return resolve(arr);
                                    }
                                }
                            },function(){
                                failed = true;
                                i++;
                                if(i == arrLen){
                                    if(failed){
                                        return reject();
                                    }
                                    else{
                                        return resolve(arr);
                                    }
                                }
                            });    
                        }
                        else{
                            updateData({schema:module,data:item, name:idb.name}).then(function(){
                                i++;
                                if(i == arrLen){
                                    if(failed){
                                        return reject();
                                    }else{
                                        return resolve(arr);
                                    }
                                }
                            },function(){
                                failed = true;
                                i++;
                                if(i == arrLen){
                                    if(failed){
                                        return reject();
                                    }
                                    else{
                                        return resolve(arr);
                                    }
                                }
                            });    
                        }
                    });
                });
            });
        }
        else{
            resolve();
        }
    });
}

function openIDB(obj){
    var dbName = obj.name || 'lyte', 
    version = obj.version, 
    models = obj.models,
    maintainOrder = obj.maintainOrder,
    idb; 
    open(dbName,version,models,maintainOrder).then(function(oObj){
        idb = oObj.idb;
        // idb = idbObj[obj.name];
        idb.close();
        self.postMessage({lyteidb:true, msg:'successfully upgraded db', type:"open", name:dbName});
    }, function(){
        self.postMessage({lyteidb:true, msg:'error'});    
    });
}

function open(dbName, version, models, maintainOrder){
    return new Promise(function(resolve, reject){
        var req = indexedDB.open(dbName, version), 
        objStore, idb;
        req.onupgradeneeded = function (e) {
            idb = idbObj[dbName] = e.target.result;
            // idb = e.target.result;
            if(models){
                models.forEach(function(item, index){
                    if(!idb.objectStoreNames.contains(item.modelName)){
                        var order = item.hasOwnProperty("maintainOrder") ? item.maintainOrder : maintainOrder;
                        if(order === true){
                            var objStore = idb.createObjectStore(item.modelName,{autoIncrement:true});
                            objStore.createIndex("pk", item.pK.split(","));    
                        }
                        else{
                            var objStore = idb.createObjectStore(item.modelName,{keyPath: item.pK.split(",")/*,autoIncrement:true*/});
                        }
                        // objStore.createIndex("pk", item.pK.split(","));
                    }
                });
            }
            if(!idb.objectStoreNames.contains("__meta")){
                idb.createObjectStore("__meta",{keyPath:"module"})
            }
            // self.postMessage({lyteidb:true, msg:'successfully upgraded db', type:"open"});
            resolve({lyteidb:true, msg:'successfully upgraded db', type:"open", idb:e.target.result});
        };
        req.onblocked = function(e){
            reject({lyteidb:true, msg:'error'});
        }
        req.onsuccess = function (e) {
            idbObj[dbName] = e.target.result;
            // self.postMessage({lyteidb:true, msg:'successfully opened db', type:"open"});
            resolve({lyteidb:true, msg:'successfully opened db', type:"open", idb:e.target.result});
        };
        req.onerror = function(e) {
        //   self.postMessage({lyteidb:true, msg:'error'});    
          reject({lyteidb:true, msg:'error'});
        }
    });
}

function addMultiple(obj){
    return new Promise(function(resolve,reject){
        var len = obj.data.length,
        i=0,
        idb = idbObj[obj.name];
        obj.data.forEach(function(item, index){
            addData({schema:obj.schema,data:item, name:obj.name}, false).then(function(){
                if(++i == len){
                    idb.close();
                    return resolve();
                }
            },function(){
                if(++i == len){
                    idb.close();
                    return resolve();
                }
            });
        });
    });
}

function addData(obj, close){
    return new Promise(function(resolve,reject){
        var data = obj.data, 
        schema = obj.schema,
        idb = idbObj[obj.name];
        open(idb.name, idb.version).then(function(oObj){
            idb = oObj.idb;
            var obs = idb.transaction([schema],"readwrite").objectStore(schema);
            var req = obs.add(data);
            req.onsuccess = function (e){
                close !== false ? idb.close() : undefined;
                // if(obj.queryCache == false && /^(create|createRecord)$/.test(obj.type)){
                //     checkAndRemoveCachedData(obj).then(function(){
                //         return resolve({msg:"Successfully deleted data"});
                //     }, function(){
                //         return resolve({msg:"Successfully deleted data"});
                //     });                    
                // }
                return resolve({msg:"Successfully added data"});
                //self.postMessage({msg:"Successfully added data"});
            }
            req.onerror = function (e){
                close !== false ? idb.close() : undefined
                return reject({msg:"Error while adding data"});
    //            self.postMessage({msg:"Error while adding data"});
            }
            req.oncomplete = function (e){
                close !== false ? idb.close() : undefined
                return resolve({msg:"Successfully added data"});
    //          self.postMessage({msg:"Successfully added data"});
            }    
        }, function(){
            return reject({msg:"Cannot open indexeddb"});
        })
    });
}

function deleteMultiple(obj){
    return new Promise(function(resolve, reject){
        var len = obj.data.length, 
        i=0, 
        idb = idbObj[obj.name];
        obj.data.forEach(function(item,index){
            deleteData({schema:obj.schema,key:item, name:obj.name}, false).then(function(){
                if(++i == len){
                    idb.close();
                    return resolve();
                }
            },function(){
                if(++i == len){
                    idb.close();
                    return resolve();
                }
            });
        });
    });
}

function deleteData(obj, close){
    return new Promise(function(resolve, reject){
        var schema = obj.schema, 
        key = obj.key, 
        idb = idbObj[obj.name];
        open(idb.name, idb.version).then(function(oObj){
            idb = oObj.idb;
            var obs = idb.transaction([schema],"readwrite").objectStore(schema), iobs;
            if(obs.indexNames.contains("pk")){
                iobs = obs.index("pk");
                if(typeof iobs.keyPath == "string"){
                    obj.key = key = obj.key[iobs.keyPath];
                }
                else if(Array.isArray(iobs.keyPath)){
                    var arr = [];
                    iobs.keyPath.forEach(function(itm){
                        arr.push(obj.key[itm]);
                    });
                    key = arr;
                }
                openCursorForKey(iobs, key).then(function(cobj){
                    var pK = cobj.cursor.primaryKey
                    var req = obs.delete(pK);
                    req.onsuccess = function (e){
                        close !== false ? idb.close(): undefined;
                        if(obj.queryCache == true){
                            checkAndRemoveCachedData(obj).then(function(){
                                return resolve({msg:"Successfully deleted data"});
                            }, function(){
                                return resolve({msg:"Successfully deleted data"});
                            });
                        }
                        else{
                            return resolve({msg:"Successfully deleted data"});
                        }
                        // self.postMessage({msg:"Successfully deleted data"});
                    }
                    req.onerror = function (e){
                        close !== false ? idb.close(): undefined;
                        return reject({msg:"Error while deleting data"});
                        // self.postMessage({msg:"Error while deleting data"});
                    }
                    req.oncomplete = function (e){
                        close !== false ? idb.close(): undefined;
                        return resolve({msg:"Successfully deleted data"});
                        // self.postMessage({msg:"Successfully deleted data"});
                    } 
                });
            }
            else{
                if(typeof obs.keyPath == "string"){
                    obj.key = key = obj.key[obs.keyPath];
                }
                else if(Array.isArray(obs.keyPath)){
                    var arr = [];
                    obs.keyPath.forEach(function(itm){
                        arr.push(obj.key[itm]);
                    });
                    key = arr;
                }
                var req = obs.delete(key);
                req.onsuccess = function (e){
                    close !== false ? idb.close(): undefined;
                    if(obj.queryCache == true){
                        checkAndRemoveCachedData(obj).then(function(){
                            return resolve({msg:"Successfully deleted data"});
                        }, function(){
                            return resolve({msg:"Successfully deleted data"});
                        });
                    }
                    else{
                        return resolve({msg:"Successfully deleted data"});
                    }
                    // self.postMessage({msg:"Successfully deleted data"});
                }
                req.onerror = function (e){
                    close !== false ? idb.close(): undefined;
                    return reject({msg:"Error while deleting data"});
                    // self.postMessage({msg:"Error while deleting data"});
                }
                req.oncomplete = function (e){
                    close !== false ? idb.close(): undefined;
                    return resolve({msg:"Successfully deleted data"});
                    // self.postMessage({msg:"Successfully deleted data"});
                }    
            }
        }, function(){
            return reject({msg:"Cannot open indexeddb"});
        });
    });
}

function updateMultiple(obj){
    return new Promise(function(resolve, reject){
        var len = obj.data.length, 
        i=0, 
        idb = idbObj[obj.name];
        obj.data.forEach(function(item, index){
            updateData({schema:obj.schema,data:obj.data,name:obj.name}, false).then(function(){
                if(++i == len){
                    idb.close();
                    return resolve();
                }
            },function(){
                if(++i == len){
                    idb.close();
                    return resolve();
                }
            });
        });
    });
}

function updateData(obj, close){
    return new Promise(function(resolve,reject){
        var schema = obj.schema, 
        data = obj.data, 
        key = obj.key,
        idb = idbObj[obj.name];
        getData(obj).then(function(res){
            var resData = res.data;
            if(res.data == undefined){
                addData(obj).then(function(){
                    return resolve({msg: "Successfully added data"});
                },function(){
                    return reject({msg:"Error while adding data"});
                });
            }
            else{
                for(var key in data){
                    resData[key] = data[key];
                }
                open(idb.name, idb.version).then(function(oObj){
                    idb = oObj.idb;
                    var obs = idb.transaction([schema],"readwrite").objectStore(schema), indexed, iobs;
                    if(obs.indexNames.contains("pk")){
                        iobs = obs.index("pk");
                        indexed = true;
                        if(typeof iobs.keyPath == "string"){
                            obj.key = key = obj.data[iobs.keyPath];
                        }
                        else if(Array.isArray(iobs.keyPath)){
                            var arr = [];
                            iobs.keyPath.forEach(function(itm){
                                arr.push(obj.data[itm]);
                            });
                            key = arr;
                        }
                        openCursorForKey(iobs, key).then(function(cobj){
                            var pK = cobj.cursor.primaryKey
                            if(pK !== undefined){
                                openCursorForKey(obs, pK).then(function(cobj2){
                                    var _req = cobj2.cursor.update(obj.data);
                                    _req.onsuccess = function (e){
                                        var ind = e.target.result;
                                        close !== false ? idb.close() : undefined;
                                        return resolve({msg:"Successfully updated data"});
                                    }
                                    _req.onerror = function (e){
                                        close !== false ? idb.close() : undefined;
                                        return reject({msg:"Error while updating data"});
                                        // self.postMessage({msg:"Error while updating data"});
                                    }
                                    _req.oncomplete = function (e){
                                        close !== false ? idb.close() : undefined;
                                        return resolve({msg:"Successfully updated data"});            
                                        // self.postMessage({msg:"Successfully updated data"});
                                    } 
                                });
                            }
                        });
                    }
                    else{
                        var req = obs.put(resData);
                        req.onsuccess = function (e){
                            close !== false ? idb.close() : undefined;
                            return resolve({msg:"Successfully updated data"});
                            // self.postMessage({msg:"Successfully updated data"});
                        }
                        req.onerror = function (e){
                            close !== false ? idb.close() : undefined;
                            return reject({msg:"Error while updating data"});
                            // self.postMessage({msg:"Error while updating data"});
                        }
                        req.oncomplete = function (e){
                            close !== false ? idb.close() : undefined;
                            return resolve({msg:"Successfully updated data"});            
                            // self.postMessage({msg:"Successfully updated data"});
                        }        
                    }
                }, function(){
                    return reject({msg:"Cannot open indexeddb"});
                });
            }
        },function(){
            return reject({msg:"Error while updating data"});
        });
    });
}

function getData(obj){
    return new Promise(function(resolve,reject){
        var schema = obj.schema, 
        key = obj.key,
        idb = idbObj[obj.name];

        if(idb && idb.objectStoreNames.contains(schema)){
            open(idb.name, idb.version).then(function(oObj){
                idb = oObj.idb;
                var obs = idb.transaction([schema],"readwrite").objectStore(schema);
                if(obs.indexNames.contains("pk")){
                    obs = obs.index("pk");
                }
                if(obj.processKey){
                    if(Array.isArray(obs.keyPath)){
                        var arr = [];
                        if(key && typeof key == "object"){
                            obs.keyPath.forEach(function(itm){
                                arr.push(key[itm]);
                            });
                        }
                        else{
                            arr.push(key);
                        }
                        key = arr;
                    }
                }
                else if(!key && obj.data){
                    if(typeof obs.keyPath == "string"){
                        key = obj.data[obs.keyPath];
                    }
                    else if(Array.isArray(obs.keyPath)){
                        var arr = [];
                        obs.keyPath.forEach(function(itm){
                            arr.push(obj.data[itm]);
                        });
                        key = arr;
                    }
                }
                var req = obs.get(key);
                req.onsuccess = function (e){
                    idb.close();
                    return resolve({msg:"Successfully got data success", data:e.target.result});
                }
                req.onerror = function (e){
                    idb.close();
                    return reject({msg:"Error while getting data"});
                }
                req.oncomplete = function (e){
                    idb.close();
                    return resolve({msg:"Successfully got data complete", data:e.target.result});
                }
            }, function(){
                return reject({msg:"Cannot open indexeddb"});
            });
        }
        else{
            return reject({msg:"Error while getting data"});
        }
    });
}

function getAll(obj){
    return new Promise(function(resolve, reject){
        var schema = obj.schema, 
        idb = idbObj[obj.name];
        if(idb && idb.objectStoreNames.contains(schema)){
            open(idb.name, idb.version).then(function(oObj){
                idb = oObj.idb;
                var obs = idb.transaction([schema],"readwrite").objectStore(schema);
                var req = obs.getAll();
                req.onsuccess = function (e){
                    idb.close();
                    return resolve({msg:"Successfully got data", data:e.target.result});
                }
                req.onerror = function (e){
                    idb.close();
                    return reject({msg:"Error while getting data"});
                }
                req.oncomplete = function (e){
                    idb.close();
                    return resolve({msg:"Successfully got data", data:e.target.result});
                }
            }, function(){
                return reject({msg:"Cannot open indexeddb"});
            });
        }
        else{
            return reject({msg:"Error while getting data"})
        }
    });
}

function openCursorForKey(obs, key){
    return new Promise(function(resolve, reject){
        var req = obs.openCursor(key);
        req.onsuccess = function(e){
            return resolve({cursor: e.target.result});
        }
        req.onerror = function(){
            return reject("Curson not established");
        }
    });
}

self.postMessage({lyteidb:true, init: "done"});
