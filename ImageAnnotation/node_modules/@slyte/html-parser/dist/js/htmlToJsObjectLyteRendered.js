/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./lib/htmlParser.js":
/*!***************************!*\
  !*** ./lib/htmlParser.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
//ignorei18n_start
// const fs = __non_webpack_require__("fs");
// const fs = eval('require("fs")')
const HTMLParser = (function () {

    const regexFor = {
        // startTag: /^<(?<nodeName>[a-zA-Z][-a-zA-Z0-9_]*)(?<attributes>(?:\s*[a-zA-Z_:!0-9,][-a-zA-Z0-9_:%."'`;]*(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|{{[^>}]*}}|\w*|[^>]+))?)*)\s*(\/?)>/,
        endTag: /^<\/(?<nodeName>[a-zA-z][-a-zA-Z0-9_]*)(?<attributes>(?:\s*[a-zA-Z_:!0-9,][-a-zA-Z0-9_:%."'`;]*(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>]+))?)*)\s*(\/?)>/,
        attr: /([a-zA-Z0-9_:!'"},@{][-a-zA-Z0-9_:."'`%;{]*)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|([^>\s]+)))?/g,
    }
    let paragraphTagStarted = 0;
    let willHaveUnclosedClosingTag = false;
    let doNotCheckThisTag = "";
    let restCopy = "";
    let checkClosingTag = false;
    let flag = false;
    let seenSVGBefore = 0;
    let seenSvgMiddleMenBefore = 0;
    let seenPreBefore = false;
    let seenTableBefore = 0;
    // let doCheckUntil = undefined;
    const svgCamelCaseTags = {
        "filterunits":"filterUnits",
        "allowreorder": "allowReorder",
        "attributename": "attributeName",
        "attributetype": "attributeType",
        "autoreverse": "autoReverse",
        "basefrequency": "baseFrequency",
        "baseprofile": "baseProfile",
        "calcmode": "calcMode",
        "clippathunits": "clipPathUnits",
        "contentScriptType": "contentScriptType",
        "contentstyletype": "contentStyleType",
        "diffuseconstant": "diffuseConstant",
        "edgemode": "edgeMode",
        "externalresourcesrequired": "externalResourcesRequired",
        "filterres": "filterRes",
        "filterUnits": "filterUnits",
        "glyphref": "glyphRef",
        "gradienttransform": "gradientTransform",
        "gradientunits": "gradientUnits",
        "kernelmatrix": "kernelMatrix",
        "kernelunitlength": "kernelUnitLength",
        "keypoints": "keyPoints",
        "keysplines": "keySplines",
        "keytimes": "keyTimes",
        "lengthadjust": "lengthAdjust",
        "limitingconeangle": "limitingConeAngle",
        "markerheight": "markerHeight",
        "markerunits": "markerUnits",
        "markerwidth": "markerWidth",
        "maskcontentunits": "maskContentUnits",
        "maskunits": "maskUnits",
        "patterncontentunits": "patternContentUnits",
        "patterntransform": "patternTransform",
        "patternunits": "patternUnits",
        "pointsatx": "pointsAtX",
        "pointsaty": "pointsAtY",
        "pointsatz": "pointsAtZ",
        "preservealpha": "preserveAlpha",
        "preserveaspectratio": "preserveAspectRatio",
        "primitiveunits": "primitiveUnits",
        "repeatcount": "repeatCount",
        "repeatdur": "repeatDur",
        "requiredextensions": "requiredExtensions",
        "requiredfeatures": "requiredFeatures",
        "specularconstant": "specularConstant",
        "specularexponent": "specularExponent",
        "spreadmethod": "spreadMethod",
        "startoffset": "startOffset",
        "stddeviation": "stdDeviation",
        "stitchtiles": "stitchTiles",
        "surfacescale": "surfaceScale",
        "systemlanguage": "systemLanguage",
        "tablevalues": "tableValues",
        "textlength": "textLength",
        "viewbox": "viewBox",
        "viewtarget": "viewTarget",
        "xchannelselector": "xChannelSelector",
        "ychannelselector": "yChannelSelector",
        "refx": "refX",
        "refy": "refY",
        "targetx": "targetX",
        "targety": "targetY",
        "numoctaves": "numOctaves",
        "zoomandpan": "zoomAndPan",
    }
    const chromeChangedTags = {
        "image":"img"
    }
    const createMapFor = function (array) {
        return array.reduce(function (acc, item) {
            acc[item] = true;
            return acc;
        }, {});
    }
    //seenSVGBefore should not process this tags
    const svgMiddleMen = createMapFor(['foreignobject']);
    const svgSelfClosingTags = createMapFor([
        'circle',
        'ellipse',
        'line',
        'path',
        'polygon',
        'polyline',
        'rect',
        'use',
        'title',
        'stop'
    ])
    const tableTags = createMapFor(["tbody", "thead", "tfoot", "colgroup", "caption", "tr", "th", "td", "col"])

    const EMPTY_ELEMENTS = createMapFor([
        "area",
        "base",
        "basefont",
        "br",
        "col",
        "frame",
        "hr",
        "img",
        "track",
        "input",
        "link",
        "meta",
        "param",
        "embed",
        "command",
        "keygen",
        "source",
        "wbr",
        "circle",
        "ellipse",
        "line",
        "polyline",
        "rect",
    ]);
    const SELF_CLOSING = createMapFor([
        "colgroup",
        "dd",
        "dt",
        "li",
        "options",
        "p",
        // "td",
        // "tfoot",
        // "th",
        // "thead",
        // "tr"
    ]);
    let selfClosingTags = createMapFor(['style', 'area', 'base', 'br', 'col', 'embed', 'hr', 'input', 'keygen', 'link', 'meta', 'param', 'wbr', 'img', 'track']);
    let notAllowedTagsInsideParagraphTag = createMapFor(["div", "table", "body", "h1", "h2", "h3", "h4", "h5", "h6","ul","li"]);
    const SPECIAL_ELEMENTS = createMapFor([
        'style',
        'script'
    ]);
    const nodeStartStack = []
    return function (htmlString, callbacks, emberFlag, fileName,errorObj,withoutTableProcessing, lineIndex = 1, colIndex = 0) {
        let hasUnparsedChars;
        let match;
        let mismatchColIndex = {};
        let stack = [];
        seenSVGBefore = 0,seenSvgMiddleMenBefore = 0,seenTableBefore = 0;
        // let checkList = [];
        let stringInPrevLoopState = htmlString;
        let elemStack = [];
        let seenTemplate = false;
        stack.getLastItem = function () {
            return this[this.length - 1];
        };
        elemStack.getLastItem = function () {
            return this[this.length - 1];
        }
        // checkList.getLastItem = function () {
        //   return this[this.length - 1];
        // };
        function validateTagName(str, errorObject) {
            str = str.trim()
            if (str.length == 0 || !(/^[a-zA-Z_][-a-zA-Z0-9_]*$/).test(str)) {
                errorObject.bool = false;
                errorObject.error = "Invalid tag name :`"+"<"+str+"`";
                errorObject.fromParser = true;
                return false;
            }
            return chromeChangedTags[str] ? chromeChangedTags[str] : str;
        }

        function getStartTag(str) {
            try {
                let foundTagName = false,
                    tagName = "",
                    errorObject = {
                        bool: true
                    },
                    doubleQuotesStarted = false,
                    dIndex = 0,
                    singleQuotesStarted = false,
                    sIndex = 0,
                    mustacheStarted = 0,
                    mIndex = 0,
                    attrStartIndex = 0,
                    tickStarted = false;
                // foundEqualTo = false;

                for (let i = 0; i < str.length; i++) {
                    if (!foundTagName) {
                        if (str[i] == " " || str[i] == "\n" || str[i] == "/" || str[i] == "\t") {
                            tagName = validateTagName(tagName, errorObject)
                            if (!tagName) return errorObject;
                            foundTagName = true
                            attrStartIndex = i;
                            continue;
                        }
                        if (str[i] == ">") {
                            tagName = validateTagName(tagName, errorObject)
                            if (!tagName) return errorObject;
                            let res = ["<" + str.substring(0, i + 1), tagName, "", "", "<" + str];
                            res.bool = true;
                            return res;
                        }
                        if (str[i] == "/" && str[i + 1] == ">") {
                            tagName = validateTagName(tagName, errorObject)
                            if (!tagName) return errorObject;
                            let res = ["<" + str.substring(0, i + 1), tagName, "", "/", "<" + str];
                            res.bool = true;
                            return res;
                        }
                        tagName += str[i];
                        continue;
                    }
                    if (str[i] == "`" && str[i - 1] != "\\" && !doubleQuotesStarted && !singleQuotesStarted) {
                        // if(tickStarted){
                        //     foundEqualTo = false;
                        // }
                        tickStarted = !tickStarted;
                        sIndex = i + 1;
                    }
                    if (str[i] == "'" && str[i - 1] != "\\" && !doubleQuotesStarted && !tickStarted) {
                        // if(singleQuotesStarted){
                        //     foundEqualTo = false;
                        // }
                        singleQuotesStarted = !singleQuotesStarted;
                        sIndex = i + 1;
                    }
                    if (str[i] == '"' && str[i - 1] != "\\" && !singleQuotesStarted && !tickStarted) {
                        // if(doubleQuotesStarted){
                        //     foundEqualTo = false;
                        // }
                        doubleQuotesStarted = !doubleQuotesStarted;
                        dIndex = i + 1;
                    }

                    if (!tickStarted && !singleQuotesStarted && !doubleQuotesStarted && str[i] == "{" && str[i + 1] == "{") {

                        mustacheStarted = true;
                        mIndex = i;
                    }
                    if (!tickStarted && !singleQuotesStarted && !doubleQuotesStarted && str[i] == "}" && str[i + 1] == "}") {
                        // if(mustacheStarted){
                        //     foundEqualTo = false;
                        // }
                        mustacheStarted = false;
                    }
                    // if(str[i] == " " && !doubleQuotesStarted && !singleQuotesStarted && !tickStarted && !mustacheStarted){
                    //     foundEqualTo = false;
                    //   }
                    // if(str[i] == "=" && !tickStarted && !doubleQuotesStarted && !mustacheStarted && !singleQuotesStarted){
                    //     foundEqualTo = true;
                    // }
                    if (!tickStarted && !singleQuotesStarted && !doubleQuotesStarted && !mustacheStarted && str[i] == "<"){
                        // let e  = new Error("Unclosed `>` for the tag "+tagName);
                        errorObject.bool = false;
                        errorObject.error = "Unclosed `>` for the tag `"+tagName+"`";
                        errorObject.fromParser = true;
                        let temp = str.substr(0,i).split("\n");
                        lineIndex+=(temp.length -1);
                        colIndex = temp[temp.length-1].length;
                        return errorObject;
                    }
                    if (!tickStarted && !singleQuotesStarted && !doubleQuotesStarted && !mustacheStarted && str[i] == ">") {
                        let res = [];
                        if (str[i - 1] == "/") {
                            res = ["<" + str.substring(0, i + 1), tagName, str.substring(attrStartIndex, i - 1), "/", "<" + str];
                            res.bool = true;
                            return res;
                        }
                        res = ["<" + str.substring(0, i + 1), tagName, str.substring(attrStartIndex, i), "", "<" + str]
                        res.bool = true;
                        return res;
                    }
                }
                errorObject.bool = false;
                let temp;
                if (singleQuotesStarted) {
                    errorObject.error = "Unclosed Single Quote ";
                    temp = str.substr(0,sIndex).split("\n");
                    lineIndex+=(temp.length -1);
                    colIndex = temp[temp.length-1].length;
                    errorObject.index = str.substring(0, sIndex);
                } else if (doubleQuotesStarted) {
                    errorObject.error = "Unclosed Double Quote ";
                    temp = str.substr(0,dIndex).split("\n");
                    lineIndex+=(temp.length -1);
                    colIndex = temp[temp.length-1].length;
                    errorObject.index = str.substring(0, dIndex);
                } else if (mustacheStarted) {
                    errorObject.error = "Unclosed Mustache ";
                    temp = str.substr(0,mIndex).split("\n");
                    lineIndex+=(temp.length -1);
                    colIndex = temp[temp.length-1].length;
                    errorObject.index = str.substring(0, mIndex);
                } else {
                    errorObject.error = "Unclosed tag `>`";
                }
                return errorObject;
            } catch (e) {
                console.log("Error in parsing")
            }
        }

        function parseStartTag(tag, tagName, rest, unary) {
            if (tagName) {
                let lowerTagName = tagName.toLowerCase();
                if (lowerTagName == "svg") {
                    seenSVGBefore++;
                }
                if (lowerTagName == "pre") {
                    seenPreBefore = true;
                }
                if (lowerTagName == "table") {
                    seenTableBefore += 1;
                }
                if(svgMiddleMen[lowerTagName]){
                    seenSvgMiddleMenBefore++;
                }
                if (seenSVGBefore == 0 && tagName.toLowerCase) {
                    tagName = lowerTagName;
                }
            }
            // @Handle3055 to get precise line and column number
            // if(tagName && !seenPreBefore){
            //   tagName = tagName.replace(/\r?\n|\r/g,' ').replace(/\s+/g,' ');
            //   if (tag) {
            //     tag = tag.replace(/\r?\n|\r/g, ' ').replace(/\s+/g, ' ');
            //   }
            // }
            
            if(unary && !seenSVGBefore && svgSelfClosingTags[tagName]){
                let err = new Error("Error: Invalid svg tag " + tag + "....." );
                err.fromParser =true;
                throw err;
            }
            if (stack.getLastItem() == tagName && SELF_CLOSING[tagName]) {
                parseEndTag("", tagName);
            }
            let matchRes;
            if (tag && (matchRes = tag.match(/(?!({{)|"|'.*)\n(?!.*(}})|"|')/g))) {
                lineIndex = lineIndex + matchRes.length;
                colIndex = matchRes[matchRes.length-1].length;
            }
            let col = colIndex;
            if (tag) {
                colIndex = colIndex + tag.length;
            }

            unary = EMPTY_ELEMENTS[tagName] || !!unary;

            if (!unary) {
                stack.push(tagName);
                if (tagName != "p") {
                    elemStack.push(tagName);
                }

                // if(checkList.length>0){
                //   checkList.push(tagName);
                // }
            }
            doNotCheckThisTag = tagName
            let attrs = [];
            restCopy = rest;
            rest.replace(regexFor.attr, function (match, name) {
                const arg2 = arguments[2];
                const arg3 = arguments[3];
                const arg4 = arguments[4];
                const value = arg2 ? arg2 : (arg3 ? arg3 : (arg4 ? arg4 : ''));
                let quote = name.indexOf("'");
                let err;
                if (quote !== -1) {
                    // console.log("Unclosed Single quote in " + restCopy.substring(0,21) + "...");
                    err =  new Error("Error: Unclosed Single quote in " + tag + "....."+ "</" + tagName+ ">");
                    err.fromParser = true;
                    err.lineIndex = lineIndex;
                    err.colIndex = colIndex;
                    throw err;
                }
                quote = name.indexOf('"')
                if (quote !== -1) {
                    // console.log("Unclosed Double quote in " + restCopy.substring(0,21) + "...");
                    err = new Error("Error: Unclosed Double quote in " + tag.substring(0,100)+ "....."/* + "....." + "</" + tagName+ ">"*/);
                    err.fromParser = true;
                    err.lineIndex = lineIndex;
                    err.colIndex = colIndex;
                    throw err;
                }
                if (name.indexOf("{{") == 0) {
                    // console.log("Invalid Mustache :"+ name+"...")
                    err = new Error("Error: Invalid Mustache : " + name + "...");
                    err.fromParser = true;
                    err.lineIndex = lineIndex;
                    err.colIndex = colIndex;
                    throw err;
                }
                if (seenSVGBefore > 0 && svgCamelCaseTags[name.toLowerCase()]) {
                    name = svgCamelCaseTags[name.toLowerCase()];
                } else {
                    name = name.toLowerCase();
                }
                // let errorChecker = value.match(/(["'`])(?:(?:\\1|(?:(?!\1)).)*)(\1)/)
                // if (errorChecker && errorChecker[0].length != value.length ){
                //   console.warn("Unclosed quotes:) in attribute",value);
                // }
                let obj = {
                    name: name,
                    value: value.replace(/"/g, "&quot;"),
                    escaped: value.replace(/(^|[^\\])"/g, '$1\\\"')
                }
                if(name == "lyte-if" || (name == "is" && value == "if") || name == "lyte-switch" || (name == "is" && value == "switch")|| name == "lyte-for" || (name == "is" && value == "for")||  name == "lyte-for-in" || (name == "is" && value == "forIn")){
                    obj.errorInfo = {
                        name: "errorInfo",
                        details: {
                            tagName: tagName,
                            name: name,
                            value: value.replace(/"/g, "&quot;")
                        }
                    }
                }
                attrs.push(obj);
            });
            if (callbacks.start) {
                if (tag && tag.match(/<.*\/>/g)) {
                    if(!(selfClosingTags[tagName] || svgSelfClosingTags[tagName])){
                        let err = new Error("Invalid self-closing tag `" + tagName + "` in " + (tag+ htmlString).substring(0, 100) + "...");
                        err.fromParser = true;
                        err.lineIndex = lineIndex;
                        err.colIndex = colIndex;
                        throw err;
                    }
                    // attrs.push({
                    //     name: "singleAttribute",
                    //     value: "true",
                    //     escaped: "true" //"
                    // });

                } else {
                    if (!selfClosingTags[tagName]) {
                        nodeStartStack.push(tagName);
                    }
                }
                if (checkClosingTag) {
                    attrs.push({
                        name: "checkClosingTag",
                        value: "true",
                        escaped: "true" //"
                    });
                }
                callbacks.start(tagName, attrs, unary,seenSVGBefore, lineIndex, col);
            }
        }

        function parseEndTag(tag, tagName) {
            if (tagName) {
                let lowerTagName = tagName.toLowerCase();
                // if (doCheckUntil && doCheckUntil == lowerTagName) {
                //     doCheckUntil = undefined;
                // }
                if (lowerTagName == "svg") {
                    seenSVGBefore--;
                }
                if(svgMiddleMen[lowerTagName]){
                    seenSvgMiddleMenBefore--;
                }
                if (lowerTagName == "table") {
                    seenTableBefore--;
                }
                if (lowerTagName == "pre") {
                    seenPreBefore = false;
                }
                if (seenSVGBefore == 0 && tagName.toLowerCase) {
                        tagName = lowerTagName;
                }
                if (tagName != "p" && !EMPTY_ELEMENTS[tagName]) {
                    // console.warn("Issue in Closing tag ", tagName);
                    let lastElem = elemStack.pop();
                    if (lastElem.toLowerCase() != tagName.toLowerCase()) {
                        if (tagName != "template") {
                            let i = elemStack.length - 1;
                            for (; i >= 0; i--) {
                                if (elemStack[i] == tagName) {
                                    break;
                                }
                            }
                            let removeIndex = i;
                            for (; i > 0; i--) {
                                if (elemStack[i] == "template") {
                                    elemStack.splice(removeIndex, 1);
                                    break;
                                }
                            }
                            elemStack.push(lastElem);
                            return;
                        }
    
                        // else{
                        //   tagName = lastElem;
                        //   let i = elemStack.length - 1;
                        //   for (; i >= 0; i--) {
                        //     if (elemStack[i] == lastElem) {
                        //       elemStack[i] = tagName;
                        //       break;
                        //     }
                        //   }
                        // }
    
                    }
                }
            }
            
            // @Handle3055 to get precise line and column number
            // if(tagName && !seenPreBefore){
            //   tagName = tagName.replace(/\r?\n|\r/g,' ').replace(/\s+/g,' ');
            //   if(tag){
            //   tag = tag.replace(/\r?\n|\r/g,' ').replace(/\s+/g,' ');
            //   }
            // }
            
            

            // if (checkList.length > 0) {
            //   if (checkList.getLastItem() == tagName) {
            //     checkList.pop();
            //   }
            //   else {
            //     debugger;
            //   }
            // }
            if (tag) {
                colIndex += tag.length;
            }
            let pos;
            if (!tagName) {
                pos = 0;
            } else {
                for (pos = stack.length - 1; pos >= 0; pos--) {
                    if (stack[pos] == tagName) {
                        break;
                    }
                }
            }
            if (pos >= 0) {
                for (let i = stack.length - 1; i >= pos; i--) {
                    if (callbacks.end) {
                        callbacks.end(stack[i], stack[i] != tagName, this && this.misMatchCase ? this.misMatchCase : null, ((seenSvgMiddleMenBefore>0)?0:seenSVGBefore));
                    }
                }
                stack.length = pos;
            }
            // </br> handled this here
            else if (tagName == "br") {
                parseStartTag(null, tagName, "", null);
            }
        }
        const replacerFn = function (all, text) {
            // @Handle3055 to get precise line and column number
            let matchRes;
            if (text && (matchRes = text.match(/(?!({{)|"|'.*)\n(?!.*(}})|"|')/g))) {
                lineIndex += matchRes.length;
                colIndex = matchRes[matchRes.length - 1].length;
            }
            
            // if(!seenPreBefore && text){
            //   text = text.replace(/\r?\n|\r/g,' ').replace(/\s+/g,' ');
            // }
            text = text.replace(/<!--([\s\S]*?)-->|<!\[CDATA\[([\s\S]*?)]]>/g, "$1$2");
            let col = colIndex;
            colIndex += text.length;

            if (callbacks.chars) {
                callbacks.chars(text, lineIndex, col, checkClosingTag);
            }
            return "";
        }
        if (emberFlag && htmlString.indexOf("{{!--")) {
            htmlString = htmlString.replace(/{{!--[\s\S]*?--}}/g, "");
        }
        while (htmlString) {
            hasUnparsedChars = true;
            if (!stack.getLastItem() || !SPECIAL_ELEMENTS[stack.getLastItem()]) {
                
                // Check for Comments
                let checkStr  = htmlString.substring(0,4);
                if (checkStr== "<!--"/*htmlString.indexOf("<!--") == 0*/) {
                    let index = htmlString.indexOf("-->");
                    if (index >= 0) {
                        if (callbacks.comment) {
                            let col = colIndex;
                            colIndex += htmlString.substring(4, index).length + 7;
                            callbacks.comment(htmlString.substring(4, index), lineIndex, col);
                            let matchRes = htmlString.substring(4, index).match(/\n/g)
                            if (matchRes) {
                                lineIndex = lineIndex + matchRes.length;
                                colIndex = matchRes[matchRes.length-1].length;
                            }
                        }
                        htmlString = htmlString.substring(index + 3);
                        hasUnparsedChars = false;
                    }
                } else if (checkStr.indexOf("</") == 0) {
                    match = htmlString.match(regexFor.endTag);
                    // console.log("%c checker ",match[1]);

                    if (match) {
                        let misMatchCase = false;
                        if(match[1] == "p"){
                            paragraphTagStarted = 0;
                        }
                        if(paragraphTagStarted == 2 && match[1] == "template"){
                            paragraphTagStarted = 1;
                        }
                        if (match[1] == "p" && stack.getLastItem() != "p" && willHaveUnclosedClosingTag) {
                            parseStartTag(null, "p", "", null);
                        }
                        if (match[1] == "checkClosingTag") {
                            checkClosingTag = false;
                            htmlString = htmlString.substring(match[0].length);
                            continue;
                        }
                        let check = match[1];
                        if (seenSVGBefore == 0 && check && check.toLowerCase) {
                            check = check.toLowerCase();
                        }
                        if (check != stack.getLastItem() && !EMPTY_ELEMENTS[check]) {
                            // console.error("Issue in Closing tag:)\n\tUnclosed `"+  elemStack.getLastItem()+"` in "+htmlString);
                            let err = new Error("Unclosed `" + elemStack.getLastItem() + "` in " + htmlString.substring(0, 100) + "...");
                            err.fromParser = true;
                            err.lineIndex = lineIndex;
                            err.colIndex = colIndex;
                            throw err;
                            // throw new Error("Issue in Closing tag:)\n\tUnclosed `"+  elemStack.getLastItem()+"` in "+htmlString);
                        }
                        if (match[1] == "template" && elemStack.getLastItem() != "template" && match[1] != "p" && !EMPTY_ELEMENTS[match[1]]) {
                            let match2 = htmlString.match(`<\/\s*` + elemStack.getLastItem() + `\s*>`);
                            if (match2) {
                                // htmlString = htmlString.replace(match2[0], match[0]);
                                htmlString = htmlString.replace(match2[0], "</checkClosingTag>");
                                checkClosingTag = true;
                                htmlString = htmlString.replace(match[0], match2[0]);
                                htmlString = htmlString.substring(0, match2[0].length) + match[0] + htmlString.substring(match2[0].length);
                                match = htmlString.match(regexFor.endTag);
                                stringInPrevLoopState = undefined;
                                misMatchCase = true;
                                // htmlString.replace(/<\/\s*${elemStack.getLastItem()}\s*>/, match[0]);
                            }
                        }
                        htmlString = htmlString.substring(match[0].length);

                        match[0].replace(regexFor.endTag, parseEndTag.bind({
                            misMatchCase: misMatchCase
                        }));
                        hasUnparsedChars = false;
                    } 
                } else if (checkStr.indexOf("<") == 0) {

                    // match = htmlString.match(regexFor.startTag);
                    // let start = Date.now();
                    match = getStartTag(htmlString.slice(1));
                    // errorObj.performance+=(Date.now()-start);
                    if (match.bool) {
                        // console.log(paragraphTagStarted && match[1] != "p" , notAllowedTagsInsideParagraphTag[match[1]],match[1] )
                        if (paragraphTagStarted == 1  && match[1] != "p" && notAllowedTagsInsideParagraphTag[match[1]]) {
                            paragraphTagStarted = 0;
                            parseEndTag(null, "p");
                            willHaveUnclosedClosingTag = true;
                        }
                        htmlString = htmlString.substring(match[0].length);
                        //to remove br tags which are immediate child to template tags
                        if(match[1] == "template" ){
                            while (htmlString.match(/^[^<]*?<\/br\s*>/)) {
                                htmlString = htmlString.replace(/<\/br\s*>/, "");
                            }
                        }
                        //to handle table tags without table as its parent element
                        if (!withoutTableProcessing) {
                            if (stack.getLastItem() != "template" && seenTableBefore == 0 && tableTags[match[1]]) {
                                if (errorObj) {
                                    errorObj.warnings.push({ message: "Warning: Misplaced " + match[1] + " tag in " + match[0] + "....." + "</" + match[1] + ">" + ((fileName && fileName.trim().length != 0) ? "\n\t  at Component: " + fileName : "") });
                                }
                                else{
                                    console.warn( "Warning: Misplaced " + match[1] + " tag in " + match[0] + "....." + "</" + match[1] + ">" + ((fileName && fileName.trim().length != 0) ? "\n\t  at Component: " + fileName : ""));
                                }
                            }
                            // else if (stack.getLastItem() == "template" && seenTableBefore == 0 && tableTags[match[1]]) {
                            //     if (errorObj) {
                            //         errorObj.warnings.push({ message: "Warning: Misplaced "+match[1] + " tag in " + match[0] + "....." + "</" + match[1] + ">" + ((fileName && fileName.trim().length != 0) ? "\n\t  at Component: " + fileName : "") });
                            //     }
                            //     else{
                            //         console.warn("Warning: Misplaced "+match[1] + " tag in " + match[0] + "....." + "</" + match[1] + ">" + ((fileName && fileName.trim().length != 0) ? "\n\t  at Component: " + fileName : ""));
                            //     }
                            //     doCheckUntil = match[1].toLowerCase();
                            // }
                        }
                        // if(match[1] == "code"){
                        //     let codeTagMatch = /<\/code\s*>/gm.exec(htmlString);
                        //     if(codeTagMatch){
                        //         let innerString = htmlString.substring(0,codeTagMatch.index);
                        //         htmlString = htmlString.substring(codeTagMatch.index);
                        //         parseStartTag(match[0], match[1], match[2], match[3],innerString);
                        //     }
                        //     else{
                        //         throw new Error("Error: Unclosed `code` tag");
                        //     }
                        // }
                        // else{
                            parseStartTag(match[0], match[1], match[2], match[3]);
                        // }
                        // match[0].replace(regexFor.startTag, parseStartTag);
                        hasUnparsedChars = false;
                        if(match[1] == "p"){
                            paragraphTagStarted = 1;
                        }
                        if(paragraphTagStarted == 1 && match[1] == "template"){ 
                            paragraphTagStarted = 2;
                        }
                        // paragraphTagStarted = (match[1] == "p");
                    } else {
                        let err =  new Error(match.error + ((match.index) ? " in <" + match.index.substring(0,(match.index.indexOf(">")!=-1)?match.index.indexOf(">")+1:51) + "....." : ""));
                        err.fromParser = true;
                        err.lineIndex = lineIndex;
                        err.colIndex = colIndex;
                        throw err;
                    }
                }
                if (hasUnparsedChars) {
                    
                    // index = htmlString.indexOf("<");
                    let hasSeenOpenMustache = false,newLineCount = 0,index,lastNewLineIndex =undefined,mustacheIndex = {};
                    for (let i = 0; i < htmlString.length; i++) {
                        if(htmlString[i] == "\n"){
                            newLineCount++;
                            lastNewLineIndex = i;
                        }
                        if (htmlString[i] == '{' && htmlString[i + 1] == '{') {
                            hasSeenOpenMustache = true;
                            mustacheIndex = {colIndex:i-newLineCount,lineIndex:lineIndex+newLineCount};
                        }
                        if (htmlString[i] == '}' && htmlString[i + 1] == '}') {
                            hasSeenOpenMustache = false;
                        }
                        // if (htmlString[i] == '<' && !hasSeenOpenMustache) {
                        if (htmlString[i] == '<' && !hasSeenOpenMustache){// && (getStartTag(htmlString.slice(i+1)).bool || htmlString.slice(i).match(regexFor.endTag))) {//@Harish3055 check this
                            index = i;
                            break;
                        }
                    }
                    if(hasSeenOpenMustache){
                        let err = new Error("Unclosed Mustache at "+htmlString.substring(mustacheIndex.colIndex,mustacheIndex.colIndex+50));
                        err.fromParser = true;
                        err.lineIndex = mustacheIndex.lineIndex;
                        err.colIndex = (mustacheIndex.lineIndex == lineIndex)?/* <h1>check{{{}</h1> */colIndex+mustacheIndex.colIndex:/* <h1>che\nck{{{}</h1> */mustacheIndex.colIndex;
                        throw err;
                    }
                    if(!index){
                        mismatchColIndex = {colIndex,lineIndex};
                        index = htmlString.length;
                        newLineCount = 0;
                    }
                    let text = index < 0 ? htmlString : htmlString.substring(0, index);
                    htmlString = index < 0 ? "" : htmlString.substring(index);
                    if (callbacks.chars) {
                        // @Handle3055 to get precise line and column number
                        // if(!seenPreBefore && text){
                        //   text = text.replace(/\r?\n|\r/g,' ').replace(/\s+/g,' ');
                        // }
                        callbacks.chars(text, lineIndex, colIndex, checkClosingTag);
                        colIndex = colIndex + text.length;
                        if (newLineCount) {
                            lineIndex+=newLineCount;
                            colIndex = text.length - lastNewLineIndex;
                        }
                    }
                }
            } else {
                htmlString = htmlString.replace(new RegExp("([\\s\\S]*?)<\/" + stack.getLastItem() + "[^>]*>"), replacerFn);
                parseEndTag("", stack.getLastItem());
            }
            if (htmlString == stringInPrevLoopState) {
                throw "Parse Error: " + htmlString.substring(0,100)+"...";
            }
            stringInPrevLoopState = htmlString;
        }
        if(stack.length>0){
            let err =  new Error("Unclosed `" + elemStack.getLastItem() + "` in " + htmlString.substring(0, 100) + "..."+((fileName && fileName.trim().length != 0) ? "\n\t    at Component: " + fileName : ""));
            err.lineIndex = mismatchColIndex.lineIndex || lineIndex;
            err.colIndex = mismatchColIndex.colIndex || colIndex;
            throw err;
        }
        parseEndTag();
    }
}());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HTMLParser);
//ignorei18n_end

/***/ }),

/***/ "./src/HandleMustache.js":
/*!*******************************!*\
  !*** ./src/HandleMustache.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
let errorType = ["Empty Mustache Not allowed", "missing ',' in helper function parameters", "Unexpected token ", "Misplaced ','", "Callback invocation is not supported", "Only helper function calls are allowed", "Syntax error encountered while accessing object", "Syntax Error invalid '.' Dot operator", `String started and never closed`, "Syntax Error unmatched ", " Array Without indexing ", "Syntax Error"]
let capturedError = undefined;

function isAlphaNumeric(code) {
    code = code.charCodeAt(0);
    if ((code > 47 && code < 58) || (code > 64 && code < 91) || (code > 96 && code < 123)) {
        return true;
    }
    return false;
}

function isNumeric(code) {
    code = code.charCodeAt(0);
    if (code > 47 && code < 58) {
        return true;
    }
    return false;
}

function validKeysString(val) {
    return isAlphaNumeric(val) || "!@#$%^&*_+-=".indexOf(val) != -1;
}

function isValidSquareBracket(val) {
    if (isAlphaNumeric(val) || val == "]" || val == ")" || val == "_" || val == "$" || val == " ") {
        return true;
    }
    return false;
}

function isValidDot(val) {
    return isValidSquareBracket(val) || "!@#$%^&*_+-=".indexOf(val) != -1;
}

function updateSqBracket(val) {
    for (let i = 0; i < val.length; i++) {
        val[i]++;
    }
    return val;
}

function isValidVariableName(name) {
    return /^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(name);
}

function getObservedAttributes(str, check) {
    let observedAttributes = [],
        string = "",
        variableStarted = false,
        doubleQuoteStringStarted = false,
        singleQuoteStringStarted = false,
        dotStarted = false;

    for (let i = 0; i < str.length; i++) {
        if (str[i] == "'" && str[i - 1] != "\\") {
            doubleQuoteStringStarted = !doubleQuoteStringStarted;
        } else if (str[i] == '"' && str[i - 1] != "\\") {
            singleQuoteStringStarted = !singleQuoteStringStarted;
        } else if (!doubleQuoteStringStarted && !singleQuoteStringStarted) {
            if (isAlphaNumeric(str[i]) || str[i] == '_') {
                variableStarted = true;
                string += str[i];
            } else {
                if (str[i] == " ") {
                    continue;
                }

                if (dotStarted) {
                    string = ""
                    if (str[i] != ".") {
                        dotStarted = false;
                    } else {
                        continue;
                    }
                }
                if (str[i] == ".") {
                    dotStarted = true;
                }
                if (string.length > 0 && str[i] != '(' && isValidVariableName(string)) {

                    check.observedAttributes[string] = true;
                }
                variableStarted = false;
            }
        }
        if (!variableStarted) {
            string = "";
        }
    }
    return observedAttributes
}

function checkForMixedCase(val) {
    let seenDoubleQuotes = false,
        seenSingleQuotes = false,
        mustacheStarted = false,
        mixedCase = false;
    let slashCount = 0;
    let mustacheSpots = [],res = "",mus={};
    for (let i = 0; i < val.length; i++) {
        //remove spaces other than present in double and single quotes
        if (mustacheStarted && ((seenDoubleQuotes || seenSingleQuotes) || val[i].match(/\S/))) {
            res += val[i];
        }
        if (val[i - 1] != "\\" && val[i] == "{" && val[i + 1] == "{" && !seenDoubleQuotes && !seenSingleQuotes) {
            if(mustacheStarted){
                return {
                    bool:false,
                    errorIndex:i-mus.index[0]+1,
                    err:"Invalid dynamic value inside dynamic value `{{`"
                };
            }
            if (!mixedCase && i != 0) {
                mixedCase = true
            }
            mus = {}
            mus.index = [i];
            // spot[0] = i;
            mustacheStarted = true;
        }
        if (val[i] == "}" && val[i + 1] == "}" && !seenDoubleQuotes && !seenSingleQuotes && mustacheStarted) {
            if (!mixedCase && i + 1 != val.length - 1) {
                mixedCase = true
            }
            // spot[1] = i + 1;
            mus.index[1] = i + 1;
            mus.orgMus = val.substring(mus.index[0],mus.index[1]+1);
            mus.mus = "{"+res+"}";
            res = "";
            mustacheSpots.push(mus);
            mustacheStarted = false;
        }
        if (val[i] == "\\") {
            slashCount++;
        }
        if (val[i - 1] != "\\" || (val[i - 1] == "\\" && slashCount % 2 == 0)) {
            if (val[i] == "'" && !seenDoubleQuotes && mustacheStarted) {
                seenSingleQuotes = !seenSingleQuotes;
            }
            if (val[i] == '"' && !seenSingleQuotes && mustacheStarted) {
                seenDoubleQuotes = !seenDoubleQuotes;
            }
        }
        if (val[i] != "\\") {
            slashCount = 0;
        }

    }
    return {
        bool:true,
        mixedCase: mixedCase,
        mustacheSpots: mustacheSpots
    };
}

function getLineAndColIndex(val, obj, mSpot) {
    let beforeContextSplit = val.substring(0, mSpot).split("\n");
    return {
        colIndex: (beforeContextSplit.length - 1) ? beforeContextSplit[beforeContextSplit.length - 1].length : obj.colIndex + mSpot,
        lineIndex: obj.lineIndex + beforeContextSplit.length - 1
    };
}

function syntaxCheckWorkerNew(val, check = undefined, errorObj = {}, index,attr) {
    // val = val.trim();
    if (!check.Compile) {
        console.error("Error: `can't get trimAttr scope`");
        return {
            text: val
        };
    } else {
        let syn = undefined;
        let observedAttributes = undefined;
        let mixedCaseCheck = false;
        let origMustache = val;
        if (val.indexOf("{{") !== -1) {
            attr && (val = val.trim().replace(/^@nbsp@|@nbsp@$/gm,""));
            //   let  tempVal =val.match(/{{[^}]*?(?:(?:[^\1]*?\1)[^}]*?)*}}/g)
            let tempCopy, valCopy = val;
            let res = checkForMixedCase(val);
            if (res.bool) {
                const {
                    mixedCase,
                    mustacheSpots
                } = res;
                mixedCaseCheck = mixedCase;
                if (mustacheSpots.length && mustacheSpots.length > 0) {
                    for (let j = 0; j < mustacheSpots.length; j++) {
                        let mustache = mustacheSpots[j].mus,//valCopy.substring(mustacheSpots[j][0], mustacheSpots[j][1] + 1),
                            x = mustache,
                            spots = mustacheSpots[j].index;
                        if(mustache.match(/\&|\||\!|\=|\+|-|\*|\/|<|>|\?|:|%/gm)){
                            x = check.Compile.trimAttr(mustache, [], {}, undefined, "", check);
                            
                        }
                        val = val.replace(mustacheSpots[j].orgMus, () => {
                            return x;
                        });
                        tempCopy = x;
                        syn = processAttr(x);
                        if (!syn.bool) {
                            if (errorObj.hasOwnProperty("mustacheSyntax")) {
                                syn = Object.assign(syn, getLineAndColIndex(val, index, spots[0]));
                                syn.dynamicValue = x;
                                syn.fileName = check.fileName;
                                syn.musEnd = getLineAndColIndex(val, index, spots[1]);
                                errorObj.mustacheSyntax.arr.push(syn);
                                if (errorObj.mustacheSyntax.obj[errorType[syn.errType]]) {
                                    errorObj.mustacheSyntax.obj[errorType[syn.errType]].push(check.fileName)
                                } else {
                                    errorObj.mustacheSyntax.obj[errorType[syn.errType]] = [check.fileName]
                                }
                            }
                        }
                        if (check && check.emberFlag && ((syn && syn.bool) || (!capturedError))) {
                            getObservedAttributes(tempCopy, check);
                        }

                    }
                } else {
                    syn = processAttr(val);
                    if (!syn.bool) {
                        syn.dynamicValue = val;
                        if ( errorObj.hasOwnProperty("mustacheSyntax") ) {
                            syn = Object.assign(syn, getLineAndColIndex(val, index, val.indexOf("{{")));
                            syn.fileName = check.fileName;
                            errorObj.mustacheSyntax.arr.push(syn);
                            if (errorObj.mustacheSyntax.obj[errorType[syn.errType]]) {
                                errorObj.mustacheSyntax.obj[errorType[syn.errType]].push(check.fileName)
                            } else {
                                errorObj.mustacheSyntax.obj[errorType[syn.errType]] = [check.fileName]
                            }
                        }
                    }
                }
            }
            else{
                res = Object.assign(res, getLineAndColIndex(val, index, val.indexOf("{{")));
                res.dynamicValue = val;
                res.fileName = check.fileName;
                errorObj.mustacheSyntax.arr.push(res);
                if (errorObj.mustacheSyntax.obj[res.err]) {
                    errorObj.mustacheSyntax.obj[res.err].push(check.fileName)
                } else {
                    errorObj.mustacheSyntax.obj[res.err] = [check.fileName]
                }
            }
        }
        if (!check.fromInternal && check.withoutTemplateConversion) {
            val = origMustache;
        }
        val = val.replace(/@nbsp@/gm, "&nbsp;");
        return {
            text: val,
            type: syn ? ((mixedCaseCheck) ? "Mixed" : syn.type) : syn,
            "observedAttributes": (observedAttributes && observedAttributes.length > 0) ? observedAttributes : undefined
        };
    }
}

function processAttr(val) {
    let parsingMustache,
        mustacheIndex = 0,
        typeStarted,
        type = null,
        mustache = 0,
        retObj = {
            mustache: 0,
            bool: true,
            err: null,
            errorIndex: 0
        },
        valueBeforeSpace = undefined,
        stringStartIndex = 0,
        seenTextBeforeNextcomma = undefined,
        seenTokenBefore = false,
        stringStartCheck = false,
        dotStarted = false;
    if (val == '{{}}') {
        retObj.bool = false;
        retObj.err = errorType[0];
        retObj.errType = 0;
        retObj.errorIndex = 0;
        return retObj;
    }
    for (let i = 0; i < val.length; i++) {
        if (parsingMustache) {
            if ((validKeysString(val[i]))) {
                if ((!stringStarted && !dotStarted && "!@#%^&*+-=".indexOf(val[i]) != -1) || (val[i - 1] == " " && seenTokenBefore) || (stringStartCheck && val[i - 1] == " ")) {
                    retObj.bool = false;
                    retObj.err = errorType[2] + val[i];
                    retObj.errType = 2;
                    retObj.errorIndex = i;
                    return retObj;
                }
                if (!stringStarted) {
                    seenTokenBefore = true;
                }

            } else if (val[i] != " ") {
                if (!stringStarted && (val[i] == "'" || val[i] == '"')) {
                    if (val[i - 1] == " " && seenTokenBefore) {
                        retObj.bool = false;
                        retObj.err = errorType[2] + val[i];
                        retObj.errType = 2
                        retObj.errorIndex = i;
                        return retObj;
                    }
                }
                if (!stringStarted && val[i] == ".") {
                    dotStarted = true;
                } else {
                    dotStarted = false;
                }
                stringStartCheck = false;
                seenTokenBefore = false;
            }
            if (seenTextBeforeNextcomma == false && val[i] != " " && val[i] != ",") {
                seenTextBeforeNextcomma = true;
            }
            if (sqBrackets.length > 0 && ![" ", "]", "["].includes(val[i])) {
                sqBrackets = updateSqBracket(sqBrackets);
            }
            if (spaceStarted && val[i] == "," && !stringStarted) {
                spaceStarted = false;
                valueBeforeSpace = undefined;
            }
            // console.log(val[i],stringStarted)

            if (!stringStarted && !commaSeen && isAlphaNumeric(val[i]) && ((valueBeforeSpace && isAlphaNumeric(valueBeforeSpace)) || (valueBeforeSpace && ["'", '"'].includes(valueBeforeSpace)) || ["'", '"'].includes(val[i - 1]))) {
                // console.log(1)
                retObj.bool = false;
                retObj.err = errorType[2] + val[i];
                retObj.errType = 2
                retObj.errorIndex = i;
                return retObj;
            }
            if (spaceStarted && ![",", " "].includes(val[i]) && !stringStarted && !commaSeen && paranthesis != 0) {

                if (val[i] == "(" || val[i] == "[" || ((val[i] == ")" || val[i]=="'" || val[i] == '"')  && paranthesis >= 1) || (val[i] == "]" && squareBracketCount >= 1) || isAlphaNumeric(val[i])) {
                    spaceStarted = false;
                    valueBeforeSpace = undefined;
                }
                else {
                    // console.log(2)
                    retObj.bool = false;
                    retObj.err = errorType[2] + val[i];
                    retObj.errType = 2
                    retObj.errorIndex = i;
                    return retObj;
                }
            } else if (!stringStarted && "," == val[i] && paranthesis == 0) {
                // console.log(3)
                retObj.bool = false;
                retObj.err = errorType[3];
                retObj.errType = 3
                retObj.errorIndex = i;
                return retObj;
            } else if (!stringStarted && val[i] == ',') {
                if (seenTextBeforeNextcomma == false) {
                    // param check case
                    // console.log("Found the spot dood!!",val.substr(i))
                    seenTextBeforeNextcomma = false
                }
                seenTextBeforeNextcomma = false;
                commaSeen = true;
            }

            if (checkThis) {
                if (![",", " ", "}"].includes(val[i])) {
                    if ([")", "]"].includes(checkThis) || (['"', "'"].includes(checkThis) && !stringStarted)) {
                        if (((val[i] == ")" && paranthesis >= 0) || (val[i] == "]" && sqBrackets.length > 0) || (val[i] == '[') || (val[i] == '.'))) {
                            checkThis = undefined;
                        }
                        // else if (val[i] == ")" && checkThis == "[" && paranthesis == 0) {
                        //     checkThis = undefined;
                        // }
                        else if (!commaSeen && !spaceStarted && !stringStarted && !(!stringStarted && checkThis == '"') && !(!stringStarted && checkThis == "'")) {
                            if (paranthesis > 0 && checkThis == ']') {
                                // console.log(4)
                                retObj.bool = false;
                                retObj.err = errorType[4];
                                retObj.errType = 4
                                retObj.errorIndex = i;
                                return retObj;
                            } else {
                                retObj.bool = false;
                                if (val[i] == '(' && checkThis == ')') {
                                    retObj.err = errorType[11];
                                    retObj.errType = 11
                                    retObj.errorIndex = i;
                                    return retObj;
                                }
                                if (val[i] == ']' && checkThis == ')') {
                                    retObj.err = errorType[5];
                                    retObj.errType = 5
                                    retObj.errorIndex = i;
                                    return retObj;
                                }
                                if ((val[i] == ']' && checkThis != ']') || (val[i] == ')' && checkThis != ')')) {
                                    retObj.err = errorType[11]
                                    retObj.errType = 11;
                                    retObj.errorIndex = i;
                                    return retObj;
                                }
                                if (val[i - 1] == ')') {
                                    retObj.err = errorType[2]
                                    retObj.errType = 2
                                    retObj.errorIndex = i;
                                    return retObj;
                                }

                            }
                        }
                    } else if (checkThis == '.') {
                        if (val[i].toUpperCase() != val[i].toLowerCase() || "!@#$%^&*_+-={}".indexOf(val[i]) != -1 || isNumeric(val[i])) {
                            checkThis = undefined;
                        } else if (!spaceStarted) {
                            retObj.bool = false;
                            retObj.err = errorType[6];
                            retObj.errType = 6
                            // console.log(6);
                            retObj.errorIndex = i;
                            return retObj;
                        }
                    }
                } else if (!stringStarted && val[i] == "," && paranthesis == 0) {

                    retObj.bool = false;
                    retObj.err = errorType[11];
                    retObj.errType = 11
                    // console.log(7);
                    retObj.errorIndex = i;
                    return retObj;

                } else if (!stringStarted && val[i] == ',') {
                    checkThis = undefined;
                }
            }
            if (paranthesis == 0 && val[i - 1] == ')' && ['.', '['].includes(val[i])) {
                type = "Extra Helper"
            }
            if (val[i] == "\\") {

                // if ( !(stringStarted && (i + 1 < val.length) && ['"', "'", '?', '\\'].includes(val[i + 1])) ){
                // console.log(val.substring(i), val[i], val[i + 1], stringStarted)
                // retObj.bool = false;
                // retObj.err = "Syntax Error invalid escape sequence";
                // retObj.errorIndex = i;
                // return retObj;
                // }
                i = i + 1;
            } else if (val[i] == "'") {
                if (lastString != '"') { //val[i-1] != "\\"  && 
                    if (!stringStarted) {
                        if(!(paranthesis>0 || (squareBracket && squareBracket.length>0))){
                            retObj.bool = false;
                            retObj.err = errorType[2]+ "'";
                            retObj.errType = 2;
                            retObj.errorIndex = i;
                            return retObj;
                        }
                        quotesBracket.push("'")
                        stringStarted = true;
                        stringStartIndex = i;
                        lastString = "'";
                    } else {
                        let count = undefined;
                        if (val[i - 1] == "\\") {
                            count = 0;
                            for (let j = i - 1; j >= 0; j--) {
                                if (val[j] == "\\") {
                                    count++;
                                } else {
                                    break;
                                }
                            }
                        }
                        if (count == undefined || count % 2 == 0) {
                            quotesBracket.pop("'")
                            stringStarted = false;
                            stringStartCheck = true;
                            lastString = undefined;
                        }
                    }

                }
            } else if (val[i] == '"') {

                if (lastString != "'") { //val[i-1] != "\\" &&
                    if (!stringStarted) {
                        if(!(paranthesis>0 || (squareBracket && squareBracket.length>0))){
                            retObj.bool = false;
                            retObj.err = errorType[2]+ '"';
                            retObj.errType = 2;
                            retObj.errorIndex = i;
                            return retObj;
                        }
                        quotesBracket.push('"')
                        stringStarted = true;
                        stringStartIndex = i;
                        lastString = '"'
                    } else {
                        let count = undefined;
                        if (val[i - 1] == "\\") {
                            count = 0;
                            for (let j = i - 1; j >= 0; j--) {
                                if (val[j] == "\\") {
                                    count++;
                                } else {
                                    break;
                                }
                            }
                        }
                        if (count == undefined || count % 2 == 0) {
                            quotesBracket.pop('"')
                            stringStarted = false;
                            stringStartCheck = true;
                            lastString = undefined;
                        }
                    }
                }
            } else if (val[i] == "{" && !stringStarted && dotStarted) {
                retObj.bool = false;
                retObj.err = errorType[2] + "'{' bracket ";
                retObj.errType = 2
                // console.log(8);
                retObj.errorIndex = i;
                return retObj;
            } else if (val[i] == "{" && stringStarted && val[i - 1] == "{") {
                retObj.mustache++;
            } else if (val[i] == "}" && val[i - 1] == "}" && !stringStarted) {
                if (curlyBracket.length) {
                    retObj.bool = false;
                    retObj.err = errorType[9] + "'(' bracket ";
                    retObj.errType = 9
                    // console.log(9);
                    retObj.errorIndex = i;
                    return retObj;
                }
                if (squareBracket.length) {
                    retObj.bool = false;
                    retObj.err = errorType[9] + "'[' bracket ";
                    retObj.errType = 9
                    // console.log(10);
                    retObj.errorIndex = i;
                    return retObj;
                }
                parsingMustache = false;

            } else if (val[i] == "[" && !stringStarted) {
                if (isValidSquareBracket(val[i - 1])) {
                    squareBracket.push("[");
                    sqBrackets.push(0);
                }
                //  else {
                //     retObj.bool = false;
                //     retObj.err = "Syntax Error invalid '"+val[i-1]+"'";
                //     retObj.errorIndex = i;
                //     return retObj;
                // }
                if (!typeStarted) {
                    typeStarted = 1
                }
                if (typeStarted == 1) {
                    if (!squareBracketCount && squareBracketCount != 0) {
                        squareBracketCount = 1
                    } else {
                        squareBracketCount += 1;
                    }

                    if (squareBracketCount > 1) {
                        type = "Multi-dimensional array"
                    }

                }

            } else if (val[i] == "]" && !stringStarted) {
                let check;
                if (squareBracket.length) {
                    squareBracket.pop();
                    check = sqBrackets.pop();
                } else {
                    retObj.bool = false;
                    retObj.err = errorType[9] + "']' bracket ";
                    retObj.errType = 9
                    retObj.errorIndex = i;
                    return retObj;
                }
                if (check == 0) {
                    retObj.bool = false;
                    retObj.err = errorType[10];
                    retObj.errType = 10;
                    retObj.errorIndex = i;
                    return retObj;
                }
                squareBracketCount -= 1;

            } else if (val[i] == "(" && !stringStarted) {
                if (i > 0 && (isAlphaNumeric(val[i - 1]) || val[i] == '_')) {
                    curlyBracket.push('(');
                } else {
                    // console.log(12);
                    retObj.bool = false;
                    retObj.err = errorType[2];
                    retObj.errType = 2;
                    retObj.errorIndex = i;
                    return retObj;
                }
                paranthesis += 1
                if (paranthesisLog == 0) {
                    continue;
                }
                if (!typeStarted) {
                    typeStarted = 2
                }
                if (typeStarted == 1 && squareBracketCount > 0) {
                    type = "Multi-dimensional array"
                }
                if (typeStarted == 3 && sqBrackets.length == 0) {
                    retObj.bool = false;
                    retObj.err = errorType[5];
                    retObj.errType = 5;
                    // console.log(13);
                    retObj.errorIndex = dotIndex;
                    return retObj;
                }
                if (typeStarted == 2) {
                    if (!paranthesisLog && paranthesisLog != 0) {
                        paranthesisLog = 1
                    } else {
                        paranthesisLog += 1;
                    }
                    if (paranthesisLog > 1) {
                        type = "helper"
                    }
                }
            } else if (val[i] == ")" && !stringStarted) {
                if (curlyBracket.length) {
                    curlyBracket.pop();
                } else {
                    retObj.bool = false;
                    retObj.err = errorType[9] + "')' bracket ";
                    retObj.errType = 9
                    retObj.errorIndex = i;
                    return retObj;
                }
                paranthesis -= 1;
                paranthesisLog -= 1;
                if (!typeStarted) {
                    typeStarted = 2;
                }
                if (typeStarted == 2) {
                    if (paranthesisLog == 0 && !type) {
                        type = "helper";
                    }
                }
            } else if (val[i] == "." && !stringStarted) {

                if (!isValidDot(val[i - 1])) {
                    retObj.bool = false;
                    retObj.err = errorType[7];
                    retObj.errType = 7;
                    retObj.errorIndex = i;
                    return retObj;
                }
                if (!typeStarted) {
                    typeStarted = 3;
                }
                if (typeStarted == 1 && sqBrackets.length > 0) {
                    type = "Multi-dimensional array"
                }
                dotIndex = i;
            } else {
                if ((isAlphaNumeric(val[i]) || val[i] == "_") && !stringStarted) {
                    if (val[i + 1] == "'" || val[i + 1] == '"') {
                        retObj.bool = false;
                        retObj.err = errorType[2] + val[i + 1];
                        retObj.errType = 2
                        // console.log(14);
                        retObj.errorIndex = i + 1;
                        return retObj;
                    }
                }
            }

            if (!stringStarted && commaSeen && ![" ", ","].includes(val[i])) {
                if (seenTextBeforeNextcomma == false) {
                    seenTextBeforeNextcomma = false;
                    // param check case
                    // console.log("Found the spot dood!!",val.substr(i))
                }
                commaSeen = false;
                seenTextBeforeNextcomma = undefined;
            }
            if (paranthesis > 0) {
                if (val[i + 1] == " " && !stringStarted) {
                    spaceStarted = true;
                    valueBeforeSpace = val[i];
                    continue;
                }
                if (spaceStarted) {
                    continue;
                }

            };
            if (!stringStarted && paranthesis >= 0 && [")", "]", ".", "'", '"'].includes(val[i])) {
                checkThis = val[i];

            }

        } else if ((val[i] == "{" && val[i - 1] == "{" && val[i - 2] != "\\")) {
            mustache++;
            var curlyBracket = [],
                squareBracket = [],
                stringStarted, lastString, quotesBracket = [],
                paranthesis = 0,
                squareBracketCount, //typeStarted 1:Array 2:helpers 3:Dict or Object 
                spaceStarted, checkThis, paranthesisLog, emptyArrayDetector = true,
                sqBrackets = [],
                commaSeen,
                dotIndex;
            typeStarted = null;
            type = null;
            parsingMustache = true;
            checkThis = undefined;
            mustacheIndex = i;
            // 
        }
    }
    if (stringStarted) {
        retObj.bool = false;
        retObj.err = errorType[8];
        retObj.errType = 8;
        retObj.errorIndex = stringStartIndex;
        return retObj;
    }
    if (parsingMustache) {
        retObj.bool = false;
        retObj.err = errorType[9] + "'{' bracket";
        retObj.errType = 9;
        retObj.errorIndex = mustacheIndex; //harish check
        return retObj;
    }
    if (!type) {
        type = "Normal Data"
    }
    if (mustache > 1) {
        {
            type = "mixed mustache";
        }
    }
    retObj.type = type;
    return retObj;
}
// console.log(processAttr("{{obbHelp(obb,obb.{})}}"))
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (syntaxCheckWorkerNew);
// let str = "{{if(ifEquals(module_info.show_zf_panel,0),,'zfGetStartInit')}}"
// console.log(str)
// let err = processAttr(str)
// if(err.bool === false){
//     console.log(err)
//     console.log(str.substr(err.errorIndex))
// }
// ls = [
//     "{{dynamicData}}",
//     "{{dynamicData[data.some][someNumber].key['a']}}",
//     "{{$lg.dynamicData}}",
//     "{{object[key.name]}}",
//     "{{helper()}}",
//     "{{ helper('anything##(*(*&*&*}}\"', data) }}",
//     "{{ helper(anotherHelper(), 'something', newHelper(data))}}",
//     "{{helper().something}}", //future
//     "{{helper().something[data].key.a.b}}", //future
//     "{{dynamichelper()[some]}}",
//     "{{ dynamichelper()[somehelper()]}}",
//     "{{array[someNewArray[data]]}}",
//     "{{array[helper()]}}",
//     "{{helper(arr[arr[0]])}}",
// ]

// let invalid = [
//     "{{dynamic{{val}}}} ",
//     "{{dynamichelper()helper()}}",
//     "{{dynamichelper()()}}",
//     "{{()dynamichelper()}}",
//     "{{[]dynamichelper()}}",
//     "{{.dynamichelper()}}",
//     "{{}}",
//     "{{helper(abc),newHelper()}}",
//     "{{name.some()}}",
//     "{{arr[]}}",
//     "{{helper()aa}}",
//     "{{helper(data1'string')}}",
//     "{{arr[0]()}}"
// ]

// for (let i = 0; i < invalid.length; i++){
//     console.log(syntaxCheckWorkerNew(invalid[i]),invalid[i])
// }


// testCasesInFile =[ 
//     "{{newHelp(h1(h2(h3(h4(h5('a'),help(obj.something1.something2.something3.something4.something5.something6.something7.something8),help(arr[0],arr1[0][1],arr2[0][0][0])),help(obj.something1.something2.something3.something4.something5.something6.something7.something8))),objArrMix.something1.something2[zero].something3[bigDataBigDataBigDataBigDataBigDataBigDataBigDataBigData][obj.something1.something2.something3.something4.something5.something6.something7.something0][sampObj.a].something5.something6.something7.something8[0].arr[1]))}}",
//     "{{newHelp(returnNum(123),returnStr('str'),returnObj(sampObj),returnBool(flag), returnArr(arr))}}",
//     "{{ 'sample'}}",
//     "{{newHelp(h1(h2(h3(h4(h5('a'))))))}}",
//     "{{help(objArrMix.something1.something2[zero].something3[bigDataBigDataBigDataBigDataBigDataBigDataBigDataBigData][obj.something1.something2.something3.something4.something5.something6.something7.something0][sampObj.a].something5.something6.something7.something8[0].arr[1])}}",
//     "{{help(arrObj[zero].something)}}",
//     "{{help('a','abc{{def')}}",
//     "{{help('a','\@')}}",

//     "{{help('str', 'hello\\'s' , 'hello\\\'s','hello\\\\\'s')}}",
// ]

// console.log(testCasesInFile[testCasesInFile.length-1])
// for (let i = 0; i < testCasesInFile.length;i++)

/***/ }),

/***/ "./src/decodeHtmlEntities.js":
/*!***********************************!*\
  !*** ./src/decodeHtmlEntities.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
let regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
let decodeMap = {'aacute':'\xE1','Aacute':'\xC1','abreve':'\u0103','Abreve':'\u0102','ac':'\u223E','acd':'\u223F','acE':'\u223E\u0333','acirc':'\xE2','Acirc':'\xC2','acute':'\xB4','acy':'\u0430','Acy':'\u0410','aelig':'\xE6','AElig':'\xC6','af':'\u2061','afr':'\uD835\uDD1E','Afr':'\uD835\uDD04','agrave':'\xE0','Agrave':'\xC0','alefsym':'\u2135','aleph':'\u2135','alpha':'\u03B1','Alpha':'\u0391','amacr':'\u0101','Amacr':'\u0100','amalg':'\u2A3F','amp':'&','AMP':'&','and':'\u2227','And':'\u2A53','andand':'\u2A55','andd':'\u2A5C','andslope':'\u2A58','andv':'\u2A5A','ang':'\u2220','ange':'\u29A4','angle':'\u2220','angmsd':'\u2221','angmsdaa':'\u29A8','angmsdab':'\u29A9','angmsdac':'\u29AA','angmsdad':'\u29AB','angmsdae':'\u29AC','angmsdaf':'\u29AD','angmsdag':'\u29AE','angmsdah':'\u29AF','angrt':'\u221F','angrtvb':'\u22BE','angrtvbd':'\u299D','angsph':'\u2222','angst':'\xC5','angzarr':'\u237C','aogon':'\u0105','Aogon':'\u0104','aopf':'\uD835\uDD52','Aopf':'\uD835\uDD38','ap':'\u2248','apacir':'\u2A6F','ape':'\u224A','apE':'\u2A70','apid':'\u224B','apos':'\'','ApplyFunction':'\u2061','approx':'\u2248','approxeq':'\u224A','aring':'\xE5','Aring':'\xC5','ascr':'\uD835\uDCB6','Ascr':'\uD835\uDC9C','Assign':'\u2254','ast':'*','asymp':'\u2248','asympeq':'\u224D','atilde':'\xE3','Atilde':'\xC3','auml':'\xE4','Auml':'\xC4','awconint':'\u2233','awint':'\u2A11','backcong':'\u224C','backepsilon':'\u03F6','backprime':'\u2035','backsim':'\u223D','backsimeq':'\u22CD','Backslash':'\u2216','Barv':'\u2AE7','barvee':'\u22BD','barwed':'\u2305','Barwed':'\u2306','barwedge':'\u2305','bbrk':'\u23B5','bbrktbrk':'\u23B6','bcong':'\u224C','bcy':'\u0431','Bcy':'\u0411','bdquo':'\u201E','becaus':'\u2235','because':'\u2235','Because':'\u2235','bemptyv':'\u29B0','bepsi':'\u03F6','bernou':'\u212C','Bernoullis':'\u212C','beta':'\u03B2','Beta':'\u0392','beth':'\u2136','between':'\u226C','bfr':'\uD835\uDD1F','Bfr':'\uD835\uDD05','bigcap':'\u22C2','bigcirc':'\u25EF','bigcup':'\u22C3','bigodot':'\u2A00','bigoplus':'\u2A01','bigotimes':'\u2A02','bigsqcup':'\u2A06','bigstar':'\u2605','bigtriangledown':'\u25BD','bigtriangleup':'\u25B3','biguplus':'\u2A04','bigvee':'\u22C1','bigwedge':'\u22C0','bkarow':'\u290D','blacklozenge':'\u29EB','blacksquare':'\u25AA','blacktriangle':'\u25B4','blacktriangledown':'\u25BE','blacktriangleleft':'\u25C2','blacktriangleright':'\u25B8','blank':'\u2423','blk12':'\u2592','blk14':'\u2591','blk34':'\u2593','block':'\u2588','bne':'=\u20E5','bnequiv':'\u2261\u20E5','bnot':'\u2310','bNot':'\u2AED','bopf':'\uD835\uDD53','Bopf':'\uD835\uDD39','bot':'\u22A5','bottom':'\u22A5','bowtie':'\u22C8','boxbox':'\u29C9','boxdl':'\u2510','boxdL':'\u2555','boxDl':'\u2556','boxDL':'\u2557','boxdr':'\u250C','boxdR':'\u2552','boxDr':'\u2553','boxDR':'\u2554','boxh':'\u2500','boxH':'\u2550','boxhd':'\u252C','boxhD':'\u2565','boxHd':'\u2564','boxHD':'\u2566','boxhu':'\u2534','boxhU':'\u2568','boxHu':'\u2567','boxHU':'\u2569','boxminus':'\u229F','boxplus':'\u229E','boxtimes':'\u22A0','boxul':'\u2518','boxuL':'\u255B','boxUl':'\u255C','boxUL':'\u255D','boxur':'\u2514','boxuR':'\u2558','boxUr':'\u2559','boxUR':'\u255A','boxv':'\u2502','boxV':'\u2551','boxvh':'\u253C','boxvH':'\u256A','boxVh':'\u256B','boxVH':'\u256C','boxvl':'\u2524','boxvL':'\u2561','boxVl':'\u2562','boxVL':'\u2563','boxvr':'\u251C','boxvR':'\u255E','boxVr':'\u255F','boxVR':'\u2560','bprime':'\u2035','breve':'\u02D8','Breve':'\u02D8','brvbar':'\xA6','bscr':'\uD835\uDCB7','Bscr':'\u212C','bsemi':'\u204F','bsim':'\u223D','bsime':'\u22CD','bsol':'\\','bsolb':'\u29C5','bsolhsub':'\u27C8','bull':'\u2022','bullet':'\u2022','bump':'\u224E','bumpe':'\u224F','bumpE':'\u2AAE','bumpeq':'\u224F','Bumpeq':'\u224E','cacute':'\u0107','Cacute':'\u0106','cap':'\u2229','Cap':'\u22D2','capand':'\u2A44','capbrcup':'\u2A49','capcap':'\u2A4B','capcup':'\u2A47','capdot':'\u2A40','CapitalDifferentialD':'\u2145','caps':'\u2229\uFE00','caret':'\u2041','caron':'\u02C7','Cayleys':'\u212D','ccaps':'\u2A4D','ccaron':'\u010D','Ccaron':'\u010C','ccedil':'\xE7','Ccedil':'\xC7','ccirc':'\u0109','Ccirc':'\u0108','Cconint':'\u2230','ccups':'\u2A4C','ccupssm':'\u2A50','cdot':'\u010B','Cdot':'\u010A','cedil':'\xB8','Cedilla':'\xB8','cemptyv':'\u29B2','cent':'\xA2','centerdot':'\xB7','CenterDot':'\xB7','cfr':'\uD835\uDD20','Cfr':'\u212D','chcy':'\u0447','CHcy':'\u0427','check':'\u2713','checkmark':'\u2713','chi':'\u03C7','Chi':'\u03A7','cir':'\u25CB','circ':'\u02C6','circeq':'\u2257','circlearrowleft':'\u21BA','circlearrowright':'\u21BB','circledast':'\u229B','circledcirc':'\u229A','circleddash':'\u229D','CircleDot':'\u2299','circledR':'\xAE','circledS':'\u24C8','CircleMinus':'\u2296','CirclePlus':'\u2295','CircleTimes':'\u2297','cire':'\u2257','cirE':'\u29C3','cirfnint':'\u2A10','cirmid':'\u2AEF','cirscir':'\u29C2','ClockwiseContourIntegral':'\u2232','CloseCurlyDoubleQuote':'\u201D','CloseCurlyQuote':'\u2019','clubs':'\u2663','clubsuit':'\u2663','colon':':','Colon':'\u2237','colone':'\u2254','Colone':'\u2A74','coloneq':'\u2254','comma':',','commat':'@','comp':'\u2201','compfn':'\u2218','complement':'\u2201','complexes':'\u2102','cong':'\u2245','congdot':'\u2A6D','Congruent':'\u2261','conint':'\u222E','Conint':'\u222F','ContourIntegral':'\u222E','copf':'\uD835\uDD54','Copf':'\u2102','coprod':'\u2210','Coproduct':'\u2210','copy':'\xA9','COPY':'\xA9','copysr':'\u2117','CounterClockwiseContourIntegral':'\u2233','crarr':'\u21B5','cross':'\u2717','Cross':'\u2A2F','cscr':'\uD835\uDCB8','Cscr':'\uD835\uDC9E','csub':'\u2ACF','csube':'\u2AD1','csup':'\u2AD0','csupe':'\u2AD2','ctdot':'\u22EF','cudarrl':'\u2938','cudarrr':'\u2935','cuepr':'\u22DE','cuesc':'\u22DF','cularr':'\u21B6','cularrp':'\u293D','cup':'\u222A','Cup':'\u22D3','cupbrcap':'\u2A48','cupcap':'\u2A46','CupCap':'\u224D','cupcup':'\u2A4A','cupdot':'\u228D','cupor':'\u2A45','cups':'\u222A\uFE00','curarr':'\u21B7','curarrm':'\u293C','curlyeqprec':'\u22DE','curlyeqsucc':'\u22DF','curlyvee':'\u22CE','curlywedge':'\u22CF','curren':'\xA4','curvearrowleft':'\u21B6','curvearrowright':'\u21B7','cuvee':'\u22CE','cuwed':'\u22CF','cwconint':'\u2232','cwint':'\u2231','cylcty':'\u232D','dagger':'\u2020','Dagger':'\u2021','daleth':'\u2138','darr':'\u2193','dArr':'\u21D3','Darr':'\u21A1','dash':'\u2010','dashv':'\u22A3','Dashv':'\u2AE4','dbkarow':'\u290F','dblac':'\u02DD','dcaron':'\u010F','Dcaron':'\u010E','dcy':'\u0434','Dcy':'\u0414','dd':'\u2146','DD':'\u2145','ddagger':'\u2021','ddarr':'\u21CA','DDotrahd':'\u2911','ddotseq':'\u2A77','deg':'\xB0','Del':'\u2207','delta':'\u03B4','Delta':'\u0394','demptyv':'\u29B1','dfisht':'\u297F','dfr':'\uD835\uDD21','Dfr':'\uD835\uDD07','dHar':'\u2965','dharl':'\u21C3','dharr':'\u21C2','DiacriticalAcute':'\xB4','DiacriticalDot':'\u02D9','DiacriticalDoubleAcute':'\u02DD','DiacriticalGrave':'`','DiacriticalTilde':'\u02DC','diam':'\u22C4','diamond':'\u22C4','Diamond':'\u22C4','diamondsuit':'\u2666','diams':'\u2666','die':'\xA8','DifferentialD':'\u2146','digamma':'\u03DD','disin':'\u22F2','div':'\xF7','divide':'\xF7','divideontimes':'\u22C7','divonx':'\u22C7','djcy':'\u0452','DJcy':'\u0402','dlcorn':'\u231E','dlcrop':'\u230D','dollar':'$','dopf':'\uD835\uDD55','Dopf':'\uD835\uDD3B','dot':'\u02D9','Dot':'\xA8','DotDot':'\u20DC','doteq':'\u2250','doteqdot':'\u2251','DotEqual':'\u2250','dotminus':'\u2238','dotplus':'\u2214','dotsquare':'\u22A1','doublebarwedge':'\u2306','DoubleContourIntegral':'\u222F','DoubleDot':'\xA8','DoubleDownArrow':'\u21D3','DoubleLeftArrow':'\u21D0','DoubleLeftRightArrow':'\u21D4','DoubleLeftTee':'\u2AE4','DoubleLongLeftArrow':'\u27F8','DoubleLongLeftRightArrow':'\u27FA','DoubleLongRightArrow':'\u27F9','DoubleRightArrow':'\u21D2','DoubleRightTee':'\u22A8','DoubleUpArrow':'\u21D1','DoubleUpDownArrow':'\u21D5','DoubleVerticalBar':'\u2225','downarrow':'\u2193','Downarrow':'\u21D3','DownArrow':'\u2193','DownArrowBar':'\u2913','DownArrowUpArrow':'\u21F5','DownBreve':'\u0311','downdownarrows':'\u21CA','downharpoonleft':'\u21C3','downharpoonright':'\u21C2','DownLeftRightVector':'\u2950','DownLeftTeeVector':'\u295E','DownLeftVector':'\u21BD','DownLeftVectorBar':'\u2956','DownRightTeeVector':'\u295F','DownRightVector':'\u21C1','DownRightVectorBar':'\u2957','DownTee':'\u22A4','DownTeeArrow':'\u21A7','drbkarow':'\u2910','drcorn':'\u231F','drcrop':'\u230C','dscr':'\uD835\uDCB9','Dscr':'\uD835\uDC9F','dscy':'\u0455','DScy':'\u0405','dsol':'\u29F6','dstrok':'\u0111','Dstrok':'\u0110','dtdot':'\u22F1','dtri':'\u25BF','dtrif':'\u25BE','duarr':'\u21F5','duhar':'\u296F','dwangle':'\u29A6','dzcy':'\u045F','DZcy':'\u040F','dzigrarr':'\u27FF','eacute':'\xE9','Eacute':'\xC9','easter':'\u2A6E','ecaron':'\u011B','Ecaron':'\u011A','ecir':'\u2256','ecirc':'\xEA','Ecirc':'\xCA','ecolon':'\u2255','ecy':'\u044D','Ecy':'\u042D','eDDot':'\u2A77','edot':'\u0117','eDot':'\u2251','Edot':'\u0116','ee':'\u2147','efDot':'\u2252','efr':'\uD835\uDD22','Efr':'\uD835\uDD08','eg':'\u2A9A','egrave':'\xE8','Egrave':'\xC8','egs':'\u2A96','egsdot':'\u2A98','el':'\u2A99','Element':'\u2208','elinters':'\u23E7','ell':'\u2113','els':'\u2A95','elsdot':'\u2A97','emacr':'\u0113','Emacr':'\u0112','empty':'\u2205','emptyset':'\u2205','EmptySmallSquare':'\u25FB','emptyv':'\u2205','EmptyVerySmallSquare':'\u25AB','emsp':'\u2003','emsp13':'\u2004','emsp14':'\u2005','eng':'\u014B','ENG':'\u014A','ensp':'\u2002','eogon':'\u0119','Eogon':'\u0118','eopf':'\uD835\uDD56','Eopf':'\uD835\uDD3C','epar':'\u22D5','eparsl':'\u29E3','eplus':'\u2A71','epsi':'\u03B5','epsilon':'\u03B5','Epsilon':'\u0395','epsiv':'\u03F5','eqcirc':'\u2256','eqcolon':'\u2255','eqsim':'\u2242','eqslantgtr':'\u2A96','eqslantless':'\u2A95','Equal':'\u2A75','equals':'=','EqualTilde':'\u2242','equest':'\u225F','Equilibrium':'\u21CC','equiv':'\u2261','equivDD':'\u2A78','eqvparsl':'\u29E5','erarr':'\u2971','erDot':'\u2253','escr':'\u212F','Escr':'\u2130','esdot':'\u2250','esim':'\u2242','Esim':'\u2A73','eta':'\u03B7','Eta':'\u0397','eth':'\xF0','ETH':'\xD0','euml':'\xEB','Euml':'\xCB','euro':'\u20AC','excl':'!','exist':'\u2203','Exists':'\u2203','expectation':'\u2130','exponentiale':'\u2147','ExponentialE':'\u2147','fallingdotseq':'\u2252','fcy':'\u0444','Fcy':'\u0424','female':'\u2640','ffilig':'\uFB03','fflig':'\uFB00','ffllig':'\uFB04','ffr':'\uD835\uDD23','Ffr':'\uD835\uDD09','filig':'\uFB01','FilledSmallSquare':'\u25FC','FilledVerySmallSquare':'\u25AA','fjlig':'fj','flat':'\u266D','fllig':'\uFB02','fltns':'\u25B1','fnof':'\u0192','fopf':'\uD835\uDD57','Fopf':'\uD835\uDD3D','forall':'\u2200','ForAll':'\u2200','fork':'\u22D4','forkv':'\u2AD9','Fouriertrf':'\u2131','fpartint':'\u2A0D','frac12':'\xBD','frac13':'\u2153','frac14':'\xBC','frac15':'\u2155','frac16':'\u2159','frac18':'\u215B','frac23':'\u2154','frac25':'\u2156','frac34':'\xBE','frac35':'\u2157','frac38':'\u215C','frac45':'\u2158','frac56':'\u215A','frac58':'\u215D','frac78':'\u215E','frasl':'\u2044','frown':'\u2322','fscr':'\uD835\uDCBB','Fscr':'\u2131','gacute':'\u01F5','gamma':'\u03B3','Gamma':'\u0393','gammad':'\u03DD','Gammad':'\u03DC','gap':'\u2A86','gbreve':'\u011F','Gbreve':'\u011E','Gcedil':'\u0122','gcirc':'\u011D','Gcirc':'\u011C','gcy':'\u0433','Gcy':'\u0413','gdot':'\u0121','Gdot':'\u0120','ge':'\u2265','gE':'\u2267','gel':'\u22DB','gEl':'\u2A8C','geq':'\u2265','geqq':'\u2267','geqslant':'\u2A7E','ges':'\u2A7E','gescc':'\u2AA9','gesdot':'\u2A80','gesdoto':'\u2A82','gesdotol':'\u2A84','gesl':'\u22DB\uFE00','gesles':'\u2A94','gfr':'\uD835\uDD24','Gfr':'\uD835\uDD0A','gg':'\u226B','Gg':'\u22D9','ggg':'\u22D9','gimel':'\u2137','gjcy':'\u0453','GJcy':'\u0403','gl':'\u2277','gla':'\u2AA5','glE':'\u2A92','glj':'\u2AA4','gnap':'\u2A8A','gnapprox':'\u2A8A','gne':'\u2A88','gnE':'\u2269','gneq':'\u2A88','gneqq':'\u2269','gnsim':'\u22E7','gopf':'\uD835\uDD58','Gopf':'\uD835\uDD3E','grave':'`','GreaterEqual':'\u2265','GreaterEqualLess':'\u22DB','GreaterFullEqual':'\u2267','GreaterGreater':'\u2AA2','GreaterLess':'\u2277','GreaterSlantEqual':'\u2A7E','GreaterTilde':'\u2273','gscr':'\u210A','Gscr':'\uD835\uDCA2','gsim':'\u2273','gsime':'\u2A8E','gsiml':'\u2A90','gt':'>','Gt':'\u226B','GT':'>','gtcc':'\u2AA7','gtcir':'\u2A7A','gtdot':'\u22D7','gtlPar':'\u2995','gtquest':'\u2A7C','gtrapprox':'\u2A86','gtrarr':'\u2978','gtrdot':'\u22D7','gtreqless':'\u22DB','gtreqqless':'\u2A8C','gtrless':'\u2277','gtrsim':'\u2273','gvertneqq':'\u2269\uFE00','gvnE':'\u2269\uFE00','Hacek':'\u02C7','hairsp':'\u200A','half':'\xBD','hamilt':'\u210B','hardcy':'\u044A','HARDcy':'\u042A','harr':'\u2194','hArr':'\u21D4','harrcir':'\u2948','harrw':'\u21AD','Hat':'^','hbar':'\u210F','hcirc':'\u0125','Hcirc':'\u0124','hearts':'\u2665','heartsuit':'\u2665','hellip':'\u2026','hercon':'\u22B9','hfr':'\uD835\uDD25','Hfr':'\u210C','HilbertSpace':'\u210B','hksearow':'\u2925','hkswarow':'\u2926','hoarr':'\u21FF','homtht':'\u223B','hookleftarrow':'\u21A9','hookrightarrow':'\u21AA','hopf':'\uD835\uDD59','Hopf':'\u210D','horbar':'\u2015','HorizontalLine':'\u2500','hscr':'\uD835\uDCBD','Hscr':'\u210B','hslash':'\u210F','hstrok':'\u0127','Hstrok':'\u0126','HumpDownHump':'\u224E','HumpEqual':'\u224F','hybull':'\u2043','hyphen':'\u2010','iacute':'\xED','Iacute':'\xCD','ic':'\u2063','icirc':'\xEE','Icirc':'\xCE','icy':'\u0438','Icy':'\u0418','Idot':'\u0130','iecy':'\u0435','IEcy':'\u0415','iexcl':'\xA1','iff':'\u21D4','ifr':'\uD835\uDD26','Ifr':'\u2111','igrave':'\xEC','Igrave':'\xCC','ii':'\u2148','iiiint':'\u2A0C','iiint':'\u222D','iinfin':'\u29DC','iiota':'\u2129','ijlig':'\u0133','IJlig':'\u0132','Im':'\u2111','imacr':'\u012B','Imacr':'\u012A','image':'\u2111','ImaginaryI':'\u2148','imagline':'\u2110','imagpart':'\u2111','imath':'\u0131','imof':'\u22B7','imped':'\u01B5','Implies':'\u21D2','in':'\u2208','incare':'\u2105','infin':'\u221E','infintie':'\u29DD','inodot':'\u0131','int':'\u222B','Int':'\u222C','intcal':'\u22BA','integers':'\u2124','Integral':'\u222B','intercal':'\u22BA','Intersection':'\u22C2','intlarhk':'\u2A17','intprod':'\u2A3C','InvisibleComma':'\u2063','InvisibleTimes':'\u2062','iocy':'\u0451','IOcy':'\u0401','iogon':'\u012F','Iogon':'\u012E','iopf':'\uD835\uDD5A','Iopf':'\uD835\uDD40','iota':'\u03B9','Iota':'\u0399','iprod':'\u2A3C','iquest':'\xBF','iscr':'\uD835\uDCBE','Iscr':'\u2110','isin':'\u2208','isindot':'\u22F5','isinE':'\u22F9','isins':'\u22F4','isinsv':'\u22F3','isinv':'\u2208','it':'\u2062','itilde':'\u0129','Itilde':'\u0128','iukcy':'\u0456','Iukcy':'\u0406','iuml':'\xEF','Iuml':'\xCF','jcirc':'\u0135','Jcirc':'\u0134','jcy':'\u0439','Jcy':'\u0419','jfr':'\uD835\uDD27','Jfr':'\uD835\uDD0D','jmath':'\u0237','jopf':'\uD835\uDD5B','Jopf':'\uD835\uDD41','jscr':'\uD835\uDCBF','Jscr':'\uD835\uDCA5','jsercy':'\u0458','Jsercy':'\u0408','jukcy':'\u0454','Jukcy':'\u0404','kappa':'\u03BA','Kappa':'\u039A','kappav':'\u03F0','kcedil':'\u0137','Kcedil':'\u0136','kcy':'\u043A','Kcy':'\u041A','kfr':'\uD835\uDD28','Kfr':'\uD835\uDD0E','kgreen':'\u0138','khcy':'\u0445','KHcy':'\u0425','kjcy':'\u045C','KJcy':'\u040C','kopf':'\uD835\uDD5C','Kopf':'\uD835\uDD42','kscr':'\uD835\uDCC0','Kscr':'\uD835\uDCA6','lAarr':'\u21DA','lacute':'\u013A','Lacute':'\u0139','laemptyv':'\u29B4','lagran':'\u2112','lambda':'\u03BB','Lambda':'\u039B','lang':'\u27E8','Lang':'\u27EA','langd':'\u2991','langle':'\u27E8','lap':'\u2A85','Laplacetrf':'\u2112','laquo':'\xAB','larr':'\u2190','lArr':'\u21D0','Larr':'\u219E','larrb':'\u21E4','larrbfs':'\u291F','larrfs':'\u291D','larrhk':'\u21A9','larrlp':'\u21AB','larrpl':'\u2939','larrsim':'\u2973','larrtl':'\u21A2','lat':'\u2AAB','latail':'\u2919','lAtail':'\u291B','late':'\u2AAD','lates':'\u2AAD\uFE00','lbarr':'\u290C','lBarr':'\u290E','lbbrk':'\u2772','lbrace':'{','lbrack':'[','lbrke':'\u298B','lbrksld':'\u298F','lbrkslu':'\u298D','lcaron':'\u013E','Lcaron':'\u013D','lcedil':'\u013C','Lcedil':'\u013B','lceil':'\u2308','lcub':'{','lcy':'\u043B','Lcy':'\u041B','ldca':'\u2936','ldquo':'\u201C','ldquor':'\u201E','ldrdhar':'\u2967','ldrushar':'\u294B','ldsh':'\u21B2','le':'\u2264','lE':'\u2266','LeftAngleBracket':'\u27E8','leftarrow':'\u2190','Leftarrow':'\u21D0','LeftArrow':'\u2190','LeftArrowBar':'\u21E4','LeftArrowRightArrow':'\u21C6','leftarrowtail':'\u21A2','LeftCeiling':'\u2308','LeftDoubleBracket':'\u27E6','LeftDownTeeVector':'\u2961','LeftDownVector':'\u21C3','LeftDownVectorBar':'\u2959','LeftFloor':'\u230A','leftharpoondown':'\u21BD','leftharpoonup':'\u21BC','leftleftarrows':'\u21C7','leftrightarrow':'\u2194','Leftrightarrow':'\u21D4','LeftRightArrow':'\u2194','leftrightarrows':'\u21C6','leftrightharpoons':'\u21CB','leftrightsquigarrow':'\u21AD','LeftRightVector':'\u294E','LeftTee':'\u22A3','LeftTeeArrow':'\u21A4','LeftTeeVector':'\u295A','leftthreetimes':'\u22CB','LeftTriangle':'\u22B2','LeftTriangleBar':'\u29CF','LeftTriangleEqual':'\u22B4','LeftUpDownVector':'\u2951','LeftUpTeeVector':'\u2960','LeftUpVector':'\u21BF','LeftUpVectorBar':'\u2958','LeftVector':'\u21BC','LeftVectorBar':'\u2952','leg':'\u22DA','lEg':'\u2A8B','leq':'\u2264','leqq':'\u2266','leqslant':'\u2A7D','les':'\u2A7D','lescc':'\u2AA8','lesdot':'\u2A7F','lesdoto':'\u2A81','lesdotor':'\u2A83','lesg':'\u22DA\uFE00','lesges':'\u2A93','lessapprox':'\u2A85','lessdot':'\u22D6','lesseqgtr':'\u22DA','lesseqqgtr':'\u2A8B','LessEqualGreater':'\u22DA','LessFullEqual':'\u2266','LessGreater':'\u2276','lessgtr':'\u2276','LessLess':'\u2AA1','lesssim':'\u2272','LessSlantEqual':'\u2A7D','LessTilde':'\u2272','lfisht':'\u297C','lfloor':'\u230A','lfr':'\uD835\uDD29','Lfr':'\uD835\uDD0F','lg':'\u2276','lgE':'\u2A91','lHar':'\u2962','lhard':'\u21BD','lharu':'\u21BC','lharul':'\u296A','lhblk':'\u2584','ljcy':'\u0459','LJcy':'\u0409','ll':'\u226A','Ll':'\u22D8','llarr':'\u21C7','llcorner':'\u231E','Lleftarrow':'\u21DA','llhard':'\u296B','lltri':'\u25FA','lmidot':'\u0140','Lmidot':'\u013F','lmoust':'\u23B0','lmoustache':'\u23B0','lnap':'\u2A89','lnapprox':'\u2A89','lne':'\u2A87','lnE':'\u2268','lneq':'\u2A87','lneqq':'\u2268','lnsim':'\u22E6','loang':'\u27EC','loarr':'\u21FD','lobrk':'\u27E6','longleftarrow':'\u27F5','Longleftarrow':'\u27F8','LongLeftArrow':'\u27F5','longleftrightarrow':'\u27F7','Longleftrightarrow':'\u27FA','LongLeftRightArrow':'\u27F7','longmapsto':'\u27FC','longrightarrow':'\u27F6','Longrightarrow':'\u27F9','LongRightArrow':'\u27F6','looparrowleft':'\u21AB','looparrowright':'\u21AC','lopar':'\u2985','lopf':'\uD835\uDD5D','Lopf':'\uD835\uDD43','loplus':'\u2A2D','lotimes':'\u2A34','lowast':'\u2217','lowbar':'_','LowerLeftArrow':'\u2199','LowerRightArrow':'\u2198','loz':'\u25CA','lozenge':'\u25CA','lozf':'\u29EB','lpar':'(','lparlt':'\u2993','lrarr':'\u21C6','lrcorner':'\u231F','lrhar':'\u21CB','lrhard':'\u296D','lrm':'\u200E','lrtri':'\u22BF','lsaquo':'\u2039','lscr':'\uD835\uDCC1','Lscr':'\u2112','lsh':'\u21B0','Lsh':'\u21B0','lsim':'\u2272','lsime':'\u2A8D','lsimg':'\u2A8F','lsqb':'[','lsquo':'\u2018','lsquor':'\u201A','lstrok':'\u0142','Lstrok':'\u0141','lt':'<','Lt':'\u226A','LT':'<','ltcc':'\u2AA6','ltcir':'\u2A79','ltdot':'\u22D6','lthree':'\u22CB','ltimes':'\u22C9','ltlarr':'\u2976','ltquest':'\u2A7B','ltri':'\u25C3','ltrie':'\u22B4','ltrif':'\u25C2','ltrPar':'\u2996','lurdshar':'\u294A','luruhar':'\u2966','lvertneqq':'\u2268\uFE00','lvnE':'\u2268\uFE00','macr':'\xAF','male':'\u2642','malt':'\u2720','maltese':'\u2720','map':'\u21A6','Map':'\u2905','mapsto':'\u21A6','mapstodown':'\u21A7','mapstoleft':'\u21A4','mapstoup':'\u21A5','marker':'\u25AE','mcomma':'\u2A29','mcy':'\u043C','Mcy':'\u041C','mdash':'\u2014','mDDot':'\u223A','measuredangle':'\u2221','MediumSpace':'\u205F','Mellintrf':'\u2133','mfr':'\uD835\uDD2A','Mfr':'\uD835\uDD10','mho':'\u2127','micro':'\xB5','mid':'\u2223','midast':'*','midcir':'\u2AF0','middot':'\xB7','minus':'\u2212','minusb':'\u229F','minusd':'\u2238','minusdu':'\u2A2A','MinusPlus':'\u2213','mlcp':'\u2ADB','mldr':'\u2026','mnplus':'\u2213','models':'\u22A7','mopf':'\uD835\uDD5E','Mopf':'\uD835\uDD44','mp':'\u2213','mscr':'\uD835\uDCC2','Mscr':'\u2133','mstpos':'\u223E','mu':'\u03BC','Mu':'\u039C','multimap':'\u22B8','mumap':'\u22B8','nabla':'\u2207','nacute':'\u0144','Nacute':'\u0143','nang':'\u2220\u20D2','nap':'\u2249','napE':'\u2A70\u0338','napid':'\u224B\u0338','napos':'\u0149','napprox':'\u2249','natur':'\u266E','natural':'\u266E','naturals':'\u2115','nbsp':'\xA0','nbump':'\u224E\u0338','nbumpe':'\u224F\u0338','ncap':'\u2A43','ncaron':'\u0148','Ncaron':'\u0147','ncedil':'\u0146','Ncedil':'\u0145','ncong':'\u2247','ncongdot':'\u2A6D\u0338','ncup':'\u2A42','ncy':'\u043D','Ncy':'\u041D','ndash':'\u2013','ne':'\u2260','nearhk':'\u2924','nearr':'\u2197','neArr':'\u21D7','nearrow':'\u2197','nedot':'\u2250\u0338','NegativeMediumSpace':'\u200B','NegativeThickSpace':'\u200B','NegativeThinSpace':'\u200B','NegativeVeryThinSpace':'\u200B','nequiv':'\u2262','nesear':'\u2928','nesim':'\u2242\u0338','NestedGreaterGreater':'\u226B','NestedLessLess':'\u226A','NewLine':'\n','nexist':'\u2204','nexists':'\u2204','nfr':'\uD835\uDD2B','Nfr':'\uD835\uDD11','nge':'\u2271','ngE':'\u2267\u0338','ngeq':'\u2271','ngeqq':'\u2267\u0338','ngeqslant':'\u2A7E\u0338','nges':'\u2A7E\u0338','nGg':'\u22D9\u0338','ngsim':'\u2275','ngt':'\u226F','nGt':'\u226B\u20D2','ngtr':'\u226F','nGtv':'\u226B\u0338','nharr':'\u21AE','nhArr':'\u21CE','nhpar':'\u2AF2','ni':'\u220B','nis':'\u22FC','nisd':'\u22FA','niv':'\u220B','njcy':'\u045A','NJcy':'\u040A','nlarr':'\u219A','nlArr':'\u21CD','nldr':'\u2025','nle':'\u2270','nlE':'\u2266\u0338','nleftarrow':'\u219A','nLeftarrow':'\u21CD','nleftrightarrow':'\u21AE','nLeftrightarrow':'\u21CE','nleq':'\u2270','nleqq':'\u2266\u0338','nleqslant':'\u2A7D\u0338','nles':'\u2A7D\u0338','nless':'\u226E','nLl':'\u22D8\u0338','nlsim':'\u2274','nlt':'\u226E','nLt':'\u226A\u20D2','nltri':'\u22EA','nltrie':'\u22EC','nLtv':'\u226A\u0338','nmid':'\u2224','NoBreak':'\u2060','NonBreakingSpace':'\xA0','nopf':'\uD835\uDD5F','Nopf':'\u2115','not':'\xAC','Not':'\u2AEC','NotCongruent':'\u2262','NotCupCap':'\u226D','NotDoubleVerticalBar':'\u2226','NotElement':'\u2209','NotEqual':'\u2260','NotEqualTilde':'\u2242\u0338','NotExists':'\u2204','NotGreater':'\u226F','NotGreaterEqual':'\u2271','NotGreaterFullEqual':'\u2267\u0338','NotGreaterGreater':'\u226B\u0338','NotGreaterLess':'\u2279','NotGreaterSlantEqual':'\u2A7E\u0338','NotGreaterTilde':'\u2275','NotHumpDownHump':'\u224E\u0338','NotHumpEqual':'\u224F\u0338','notin':'\u2209','notindot':'\u22F5\u0338','notinE':'\u22F9\u0338','notinva':'\u2209','notinvb':'\u22F7','notinvc':'\u22F6','NotLeftTriangle':'\u22EA','NotLeftTriangleBar':'\u29CF\u0338','NotLeftTriangleEqual':'\u22EC','NotLess':'\u226E','NotLessEqual':'\u2270','NotLessGreater':'\u2278','NotLessLess':'\u226A\u0338','NotLessSlantEqual':'\u2A7D\u0338','NotLessTilde':'\u2274','NotNestedGreaterGreater':'\u2AA2\u0338','NotNestedLessLess':'\u2AA1\u0338','notni':'\u220C','notniva':'\u220C','notnivb':'\u22FE','notnivc':'\u22FD','NotPrecedes':'\u2280','NotPrecedesEqual':'\u2AAF\u0338','NotPrecedesSlantEqual':'\u22E0','NotReverseElement':'\u220C','NotRightTriangle':'\u22EB','NotRightTriangleBar':'\u29D0\u0338','NotRightTriangleEqual':'\u22ED','NotSquareSubset':'\u228F\u0338','NotSquareSubsetEqual':'\u22E2','NotSquareSuperset':'\u2290\u0338','NotSquareSupersetEqual':'\u22E3','NotSubset':'\u2282\u20D2','NotSubsetEqual':'\u2288','NotSucceeds':'\u2281','NotSucceedsEqual':'\u2AB0\u0338','NotSucceedsSlantEqual':'\u22E1','NotSucceedsTilde':'\u227F\u0338','NotSuperset':'\u2283\u20D2','NotSupersetEqual':'\u2289','NotTilde':'\u2241','NotTildeEqual':'\u2244','NotTildeFullEqual':'\u2247','NotTildeTilde':'\u2249','NotVerticalBar':'\u2224','npar':'\u2226','nparallel':'\u2226','nparsl':'\u2AFD\u20E5','npart':'\u2202\u0338','npolint':'\u2A14','npr':'\u2280','nprcue':'\u22E0','npre':'\u2AAF\u0338','nprec':'\u2280','npreceq':'\u2AAF\u0338','nrarr':'\u219B','nrArr':'\u21CF','nrarrc':'\u2933\u0338','nrarrw':'\u219D\u0338','nrightarrow':'\u219B','nRightarrow':'\u21CF','nrtri':'\u22EB','nrtrie':'\u22ED','nsc':'\u2281','nsccue':'\u22E1','nsce':'\u2AB0\u0338','nscr':'\uD835\uDCC3','Nscr':'\uD835\uDCA9','nshortmid':'\u2224','nshortparallel':'\u2226','nsim':'\u2241','nsime':'\u2244','nsimeq':'\u2244','nsmid':'\u2224','nspar':'\u2226','nsqsube':'\u22E2','nsqsupe':'\u22E3','nsub':'\u2284','nsube':'\u2288','nsubE':'\u2AC5\u0338','nsubset':'\u2282\u20D2','nsubseteq':'\u2288','nsubseteqq':'\u2AC5\u0338','nsucc':'\u2281','nsucceq':'\u2AB0\u0338','nsup':'\u2285','nsupe':'\u2289','nsupE':'\u2AC6\u0338','nsupset':'\u2283\u20D2','nsupseteq':'\u2289','nsupseteqq':'\u2AC6\u0338','ntgl':'\u2279','ntilde':'\xF1','Ntilde':'\xD1','ntlg':'\u2278','ntriangleleft':'\u22EA','ntrianglelefteq':'\u22EC','ntriangleright':'\u22EB','ntrianglerighteq':'\u22ED','nu':'\u03BD','Nu':'\u039D','num':'#','numero':'\u2116','numsp':'\u2007','nvap':'\u224D\u20D2','nvdash':'\u22AC','nvDash':'\u22AD','nVdash':'\u22AE','nVDash':'\u22AF','nvge':'\u2265\u20D2','nvgt':'>\u20D2','nvHarr':'\u2904','nvinfin':'\u29DE','nvlArr':'\u2902','nvle':'\u2264\u20D2','nvlt':'<\u20D2','nvltrie':'\u22B4\u20D2','nvrArr':'\u2903','nvrtrie':'\u22B5\u20D2','nvsim':'\u223C\u20D2','nwarhk':'\u2923','nwarr':'\u2196','nwArr':'\u21D6','nwarrow':'\u2196','nwnear':'\u2927','oacute':'\xF3','Oacute':'\xD3','oast':'\u229B','ocir':'\u229A','ocirc':'\xF4','Ocirc':'\xD4','ocy':'\u043E','Ocy':'\u041E','odash':'\u229D','odblac':'\u0151','Odblac':'\u0150','odiv':'\u2A38','odot':'\u2299','odsold':'\u29BC','oelig':'\u0153','OElig':'\u0152','ofcir':'\u29BF','ofr':'\uD835\uDD2C','Ofr':'\uD835\uDD12','ogon':'\u02DB','ograve':'\xF2','Ograve':'\xD2','ogt':'\u29C1','ohbar':'\u29B5','ohm':'\u03A9','oint':'\u222E','olarr':'\u21BA','olcir':'\u29BE','olcross':'\u29BB','oline':'\u203E','olt':'\u29C0','omacr':'\u014D','Omacr':'\u014C','omega':'\u03C9','Omega':'\u03A9','omicron':'\u03BF','Omicron':'\u039F','omid':'\u29B6','ominus':'\u2296','oopf':'\uD835\uDD60','Oopf':'\uD835\uDD46','opar':'\u29B7','OpenCurlyDoubleQuote':'\u201C','OpenCurlyQuote':'\u2018','operp':'\u29B9','oplus':'\u2295','or':'\u2228','Or':'\u2A54','orarr':'\u21BB','ord':'\u2A5D','order':'\u2134','orderof':'\u2134','ordf':'\xAA','ordm':'\xBA','origof':'\u22B6','oror':'\u2A56','orslope':'\u2A57','orv':'\u2A5B','oS':'\u24C8','oscr':'\u2134','Oscr':'\uD835\uDCAA','oslash':'\xF8','Oslash':'\xD8','osol':'\u2298','otilde':'\xF5','Otilde':'\xD5','otimes':'\u2297','Otimes':'\u2A37','otimesas':'\u2A36','ouml':'\xF6','Ouml':'\xD6','ovbar':'\u233D','OverBar':'\u203E','OverBrace':'\u23DE','OverBracket':'\u23B4','OverParenthesis':'\u23DC','par':'\u2225','para':'\xB6','parallel':'\u2225','parsim':'\u2AF3','parsl':'\u2AFD','part':'\u2202','PartialD':'\u2202','pcy':'\u043F','Pcy':'\u041F','percnt':'%','period':'.','permil':'\u2030','perp':'\u22A5','pertenk':'\u2031','pfr':'\uD835\uDD2D','Pfr':'\uD835\uDD13','phi':'\u03C6','Phi':'\u03A6','phiv':'\u03D5','phmmat':'\u2133','phone':'\u260E','pi':'\u03C0','Pi':'\u03A0','pitchfork':'\u22D4','piv':'\u03D6','planck':'\u210F','planckh':'\u210E','plankv':'\u210F','plus':'+','plusacir':'\u2A23','plusb':'\u229E','pluscir':'\u2A22','plusdo':'\u2214','plusdu':'\u2A25','pluse':'\u2A72','PlusMinus':'\xB1','plusmn':'\xB1','plussim':'\u2A26','plustwo':'\u2A27','pm':'\xB1','Poincareplane':'\u210C','pointint':'\u2A15','popf':'\uD835\uDD61','Popf':'\u2119','pound':'\xA3','pr':'\u227A','Pr':'\u2ABB','prap':'\u2AB7','prcue':'\u227C','pre':'\u2AAF','prE':'\u2AB3','prec':'\u227A','precapprox':'\u2AB7','preccurlyeq':'\u227C','Precedes':'\u227A','PrecedesEqual':'\u2AAF','PrecedesSlantEqual':'\u227C','PrecedesTilde':'\u227E','preceq':'\u2AAF','precnapprox':'\u2AB9','precneqq':'\u2AB5','precnsim':'\u22E8','precsim':'\u227E','prime':'\u2032','Prime':'\u2033','primes':'\u2119','prnap':'\u2AB9','prnE':'\u2AB5','prnsim':'\u22E8','prod':'\u220F','Product':'\u220F','profalar':'\u232E','profline':'\u2312','profsurf':'\u2313','prop':'\u221D','Proportion':'\u2237','Proportional':'\u221D','propto':'\u221D','prsim':'\u227E','prurel':'\u22B0','pscr':'\uD835\uDCC5','Pscr':'\uD835\uDCAB','psi':'\u03C8','Psi':'\u03A8','puncsp':'\u2008','qfr':'\uD835\uDD2E','Qfr':'\uD835\uDD14','qint':'\u2A0C','qopf':'\uD835\uDD62','Qopf':'\u211A','qprime':'\u2057','qscr':'\uD835\uDCC6','Qscr':'\uD835\uDCAC','quaternions':'\u210D','quatint':'\u2A16','quest':'?','questeq':'\u225F','quot':'"','QUOT':'"','rAarr':'\u21DB','race':'\u223D\u0331','racute':'\u0155','Racute':'\u0154','radic':'\u221A','raemptyv':'\u29B3','rang':'\u27E9','Rang':'\u27EB','rangd':'\u2992','range':'\u29A5','rangle':'\u27E9','raquo':'\xBB','rarr':'\u2192','rArr':'\u21D2','Rarr':'\u21A0','rarrap':'\u2975','rarrb':'\u21E5','rarrbfs':'\u2920','rarrc':'\u2933','rarrfs':'\u291E','rarrhk':'\u21AA','rarrlp':'\u21AC','rarrpl':'\u2945','rarrsim':'\u2974','rarrtl':'\u21A3','Rarrtl':'\u2916','rarrw':'\u219D','ratail':'\u291A','rAtail':'\u291C','ratio':'\u2236','rationals':'\u211A','rbarr':'\u290D','rBarr':'\u290F','RBarr':'\u2910','rbbrk':'\u2773','rbrace':'}','rbrack':']','rbrke':'\u298C','rbrksld':'\u298E','rbrkslu':'\u2990','rcaron':'\u0159','Rcaron':'\u0158','rcedil':'\u0157','Rcedil':'\u0156','rceil':'\u2309','rcub':'}','rcy':'\u0440','Rcy':'\u0420','rdca':'\u2937','rdldhar':'\u2969','rdquo':'\u201D','rdquor':'\u201D','rdsh':'\u21B3','Re':'\u211C','real':'\u211C','realine':'\u211B','realpart':'\u211C','reals':'\u211D','rect':'\u25AD','reg':'\xAE','REG':'\xAE','ReverseElement':'\u220B','ReverseEquilibrium':'\u21CB','ReverseUpEquilibrium':'\u296F','rfisht':'\u297D','rfloor':'\u230B','rfr':'\uD835\uDD2F','Rfr':'\u211C','rHar':'\u2964','rhard':'\u21C1','rharu':'\u21C0','rharul':'\u296C','rho':'\u03C1','Rho':'\u03A1','rhov':'\u03F1','RightAngleBracket':'\u27E9','rightarrow':'\u2192','Rightarrow':'\u21D2','RightArrow':'\u2192','RightArrowBar':'\u21E5','RightArrowLeftArrow':'\u21C4','rightarrowtail':'\u21A3','RightCeiling':'\u2309','RightDoubleBracket':'\u27E7','RightDownTeeVector':'\u295D','RightDownVector':'\u21C2','RightDownVectorBar':'\u2955','RightFloor':'\u230B','rightharpoondown':'\u21C1','rightharpoonup':'\u21C0','rightleftarrows':'\u21C4','rightleftharpoons':'\u21CC','rightrightarrows':'\u21C9','rightsquigarrow':'\u219D','RightTee':'\u22A2','RightTeeArrow':'\u21A6','RightTeeVector':'\u295B','rightthreetimes':'\u22CC','RightTriangle':'\u22B3','RightTriangleBar':'\u29D0','RightTriangleEqual':'\u22B5','RightUpDownVector':'\u294F','RightUpTeeVector':'\u295C','RightUpVector':'\u21BE','RightUpVectorBar':'\u2954','RightVector':'\u21C0','RightVectorBar':'\u2953','ring':'\u02DA','risingdotseq':'\u2253','rlarr':'\u21C4','rlhar':'\u21CC','rlm':'\u200F','rmoust':'\u23B1','rmoustache':'\u23B1','rnmid':'\u2AEE','roang':'\u27ED','roarr':'\u21FE','robrk':'\u27E7','ropar':'\u2986','ropf':'\uD835\uDD63','Ropf':'\u211D','roplus':'\u2A2E','rotimes':'\u2A35','RoundImplies':'\u2970','rpar':')','rpargt':'\u2994','rppolint':'\u2A12','rrarr':'\u21C9','Rrightarrow':'\u21DB','rsaquo':'\u203A','rscr':'\uD835\uDCC7','Rscr':'\u211B','rsh':'\u21B1','Rsh':'\u21B1','rsqb':']','rsquo':'\u2019','rsquor':'\u2019','rthree':'\u22CC','rtimes':'\u22CA','rtri':'\u25B9','rtrie':'\u22B5','rtrif':'\u25B8','rtriltri':'\u29CE','RuleDelayed':'\u29F4','ruluhar':'\u2968','rx':'\u211E','sacute':'\u015B','Sacute':'\u015A','sbquo':'\u201A','sc':'\u227B','Sc':'\u2ABC','scap':'\u2AB8','scaron':'\u0161','Scaron':'\u0160','sccue':'\u227D','sce':'\u2AB0','scE':'\u2AB4','scedil':'\u015F','Scedil':'\u015E','scirc':'\u015D','Scirc':'\u015C','scnap':'\u2ABA','scnE':'\u2AB6','scnsim':'\u22E9','scpolint':'\u2A13','scsim':'\u227F','scy':'\u0441','Scy':'\u0421','sdot':'\u22C5','sdotb':'\u22A1','sdote':'\u2A66','searhk':'\u2925','searr':'\u2198','seArr':'\u21D8','searrow':'\u2198','sect':'\xA7','semi':';','seswar':'\u2929','setminus':'\u2216','setmn':'\u2216','sext':'\u2736','sfr':'\uD835\uDD30','Sfr':'\uD835\uDD16','sfrown':'\u2322','sharp':'\u266F','shchcy':'\u0449','SHCHcy':'\u0429','shcy':'\u0448','SHcy':'\u0428','ShortDownArrow':'\u2193','ShortLeftArrow':'\u2190','shortmid':'\u2223','shortparallel':'\u2225','ShortRightArrow':'\u2192','ShortUpArrow':'\u2191','shy':'\xAD','sigma':'\u03C3','Sigma':'\u03A3','sigmaf':'\u03C2','sigmav':'\u03C2','sim':'\u223C','simdot':'\u2A6A','sime':'\u2243','simeq':'\u2243','simg':'\u2A9E','simgE':'\u2AA0','siml':'\u2A9D','simlE':'\u2A9F','simne':'\u2246','simplus':'\u2A24','simrarr':'\u2972','slarr':'\u2190','SmallCircle':'\u2218','smallsetminus':'\u2216','smashp':'\u2A33','smeparsl':'\u29E4','smid':'\u2223','smile':'\u2323','smt':'\u2AAA','smte':'\u2AAC','smtes':'\u2AAC\uFE00','softcy':'\u044C','SOFTcy':'\u042C','sol':'/','solb':'\u29C4','solbar':'\u233F','sopf':'\uD835\uDD64','Sopf':'\uD835\uDD4A','spades':'\u2660','spadesuit':'\u2660','spar':'\u2225','sqcap':'\u2293','sqcaps':'\u2293\uFE00','sqcup':'\u2294','sqcups':'\u2294\uFE00','Sqrt':'\u221A','sqsub':'\u228F','sqsube':'\u2291','sqsubset':'\u228F','sqsubseteq':'\u2291','sqsup':'\u2290','sqsupe':'\u2292','sqsupset':'\u2290','sqsupseteq':'\u2292','squ':'\u25A1','square':'\u25A1','Square':'\u25A1','SquareIntersection':'\u2293','SquareSubset':'\u228F','SquareSubsetEqual':'\u2291','SquareSuperset':'\u2290','SquareSupersetEqual':'\u2292','SquareUnion':'\u2294','squarf':'\u25AA','squf':'\u25AA','srarr':'\u2192','sscr':'\uD835\uDCC8','Sscr':'\uD835\uDCAE','ssetmn':'\u2216','ssmile':'\u2323','sstarf':'\u22C6','star':'\u2606','Star':'\u22C6','starf':'\u2605','straightepsilon':'\u03F5','straightphi':'\u03D5','strns':'\xAF','sub':'\u2282','Sub':'\u22D0','subdot':'\u2ABD','sube':'\u2286','subE':'\u2AC5','subedot':'\u2AC3','submult':'\u2AC1','subne':'\u228A','subnE':'\u2ACB','subplus':'\u2ABF','subrarr':'\u2979','subset':'\u2282','Subset':'\u22D0','subseteq':'\u2286','subseteqq':'\u2AC5','SubsetEqual':'\u2286','subsetneq':'\u228A','subsetneqq':'\u2ACB','subsim':'\u2AC7','subsub':'\u2AD5','subsup':'\u2AD3','succ':'\u227B','succapprox':'\u2AB8','succcurlyeq':'\u227D','Succeeds':'\u227B','SucceedsEqual':'\u2AB0','SucceedsSlantEqual':'\u227D','SucceedsTilde':'\u227F','succeq':'\u2AB0','succnapprox':'\u2ABA','succneqq':'\u2AB6','succnsim':'\u22E9','succsim':'\u227F','SuchThat':'\u220B','sum':'\u2211','Sum':'\u2211','sung':'\u266A','sup':'\u2283','Sup':'\u22D1','sup1':'\xB9','sup2':'\xB2','sup3':'\xB3','supdot':'\u2ABE','supdsub':'\u2AD8','supe':'\u2287','supE':'\u2AC6','supedot':'\u2AC4','Superset':'\u2283','SupersetEqual':'\u2287','suphsol':'\u27C9','suphsub':'\u2AD7','suplarr':'\u297B','supmult':'\u2AC2','supne':'\u228B','supnE':'\u2ACC','supplus':'\u2AC0','supset':'\u2283','Supset':'\u22D1','supseteq':'\u2287','supseteqq':'\u2AC6','supsetneq':'\u228B','supsetneqq':'\u2ACC','supsim':'\u2AC8','supsub':'\u2AD4','supsup':'\u2AD6','swarhk':'\u2926','swarr':'\u2199','swArr':'\u21D9','swarrow':'\u2199','swnwar':'\u292A','szlig':'\xDF','Tab':'\t','target':'\u2316','tau':'\u03C4','Tau':'\u03A4','tbrk':'\u23B4','tcaron':'\u0165','Tcaron':'\u0164','tcedil':'\u0163','Tcedil':'\u0162','tcy':'\u0442','Tcy':'\u0422','tdot':'\u20DB','telrec':'\u2315','tfr':'\uD835\uDD31','Tfr':'\uD835\uDD17','there4':'\u2234','therefore':'\u2234','Therefore':'\u2234','theta':'\u03B8','Theta':'\u0398','thetasym':'\u03D1','thetav':'\u03D1','thickapprox':'\u2248','thicksim':'\u223C','ThickSpace':'\u205F\u200A','thinsp':'\u2009','ThinSpace':'\u2009','thkap':'\u2248','thksim':'\u223C','thorn':'\xFE','THORN':'\xDE','tilde':'\u02DC','Tilde':'\u223C','TildeEqual':'\u2243','TildeFullEqual':'\u2245','TildeTilde':'\u2248','times':'\xD7','timesb':'\u22A0','timesbar':'\u2A31','timesd':'\u2A30','tint':'\u222D','toea':'\u2928','top':'\u22A4','topbot':'\u2336','topcir':'\u2AF1','topf':'\uD835\uDD65','Topf':'\uD835\uDD4B','topfork':'\u2ADA','tosa':'\u2929','tprime':'\u2034','trade':'\u2122','TRADE':'\u2122','triangle':'\u25B5','triangledown':'\u25BF','triangleleft':'\u25C3','trianglelefteq':'\u22B4','triangleq':'\u225C','triangleright':'\u25B9','trianglerighteq':'\u22B5','tridot':'\u25EC','trie':'\u225C','triminus':'\u2A3A','TripleDot':'\u20DB','triplus':'\u2A39','trisb':'\u29CD','tritime':'\u2A3B','trpezium':'\u23E2','tscr':'\uD835\uDCC9','Tscr':'\uD835\uDCAF','tscy':'\u0446','TScy':'\u0426','tshcy':'\u045B','TSHcy':'\u040B','tstrok':'\u0167','Tstrok':'\u0166','twixt':'\u226C','twoheadleftarrow':'\u219E','twoheadrightarrow':'\u21A0','uacute':'\xFA','Uacute':'\xDA','uarr':'\u2191','uArr':'\u21D1','Uarr':'\u219F','Uarrocir':'\u2949','ubrcy':'\u045E','Ubrcy':'\u040E','ubreve':'\u016D','Ubreve':'\u016C','ucirc':'\xFB','Ucirc':'\xDB','ucy':'\u0443','Ucy':'\u0423','udarr':'\u21C5','udblac':'\u0171','Udblac':'\u0170','udhar':'\u296E','ufisht':'\u297E','ufr':'\uD835\uDD32','Ufr':'\uD835\uDD18','ugrave':'\xF9','Ugrave':'\xD9','uHar':'\u2963','uharl':'\u21BF','uharr':'\u21BE','uhblk':'\u2580','ulcorn':'\u231C','ulcorner':'\u231C','ulcrop':'\u230F','ultri':'\u25F8','umacr':'\u016B','Umacr':'\u016A','uml':'\xA8','UnderBar':'_','UnderBrace':'\u23DF','UnderBracket':'\u23B5','UnderParenthesis':'\u23DD','Union':'\u22C3','UnionPlus':'\u228E','uogon':'\u0173','Uogon':'\u0172','uopf':'\uD835\uDD66','Uopf':'\uD835\uDD4C','uparrow':'\u2191','Uparrow':'\u21D1','UpArrow':'\u2191','UpArrowBar':'\u2912','UpArrowDownArrow':'\u21C5','updownarrow':'\u2195','Updownarrow':'\u21D5','UpDownArrow':'\u2195','UpEquilibrium':'\u296E','upharpoonleft':'\u21BF','upharpoonright':'\u21BE','uplus':'\u228E','UpperLeftArrow':'\u2196','UpperRightArrow':'\u2197','upsi':'\u03C5','Upsi':'\u03D2','upsih':'\u03D2','upsilon':'\u03C5','Upsilon':'\u03A5','UpTee':'\u22A5','UpTeeArrow':'\u21A5','upuparrows':'\u21C8','urcorn':'\u231D','urcorner':'\u231D','urcrop':'\u230E','uring':'\u016F','Uring':'\u016E','urtri':'\u25F9','uscr':'\uD835\uDCCA','Uscr':'\uD835\uDCB0','utdot':'\u22F0','utilde':'\u0169','Utilde':'\u0168','utri':'\u25B5','utrif':'\u25B4','uuarr':'\u21C8','uuml':'\xFC','Uuml':'\xDC','uwangle':'\u29A7','vangrt':'\u299C','varepsilon':'\u03F5','varkappa':'\u03F0','varnothing':'\u2205','varphi':'\u03D5','varpi':'\u03D6','varpropto':'\u221D','varr':'\u2195','vArr':'\u21D5','varrho':'\u03F1','varsigma':'\u03C2','varsubsetneq':'\u228A\uFE00','varsubsetneqq':'\u2ACB\uFE00','varsupsetneq':'\u228B\uFE00','varsupsetneqq':'\u2ACC\uFE00','vartheta':'\u03D1','vartriangleleft':'\u22B2','vartriangleright':'\u22B3','vBar':'\u2AE8','Vbar':'\u2AEB','vBarv':'\u2AE9','vcy':'\u0432','Vcy':'\u0412','vdash':'\u22A2','vDash':'\u22A8','Vdash':'\u22A9','VDash':'\u22AB','Vdashl':'\u2AE6','vee':'\u2228','Vee':'\u22C1','veebar':'\u22BB','veeeq':'\u225A','vellip':'\u22EE','verbar':'|','Verbar':'\u2016','vert':'|','Vert':'\u2016','VerticalBar':'\u2223','VerticalLine':'|','VerticalSeparator':'\u2758','VerticalTilde':'\u2240','VeryThinSpace':'\u200A','vfr':'\uD835\uDD33','Vfr':'\uD835\uDD19','vltri':'\u22B2','vnsub':'\u2282\u20D2','vnsup':'\u2283\u20D2','vopf':'\uD835\uDD67','Vopf':'\uD835\uDD4D','vprop':'\u221D','vrtri':'\u22B3','vscr':'\uD835\uDCCB','Vscr':'\uD835\uDCB1','vsubne':'\u228A\uFE00','vsubnE':'\u2ACB\uFE00','vsupne':'\u228B\uFE00','vsupnE':'\u2ACC\uFE00','Vvdash':'\u22AA','vzigzag':'\u299A','wcirc':'\u0175','Wcirc':'\u0174','wedbar':'\u2A5F','wedge':'\u2227','Wedge':'\u22C0','wedgeq':'\u2259','weierp':'\u2118','wfr':'\uD835\uDD34','Wfr':'\uD835\uDD1A','wopf':'\uD835\uDD68','Wopf':'\uD835\uDD4E','wp':'\u2118','wr':'\u2240','wreath':'\u2240','wscr':'\uD835\uDCCC','Wscr':'\uD835\uDCB2','xcap':'\u22C2','xcirc':'\u25EF','xcup':'\u22C3','xdtri':'\u25BD','xfr':'\uD835\uDD35','Xfr':'\uD835\uDD1B','xharr':'\u27F7','xhArr':'\u27FA','xi':'\u03BE','Xi':'\u039E','xlarr':'\u27F5','xlArr':'\u27F8','xmap':'\u27FC','xnis':'\u22FB','xodot':'\u2A00','xopf':'\uD835\uDD69','Xopf':'\uD835\uDD4F','xoplus':'\u2A01','xotime':'\u2A02','xrarr':'\u27F6','xrArr':'\u27F9','xscr':'\uD835\uDCCD','Xscr':'\uD835\uDCB3','xsqcup':'\u2A06','xuplus':'\u2A04','xutri':'\u25B3','xvee':'\u22C1','xwedge':'\u22C0','yacute':'\xFD','Yacute':'\xDD','yacy':'\u044F','YAcy':'\u042F','ycirc':'\u0177','Ycirc':'\u0176','ycy':'\u044B','Ycy':'\u042B','yen':'\xA5','yfr':'\uD835\uDD36','Yfr':'\uD835\uDD1C','yicy':'\u0457','YIcy':'\u0407','yopf':'\uD835\uDD6A','Yopf':'\uD835\uDD50','yscr':'\uD835\uDCCE','Yscr':'\uD835\uDCB4','yucy':'\u044E','YUcy':'\u042E','yuml':'\xFF','Yuml':'\u0178','zacute':'\u017A','Zacute':'\u0179','zcaron':'\u017E','Zcaron':'\u017D','zcy':'\u0437','Zcy':'\u0417','zdot':'\u017C','Zdot':'\u017B','zeetrf':'\u2128','ZeroWidthSpace':'\u200B','zeta':'\u03B6','Zeta':'\u0396','zfr':'\uD835\uDD37','Zfr':'\u2128','zhcy':'\u0436','ZHcy':'\u0416','zigrarr':'\u21DD','zopf':'\uD835\uDD6B','Zopf':'\u2124','zscr':'\uD835\uDCCF','Zscr':'\uD835\uDCB5','zwj':'\u200D','zwnj':'\u200C'};

let codePointToSymbol = function(codePoint,flag) {
    return String.fromCodePoint(flag ? codePoint : "0x" + codePoint);
    
}
const createMapFor = function (array) {
    return array.reduce(function (acc, item) {
      acc[item] = true;
      return acc;
    }, {});
  }
let withoutSemicolonAcceptedString = createMapFor(['amp', 'lt', 'gt', 'quot']);
let convertSemicolonAcceptedString = createMapFor(['not','sup1','cent','pound','curren','yen','brvbar','sect','uml','copy','ordf','laquo','shy','reg','macr','deg','plusmn','sup2','sup3','acute','micro','para','middot','cedil','ordm','raquo','frac14','frac12','frac34','iquest','Agrave','Aacute','Acirc','Atilde','Auml','Aring','AElig','Ccedil','Egrave','Eacute','Ecirc','Euml','Igrave','Iacute','Icirc','Iuml','ETH','Ntilde','Ograve','Oacute','Ocirc','Otilde','Ouml','times','Oslash','Ugrave','Uacute','Ucirc','Uuml','Yacute','THORN','szlig','agrave','aacute','acirc','atilde','auml','aring','ccedil','aelig','egrave','eacute','ecirc','euml','igrave','iacute','icirc','iuml','eth','ntilde','ograve','oacute','ocirc','otilde','ouml','divide','oslash','ugrave','uacute','ucirc','uuml','yacute','thorn','yuml']);

let decode = function (str,fromTextNode = false) {
	return str.replace(regexDecode, function(normalText, match1, matchWithoutSemiColon, $3, match2, semiColon1, match3, semiColon2) {
		if (match1) {
			return decodeMap[match1];
		}
		if ((match2) || (match3)) {
			return codePointToSymbol(match2 ? match2 : match3, match2 ? true : false);
		}
		if(!fromTextNode && matchWithoutSemiColon && $3.length==0 && withoutSemicolonAcceptedString[matchWithoutSemiColon]){
			return '&'+matchWithoutSemiColon+';';
		}
		
		if(fromTextNode && matchWithoutSemiColon && withoutSemicolonAcceptedString[matchWithoutSemiColon]){
			return '&'+matchWithoutSemiColon+';'+$3;
		}
		if(fromTextNode && matchWithoutSemiColon && convertSemicolonAcceptedString[matchWithoutSemiColon]){

			return decodeMap[matchWithoutSemiColon]+$3;
		}
			return normalText;
		});
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({decode:decode});
// console.time("sample")
// console.log(decode('welcome-comp'))
// console.timeEnd("sample")

/***/ }),

/***/ "./src/htmlToJsObjectLyteRendered.js":
/*!*******************************************!*\
  !*** ./src/htmlToJsObjectLyteRendered.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   htmlToJsObjectLyteRendered: () => (/* binding */ htmlToJsObjectLyteRendered)
/* harmony export */ });
/* harmony import */ var _lib_htmlParser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/htmlParser.js */ "./lib/htmlParser.js");
/* harmony import */ var _nodeStructClass_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nodeStructClass.js */ "./src/nodeStructClass.js");
/* harmony import */ var _HandleMustache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HandleMustache */ "./src/HandleMustache.js");
/* harmony import */ var _decodeHtmlEntities_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./decodeHtmlEntities.js */ "./src/decodeHtmlEntities.js");
//ignorei18n_start

/*
pageBuilder :  data,callbacks,preventSpaceText
*/





const createMapFor = function (array) {
  return array.reduce(function (acc, item) {
    acc[item] = true;
    return acc;
  }, {});
}

let observedAttributes = {}
let tagsTable = {
  "table": ["tbody", "thead", "tfoot", "colgroup", "template"],
  "tbody": ["tr", "template"],
  "tr": ["td", "th", "template"],
  "thead": ["tr", "template"],
  "tfoot": ["tr", "template"],
  "colgroup": ["col", "template"]
}
let tagLevel = {
  "td": 0,
  "th": 0,
  "tr": 1,
  "tbody": 2,
  "thead": 2,
  "tfoot": 2,
  "colgroup": 2
}
let tableTags = ["tbody", "thead", "tfoot", "colgroup", "caption"]
let allTableTags = createMapFor(tableTags.concat([ "tr", "th", "td", "col", "table", "template"]))
tableTags = createMapFor(tableTags);
let removedTableTags = ["body"]
let ls = []
let styleTagStarted = false;
let selfClosingTags = createMapFor(["path", "title", "animateTransform", "set", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "animate", "animateColor", "use", "stop", "track", 'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr', 'line', 'rect', 'polyline', 'polygon', 'circle', 'ellipse']);

function removeUnwantedTags(obj) {
  if (!obj || obj.tag == "td" || obj.tag == "th") {
    return
  };
  if (obj.tag != "input" && obj.parent.tag && obj.tag && tagsTable[obj.parent.tag] && tagsTable[obj.parent.tag].indexOf(obj.tag) == -1) {
    if(allTableTags[obj.parent.tag.toLowerCase()] && allTableTags[obj.tag.toLowerCase()] && tagLevel[obj.parent.tag.toLowerCase()] <= tagLevel[obj.tag.toLowerCase()]){
      throw new Error("Invalid tag " + obj.tagName + " inside " + obj.parent.tagName);
    }
    ls.push(obj);
    obj.remove();
  }
  if (obj.tag == "input" && obj.attr.type != "hidden") {
    ls.push(obj);
    obj.remove();
  }
  if(obj.child){
    for (let i of obj.children) {
      removeUnwantedTags(i);
    }
  }
}

function processTable(obj, tag, check) {
  let samp = obj.querySelectorAll(tag, true);
  for (let node of samp) {
    let child = node.child[0]
    let flag = false;
    while (child) {
      if (removedTableTags.indexOf(child.tag) != -1) {
        flag = true;
        let index = node.child.indexOf(child);
        // let temp = [...node.child.slice(0, index), ...child.child, ...node.child.slice(index + 1)]
        let temp = ((node.child.slice(0, index)).concat(child.child)).concat(node.child.slice(index + 1));

        node.child = []
        for (let childToPush of temp) {
          node.appendChild(childToPush);
        }
        child = node.child[index];
        continue;
      }
      child = child.next
    }
    if (flag) {
      child = node.child[0];
      while (child) {
        if (child.next && child.node == "#text" && child.next.node == "#text") {
          child.text = child.text + child.next.text;
          child.next.remove();
        }
        child = child.next
      }
    }
    child = node.child[0]
    if (child && child.node != "element") {
      child = child.nextElementSibling;
    }
    let ptr = child;
    let checkerTemplateAsFirstNode = true;
    let targObj = new _nodeStructClass_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
      tag: check,
      node: "element"
    })
    while (child) {

      if ((check == "tr") && child.tag == "template") {
        child = child.nextElementSibling;
        ptr = child
        continue;
      }
      if (checkerTemplateAsFirstNode && child.tag == "template") {
        child = child.nextElementSibling;
        ptr = child
        continue;
      }
      checkerTemplateAsFirstNode = false;
      if (allTableTags[child.tag] && !tableTags[child.tag] && ((child.tag != check && child.tag != "col") || (flag && child.tag == "col"))) {
        let temp = new _nodeStructClass_js__WEBPACK_IMPORTED_MODULE_1__["default"](child);
        if (temp.child) {
          for (let i of temp.child) {
            i.parent = temp;
          }
        }
        targObj.appendChild(temp);

      } else if (child.node != "#text") {
        if (targObj.child && ptr) {
          ptr.replaceWith(targObj);
          targObj = new _nodeStructClass_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
            tag: check,
            node: "element"
          })
        }
        while (child) {
          child = child.nextElementSibling;
          if (child && child.tag != check && child.tag !="template") {
            break;
          }
        }
        ptr = child;
        if (!child) {
          break;
        } else {
          continue;
        }
      } else if (child.node == "#text") {

        let temp = new _nodeStructClass_js__WEBPACK_IMPORTED_MODULE_1__["default"](child);
        if (temp.child) {
          for (let i of temp.child) {
            i.parent = temp;
          }
        }
        targObj.appendChild(temp);
      }
      let temp = child.next;
      if (child != ptr) {
        child.remove();
      }
      child = temp;
    }
    if (targObj.child && ptr) {
      ptr.replaceWith(targObj);
    }
  };
  if (check === "tbody") {
    let checkParent = obj.querySelectorAll(check, true);
    for (let tbody of checkParent) {
      let tbodyParent = tbody.parent;
      if (tbodyParent.tag != "table" && tbodyParent.tag != "template") {
        if (tbody.parent.parent) {
          let index = tbody.parent.parent.child.indexOf(tbody.parent);
          let child = tbody.parent.parent.child
          let temp = []
          let tbodyNext = null;
          tbodyParent.child.splice(tbodyParent.child.indexOf(tbody), 1);
          // ;
          if (tbody.next && tbody.next.node == "#text") {
            tbodyNext = tbody.next;
            tbodyParent.child.splice(tbodyParent.child.indexOf(tbody.next), 1);
          }
          for (let i = 0; i < child.length; i++) {
            if (i == index + 1) {
              temp.push(tbody);
              if (tbodyNext) {
                temp.push(tbodyNext)
              };
              temp.push(child[i]);
            } else {
              temp.push(child[i]);
            }
          }
          tbody.parent.parent.child = []
          let parent = tbody.parent.parent
          for (let i = 0; i < temp.length; i++) {
            parent.appendChild(temp[i]);
          }

        }
      }
    }
  }
}

function processUnwantedTags(obj) {
  let samp = obj.querySelectorAll("table", true);
  for (let node of samp) {
    ls = []
    removeUnwantedTags(node);
    let temp = [];
    let index = node.parent.child.indexOf(node);
    // temp = [...node.parent.child.slice(0, index), ...ls, ...node.parent.child.slice(index, node.parent.child.length)];
    temp = (node.parent.child.slice(0, index)).concat(ls).concat(node.parent.child.slice(index, node.parent.child.length));

    node.parent.child = [];
    for (let i of temp) {
      node.parent.appendChild(i);
    }
    // 
  }
}

function processTableTag(obj) {
  processTable(obj, "table", "tbody")
  processTable(obj, "thead", "tr");
  processTable(obj, "tbody", "tr")
  processTable(obj, "table", "colgroup", true)
  processUnwantedTags(obj);

}

function processSelect(obj) {
  let check = {
    "opt": function (obj) {
      if (!obj || !obj.child || !obj.child.length) {
        return;
      }
      let child = (obj.child[0].node == "#text") ? obj.child[0].nextElementSibling : obj.child[0];
      let ptr = undefined;
      let text = ""
      while (child) {
        if (child.tag != "template" && child.node != "#text") {
          let response = this.other(child);
          if (child.node != "#text" && !ptr && child.tag != "template" && typeof response != "object") {
            ptr = child;
          }
          if (typeof response == "object") {
            child.replaceWith(new _nodeStructClass_js__WEBPACK_IMPORTED_MODULE_1__["default"](response))
            if (ptr) {
              let index = ptr.parent.child.indexOf(ptr);
              ptr.replaceWith(new _nodeStructClass_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
                node: "#text",
                text: text
              }));
              this.text(ptr.parent.child[index]);
            }
            ptr = undefined;
            text = ""
          } else {
            text += (" " + response.trim() + " ");
            if (child != ptr) {
              child.remove();
            }
          }
        } else if (child.tag == "template") {
          if (ptr) {
            let index = ptr.parent.child.indexOf(ptr);
            ptr.replaceWith(new _nodeStructClass_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
              node: "#text",
              text: text
            }));
            this.text(ptr.parent.child[index]);
          }
          ptr = undefined;
          text = ""
        } else if (child.node == "#text" && child.text.trim().length > 0) {
          let index = child.parent.child.indexOf(child);
          this.text(child.parent.child[index]);
        }
        child = child.next;
      }
      if (ptr && text.trim().length > 0) {
        let index = ptr.parent.child.indexOf(ptr);
        ptr.replaceWith(new _nodeStructClass_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
          node: "#text",
          text: text
        }));
        this.text(ptr.parent.child[index]);
      }
    },
    "text": function (obj) {
      let child = obj.prev;
      let prevText = "";
      while (child) {
        if (child.node != "#text") {
          break;
        }
        prevText = " " + child.text.trim() + prevText + " ";
        let temp = child;
        child.remove();
        child = temp.prev;
      }
      child = obj.next;
      let nextText = "";
      while (child) {
        if (child.node != "#text") {
          break;
        }
        nextText = " " + nextText + child.text.trim() + " ";
        let temp = child;
        child.remove();
        child = temp.next;
      }
      obj.text = prevText.trim() + obj.text + nextText.trim();
    },
    "other": function (obj, text = "") {
      if (!obj) {
        return text;
      }
      if (obj.tag == "template") {
        return obj;
      }
      if (obj.node == "#text" && obj.text.trim().length > 0) {
        text += (" " + obj.text.trim() + " ");
      }
      if (!obj.child) {
        return text;
      }
      let child = obj.child
      for (let i of child) {
        text = this.other(i, text);
        if (typeof res == "object") {
          return res;
        }
      }
      return text;
    }
  }
  if (obj.child) {
    let child = obj.child[0];
    while (child) {
      if (child.node != "#text") {
        if (child.tag == "option" || child.tag == "optgroup") {
          check.opt(child)
        } else if (child.tag != "template") {
          let response = check.other(child);
          if (typeof response == "object") {
            child.replaceWith(new _nodeStructClass_js__WEBPACK_IMPORTED_MODULE_1__["default"](response))
          } else {
            let index = child.parent.child.indexOf(child);
            child.replaceWith(new _nodeStructClass_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
              node: "#text",
              text: response
            }));
            check.text(child.parent.child[index]);
          }
          // child.replaceWith(new Node({ node: "text", text: response }));
        }
      }
      child = child.next;
    }
  }
}

function processSelectTags(obj) {
  let samp = obj.querySelectorAll("select", true);
  for (let select of samp) {
    processSelect(select);
  }
}
const htmlToJsObjectLyteRendered = (function () {

  function removeDOCTYPE(html) {
    return html
      .replace(/<\?xml.*\?>\n/, '')
      .replace(/<!doctype.*\>\n/, '')
      .replace(/<!DOCTYPE.*\>\n/, '');
  }
  const convertToHtml = function (json, customHooks, checks) {
    if (checks && checks.attrWithoutValue) {
      checks.attrWithoutValue = createMapFor(checks.attrWithoutValue);
    }
    return getHtml(json, customHooks, checks);
  }
  const getHtml = function (json, customHooks, checks ,styleStarted = false) {
    customHooks = customHooks || {
      handlers: {}
    };
    if (typeof json === 'object' && json !== null && !Array.isArray(json)) {
      // Empty Elements - HTML 4.01
      if(json.tag == "style"){
        styleStarted = true;
      }
      let empty = ['area', 'base', 'basefont', 'br', 'col', 'frame', 'hr', 'img', 'input', 'isindex', 'link', 'meta', 'param', 'embed', 'source', "track"];

      let attr = '';
      let attrType = json.attrType;
      if (json.attr) {
        // const appendQuotes = customHooks.addQuotes || addQuotes;
        let errorinfo;
        if (json.attr.errorinfo) {
          errorinfo = Object.assign(json.attr.errorinfo);
          delete json.attr.errorinfo;
        }
        attr = Object.keys(json.attr).map(function (key) {
          let value = json.attr[key],
            closers = '"';
          if (Array.isArray(value)) {
            value = value.join(' ');
          }
          if (!checks || !checks.withoutTemplateConversion) {
            // console.log("attribute", value);
            // return key + '=' + appendQuotes(value);
            value = value.replace(/&lt;/g, "<");
            value = value.replace(/&gt;/g, ">");
            // value = value.replace(/&lt/g, "<");
            // value = value.replace(/&gt/g, ">");

            value = value.replace(/"/g, "&quot;");
            // value = value.replace(/(?!{{.*\(.*)>(?!.*\)}})/gm, "&gt;");
            // value = value.replace(/(?!{{.*\(.*)<(?!.*\)}})/gm, "&lt;");
            value = value.replace(/&apos;/gm, "'");
            value = value.replace(/&(?!quot;)(?!amp;)(?![gl]t;)(?![Oo][Ee]lig;)(?![Ss]caron;)(?!Yuml;)(?!circ;)(?!tilde;)(?!e[mn]sp;)(?!thinsp;)(?!zwnj;)(?!zwj;)(?![hl]rm;)(?!rlm;)(?![mn]dash;)(?![rl]squo;)(?!sbquo;)(?![rbl]dquo;)(?![dD]agger;)(?!permil;)(?![rl]saquo;)(?!euro;)(?!nbsp;)(?!apos;)(?!cent;)(?!pound;)(?!yen;)(?!copy;)(?!reg;)/gm, "&amp;")
          } else {
            if (attrType && attrType.___attrStart___) {
              let valCloser = attrType.___attrStart___[key];
              if (valCloser) {
                closers = (valCloser === "'" || valCloser === '"') ? valCloser : "";
              }
            }
            if (checks.attrWithoutValue && checks.attrWithoutValue[key] && value == "") {
              return key;
            }
          }

          return key + "=" + closers + value + closers;
        }).join(' ');
        if (errorinfo) {
          json.attr.errorInfo = errorinfo;
        }
        if (attr !== '') {
          attr = ' ' + attr;
        }
      }
      // attr = attr.replace(/"/g,"&quot;")
      let child = '';
      const convertChild = function () {
        let ptr = json.child || json.content.child
        if (ptr) {
          child = ptr.map(function (item) {
            return getHtml(item, customHooks, checks,styleStarted);
          }).join('');
        }
      }
      if (json.node === 'element') {
        let tag = json.tag;
        const handler = (customHooks.handlers || {})[json.node];
        if (typeof handler === 'function') {
          const output = handler(json);
          if (output !== null) {
            return output;
          }
        }

        convertChild();
        if (empty.indexOf(tag) > -1) {
          // empty element
          return '<' + json.tag + attr + '>';
        }

        // non empty element
        let open = '<' + json.tag + attr + '>';
        let close = '</' + json.tag + '>';
        return open + child + close;
      }

      if (json.node === '#text') {
        if (!styleStarted && (!checks || !checks.withoutTemplateConversion)) {
          json.text = json.text.replace(/</g, "&lt;");
          json.text = json.text.replace(/>/g, "&gt;");
          json.text = json.text.replace(/&quot;/g, '"');
          json.text = json.text.replace(/&(?!quot;)(?!amp;)(?![gl]t;)(?![Oo][Ee]lig;)(?![Ss]caron;)(?!Yuml;)(?!circ;)(?!tilde;)(?!e[mn]sp;)(?!thinsp;)(?!zwnj;)(?!zwj;)(?![hl]rm;)(?!rlm;)(?![mn]dash;)(?![rl]squo;)(?!sbquo;)(?![rbl]dquo;)(?![dD]agger;)(?!permil;)(?![rl]saquo;)(?!euro;)(?!nbsp;)(?!apos;)(?!cent;)(?!pound;)(?!yen;)(?!copy;)(?!reg;)/gm, "&amp;");
        }
        return json.text;
      }

      if (json.node === 'html') {
        return json.html;
      }

      if (json.node === 'comment') {
        return '<!--' + json.text + '-->';
      }

      if (json.node === 'root') {
        const handler = (customHooks.handlers || {})[json.node];
        if (typeof handler === 'function') {
          const output = handler(json);
          if (output !== null) {
            return output;
          }
        }
        convertChild();
        return child;
      }

    } else {
      throw new Error("Invalid value. Expected object");
    }
  }
  const find = (obj, find) => {
    if (obj) {
      let ls = Object.keys(obj);
      for (let i = 0; i < ls.length; i++) {
        if (ls[i] == find) {
          return true;
        }
      }
    }
    return false;
  }
  const convertToObject = function (html, check = {
    enhanced: false,
    fromSub: false,
    withoutTemplateConversion: false,
    pageBuilder: {},
    withLineIndex: false,
    withColumnIndex: false,
    emberFlag: false,
    fileName: "",
    fromCLI: false,
    withoutTableProcessing: false,
    ide: false
  }, errorObj = {}) {
    observedAttributes = {}
    if (typeof html === "string" || html instanceof String) {
      if (check) {
        check.fromMain = true;
        check.observedAttributes = observedAttributes;
        check.fromParser = true;
        check.syntaxCheckWorkerNew = _HandleMustache__WEBPACK_IMPORTED_MODULE_2__["default"];

      }

      let isOptionCallBackPresent = false,
        optionsData,
        optionsCallBacks,preventSpaceText,cliVersion = check.cliVersion;
      // let isOptionDataPresent = false;
      //  if(optionsData && typeof optionsData=='object' && Object.keys(optionsData).length>0)
      // {
      //   isOptionDataPresent = true;
      // }
      if (check.pageBuilder) {
        preventSpaceText = check.pageBuilder.preventSpaceText;
        optionsData = check.pageBuilder.data;
        optionsCallBacks = check.pageBuilder.callbacks;
        if (optionsCallBacks && typeof optionsCallBacks == 'object' && Object.keys(optionsCallBacks).length > 0) {
          isOptionCallBackPresent = true;
        }
      }
      html = removeDOCTYPE(html);
      const bufferArray = [];
      const results = new _nodeStructClass_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
        node: 'root',
        child: []
      });
      if (check.Compile) {
        results.__proto__.Compile = check.Compile;
      }
      if (check.fromSub && check.hasParentSvg) {
        results.hasParentSvg = check.hasParentSvg;
      }
      if (check.fromCLI) {
        //To remove body tag inside a component 
        let match = html.match(/<body\s?.*?>/gm);
        if (match) {
          if (errorObj.warnings) {
            errorObj.warnings.push({
              message: "Warning: Misplaced body tag in " + match[0] + "....." + "</body>"
            });
          }
          html = html.replace(/<body\s?.*?>/gm, "");
          html = html.replace(/<\/body\s*>/gm, "");
        }

      }
      if (check.enhanced) {
        results.parent = null;
        results.prev = null;
        results.next = null;
        if (check.withLineIndex) {
          results.lineIndex = 0
        };
        if (check.withColumnIndex) {
          results.colIndex = 0
        };
      }


      (0,_lib_htmlParser_js__WEBPACK_IMPORTED_MODULE_0__["default"])(html, {
          start: function (tag, attrs, unary, seenSVGBefore, lineIndex, colIndex) {
            let parent = bufferArray[0] || results;
            if (tag == "style") {
              styleTagStarted = true;
            }
            const node = (tag != "template" && (seenSVGBefore > 0 || check.hasParentSvg)) ? new _nodeStructClass_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
              node: 'element',
              tag: tag,
              child: [],
              attrType: {}
            }) : new _nodeStructClass_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
              node: 'element',
              tag: tag,
              child: [],
              cont: [],
              attrType: {}
            });
            if(node.tag == "table"){
              check.hasSeenTable = true;
            }
            if(node.select == "select"){
              check.hasSeenSelect = true;
            }
            if (check.Compile) {
              node.__proto__.Compile = check.Compile;
            }
            if (tag == "template" && seenSVGBefore == 0 && !check.hasParentSvg) {
              node.content = node.createDocumentFragment();
            }
            if (check.enhanced) {
              node.parent = parent;
              node.prev = (parent.child && parent.child[parent.child.length - 1]) ? parent.child[parent.child.length - 1] : null;
              node.next = null;
              if (check.withLineIndex) {
                node.lineIndex = lineIndex
              };
              if (check.withColumnIndex) {
                node.colIndex = colIndex
              };
              node.attrType = {};
            }
            let attrType = {};
            if(!check.fromInternal && check.withoutTemplateConversion){
              attrType = {
                ___attrStart___: {}
              }
            }
            let errorInfo = undefined;
            if (attrs.length !== 0) {
              // @newChanges
              node.attr = attrs.reduce(function (acc, attr) {
                const name = attr.name;
                let value = attr.value;
                const nodeData = node.data;
                if (attr.errorInfo) {
                  node.errorInfo = attr.errorInfo;
                }
                value = value.replace(/&nbsp;/gm, "@nbsp@").replace(/&#160;?/gm, "@nbsp@").replace(/&#xa0;?/gm, "@nbsp@").replace('.{}', '____lyteinternal____');
                value = _decodeHtmlEntities_js__WEBPACK_IMPORTED_MODULE_3__["default"].decode(value);
                let res = (0,_HandleMustache__WEBPACK_IMPORTED_MODULE_2__["default"])(value, check, errorObj, {
                  lineIndex,
                  colIndex
                },true);
                value = res.text;
                if (!acc[name] || (nodeData && nodeData[name])) {
                  if (isOptionCallBackPresent && optionsCallBacks[name] && typeof optionsCallBacks[name] === 'function') {
                    try {
                      value = optionsCallBacks[name](value);
                    } catch (e) {
                      console.error("Invalid callback");
                      return;
                    }
                  }
                  if (optionsData && optionsData[name]) {
                    const keyVal = optionsData[name];
                    node.data = node.data || {};
                    node.data[keyVal] = value;

                  } else {
                    acc[name] = value;
                    attrType[name] = res.type;
                    if (!check.fromInternal && check.withoutTemplateConversion) {
                      attrType.___attrStart___[name] = attr.startChar;
                    }
                  }
                }
                return acc;
              }, {});
              if (errorInfo) {
                node.errorInfo = errorInfo;
              }

            }

            node.attrType = attrType;
            if (check.enhanced && parent.child && parent.child.length) {
              parent.child[parent.child.length - 1].next = node;
            }

            if (unary) {
              let parent = bufferArray[0] || results;
              if (parent.child === void 0) {
                parent.child = [];
              }
              parent.child.push(node);
            } else {
              bufferArray.unshift(node);
            }

            // if (!find(node.attr, "lyte-if") && svg.includes(node.tag)) {
            //   splitTextNodes(node);
            // }

          },
          end: function (tag, flag, misMatchCase, seenSVGBefore) {
            // merge into parent tag

            if (tag == "style") {
              styleTagStarted = false;
            }
            let node = bufferArray.shift();
            if (node.parent && node.parent.node == "element" && allTableTags[node.parent.tag.toLowerCase()] && allTableTags[node.tag.toLowerCase()] && tagLevel[node.tag] <= 1 && tagLevel[node.parent.tag.toLowerCase()] <= tagLevel[node.tag.toLowerCase()]) {
              let err = new Error("Error: Invalid tag " + node.tagName + " inside " + node.parent.tagName);
              err.fromParser = true;
              throw err;
            }
            if (flag) {
              node.setAttribute("lt-prop-MisMatchLastParent", "true");
            }
            if (misMatchCase) {
              node.setAttribute("lt-prop-MisMatchClosingTags", "true");
            }
            if (node.tag !== tag) {
              let err = new Error('Mismatch in end tag :' + tag);
              err.fromParser = true;
              throw err;
            }
            if (node.tag == "template" && seenSVGBefore == 0 && !check.hasParentSvg) {
              let child = node.child;
              if (!node.content) {
                node.content = node.createDocumentFragment();
              }
              node.content.appendChildArr(child);
              delete node.child;
            }
            if (bufferArray.length === 0) {
              results.child.push(node);
            } else {
              const parent = bufferArray[0];
              if (parent.child === void 0) {
                parent.child = [];
              }
              parent.child.push(node);
            }
            if (node.tag && node.tag == "pre" && node.child[0].node == "#text" && node.child[0].text && node.child[0].text[0] == "\n") {
              node.child[0].text = node.child[0].text.slice(1);
              if (node.child[0].text.length == 0) {
                delete node.child[0];
                node.child = node.child.slice(1);
                node.child[0].prev = null;
              }
            }

            // console.log(node);

          },
          chars: function (text, lineIndex, colIndex, checkClosingTag) {
            if (preventSpaceText==true) {
              text = text.trim();
              if(text==''){
                return;
              }
            } 
            let parent = bufferArray[0] || results;
            const node = new _nodeStructClass_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
              node: '#text',
              text: text,
              attrType: ""
            });
            if (check.Compile) {
              node.__proto__.Compile = check.Compile;
            }
            // node.text = decodeHtmlEntities.default.decode(node.text);
            // @newChanges
            if (styleTagStarted) {
              node.style = true;
            }
            text = text.replace(/&nbsp;?/gm, "@nbsp@").replace(/&#160;?/gm, "@nbsp@").replace(/&#xa0;?/gm, "@nbsp@").replace('.{}', '____lyteinternal____');
            node.text = _decodeHtmlEntities_js__WEBPACK_IMPORTED_MODULE_3__["default"].decode(text, true);
            // console.log(decodeHtmlEntities.decode(node.text));
            if (check.enhanced) {
              node.parent = parent;
              node.prev = (parent.child && parent.child[parent.child.length - 1]) ? parent.child[parent.child.length - 1] : null;
              node.next = null;
              if (check.withLineIndex) {
                node.lineIndex = lineIndex
              };
              if (check.withColumnIndex) {
                node.colIndex = colIndex
              };
              // if (checkClosingTag) {
              //   node.checkClosingTag = true
              // };
            }
            if (check.enhanced && parent.child && parent.child.length) {
              parent.child[parent.child.length - 1].next = node;
            }
            if (bufferArray.length === 0) {
              results.child.push(node);
            } else {
              const parent = bufferArray[0] || results;
              if (parent.child === void 0) {
                parent.child = [];
              }
              parent.child.push(node);
            }

            let res = (0,_HandleMustache__WEBPACK_IMPORTED_MODULE_2__["default"])(node.text, check, errorObj, {
              lineIndex,
              colIndex
            });
            if(preventSpaceText==true){
               node.text = text;
            }
            else{
                  node.attrType = (res.type) ? res.type : ""; // changed @3055
              node.text = res.text;

              if (node.prev && node.prev.node == "#text") {
                let text = node.prev.text;
                node.text = text + node.text;
                node.prev.remove();
              }
              let nodeValue = node.text;
              if (nodeValue) {
                let mustacheValues = nodeValue.match(/{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}/g); //'
                if (mustacheValues) {
                  let newNodeArray = [];
                  let lastIndex = 0;
                  let offset = 0;
                  let flag = false;
                  for (let i = 0; i < mustacheValues.length; i++) {
                    let mustacheStartIndex = nodeValue.indexOf(mustacheValues[i]);

                    let mustacheEndIndex = mustacheStartIndex + mustacheValues[i].length;
                    if (mustacheStartIndex) {
                      flag = true;
                      newNodeArray.push(node.createTextNode(nodeValue.substring(0, mustacheStartIndex), {
                        parent: node.parent,
                        lineIndex: (check.withLineIndex) ? lineIndex : undefined,
                        colIndex: (check.withColumnIndex) ? colIndex + offset : undefined,
                        attrType: ""
                      }));
                    }
                    newNodeArray.push(node.createTextNode(nodeValue.substring(mustacheStartIndex, mustacheEndIndex), {
                      parent: node.parent,
                      lineIndex: (check.withLineIndex) ? lineIndex : undefined,
                      colIndex: (check.withColumnIndex) ? colIndex + mustacheStartIndex + offset : undefined,
                      attrType: res.type
                    }));
                    offset = offset + mustacheEndIndex;
                    nodeValue = nodeValue.substring(mustacheEndIndex);
                    lastIndex = colIndex + offset;
                  }
                  newNodeArray.push(node.createTextNode(nodeValue, {
                    parent: node.parent,
                    lineIndex: (check.withLineIndex) ? lineIndex : undefined,
                    colIndex: (check.withColumnIndex) ? lastIndex : undefined,
                    attrType: ""
                  }));
                  for (let i = 0; i < newNodeArray.length - 1; i++) {
                    newNodeArray[i].next = newNodeArray[i + 1];
                  }
                  for (let i = 1; i < newNodeArray.length; i++) {
                    newNodeArray[i].prev = newNodeArray[i - 1];
                  }
                  if (node.parent && node.parent.child) {
                    if (flag && node.prev) {
                      let lastChild = node.prev;
                      lastChild.next = newNodeArray[0];
                      newNodeArray[0].prev = lastChild;
                    }
                    let ls = node.parent.child
                    let index = node.parent.child.indexOf(node)
                    let args = [index, 1].concat(newNodeArray);
                    Array.prototype.splice.apply(ls, args);
                  }
                }
              }
             
            }
            
          },
          comment: function (text, lineIndex, colIndex) {
            if (!check.withoutComment) {
              let par;
              const node = new _nodeStructClass_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
                node: 'comment',
                text: text
              });
              par = bufferArray[0] || results;

              if (check.enhanced) {
                node.parent = par;
                node.prev = (par.child && par.child[par.child.length - 1]) ? par.child[par.child.length - 1] : null;
                node.next = null;
                if (check.withLineIndex) {
                  node.lineIndex = lineIndex
                };
                if (check.withColumnIndex) {
                  node.colIndex = colIndex
                };
              }
              if (check.enhanced && par.child && par.child.length) {
                par.child[par.child.length - 1].next = node;
              }
              const parent = bufferArray[0] || results;
              if (parent.child === void 0) {
                parent.child = [];
              }
              parent.child.push(node);
            }
          }
        },
        check.emberFlag, check.fileName, errorObj, check.withoutTableProcessing);
      if (!check.withoutTableProcessing) {
        if(check.hasSeenTable){
          processTableTag(results);
        }
        if(check.hasSeenSelector){
          processSelectTags(results);
        }
      }
      // processTableTag(results);
      let s;
      // <lyte-event-listener/> to process self closing attributes not in the list
      // s = results.querySelectorAll("[singleAttribute]", true);
      // for (let i = 0; i < s.length; i++) {
      //   let childObj = s[i];
      //   if (!selfClosingTags[s[i].tag]) { //
      //     let index = childObj.parent.child.indexOf(childObj);
      //     let ls = childObj.parent.child.slice(index + 1);
      //     let child = childObj.parent.child.splice(0, index + 1);
      //     childObj.parent.child = [];
      //     for (let childOfChild of child) {
      //       childObj.parent.appendChild(childOfChild);
      //     }
      //     childObj.child = []
      //     for (let childOfChild of ls) {
      //       childObj.appendChild(childOfChild);
      //     }
      //   }
      //   s[i].removeAttribute("singleAttribute");
      // }
      if (!check.withoutTemplateConversion) {
        let comp = results.querySelector("[tag-name]")
        let nextElement = comp.nextElementSibling;
        if(cliVersion == 4){
          if (nextElement && nextElement.tagName == "TEMPLATE" && nextElement.hasAttribute("view-port-template")) {
            errorObj.warnings.push({
              message: "Depricated Syntax : 'view-port-template' found in " + check.fileName + " . Migrate your app to using latest slyte-migrator."
            });
            let viewPortIf = comp.createElement("template");
            viewPortIf.setAttribute("lyte-if", "{{lyteViewPort}}");
            viewPortIf.setAttribute("__vp", "c-old");
            viewPortIf.content.appendChild(comp.createElement("dummy-port-element"));
            viewPortIf.content.appendChild(nextElement.content);
            viewPortIf.content.appendChild(comp.createElement("dummy-port-element"));
            let falseCase = comp.createElement("template");
            falseCase.setAttribute("lyte-else", "");
            falseCase.content.appendChild(comp.content);
            comp.innerHTML = "";
            comp.content.appendChild(viewPortIf);
            comp.content.appendChild(falseCase);
            nextElement.remove();
          } else if (nextElement && nextElement.tagName == "TEMPLATE" && nextElement.attributes["@view-out"]) {
            let viewPortIf = comp.createElement("template"); //actual content
            let attrVal = comp.getAttribute("@view-in");
            if (attrVal.startsWith("{{")) {
              attrVal = attrVal.substring(2, attrVal.length - 2);
              viewPortIf.setAttribute("lyte-if", "{{lyteViewPort(" + attrVal + ")}}");
            } else if (attrVal === "") {
              ;
              viewPortIf.setAttribute("lyte-if", "{{lyteViewPort()}}");
            } else {
              viewPortIf.setAttribute("lyte-if", "{{lyteViewPort(" + attrVal + ")}}");
            }
            viewPortIf.setAttribute("__vp", "c-new");
            viewPortIf.content.appendChild(comp.content);
            comp.removeAttribute("@view-in");

            let viewPortElse = comp.createElement("template"); //loading
            viewPortElse.setAttribute("lyte-else", "");

            viewPortElse.content.appendChild(comp.createElement("dummy-port-element"));
            viewPortElse.content.appendChild(nextElement.content);
            viewPortElse.content.appendChild(comp.createElement("dummy-port-element"));

            comp.innerHTML = "";

            comp.content.appendChild(viewPortIf);
            comp.content.appendChild(viewPortElse);
            nextElement.remove();
            comp.setAttribute("__vp", "c-new");
          }
        }
        check.Compile.splitTextNodes(comp.content, errorObj.warnings, undefined, check, errorObj, undefined);
        s = results.querySelectorAll("[lyte-else]", true);
        for (let i = 0; i < s.length; i++) {
          let node = s[i]
          if (node && !(node.previousElementSibling && (find(node.previousElementSibling, "lyte-if") || find(node.previousElementSibling, "lyte-else-if")))) {
            let temp = node.cloneNode();
            temp.innerHTML = "...";
            if (errorObj && errorObj.warnings && check.fromCLI) {
              errorObj.warnings.push({
                message: "Parse Warning : `lyte-else` without `lyte-if` in " + temp.outerHTML
              });
            } else {
              console.warn("Parse Warning : `lyte-else` without `lyte-if` in " + temp.outerHTML);
            }
          }
        }

        s = results.querySelectorAll("[lyte-else-if]", true)
        for (let i = 0; i < s.length; i++) {
          let node = s[i]
          if (node && !(node.previousElementSibling && (find(node.previousElementSibling, "lyte-if") || find(node.previousElementSibling, "lyte-else-if")))) {
            let temp = node.cloneNode();
            temp.innerHTML = "...";
            if (errorObj && errorObj.warnings && check.fromCLI) {
              errorObj.warnings.push({
                message: "Parse Warning : `lyte-else-if` without `lyte-if` in " + temp.outerHTML
              });
            } else {
              console.warn("Parse Warning : `lyte-else-if` without `lyte-if` in " + temp.outerHTML);
            }
          }
        }
      }

      // MisMatch order in closing tags inorder to put all the parent's next sibling as child's next sibling 
      // <div class="mT7 pR {{if( item.isError,'admc_errorMsg','')}}">
      //       <%if(item.type == "dropdown"){%>
      //           </div>
      //       <%}%>
      // s = results.querySelectorAll("[lt-prop-MisMatchLastParent]", true);
      // for (let i = 0; i < s.length; i++) {
      //   let ptr = s[i];
      //   let child = ptr;
      //   let parent = child.parent;
      //   while (parent && parent.tag != "template") {
      //     let ls = [];
      //     if (parent.parent) {
      //       ls = parent.parent.child.slice(parent.parent.child.indexOf(parent) + 1);
      //     } else {
      //       break;
      //     }
      //     for (let i of ls) {
      //       ptr.appendChild(i.deepCopyObject());
      //       i.remove();
      //     }
      //     child = parent;
      //     parent = parent.parent;
      //   }
      //   s[i].removeAttribute("lt-prop-MisMatchLastParent")
      // }

      // s = results.querySelectorAll("[dontConsiderForDefault]",true);
      // for (let i = 0; i < s.length; i++) {
      //   s[i].removeAttribute("dontConsiderForDefault");
      // }
      // s = results.querySelectorAll("[lt-prop-MisMatchClosingTags]", true);
      // for (let i = 0; i < s.length; i++) {
      //   s[i].removeAttribute("lt-prop-MisMatchClosingTags");
      //   let childObj = s[i];
      //   let tagToCheck = childObj.tag;
      //   while (childObj.parent) {
      //     if (childObj.parent.tag == tagToCheck) {
      //       let parent = childObj.parent;
      //       let index = parent.child.indexOf(childObj);
      //       if (parent.parent) {
      //         let ls = parent.child.slice(index + 1);
      //         parent.child.splice(index + 1);
      //         parent.child[index].next = null;
      //         let tempChilds = parent.parent.child.slice(parent.parent.child.indexOf(parent) + 1);
      //         parent.parent.child.splice(parent.parent.child.indexOf(parent) + 1);
      //         for (let node of ls) {

      //           if (!node.hasAttribute("checkClosingTag") && !node.checkClosingTag) {
      //             if (parent.parent.child[parent.parent.child.length - 1].node == "#text" && node.node == "#text" && !node.text.match(/{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}/g) && !parent.parent.child[parent.parent.child.length - 1].text.match(/{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}/g)) {
      //               node.text = parent.parent.child[parent.parent.child.length - 1].text + node.text;
      //               parent.parent.child[parent.parent.child.length - 1].remove();
      //             }
      //             parent.parent.appendChild(node);
      //           } else {
      //             if (node.hasAttribute("checkClosingTag")) {
      //               node.removeAttribute("checkClosingTag")
      //             } else {
      //               delete node.checkClosingTag;
      //             }
      //             parent.appendChild(node);
      //           }
      //         }
      //         if (parent.parent.child[parent.parent.child.length - 1].node == "#text" && tempChilds[0].node == "#text") {
      //           tempChilds[0].text = parent.parent.child[parent.parent.child.length - 1].text + tempChilds[0].text;
      //           parent.parent.child[parent.parent.child.length - 1].remove();
      //         }
      //         for (let node of tempChilds) {
      //           parent.parent.appendChild(node);
      //         }
      //       }
      //     }
      //     if (childObj.parent.tag != "template" || childObj.parent.tag != tagToCheck) {
      //       break;
      //     }
      //     childObj = childObj.parent;
      //   }
      // }

      // s = results.querySelectorAll("[checkClosingTag]", true);
      // for (let i = 0; i < s.length; i++) {
      //   s[i].removeAttribute("checkClosingTag");
      // }
      if (check.emberFlag) {
        let objAttr = check.observedAttributes;
        delete objAttr.this
        results.observedAttributes = Object.keys(objAttr);
      }
      return results;
    } else {
      throw new Error("Error: Invalid value. Expected string");
    }
  }

  const API = {
    toHtml: convertToHtml,
    toObject: convertToObject,
    processTable: processTableTag
  }
  return API;
}());

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (htmlToJsObjectLyteRendered);
//ignorei18n_end

/***/ }),

/***/ "./src/nodeStructClass.js":
/*!********************************!*\
  !*** ./src/nodeStructClass.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _htmlToJsObjectLyteRendered__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./htmlToJsObjectLyteRendered */ "./src/htmlToJsObjectLyteRendered.js");

function deepCopyObject( obj )  {
    let current, copies = [{source : obj, target : Object.create(Object.getPrototypeOf(obj))}], keys, propertyIndex, descriptor, nextSource, indexOf, sourceReferences = [obj];
    let cloneObject = copies[0].target, targetReferences = [cloneObject];
    while(current = copies.shift()){
        keys = Object.getOwnPropertyNames(current.source);
        for(propertyIndex = 0; propertyIndex < keys.length; propertyIndex++){
            descriptor = Object.getOwnPropertyDescriptor(current.source, keys[propertyIndex]);
            if(!descriptor.value || typeof descriptor.value != "object"){
                Object.defineProperty(current.target, keys[propertyIndex], descriptor);
                continue;
            }
              nextSource = descriptor.value;
              descriptor.value = Array.isArray(nextSource) ? [] : Object.create(Object.getPrototypeOf(nextSource));
              indexOf = sourceReferences.indexOf(nextSource);
              if(indexOf != -1){
                  descriptor.value = targetReferences[indexOf];
                  Object.defineProperty(current.target, keys[propertyIndex], descriptor);
                  continue;
              }
              sourceReferences.push(nextSource);
              targetReferences.push(descriptor.value);
              Object.defineProperty(current.target, keys[propertyIndex], descriptor);
              copies.push({source : nextSource, target : descriptor.value});
          }
      }
    return cloneObject;
}
//   getType = function(val){
//     return  val && ((typeof val == "object")?(Array.isArray(val)? "a":"o"):undefined);
//   }

function deepCopyNode(obj,hasSeenSvg){
	if(!obj){return}
	// let children  = (obj.content)? obj.content.childNodes:obj.childNodes;
	obj = new Node(obj);
	if(hasSeenSvg && obj.tag == "template" && obj.cont){
		let temp = obj.content.childNodes,ls = obj.child = [];
		obj.child = temp;
		delete obj.cont;
	}
	if(!hasSeenSvg && obj.tag == "template" && obj.child /*&& obj.child.length > 0*/ ){
		let temp = obj.child;
		obj.content = obj.createDocumentFragment();
		obj.cont.child=temp;
		delete obj.child;
	}
	if(obj.tag == "svg"){
		hasSeenSvg = hasSeenSvg || true;
	}
	let prev;
	if(obj.content){
		obj.content = new Node(obj.content);
		let ls = [];
		for(let i in obj.content.child){
			let ref = obj.content.child[i] = deepCopyNode(obj.content.child[i],hasSeenSvg);
			if(prev){
				prev.next = ref;
			}
			ref.parent = obj.content;
			ref.prev = prev;
			prev = ref;
			ls.push(ref);
		}
		obj.content.child = ls;
		
	}
	else if (obj.childNodes){
		let ls = [];
		for(let i in obj.child){
			let ref = obj.child[i] = deepCopyNode(obj.child[i],hasSeenSvg);
			if(prev){
				prev.next = ref;
			}
			ref.parent = obj;
			ref.prev = prev;
			prev = ref;
			ls.push(ref);
		}
		obj.child = ls;
	}
	return obj;
}
class Node{
    constructor(obj) {
		this.node = obj.node;
		(obj.hasOwnProperty("parent")) ? this.parent = obj.parent : this.parent = null;
		(obj.hasOwnProperty("prev")) ? this.prev = obj.prev : this.prev = null;
		(obj.hasOwnProperty("next")) ? this.next = obj.next : this.next = null;
		if (obj.hasOwnProperty("tag")) { this.tag = obj.tag; }
		if(obj.hasOwnProperty("text")) { this.text = obj.text; }
		if(obj.hasOwnProperty("attr")) { this.attr = Object.assign({},obj.attr); }
		if(obj.hasOwnProperty("child")) { this.child = obj.child; }
		if(obj.hasOwnProperty("attrType")) { this.attrType = Object.assign({},obj.attrType) }
		// if(obj.hasOwnProperty("style")){this.style = obj.style}
		else if(obj.node == "element"){
			this.attrType = {};
		}
		if(obj.__proto__.Compile){
			this.__proto__.Compile = obj.__proto__.Compile;
		}
		if(obj.hasOwnProperty("errorInfo")){ this.errorInfo = obj.errorInfo}
		if(obj.hasOwnProperty("cont")){this.cont = obj.content}
    }
	refreshNode(NodeStruct = false){
		let nodes = this.querySelectorAll("tbody",true);
		let ds = {};
		let value = null;
        for(let node of nodes){
            let parent = node.parent || node._parent
            let index = parent.child.indexOf(node);
            let temp = null;
            let count = 0;
            if (parent.tag != "table"){
                parent.child.splice(parent.child.indexOf(node), 1);
				let ptr = parent;
                while(parent){
                    if (parent.tag == "table" && temp) {
                        let ls = []
                        index = parent.child.indexOf(temp);
                        if (parent.hasAttribute("haveChangesInTbody")) {
                            value = parent.attr.haveChangesInTbody;
                        }
                        else {
                            count++;
                            parent.setAttribute("haveChangesInTbody", count.toString());
                            value = count.toString();
                        }
                        if(ds[value]){
                            ds[value].push({ node: node, index: index});
                        }
                        else{
                            ds[value] = [{ node: node, index: index}]
                        }
						if(node.next && node.next.node == "#text"){
							ds[value].push({ node: node.next, index: index});
							ptr.child.splice(ptr.child.indexOf(node.next), 1);
						}
                        break;
                    };
                    temp = parent;
                    parent = parent.parent
                }
            }
        }
		let ls = [];
		for(let i in ds){
			let parent = this.querySelector("[haveChangesInTbody=" + i + "]",true);
			let key = parent.attr.haveChangesInTbody;
			let childToAdd = []
			let index = null
			for(let j of ds[i]){
				childToAdd.push(j.node);
				index = j.index
			}
			let child = parent.child
			if (index == child.length - 1) {
				ls = child.concat(childToAdd);//[...child, ...childToAdd];
			}
			else{
				ls = (child.slice(0,index)).concat(childToAdd).concat(child.slice(index));//[...child.slice(0,index),...childToAdd,...child.slice(index)]
			}
			parent.child = []
			for (let j = 0; j < ls.length;j++){
				parent.appendChild(ls[j]);
			}
			parent.removeAttribute("haveChangesInTbody");
		}
		_htmlToJsObjectLyteRendered__WEBPACK_IMPORTED_MODULE_0__["default"].processTable(this);
		if (NodeStruct) {
			let list = [];
			list.push(this);
			while (list.length > 0) {
				let obj = list.splice(0, 1);
				if (obj.child) {
					for (let child of obj.child) {
						child = new Node(child);
						list.push(child);
					}
				}
			}
		}
	}
	
	get content(){
		return this.cont;
	}
	
	set content(docFag){
		this.cont = docFag;
		docFag._parent = this;
	}
	
    get children(){
		if(this.child){
			let obj = this.child;
			let res = [];
			for(let i=0; i<obj.length; i++){
				if(obj[i].node== "element") { res.push(obj[i]) }
			}
			return res;
		}
		return [];
	}
	
	//.childNodes
	get childNodes(){
		return this.child;
	}
	//.outerObj()
	get outerObj(){
		return (this.node!= "#document-fragment")?/*deepCopyNode(*/this/*)*/:undefined;
	}

	set outerObj(obj){
		if(obj){
			let tagName = this.tagName;
			obj = obj.childNodes;
			// let obj = htmlToJsObjectLyteRendered.toObject(html, { fromInternal:true, enhanced: true,withoutTableProcessing:true,withoutTemplateConversion:true,hasParentSvg:(tagName == tagName.toLowerCase()),fromSub:true ,Compile: this.__proto__.Compile}).childNodes;
			if (this.node != "#document-fragment") {
				let child = this.parent.childNodes;
				let index = child.indexOf(this);
				// child = [child.slice(0, index+1),...obj,child.slice(index+1)];
				let secondHalf = child.slice(index + 1);
				this.parent.child = child.slice(0, index);
				for(let i of obj){
					this.parent.appendChild(deepCopyNode(i,(tagName == tagName.toLowerCase())));
				}
				for(let i of secondHalf){
					this.parent.appendChild(i);
				}
			}
		}
	}
	//.outerHTML()
	get outerHTML(){
		return (this.node!= "#document-fragment")?_htmlToJsObjectLyteRendered__WEBPACK_IMPORTED_MODULE_0__["default"].toHtml(this):undefined;
	}

	set outerHTML(html){
		let tagName = this.tagName
		let obj = _htmlToJsObjectLyteRendered__WEBPACK_IMPORTED_MODULE_0__["default"].toObject(html, { fromInternal:true, enhanced: true,withoutTableProcessing:true,withoutTemplateConversion:true,hasParentSvg:(tagName == tagName.toLowerCase()),fromSub:true ,Compile: this.__proto__.Compile}).childNodes;
		if (this.node != "#document-fragment") {
			let child = this.parent.childNodes;
			let index = child.indexOf(this);
			// child = [child.slice(0, index+1),...obj,child.slice(index+1)];
			let secondHalf = child.slice(index + 1);
			this.parent.child = child.slice(0, index);
			for(let i of obj){
				this.parent.appendChild(i);
			}
			for(let i of secondHalf){
				this.parent.appendChild(i);
			}
		}
	}

	//.innerObj()
	get innerObj(){
		// let res = [];
		let obj = this;
		// let obj = deepCopyObject(this);
		obj = (!obj.content) ? obj.childNodes : obj.content.childNodes;
		// for(let i=0; i<obj.length; i++){
			// res += htmlToJsObjectLyteRendered.toHtml(obj[i]);
			// res.push(deepCopyNode(obj[i]));
		// }
		// return res;
		return obj;
	}

	set innerObj(obj){
		let tagName = this.tagName;
		if (tagName == "TEMPLATE") {
			this.content.child = [];
			if(obj.length != undefined){
				for(let i of obj){
					this.content.appendChild(deepCopyNode(i,(tagName == tagName.toLowerCase())));
				}
				// this.content.appendChildArr(obj);
			}
			else{
				this.content.appendChild(deepCopyNode(obj,(tagName == tagName.toLowerCase())));
			}
		}
		else {
			this.child = []
			if(obj.length != undefined){
				for(let i of obj){
					this.appendChild(deepCopyNode(i,(tagName == tagName.toLowerCase())));
				}
			}
			else{
				this.appendChild(deepCopyNode(obj,(tagName == tagName.toLowerCase())));
			}
		}
	}

	//.innerHTML()
	get innerHTML(){
		let res = "";
		let obj = this;
		// let obj = deepCopyObject(this);
		obj = (!obj.content) ? obj.childNodes : obj.content.childNodes;
		for(let i=0; i<obj.length; i++){
			res += _htmlToJsObjectLyteRendered__WEBPACK_IMPORTED_MODULE_0__["default"].toHtml(obj[i]);
		}
		return res;
	}
	
	set innerHTML(html){
		let tagName = this.tagName
		let obj = _htmlToJsObjectLyteRendered__WEBPACK_IMPORTED_MODULE_0__["default"].toObject(html, { fromInternal:true, enhanced: true,withoutTableProcessing:true, withoutTemplateConversion:true ,hasParentSvg:(tagName == tagName.toLowerCase()),fromSub:true,Compile: this.__proto__.Compile}).childNodes;
		if (tagName == "TEMPLATE") {
			this.content.child = [];
			this.content.appendChildArr(obj);
		}
		else {
			this.child = []
			this.appendChildArr(obj);
		}
	}
	
	//.appendChild()
	appendChild(child,deleteInPreviousParent){
		if (child.parent && child.parent.child && deleteInPreviousParent) {
			child.remove();
		}
		if(child.node == "#document-fragment"){
			return this.appendChildArr(child.child);
		}
		// let ls
		// for(let i of [...this.child,...(this.parent)?this.parent.child:[]]){
		// 	if(i == child){
		// 		i.remove(child);
		// 	}
		// }
		if (this.child && this.child.length) {
			for(let i of this.child){
				if(i==child){
					i.remove();
					break;
				}
			}
			let prev = this.child[this.child.length-1];
			child.parent = this;
			child.prev = prev;
			child.next = null;
			prev.next = child;
		}
		else {
			this.child = [];
			child.parent = this;
			child.prev = null;
			child.next = null;
		}
		this.child.push(child);
		return this;
	}
	
	appendChildArr(childArr){
        for(let i=0; i<childArr.length;i++){
          this.appendChild(childArr[i]);
        }
        return this;
      }

	//.hasAttribute()
	hasAttribute(attr){
		return (this.attr && this.attr[attr] != undefined)? true : false;
	}
	
	//.hasAttributes()
	hasAttributes(){
		return (this.attr && Object.keys(this.attr).length > 0) ? true : false;
	}
	//.getAttribute()
	getAttribute(attr){
		return (this.attr && this.attr[attr] != undefined) ? this.attr[attr] : null;
	}
	
	//.hasChildNodes()
	hasChildNodes(){
		return (this.childNodes && this.childNodes.length > 0) ? true : false;
	}
	
	get firstChild(){
		return (this.child[0]) ? this.child[0] : null;
	}
	
	//.setAttribute()
	setAttribute(attr,value){
		if(!this.attr) { this.attr = {}; }
		if (typeof value == "string" || typeof value == "number") {
			this.attr[attr] = value.toString();
		}
		else{
			this.attr[attr] =JSON.stringify(value);
		}
		return;
	}

	//.tagName()
	get tagName(){
		if(this.tag){
			let tag = this.tag
			// if(tag == "template"){
			// 	return tag.toUpperCase();
			// }
			if(tag == "svg"){
				return tag.toLowerCase();
			}
			let obj = this;
			if(!obj.replacedNode){
				while(obj){
					if(obj.tag == "svg" || obj.hasParentSvg) { return tag.toLowerCase(); }
					if(obj.tag =="foreignObject"){
						break;
					}
					// if (obj.parent) {
						obj = obj.parent;
					// }
					// else{
					// 	obj = obj._parent;
					// }
				}
			}
			return tag.toUpperCase();
		}
		return null;
	}

	//.nextSibling()
	get nextSibling(){
		return this.next;
	}

	//.nextElementSibling()
	get nextElementSibling(){
		let obj = this.next;
		while (obj) {
			if(obj.node == "element") { return obj; }
			obj = obj.next;
		}
		return null;
	}

	//.previousSibling()
	get previousSibling(){
		return this.prev;
	}

	//.previousElementSibling()
	get previousElementSibling(){
		let obj = this.prev;
		while(obj){
			if(obj.node == "element") { return obj; }
			obj = obj.prev;
		}
		return null;
	}
	updateNode(newNode){
		// let res = findParent(this,this.parent)
		// var parent = (res)?res:this.parent;
		let parent = this.parent
		let ind = parent.child.indexOf(this);
		newNode.prev = this.prev;
		newNode.next = this.next;
		newNode.parent = parent;
		if(this.prev){
			this.prev.next = newNode;
		}
		parent.child.splice(ind,1,newNode)
	}
	//.parentElement()
	get parentElement(){
		return (this.parent && this.parent.node=="element")? this.parent : null;
	}

	//.parentNode()
	get parentNode(){
		return this.parent;
	}

	nodeParentHasSvg() {
		let obj = this
		while(obj){
			if(this.tag == "svg") { return true; }
			obj = obj.parent;
		}
		return false;
	}
	
	deepCopyObject(){
		return new Node(this);
	}
	//.nodeName()
	get nodeName() {
		let obj = this;
		if(this.nodeType==2 || this.nodeType == 3){
			return this.node;		
		}
		if(obj.node && obj.node!="#document-fragment"){
			let node = obj.tagName.toUpperCase();
			while(obj){
				if(obj.tag == "svg") { return node.toLowerCase(); }
				obj = obj.parent;
			}
			return node.toUpperCase();
		}
		return null;
	}

	//.nodeType()
	get nodeType(){
		let check = {element:1,'#text':3,comment:8,attr:2,'#document-fragment':11};
		return check[this.node] || ((this.ownerElement)? 2:undefined);
	}

	//.nodeValue()
	get nodeValue(){
		if(this.nodeType==8 || this.nodeType==3) { return this.text; }
		if(this.nodeType==2){
			return this.value;
		}
		return null;
	}
	
	set nodeValue(textValue){
		if(this.nodeType == 8 || this.nodeType == 3){
			this.text = textValue;
		}
		if(this.nodeType == 2){
			this.ownerElement.setAttribute(this.nodeName, textValue);
		}
	}
	//.remove()
	remove(){
		// if(this.node == "element"){
			let index = this.parent.child.indexOf(this);
			if(this.prev) {
				this.prev.next = this.next;
			}
			if(this.next) {
				this.next.prev = this.prev;
			}
			this.parent.child.splice(index,1);
		// }
	}
	get firstElementSibling(){
		for (let i = 0; i < this.child.length;i++){
			if(this.child[i].node == "element"){
				return this.child[i];
			}
		}
		return undefined;
	}
	//.removeAttribute()
	removeAttribute(attr){
		if (this.attr) {
			delete this.attr[attr];
		}
		if(this.attr && Object.keys(this.attr).length==0) { delete this.attr; }
	}
	//.replaceWith()
	replaceWith(newNode) {
		// if(this.node == "element" && newNode.node == "element"){
			newNode.parent = this.parent;
			newNode.prev = this.prev;
			newNode.next = this.next;
			this.replacedNode = true;
			newNode.replacedNode = true;
			// newNode.attrType = this.attrType;
			let index = this.parent.child.indexOf(this);
			// this.parent.child[index] = newNode;
			this.parent.child.splice(index,1,newNode)
			if(this.next)
				{ this.next.prev = newNode; }
			if(this.prev)
				{ this.prev.next = newNode; }
		// }
	}

	//.attributes()
	get attributes(){
		let attr = this.attr;
		let res = [];
		for(let i in attr){
			res[i] = this.createAttribute(i);
			res[i].value = (attr[i]) ? attr[i] : "";
			res.push(res[i]);
		}
		return (this.attr)?res:[];
	}

	//.localName()
	get localName(){
		return this.tag?this.tag:null;
	}

	//.cloneNode()
	cloneNode(flag){
		let res={}
		res = new Node((flag)?deepCopyObject(this):this);
		
		if(this.attr)
			{ res.attr = Object.assign({},this.attr )};
		if(this.parent)
			{ res.parent = null; }
		if(this.prev)
			{ res.prev = null; }
		if(this.next)
			{ res.next = null; }
		if(res.tagName == "TEMPLATE" && !flag){
			res.content = this.createDocumentFragment();
		}
		return res;
	}
	
	createAttribute(nodeName){
		let temp = new Node({node:nodeName});
		temp.value = "";
		temp.name = nodeName;
		temp.ownerElement = this
		return temp;
	}
	
	createDocumentFragment(){
		let node = new Node({ node: "#document-fragment", child: [], cont: [] });
		if(this.__proto__.Compile){
			node.__proto__.Compile = this.__proto__.Compile;
		}
		return node;
	}
	
	//.createElement()
	createElement(tag,options = {next:null,prev:null,parent:null,attr:{}}){

		let node = {};
		if (options.attr)
			{ node = { node: "element", tag: tag.toLowerCase(),  prev: options.prev, next: options.next, parent: options.parent, attr: options.attr }; }
		else
			{ node = { node: "element", tag: tag.toLowerCase(),  prev: options.prev, next: options.next, parent: options.parent, attr: {}  }; }
		
		if(options.attrType){
			node.attrType = options.attrType
		}
		if (options.errorInfo) { 
			node.errorInfo = options.errorInfo;
		}
		node = new Node(node);
		if(this.__proto__.Compile){
			node.__proto__.Compile = this.__proto__.Compile;
		}
		if(node.tag == "template"){
			node.content = this.createDocumentFragment();
		}else{
			node.child = [];
		}
		return node;
	}
	//.createTextNode()
	createTextNode(text,options = {next:null,prev:null,parent:null}){
		let node = new Node({node:"#text",prev:options.prev,next:options.next,parent:options.parent,text:text});
		if(this.__proto__.Compile){
			node.__proto__.Compile = this.__proto__.Compile;
		}
		node.attrType = options.attrType
		if(options.lineIndex){
            node.lineIndex = options.lineIndex;
        }
        if(options.colIndex){
            node.colIndex = options.colIndex;
        }
		return node;
	}

	//.querySelector()
	findItem(dontCheckTemplate,obj,attr,attrVal,single = 1,tag = undefined){
		if (dontCheckTemplate && obj.tag == "template" && obj.tagName == "TEMPLATE") {
			obj = obj.content.child;
		}
		else {
			obj = obj.child;
		}
		if (!obj || (obj.attr && obj.attr.dontConsiderForDefault == "true")) { return null; }
		let res = null;
		for(let i=0; i<obj.length; i++){
			if (obj[i].attr && obj[i].attr.dontConsiderForDefault == "true") { continue; }
			if(single==1 && obj[i].attr && obj[i].attr[attr]==attrVal) 
				{ return obj[i]; }
			if(single==2 && obj[i].attr && this.find(obj[i].attr, attr))
				{ return obj[i]; }
			if(single==3 && obj[i].tag == attr)
				{ return obj[i]; }
			if(single==4 && obj[i].attr && obj[i].attr[attr]==attrVal && obj[i].tag == tag)
				{ return obj[i]; }
			// if (obj[i] && obj[i].tag == "template" && dontCheckTemplate) { continue; }
			else {
				res = this.findItem(dontCheckTemplate, obj[i], attr, attrVal, single, tag);
			}
			if(res) { break; }
		}
		return res;
	}

	querySelector(selector,dontCheckTemplate=false) {
		if(selector[0]=='.') { return this.findItem(dontCheckTemplate,this,"class",selector.substring(1)); }
		else if(selector[0]=='#') { return this.findItem(dontCheckTemplate,this,"id",selector.substring(1)); }
		else if(selector[0]=='['){
			if(selector.search('=')!=-1){
				let searchItem = selector.substring(1,selector.length-1).split("=");
				let attr = searchItem[0];
				let attrVal = searchItem[1].replace(/^"+|"+$/g, '');
				attrVal = attrVal.replace(/^'+|'+$/g, '');
				return this.findItem(dontCheckTemplate,this,attr,attrVal);
			}
			else {
				let attr = selector.substring(1, selector.length - 1);
				return this.findItem(dontCheckTemplate,this, attr, null, 2);
			}
		}
		else if(selector.match(/^\w+\[.+=.+]$/gm)){
			selector = selector.split("[");
			let tag = selector[0];
			selector = selector[1].split("=");
			let attr = selector[0].replace(/^"+|"+$/g, '').replace(/^'+|'+$/g, '');
			let attrVal = selector[1].substring(0,selector[1].length-1).replace(/^"+|"+$/g, '').replace(/^'+|'+$/g, '');

			return this.findItem(dontCheckTemplate,this, attr, attrVal, 4, tag);
        }
		return this.findItem(dontCheckTemplate,this,selector,null,3);
	}

	find(obj, find){
		if (obj) {
		//   let ls = Object.keys(obj)
		  for (let i in obj) {
			if (i == find) {
			  return true;
			}
		  }
		}
		return false;
	}

	//.querySelectorAll()
	findAll(obj,attr,attrVal,single,result = [],dontCheckTemplate){
		if (obj.tag == "template" && dontCheckTemplate && obj.tagName == "TEMPLATE") {
			obj = obj.content.child;
		} 
		else {
			obj = obj.child;
		}
		if(!obj){ return result;}
		for (let i=0; i<obj.length; i++){
			if(single==1 && obj[i].attr && obj[i].attr[attr]==attrVal) 
				{ result.push(obj[i]); }
			if (single == 2 && obj[i].attr && this.find(obj[i].attr, attr)) {
				{ result.push(obj[i]); }
			}
			if(single==3 && obj[i].tag == attr)
				{ result.push(obj[i]); }
			this.findAll(obj[i],attr,attrVal,single,result,dontCheckTemplate);
		}
		return result;
	}

	querySelectorAll(selector,dontCheckTemplate){
		if(selector[0]=='.') { return this.findAll(this,"class",selector.substring(1),1,[],dontCheckTemplate); }
		else if(selector[0]=='#') { return this.findAll(this,"id",selector.substring(1),1,[],dontCheckTemplate); }
		else if(selector[0]=='['){
			if(selector.search('=')!=-1){
				let searchItem = selector.substring(1,selector.length-1).split("=");
				let attr = searchItem[0];
				let attrVal = searchItem[1].replace(/^"+|"+$/g, '');
				attrVal = attrVal.replace(/^'+|'+$/g, '');
				return this.findAll(this,attr,attrVal,1,[],dontCheckTemplate);
			}
			else {
				let attr = selector.substring(1,selector.length-1);
				return this.findAll(this,attr,null,2,[],dontCheckTemplate);
			}
		};	
		return this.findAll(this,selector,null,3,[],dontCheckTemplate);
	}

	//Cases
	// let defaultCase = node.querySelectorChildren("[default]")
	// let isBreak = currentCase.querySelectorChildren("template[is=break]");
	// let isBreak = dCaseTemplate.querySelectorChildren("template[is=break]");

	querySelectorChildren(string){
		let children = this.child;
			if(string.startsWith("#")){
				return;
			}else if(string.startsWith("[")){
				let attrString = string.slice(1,string.length-1)
				for(let i=0; i<children.length; i++){
					if(children[i].attr && children[i].attr.hasOwnProperty(attrString)){
						return children[i];
					}
				}
			}else if(string.indexOf("[") != -1){
				let arr = string.split("[");
				let tagName = arr[0];
				let attrString = arr[1].slice(0,arr[1].length-1);
				let attrStringArr = attrString.split("=");
				let attrName = attrStringArr[0];
				let attrVal = attrStringArr[1];
				for(let i=0; i<children.length; i++){
					if(children[i].tag && children[i].tag == tagName){
						if(children[i].attr[attrName] && children[i].attr[attrName] == attrVal){
							return children[i];
						}
					}
				}
			}
		// }
	}

	// Cases
	// let cases = node.querySelectorAllChildren("[case]")
	querySelectorAllChildren(string){
		let children = this.child;
		let output = []
		// if(children){
			if(string.startsWith("#")){
				return output;
			}else if(string.startsWith("[")){
				let attrString = string.slice(1,string.length-1)
				for(let i=0; i<children.length; i++){
					if(children[i].attr && children[i].attr[attrString]){
						output.push(children[i])
					}
				}
			}
		// }
		return output;
	}
	json2html(obj) { return _htmlToJsObjectLyteRendered__WEBPACK_IMPORTED_MODULE_0__["default"].toHtml(obj) }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Node);

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/htmlToJsObjectLyteRendered.js");
/******/ 	Object(window["html-parser"]).htmlToJsObjectLyteRendered = __webpack_exports__["default"];
/******/ 	
/******/ })()
;