/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
/*!*******************************!*\
  !*** ./src/HandleMustache.js ***!
  \*******************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
let errorType = ["Empty Mustache Not allowed", "missing ',' in helper function parameters", "Unexpected token ", "Misplaced ','", "Callback invocation is not supported", "Only helper function calls are allowed", "Syntax error encountered while accessing object", "Syntax Error invalid '.' Dot operator", `String started and never closed`, "Syntax Error unmatched ", " Array Without indexing ", "Syntax Error"]
let capturedError = undefined;

function isAlphaNumeric(code) {
    code = code.charCodeAt(0);
    if ((code > 47 && code < 58) || (code > 64 && code < 91) || (code > 96 && code < 123)) {
        return true;
    }
    return false;
}

function isNumeric(code) {
    code = code.charCodeAt(0);
    if (code > 47 && code < 58) {
        return true;
    }
    return false;
}

function validKeysString(val) {
    return isAlphaNumeric(val) || "!@#$%^&*_+-=".indexOf(val) != -1;
}

function isValidSquareBracket(val) {
    if (isAlphaNumeric(val) || val == "]" || val == ")" || val == "_" || val == "$" || val == " ") {
        return true;
    }
    return false;
}

function isValidDot(val) {
    return isValidSquareBracket(val) || "!@#$%^&*_+-=".indexOf(val) != -1;
}

function updateSqBracket(val) {
    for (let i = 0; i < val.length; i++) {
        val[i]++;
    }
    return val;
}

function isValidVariableName(name) {
    return /^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(name);
}

function getObservedAttributes(str, check) {
    let observedAttributes = [],
        string = "",
        variableStarted = false,
        doubleQuoteStringStarted = false,
        singleQuoteStringStarted = false,
        dotStarted = false;

    for (let i = 0; i < str.length; i++) {
        if (str[i] == "'" && str[i - 1] != "\\") {
            doubleQuoteStringStarted = !doubleQuoteStringStarted;
        } else if (str[i] == '"' && str[i - 1] != "\\") {
            singleQuoteStringStarted = !singleQuoteStringStarted;
        } else if (!doubleQuoteStringStarted && !singleQuoteStringStarted) {
            if (isAlphaNumeric(str[i]) || str[i] == '_') {
                variableStarted = true;
                string += str[i];
            } else {
                if (str[i] == " ") {
                    continue;
                }

                if (dotStarted) {
                    string = ""
                    if (str[i] != ".") {
                        dotStarted = false;
                    } else {
                        continue;
                    }
                }
                if (str[i] == ".") {
                    dotStarted = true;
                }
                if (string.length > 0 && str[i] != '(' && isValidVariableName(string)) {

                    check.observedAttributes[string] = true;
                }
                variableStarted = false;
            }
        }
        if (!variableStarted) {
            string = "";
        }
    }
    return observedAttributes
}

function checkForMixedCase(val) {
    let seenDoubleQuotes = false,
        seenSingleQuotes = false,
        mustacheStarted = false,
        mixedCase = false;
    let slashCount = 0;
    let mustacheSpots = [],res = "",mus={};
    for (let i = 0; i < val.length; i++) {
        //remove spaces other than present in double and single quotes
        if (mustacheStarted && ((seenDoubleQuotes || seenSingleQuotes) || val[i].match(/\S/))) {
            res += val[i];
        }
        if (val[i - 1] != "\\" && val[i] == "{" && val[i + 1] == "{" && !seenDoubleQuotes && !seenSingleQuotes) {
            if(mustacheStarted){
                return {
                    bool:false,
                    errorIndex:i-mus.index[0]+1,
                    err:"Invalid dynamic value inside dynamic value `{{`"
                };
            }
            if (!mixedCase && i != 0) {
                mixedCase = true
            }
            mus = {}
            mus.index = [i];
            // spot[0] = i;
            mustacheStarted = true;
        }
        if (val[i] == "}" && val[i + 1] == "}" && !seenDoubleQuotes && !seenSingleQuotes && mustacheStarted) {
            if (!mixedCase && i + 1 != val.length - 1) {
                mixedCase = true
            }
            // spot[1] = i + 1;
            mus.index[1] = i + 1;
            mus.orgMus = val.substring(mus.index[0],mus.index[1]+1);
            mus.mus = "{"+res+"}";
            res = "";
            mustacheSpots.push(mus);
            mustacheStarted = false;
        }
        if (val[i] == "\\") {
            slashCount++;
        }
        if (val[i - 1] != "\\" || (val[i - 1] == "\\" && slashCount % 2 == 0)) {
            if (val[i] == "'" && !seenDoubleQuotes && mustacheStarted) {
                seenSingleQuotes = !seenSingleQuotes;
            }
            if (val[i] == '"' && !seenSingleQuotes && mustacheStarted) {
                seenDoubleQuotes = !seenDoubleQuotes;
            }
        }
        if (val[i] != "\\") {
            slashCount = 0;
        }

    }
    return {
        bool:true,
        mixedCase: mixedCase,
        mustacheSpots: mustacheSpots
    };
}

function getLineAndColIndex(val, obj, mSpot) {
    let beforeContextSplit = val.substring(0, mSpot).split("\n");
    return {
        colIndex: (beforeContextSplit.length - 1) ? beforeContextSplit[beforeContextSplit.length - 1].length : obj.colIndex + mSpot,
        lineIndex: obj.lineIndex + beforeContextSplit.length - 1
    };
}

function syntaxCheckWorkerNew(val, check = undefined, errorObj = {}, index,attr) {
    // val = val.trim();
    if (!check.Compile) {
        console.error("Error: `can't get trimAttr scope`");
        return {
            text: val
        };
    } else {
        let syn = undefined;
        let observedAttributes = undefined;
        let mixedCaseCheck = false;
        let origMustache = val;
        if (val.indexOf("{{") !== -1) {
            attr && (val = val.trim().replace(/^@nbsp@|@nbsp@$/gm,""));
            //   let  tempVal =val.match(/{{[^}]*?(?:(?:[^\1]*?\1)[^}]*?)*}}/g)
            let tempCopy, valCopy = val;
            let res = checkForMixedCase(val);
            if (res.bool) {
                const {
                    mixedCase,
                    mustacheSpots
                } = res;
                mixedCaseCheck = mixedCase;
                if (mustacheSpots.length && mustacheSpots.length > 0) {
                    for (let j = 0; j < mustacheSpots.length; j++) {
                        let mustache = mustacheSpots[j].mus,//valCopy.substring(mustacheSpots[j][0], mustacheSpots[j][1] + 1),
                            x = mustache,
                            spots = mustacheSpots[j].index;
                        if(mustache.match(/\&|\||\!|\=|\+|-|\*|\/|<|>|\?|:|%/gm)){
                            x = check.Compile.trimAttr(mustache, [], {}, undefined, "", check);
                            
                        }
                        val = val.replace(mustacheSpots[j].orgMus, () => {
                            return x;
                        });
                        tempCopy = x;
                        syn = processAttr(x);
                        if (!syn.bool) {
                            if (errorObj.hasOwnProperty("mustacheSyntax")) {
                                syn = Object.assign(syn, getLineAndColIndex(val, index, spots[0]));
                                syn.dynamicValue = x;
                                syn.fileName = check.fileName;
                                syn.musEnd = getLineAndColIndex(val, index, spots[1]);
                                errorObj.mustacheSyntax.arr.push(syn);
                                if (errorObj.mustacheSyntax.obj[errorType[syn.errType]]) {
                                    errorObj.mustacheSyntax.obj[errorType[syn.errType]].push(check.fileName)
                                } else {
                                    errorObj.mustacheSyntax.obj[errorType[syn.errType]] = [check.fileName]
                                }
                            }
                        }
                        if (check && check.emberFlag && ((syn && syn.bool) || (!capturedError))) {
                            getObservedAttributes(tempCopy, check);
                        }

                    }
                } else {
                    syn = processAttr(val);
                    if (!syn.bool) {
                        syn.dynamicValue = val;
                        if ( errorObj.hasOwnProperty("mustacheSyntax") ) {
                            syn = Object.assign(syn, getLineAndColIndex(val, index, val.indexOf("{{")));
                            syn.fileName = check.fileName;
                            errorObj.mustacheSyntax.arr.push(syn);
                            if (errorObj.mustacheSyntax.obj[errorType[syn.errType]]) {
                                errorObj.mustacheSyntax.obj[errorType[syn.errType]].push(check.fileName)
                            } else {
                                errorObj.mustacheSyntax.obj[errorType[syn.errType]] = [check.fileName]
                            }
                        }
                    }
                }
            }
            else{
                res = Object.assign(res, getLineAndColIndex(val, index, val.indexOf("{{")));
                res.dynamicValue = val;
                res.fileName = check.fileName;
                errorObj.mustacheSyntax.arr.push(res);
                if (errorObj.mustacheSyntax.obj[res.err]) {
                    errorObj.mustacheSyntax.obj[res.err].push(check.fileName)
                } else {
                    errorObj.mustacheSyntax.obj[res.err] = [check.fileName]
                }
            }
        }
        if (!check.fromInternal && check.withoutTemplateConversion) {
            val = origMustache;
        }
        val = val.replace(/@nbsp@/gm, "&nbsp;");
        return {
            text: val,
            type: syn ? ((mixedCaseCheck) ? "Mixed" : syn.type) : syn,
            "observedAttributes": (observedAttributes && observedAttributes.length > 0) ? observedAttributes : undefined
        };
    }
}

function processAttr(val) {
    let parsingMustache,
        mustacheIndex = 0,
        typeStarted,
        type = null,
        mustache = 0,
        retObj = {
            mustache: 0,
            bool: true,
            err: null,
            errorIndex: 0
        },
        valueBeforeSpace = undefined,
        stringStartIndex = 0,
        seenTextBeforeNextcomma = undefined,
        seenTokenBefore = false,
        stringStartCheck = false,
        dotStarted = false;
    if (val == '{{}}') {
        retObj.bool = false;
        retObj.err = errorType[0];
        retObj.errType = 0;
        retObj.errorIndex = 0;
        return retObj;
    }
    for (let i = 0; i < val.length; i++) {
        if (parsingMustache) {
            if ((validKeysString(val[i]))) {
                if ((!stringStarted && !dotStarted && "!@#%^&*+-=".indexOf(val[i]) != -1) || (val[i - 1] == " " && seenTokenBefore) || (stringStartCheck && val[i - 1] == " ")) {
                    retObj.bool = false;
                    retObj.err = errorType[2] + val[i];
                    retObj.errType = 2;
                    retObj.errorIndex = i;
                    return retObj;
                }
                if (!stringStarted) {
                    seenTokenBefore = true;
                }

            } else if (val[i] != " ") {
                if (!stringStarted && (val[i] == "'" || val[i] == '"')) {
                    if (val[i - 1] == " " && seenTokenBefore) {
                        retObj.bool = false;
                        retObj.err = errorType[2] + val[i];
                        retObj.errType = 2
                        retObj.errorIndex = i;
                        return retObj;
                    }
                }
                if (!stringStarted && val[i] == ".") {
                    dotStarted = true;
                } else {
                    dotStarted = false;
                }
                stringStartCheck = false;
                seenTokenBefore = false;
            }
            if (seenTextBeforeNextcomma == false && val[i] != " " && val[i] != ",") {
                seenTextBeforeNextcomma = true;
            }
            if (sqBrackets.length > 0 && ![" ", "]", "["].includes(val[i])) {
                sqBrackets = updateSqBracket(sqBrackets);
            }
            if (spaceStarted && val[i] == "," && !stringStarted) {
                spaceStarted = false;
                valueBeforeSpace = undefined;
            }
            // console.log(val[i],stringStarted)

            if (!stringStarted && !commaSeen && isAlphaNumeric(val[i]) && ((valueBeforeSpace && isAlphaNumeric(valueBeforeSpace)) || (valueBeforeSpace && ["'", '"'].includes(valueBeforeSpace)) || ["'", '"'].includes(val[i - 1]))) {
                // console.log(1)
                retObj.bool = false;
                retObj.err = errorType[2] + val[i];
                retObj.errType = 2
                retObj.errorIndex = i;
                return retObj;
            }
            if (spaceStarted && ![",", " "].includes(val[i]) && !stringStarted && !commaSeen && paranthesis != 0) {

                if (val[i] == "(" || val[i] == "[" || ((val[i] == ")" || val[i]=="'" || val[i] == '"')  && paranthesis >= 1) || (val[i] == "]" && squareBracketCount >= 1) || isAlphaNumeric(val[i])) {
                    spaceStarted = false;
                    valueBeforeSpace = undefined;
                }
                else {
                    // console.log(2)
                    retObj.bool = false;
                    retObj.err = errorType[2] + val[i];
                    retObj.errType = 2
                    retObj.errorIndex = i;
                    return retObj;
                }
            } else if (!stringStarted && "," == val[i] && paranthesis == 0) {
                // console.log(3)
                retObj.bool = false;
                retObj.err = errorType[3];
                retObj.errType = 3
                retObj.errorIndex = i;
                return retObj;
            } else if (!stringStarted && val[i] == ',') {
                if (seenTextBeforeNextcomma == false) {
                    // param check case
                    // console.log("Found the spot dood!!",val.substr(i))
                    seenTextBeforeNextcomma = false
                }
                seenTextBeforeNextcomma = false;
                commaSeen = true;
            }

            if (checkThis) {
                if (![",", " ", "}"].includes(val[i])) {
                    if ([")", "]"].includes(checkThis) || (['"', "'"].includes(checkThis) && !stringStarted)) {
                        if (((val[i] == ")" && paranthesis >= 0) || (val[i] == "]" && sqBrackets.length > 0) || (val[i] == '[') || (val[i] == '.'))) {
                            checkThis = undefined;
                        }
                        // else if (val[i] == ")" && checkThis == "[" && paranthesis == 0) {
                        //     checkThis = undefined;
                        // }
                        else if (!commaSeen && !spaceStarted && !stringStarted && !(!stringStarted && checkThis == '"') && !(!stringStarted && checkThis == "'")) {
                            if (paranthesis > 0 && checkThis == ']') {
                                // console.log(4)
                                retObj.bool = false;
                                retObj.err = errorType[4];
                                retObj.errType = 4
                                retObj.errorIndex = i;
                                return retObj;
                            } else {
                                retObj.bool = false;
                                if (val[i] == '(' && checkThis == ')') {
                                    retObj.err = errorType[11];
                                    retObj.errType = 11
                                    retObj.errorIndex = i;
                                    return retObj;
                                }
                                if (val[i] == ']' && checkThis == ')') {
                                    retObj.err = errorType[5];
                                    retObj.errType = 5
                                    retObj.errorIndex = i;
                                    return retObj;
                                }
                                if ((val[i] == ']' && checkThis != ']') || (val[i] == ')' && checkThis != ')')) {
                                    retObj.err = errorType[11]
                                    retObj.errType = 11;
                                    retObj.errorIndex = i;
                                    return retObj;
                                }
                                if (val[i - 1] == ')') {
                                    retObj.err = errorType[2]
                                    retObj.errType = 2
                                    retObj.errorIndex = i;
                                    return retObj;
                                }

                            }
                        }
                    } else if (checkThis == '.') {
                        if (val[i].toUpperCase() != val[i].toLowerCase() || "!@#$%^&*_+-={}".indexOf(val[i]) != -1 || isNumeric(val[i])) {
                            checkThis = undefined;
                        } else if (!spaceStarted) {
                            retObj.bool = false;
                            retObj.err = errorType[6];
                            retObj.errType = 6
                            // console.log(6);
                            retObj.errorIndex = i;
                            return retObj;
                        }
                    }
                } else if (!stringStarted && val[i] == "," && paranthesis == 0) {

                    retObj.bool = false;
                    retObj.err = errorType[11];
                    retObj.errType = 11
                    // console.log(7);
                    retObj.errorIndex = i;
                    return retObj;

                } else if (!stringStarted && val[i] == ',') {
                    checkThis = undefined;
                }
            }
            if (paranthesis == 0 && val[i - 1] == ')' && ['.', '['].includes(val[i])) {
                type = "Extra Helper"
            }
            if (val[i] == "\\") {

                // if ( !(stringStarted && (i + 1 < val.length) && ['"', "'", '?', '\\'].includes(val[i + 1])) ){
                // console.log(val.substring(i), val[i], val[i + 1], stringStarted)
                // retObj.bool = false;
                // retObj.err = "Syntax Error invalid escape sequence";
                // retObj.errorIndex = i;
                // return retObj;
                // }
                i = i + 1;
            } else if (val[i] == "'") {
                if (lastString != '"') { //val[i-1] != "\\"  && 
                    if (!stringStarted) {
                        if(!(paranthesis>0 || (squareBracket && squareBracket.length>0))){
                            retObj.bool = false;
                            retObj.err = errorType[2]+ "'";
                            retObj.errType = 2;
                            retObj.errorIndex = i;
                            return retObj;
                        }
                        quotesBracket.push("'")
                        stringStarted = true;
                        stringStartIndex = i;
                        lastString = "'";
                    } else {
                        let count = undefined;
                        if (val[i - 1] == "\\") {
                            count = 0;
                            for (let j = i - 1; j >= 0; j--) {
                                if (val[j] == "\\") {
                                    count++;
                                } else {
                                    break;
                                }
                            }
                        }
                        if (count == undefined || count % 2 == 0) {
                            quotesBracket.pop("'")
                            stringStarted = false;
                            stringStartCheck = true;
                            lastString = undefined;
                        }
                    }

                }
            } else if (val[i] == '"') {

                if (lastString != "'") { //val[i-1] != "\\" &&
                    if (!stringStarted) {
                        if(!(paranthesis>0 || (squareBracket && squareBracket.length>0))){
                            retObj.bool = false;
                            retObj.err = errorType[2]+ '"';
                            retObj.errType = 2;
                            retObj.errorIndex = i;
                            return retObj;
                        }
                        quotesBracket.push('"')
                        stringStarted = true;
                        stringStartIndex = i;
                        lastString = '"'
                    } else {
                        let count = undefined;
                        if (val[i - 1] == "\\") {
                            count = 0;
                            for (let j = i - 1; j >= 0; j--) {
                                if (val[j] == "\\") {
                                    count++;
                                } else {
                                    break;
                                }
                            }
                        }
                        if (count == undefined || count % 2 == 0) {
                            quotesBracket.pop('"')
                            stringStarted = false;
                            stringStartCheck = true;
                            lastString = undefined;
                        }
                    }
                }
            } else if (val[i] == "{" && !stringStarted && dotStarted) {
                retObj.bool = false;
                retObj.err = errorType[2] + "'{' bracket ";
                retObj.errType = 2
                // console.log(8);
                retObj.errorIndex = i;
                return retObj;
            } else if (val[i] == "{" && stringStarted && val[i - 1] == "{") {
                retObj.mustache++;
            } else if (val[i] == "}" && val[i - 1] == "}" && !stringStarted) {
                if (curlyBracket.length) {
                    retObj.bool = false;
                    retObj.err = errorType[9] + "'(' bracket ";
                    retObj.errType = 9
                    // console.log(9);
                    retObj.errorIndex = i;
                    return retObj;
                }
                if (squareBracket.length) {
                    retObj.bool = false;
                    retObj.err = errorType[9] + "'[' bracket ";
                    retObj.errType = 9
                    // console.log(10);
                    retObj.errorIndex = i;
                    return retObj;
                }
                parsingMustache = false;

            } else if (val[i] == "[" && !stringStarted) {
                if (isValidSquareBracket(val[i - 1])) {
                    squareBracket.push("[");
                    sqBrackets.push(0);
                }
                //  else {
                //     retObj.bool = false;
                //     retObj.err = "Syntax Error invalid '"+val[i-1]+"'";
                //     retObj.errorIndex = i;
                //     return retObj;
                // }
                if (!typeStarted) {
                    typeStarted = 1
                }
                if (typeStarted == 1) {
                    if (!squareBracketCount && squareBracketCount != 0) {
                        squareBracketCount = 1
                    } else {
                        squareBracketCount += 1;
                    }

                    if (squareBracketCount > 1) {
                        type = "Multi-dimensional array"
                    }

                }

            } else if (val[i] == "]" && !stringStarted) {
                let check;
                if (squareBracket.length) {
                    squareBracket.pop();
                    check = sqBrackets.pop();
                } else {
                    retObj.bool = false;
                    retObj.err = errorType[9] + "']' bracket ";
                    retObj.errType = 9
                    retObj.errorIndex = i;
                    return retObj;
                }
                if (check == 0) {
                    retObj.bool = false;
                    retObj.err = errorType[10];
                    retObj.errType = 10;
                    retObj.errorIndex = i;
                    return retObj;
                }
                squareBracketCount -= 1;

            } else if (val[i] == "(" && !stringStarted) {
                if (i > 0 && (isAlphaNumeric(val[i - 1]) || val[i] == '_')) {
                    curlyBracket.push('(');
                } else {
                    // console.log(12);
                    retObj.bool = false;
                    retObj.err = errorType[2];
                    retObj.errType = 2;
                    retObj.errorIndex = i;
                    return retObj;
                }
                paranthesis += 1
                if (paranthesisLog == 0) {
                    continue;
                }
                if (!typeStarted) {
                    typeStarted = 2
                }
                if (typeStarted == 1 && squareBracketCount > 0) {
                    type = "Multi-dimensional array"
                }
                if (typeStarted == 3 && sqBrackets.length == 0) {
                    retObj.bool = false;
                    retObj.err = errorType[5];
                    retObj.errType = 5;
                    // console.log(13);
                    retObj.errorIndex = dotIndex;
                    return retObj;
                }
                if (typeStarted == 2) {
                    if (!paranthesisLog && paranthesisLog != 0) {
                        paranthesisLog = 1
                    } else {
                        paranthesisLog += 1;
                    }
                    if (paranthesisLog > 1) {
                        type = "helper"
                    }
                }
            } else if (val[i] == ")" && !stringStarted) {
                if (curlyBracket.length) {
                    curlyBracket.pop();
                } else {
                    retObj.bool = false;
                    retObj.err = errorType[9] + "')' bracket ";
                    retObj.errType = 9
                    retObj.errorIndex = i;
                    return retObj;
                }
                paranthesis -= 1;
                paranthesisLog -= 1;
                if (!typeStarted) {
                    typeStarted = 2;
                }
                if (typeStarted == 2) {
                    if (paranthesisLog == 0 && !type) {
                        type = "helper";
                    }
                }
            } else if (val[i] == "." && !stringStarted) {

                if (!isValidDot(val[i - 1])) {
                    retObj.bool = false;
                    retObj.err = errorType[7];
                    retObj.errType = 7;
                    retObj.errorIndex = i;
                    return retObj;
                }
                if (!typeStarted) {
                    typeStarted = 3;
                }
                if (typeStarted == 1 && sqBrackets.length > 0) {
                    type = "Multi-dimensional array"
                }
                dotIndex = i;
            } else {
                if ((isAlphaNumeric(val[i]) || val[i] == "_") && !stringStarted) {
                    if (val[i + 1] == "'" || val[i + 1] == '"') {
                        retObj.bool = false;
                        retObj.err = errorType[2] + val[i + 1];
                        retObj.errType = 2
                        // console.log(14);
                        retObj.errorIndex = i + 1;
                        return retObj;
                    }
                }
            }

            if (!stringStarted && commaSeen && ![" ", ","].includes(val[i])) {
                if (seenTextBeforeNextcomma == false) {
                    seenTextBeforeNextcomma = false;
                    // param check case
                    // console.log("Found the spot dood!!",val.substr(i))
                }
                commaSeen = false;
                seenTextBeforeNextcomma = undefined;
            }
            if (paranthesis > 0) {
                if (val[i + 1] == " " && !stringStarted) {
                    spaceStarted = true;
                    valueBeforeSpace = val[i];
                    continue;
                }
                if (spaceStarted) {
                    continue;
                }

            };
            if (!stringStarted && paranthesis >= 0 && [")", "]", ".", "'", '"'].includes(val[i])) {
                checkThis = val[i];

            }

        } else if ((val[i] == "{" && val[i - 1] == "{" && val[i - 2] != "\\")) {
            mustache++;
            var curlyBracket = [],
                squareBracket = [],
                stringStarted, lastString, quotesBracket = [],
                paranthesis = 0,
                squareBracketCount, //typeStarted 1:Array 2:helpers 3:Dict or Object 
                spaceStarted, checkThis, paranthesisLog, emptyArrayDetector = true,
                sqBrackets = [],
                commaSeen,
                dotIndex;
            typeStarted = null;
            type = null;
            parsingMustache = true;
            checkThis = undefined;
            mustacheIndex = i;
            // 
        }
    }
    if (stringStarted) {
        retObj.bool = false;
        retObj.err = errorType[8];
        retObj.errType = 8;
        retObj.errorIndex = stringStartIndex;
        return retObj;
    }
    if (parsingMustache) {
        retObj.bool = false;
        retObj.err = errorType[9] + "'{' bracket";
        retObj.errType = 9;
        retObj.errorIndex = mustacheIndex; //harish check
        return retObj;
    }
    if (!type) {
        type = "Normal Data"
    }
    if (mustache > 1) {
        {
            type = "mixed mustache";
        }
    }
    retObj.type = type;
    return retObj;
}
// console.log(processAttr("{{obbHelp(obb,obb.{})}}"))
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (syntaxCheckWorkerNew);
// let str = "{{if(ifEquals(module_info.show_zf_panel,0),,'zfGetStartInit')}}"
// console.log(str)
// let err = processAttr(str)
// if(err.bool === false){
//     console.log(err)
//     console.log(str.substr(err.errorIndex))
// }
// ls = [
//     "{{dynamicData}}",
//     "{{dynamicData[data.some][someNumber].key['a']}}",
//     "{{$lg.dynamicData}}",
//     "{{object[key.name]}}",
//     "{{helper()}}",
//     "{{ helper('anything##(*(*&*&*}}\"', data) }}",
//     "{{ helper(anotherHelper(), 'something', newHelper(data))}}",
//     "{{helper().something}}", //future
//     "{{helper().something[data].key.a.b}}", //future
//     "{{dynamichelper()[some]}}",
//     "{{ dynamichelper()[somehelper()]}}",
//     "{{array[someNewArray[data]]}}",
//     "{{array[helper()]}}",
//     "{{helper(arr[arr[0]])}}",
// ]

// let invalid = [
//     "{{dynamic{{val}}}} ",
//     "{{dynamichelper()helper()}}",
//     "{{dynamichelper()()}}",
//     "{{()dynamichelper()}}",
//     "{{[]dynamichelper()}}",
//     "{{.dynamichelper()}}",
//     "{{}}",
//     "{{helper(abc),newHelper()}}",
//     "{{name.some()}}",
//     "{{arr[]}}",
//     "{{helper()aa}}",
//     "{{helper(data1'string')}}",
//     "{{arr[0]()}}"
// ]

// for (let i = 0; i < invalid.length; i++){
//     console.log(syntaxCheckWorkerNew(invalid[i]),invalid[i])
// }


// testCasesInFile =[ 
//     "{{newHelp(h1(h2(h3(h4(h5('a'),help(obj.something1.something2.something3.something4.something5.something6.something7.something8),help(arr[0],arr1[0][1],arr2[0][0][0])),help(obj.something1.something2.something3.something4.something5.something6.something7.something8))),objArrMix.something1.something2[zero].something3[bigDataBigDataBigDataBigDataBigDataBigDataBigDataBigData][obj.something1.something2.something3.something4.something5.something6.something7.something0][sampObj.a].something5.something6.something7.something8[0].arr[1]))}}",
//     "{{newHelp(returnNum(123),returnStr('str'),returnObj(sampObj),returnBool(flag), returnArr(arr))}}",
//     "{{ 'sample'}}",
//     "{{newHelp(h1(h2(h3(h4(h5('a'))))))}}",
//     "{{help(objArrMix.something1.something2[zero].something3[bigDataBigDataBigDataBigDataBigDataBigDataBigDataBigData][obj.something1.something2.something3.something4.something5.something6.something7.something0][sampObj.a].something5.something6.something7.something8[0].arr[1])}}",
//     "{{help(arrObj[zero].something)}}",
//     "{{help('a','abc{{def')}}",
//     "{{help('a','\@')}}",

//     "{{help('str', 'hello\\'s' , 'hello\\\'s','hello\\\\\'s')}}",
// ]

// console.log(testCasesInFile[testCasesInFile.length-1])
// for (let i = 0; i < testCasesInFile.length;i++)
Object(window["html-parser"]).HandleMustache = __webpack_exports__["default"];
/******/ })()
;