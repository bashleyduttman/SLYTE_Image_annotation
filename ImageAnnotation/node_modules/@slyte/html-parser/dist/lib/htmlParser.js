//ignorei18n_start
// const fs = __non_webpack_require__("fs");
// const fs = eval('require("fs")')
const HTMLParser = (function () {

    const regexFor = {
        // startTag: /^<(?<nodeName>[a-zA-Z][-a-zA-Z0-9_]*)(?<attributes>(?:\s*[a-zA-Z_:!0-9,][-a-zA-Z0-9_:%."'`;]*(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|{{[^>}]*}}|\w*|[^>]+))?)*)\s*(\/?)>/,
        endTag: /^<\/(?<nodeName>[a-zA-z][-a-zA-Z0-9_]*)(?<attributes>(?:\s*[a-zA-Z_:!0-9,][-a-zA-Z0-9_:%."'`;]*(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>]+))?)*)\s*(\/?)>/,
        attr: /([a-zA-Z0-9_:!'"},@{][-a-zA-Z0-9_:."'`%;{]*)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|([^>\s]+)))?/g,
    }
    let paragraphTagStarted = 0;
    let willHaveUnclosedClosingTag = false;
    let doNotCheckThisTag = "";
    let restCopy = "";
    let checkClosingTag = false;
    let flag = false;
    let seenSVGBefore = 0;
    let seenSvgMiddleMenBefore = 0;
    let seenPreBefore = false;
    let seenTableBefore = 0;
    // let doCheckUntil = undefined;
    const svgCamelCaseTags = {
        "filterunits":"filterUnits",
        "allowreorder": "allowReorder",
        "attributename": "attributeName",
        "attributetype": "attributeType",
        "autoreverse": "autoReverse",
        "basefrequency": "baseFrequency",
        "baseprofile": "baseProfile",
        "calcmode": "calcMode",
        "clippathunits": "clipPathUnits",
        "contentScriptType": "contentScriptType",
        "contentstyletype": "contentStyleType",
        "diffuseconstant": "diffuseConstant",
        "edgemode": "edgeMode",
        "externalresourcesrequired": "externalResourcesRequired",
        "filterres": "filterRes",
        "filterUnits": "filterUnits",
        "glyphref": "glyphRef",
        "gradienttransform": "gradientTransform",
        "gradientunits": "gradientUnits",
        "kernelmatrix": "kernelMatrix",
        "kernelunitlength": "kernelUnitLength",
        "keypoints": "keyPoints",
        "keysplines": "keySplines",
        "keytimes": "keyTimes",
        "lengthadjust": "lengthAdjust",
        "limitingconeangle": "limitingConeAngle",
        "markerheight": "markerHeight",
        "markerunits": "markerUnits",
        "markerwidth": "markerWidth",
        "maskcontentunits": "maskContentUnits",
        "maskunits": "maskUnits",
        "patterncontentunits": "patternContentUnits",
        "patterntransform": "patternTransform",
        "patternunits": "patternUnits",
        "pointsatx": "pointsAtX",
        "pointsaty": "pointsAtY",
        "pointsatz": "pointsAtZ",
        "preservealpha": "preserveAlpha",
        "preserveaspectratio": "preserveAspectRatio",
        "primitiveunits": "primitiveUnits",
        "repeatcount": "repeatCount",
        "repeatdur": "repeatDur",
        "requiredextensions": "requiredExtensions",
        "requiredfeatures": "requiredFeatures",
        "specularconstant": "specularConstant",
        "specularexponent": "specularExponent",
        "spreadmethod": "spreadMethod",
        "startoffset": "startOffset",
        "stddeviation": "stdDeviation",
        "stitchtiles": "stitchTiles",
        "surfacescale": "surfaceScale",
        "systemlanguage": "systemLanguage",
        "tablevalues": "tableValues",
        "textlength": "textLength",
        "viewbox": "viewBox",
        "viewtarget": "viewTarget",
        "xchannelselector": "xChannelSelector",
        "ychannelselector": "yChannelSelector",
        "refx": "refX",
        "refy": "refY",
        "targetx": "targetX",
        "targety": "targetY",
        "numoctaves": "numOctaves",
        "zoomandpan": "zoomAndPan",
    }
    const chromeChangedTags = {
        "image":"img"
    }
    const createMapFor = function (array) {
        return array.reduce(function (acc, item) {
            acc[item] = true;
            return acc;
        }, {});
    }
    //seenSVGBefore should not process this tags
    const svgMiddleMen = createMapFor(['foreignobject']);
    const svgSelfClosingTags = createMapFor([
        'circle',
        'ellipse',
        'line',
        'path',
        'polygon',
        'polyline',
        'rect',
        'use',
        'title',
        'stop'
    ])
    const tableTags = createMapFor(["tbody", "thead", "tfoot", "colgroup", "caption", "tr", "th", "td", "col"])

    const EMPTY_ELEMENTS = createMapFor([
        "area",
        "base",
        "basefont",
        "br",
        "col",
        "frame",
        "hr",
        "img",
        "track",
        "input",
        "link",
        "meta",
        "param",
        "embed",
        "command",
        "keygen",
        "source",
        "wbr",
        "circle",
        "ellipse",
        "line",
        "polyline",
        "rect",
    ]);
    const SELF_CLOSING = createMapFor([
        "colgroup",
        "dd",
        "dt",
        "li",
        "options",
        "p",
        // "td",
        // "tfoot",
        // "th",
        // "thead",
        // "tr"
    ]);
    let selfClosingTags = createMapFor(['style', 'area', 'base', 'br', 'col', 'embed', 'hr', 'input', 'keygen', 'link', 'meta', 'param', 'wbr', 'img', 'track']);
    let notAllowedTagsInsideParagraphTag = createMapFor(["div", "table", "body", "h1", "h2", "h3", "h4", "h5", "h6","ul","li"]);
    const SPECIAL_ELEMENTS = createMapFor([
        'style',
        'script'
    ]);
    const nodeStartStack = []
    return function (htmlString, callbacks, emberFlag, fileName,errorObj,withoutTableProcessing, lineIndex = 1, colIndex = 0) {
        let hasUnparsedChars;
        let match;
        let mismatchColIndex = {};
        let stack = [];
        seenSVGBefore = 0,seenSvgMiddleMenBefore = 0,seenTableBefore = 0;
        // let checkList = [];
        let stringInPrevLoopState = htmlString;
        let elemStack = [];
        let seenTemplate = false;
        stack.getLastItem = function () {
            return this[this.length - 1];
        };
        elemStack.getLastItem = function () {
            return this[this.length - 1];
        }
        // checkList.getLastItem = function () {
        //   return this[this.length - 1];
        // };
        function validateTagName(str, errorObject) {
            str = str.trim()
            if (str.length == 0 || !(/^[a-zA-Z_][-a-zA-Z0-9_]*$/).test(str)) {
                errorObject.bool = false;
                errorObject.error = "Invalid tag name :`"+"<"+str+"`";
                errorObject.fromParser = true;
                return false;
            }
            return chromeChangedTags[str] ? chromeChangedTags[str] : str;
        }

        function getStartTag(str) {
            try {
                let foundTagName = false,
                    tagName = "",
                    errorObject = {
                        bool: true
                    },
                    doubleQuotesStarted = false,
                    dIndex = 0,
                    singleQuotesStarted = false,
                    sIndex = 0,
                    mustacheStarted = 0,
                    mIndex = 0,
                    attrStartIndex = 0,
                    tickStarted = false;
                // foundEqualTo = false;

                for (let i = 0; i < str.length; i++) {
                    if (!foundTagName) {
                        if (str[i] == " " || str[i] == "\n" || str[i] == "/" || str[i] == "\t") {
                            tagName = validateTagName(tagName, errorObject)
                            if (!tagName) return errorObject;
                            foundTagName = true
                            attrStartIndex = i;
                            continue;
                        }
                        if (str[i] == ">") {
                            tagName = validateTagName(tagName, errorObject)
                            if (!tagName) return errorObject;
                            let res = ["<" + str.substring(0, i + 1), tagName, "", "", "<" + str];
                            res.bool = true;
                            return res;
                        }
                        if (str[i] == "/" && str[i + 1] == ">") {
                            tagName = validateTagName(tagName, errorObject)
                            if (!tagName) return errorObject;
                            let res = ["<" + str.substring(0, i + 1), tagName, "", "/", "<" + str];
                            res.bool = true;
                            return res;
                        }
                        tagName += str[i];
                        continue;
                    }
                    if (str[i] == "`" && str[i - 1] != "\\" && !doubleQuotesStarted && !singleQuotesStarted) {
                        // if(tickStarted){
                        //     foundEqualTo = false;
                        // }
                        tickStarted = !tickStarted;
                        sIndex = i + 1;
                    }
                    if (str[i] == "'" && str[i - 1] != "\\" && !doubleQuotesStarted && !tickStarted) {
                        // if(singleQuotesStarted){
                        //     foundEqualTo = false;
                        // }
                        singleQuotesStarted = !singleQuotesStarted;
                        sIndex = i + 1;
                    }
                    if (str[i] == '"' && str[i - 1] != "\\" && !singleQuotesStarted && !tickStarted) {
                        // if(doubleQuotesStarted){
                        //     foundEqualTo = false;
                        // }
                        doubleQuotesStarted = !doubleQuotesStarted;
                        dIndex = i + 1;
                    }

                    if (!tickStarted && !singleQuotesStarted && !doubleQuotesStarted && str[i] == "{" && str[i + 1] == "{") {

                        mustacheStarted = true;
                        mIndex = i;
                    }
                    if (!tickStarted && !singleQuotesStarted && !doubleQuotesStarted && str[i] == "}" && str[i + 1] == "}") {
                        // if(mustacheStarted){
                        //     foundEqualTo = false;
                        // }
                        mustacheStarted = false;
                    }
                    // if(str[i] == " " && !doubleQuotesStarted && !singleQuotesStarted && !tickStarted && !mustacheStarted){
                    //     foundEqualTo = false;
                    //   }
                    // if(str[i] == "=" && !tickStarted && !doubleQuotesStarted && !mustacheStarted && !singleQuotesStarted){
                    //     foundEqualTo = true;
                    // }
                    if (!tickStarted && !singleQuotesStarted && !doubleQuotesStarted && !mustacheStarted && str[i] == "<"){
                        // let e  = new Error("Unclosed `>` for the tag "+tagName);
                        errorObject.bool = false;
                        errorObject.error = "Unclosed `>` for the tag `"+tagName+"`";
                        errorObject.fromParser = true;
                        let temp = str.substr(0,i).split("\n");
                        lineIndex+=(temp.length -1);
                        colIndex = temp[temp.length-1].length;
                        return errorObject;
                    }
                    if (!tickStarted && !singleQuotesStarted && !doubleQuotesStarted && !mustacheStarted && str[i] == ">") {
                        let res = [];
                        if (str[i - 1] == "/") {
                            res = ["<" + str.substring(0, i + 1), tagName, str.substring(attrStartIndex, i - 1), "/", "<" + str];
                            res.bool = true;
                            return res;
                        }
                        res = ["<" + str.substring(0, i + 1), tagName, str.substring(attrStartIndex, i), "", "<" + str]
                        res.bool = true;
                        return res;
                    }
                }
                errorObject.bool = false;
                let temp;
                if (singleQuotesStarted) {
                    errorObject.error = "Unclosed Single Quote ";
                    temp = str.substr(0,sIndex).split("\n");
                    lineIndex+=(temp.length -1);
                    colIndex = temp[temp.length-1].length;
                    errorObject.index = str.substring(0, sIndex);
                } else if (doubleQuotesStarted) {
                    errorObject.error = "Unclosed Double Quote ";
                    temp = str.substr(0,dIndex).split("\n");
                    lineIndex+=(temp.length -1);
                    colIndex = temp[temp.length-1].length;
                    errorObject.index = str.substring(0, dIndex);
                } else if (mustacheStarted) {
                    errorObject.error = "Unclosed Mustache ";
                    temp = str.substr(0,mIndex).split("\n");
                    lineIndex+=(temp.length -1);
                    colIndex = temp[temp.length-1].length;
                    errorObject.index = str.substring(0, mIndex);
                } else {
                    errorObject.error = "Unclosed tag `>`";
                }
                return errorObject;
            } catch (e) {
                console.log("Error in parsing")
            }
        }

        function parseStartTag(tag, tagName, rest, unary) {
            if (tagName) {
                let lowerTagName = tagName.toLowerCase();
                if (lowerTagName == "svg") {
                    seenSVGBefore++;
                }
                if (lowerTagName == "pre") {
                    seenPreBefore = true;
                }
                if (lowerTagName == "table") {
                    seenTableBefore += 1;
                }
                if(svgMiddleMen[lowerTagName]){
                    seenSvgMiddleMenBefore++;
                }
                if (seenSVGBefore == 0 && tagName.toLowerCase) {
                    tagName = lowerTagName;
                }
            }
            // @Handle3055 to get precise line and column number
            // if(tagName && !seenPreBefore){
            //   tagName = tagName.replace(/\r?\n|\r/g,' ').replace(/\s+/g,' ');
            //   if (tag) {
            //     tag = tag.replace(/\r?\n|\r/g, ' ').replace(/\s+/g, ' ');
            //   }
            // }
            
            if(unary && !seenSVGBefore && svgSelfClosingTags[tagName]){
                let err = new Error("Error: Invalid svg tag " + tag + "....." );
                err.fromParser =true;
                throw err;
            }
            if (stack.getLastItem() == tagName && SELF_CLOSING[tagName]) {
                parseEndTag("", tagName);
            }
            let matchRes;
            if (tag && (matchRes = tag.match(/(?!({{)|"|'.*)\n(?!.*(}})|"|')/g))) {
                lineIndex = lineIndex + matchRes.length;
                colIndex = matchRes[matchRes.length-1].length;
            }
            let col = colIndex;
            if (tag) {
                colIndex = colIndex + tag.length;
            }

            unary = EMPTY_ELEMENTS[tagName] || !!unary;

            if (!unary) {
                stack.push(tagName);
                if (tagName != "p") {
                    elemStack.push(tagName);
                }

                // if(checkList.length>0){
                //   checkList.push(tagName);
                // }
            }
            doNotCheckThisTag = tagName
            let attrs = [];
            restCopy = rest;
            rest.replace(regexFor.attr, function (match, name) {
                const arg2 = arguments[2];
                const arg3 = arguments[3];
                const arg4 = arguments[4];
                const value = arg2 ? arg2 : (arg3 ? arg3 : (arg4 ? arg4 : ''));
                let quote = name.indexOf("'");
                let err;
                if (quote !== -1) {
                    // console.log("Unclosed Single quote in " + restCopy.substring(0,21) + "...");
                    err =  new Error("Error: Unclosed Single quote in " + tag + "....."+ "</" + tagName+ ">");
                    err.fromParser = true;
                    err.lineIndex = lineIndex;
                    err.colIndex = colIndex;
                    throw err;
                }
                quote = name.indexOf('"')
                if (quote !== -1) {
                    // console.log("Unclosed Double quote in " + restCopy.substring(0,21) + "...");
                    err = new Error("Error: Unclosed Double quote in " + tag.substring(0,100)+ "....."/* + "....." + "</" + tagName+ ">"*/);
                    err.fromParser = true;
                    err.lineIndex = lineIndex;
                    err.colIndex = colIndex;
                    throw err;
                }
                if (name.indexOf("{{") == 0) {
                    // console.log("Invalid Mustache :"+ name+"...")
                    err = new Error("Error: Invalid Mustache : " + name + "...");
                    err.fromParser = true;
                    err.lineIndex = lineIndex;
                    err.colIndex = colIndex;
                    throw err;
                }
                if (seenSVGBefore > 0 && svgCamelCaseTags[name.toLowerCase()]) {
                    name = svgCamelCaseTags[name.toLowerCase()];
                } else {
                    name = name.toLowerCase();
                }
                // let errorChecker = value.match(/(["'`])(?:(?:\\1|(?:(?!\1)).)*)(\1)/)
                // if (errorChecker && errorChecker[0].length != value.length ){
                //   console.warn("Unclosed quotes:) in attribute",value);
                // }
                let obj = {
                    name: name,
                    value: value.replace(/"/g, "&quot;"),
                    escaped: value.replace(/(^|[^\\])"/g, '$1\\\"')
                }
                if(name == "lyte-if" || (name == "is" && value == "if") || name == "lyte-switch" || (name == "is" && value == "switch")|| name == "lyte-for" || (name == "is" && value == "for")||  name == "lyte-for-in" || (name == "is" && value == "forIn")){
                    obj.errorInfo = {
                        name: "errorInfo",
                        details: {
                            tagName: tagName,
                            name: name,
                            value: value.replace(/"/g, "&quot;")
                        }
                    }
                }
                attrs.push(obj);
            });
            if (callbacks.start) {
                if (tag && tag.match(/<.*\/>/g)) {
                    if(!(selfClosingTags[tagName] || svgSelfClosingTags[tagName])){
                        let err = new Error("Invalid self-closing tag `" + tagName + "` in " + (tag+ htmlString).substring(0, 100) + "...");
                        err.fromParser = true;
                        err.lineIndex = lineIndex;
                        err.colIndex = colIndex;
                        throw err;
                    }
                    // attrs.push({
                    //     name: "singleAttribute",
                    //     value: "true",
                    //     escaped: "true" //"
                    // });

                } else {
                    if (!selfClosingTags[tagName]) {
                        nodeStartStack.push(tagName);
                    }
                }
                if (checkClosingTag) {
                    attrs.push({
                        name: "checkClosingTag",
                        value: "true",
                        escaped: "true" //"
                    });
                }
                callbacks.start(tagName, attrs, unary,seenSVGBefore, lineIndex, col);
            }
        }

        function parseEndTag(tag, tagName) {
            if (tagName) {
                let lowerTagName = tagName.toLowerCase();
                // if (doCheckUntil && doCheckUntil == lowerTagName) {
                //     doCheckUntil = undefined;
                // }
                if (lowerTagName == "svg") {
                    seenSVGBefore--;
                }
                if(svgMiddleMen[lowerTagName]){
                    seenSvgMiddleMenBefore--;
                }
                if (lowerTagName == "table") {
                    seenTableBefore--;
                }
                if (lowerTagName == "pre") {
                    seenPreBefore = false;
                }
                if (seenSVGBefore == 0 && tagName.toLowerCase) {
                        tagName = lowerTagName;
                }
                if (tagName != "p" && !EMPTY_ELEMENTS[tagName]) {
                    // console.warn("Issue in Closing tag ", tagName);
                    let lastElem = elemStack.pop();
                    if (lastElem.toLowerCase() != tagName.toLowerCase()) {
                        if (tagName != "template") {
                            let i = elemStack.length - 1;
                            for (; i >= 0; i--) {
                                if (elemStack[i] == tagName) {
                                    break;
                                }
                            }
                            let removeIndex = i;
                            for (; i > 0; i--) {
                                if (elemStack[i] == "template") {
                                    elemStack.splice(removeIndex, 1);
                                    break;
                                }
                            }
                            elemStack.push(lastElem);
                            return;
                        }
    
                        // else{
                        //   tagName = lastElem;
                        //   let i = elemStack.length - 1;
                        //   for (; i >= 0; i--) {
                        //     if (elemStack[i] == lastElem) {
                        //       elemStack[i] = tagName;
                        //       break;
                        //     }
                        //   }
                        // }
    
                    }
                }
            }
            
            // @Handle3055 to get precise line and column number
            // if(tagName && !seenPreBefore){
            //   tagName = tagName.replace(/\r?\n|\r/g,' ').replace(/\s+/g,' ');
            //   if(tag){
            //   tag = tag.replace(/\r?\n|\r/g,' ').replace(/\s+/g,' ');
            //   }
            // }
            
            

            // if (checkList.length > 0) {
            //   if (checkList.getLastItem() == tagName) {
            //     checkList.pop();
            //   }
            //   else {
            //     debugger;
            //   }
            // }
            if (tag) {
                colIndex += tag.length;
            }
            let pos;
            if (!tagName) {
                pos = 0;
            } else {
                for (pos = stack.length - 1; pos >= 0; pos--) {
                    if (stack[pos] == tagName) {
                        break;
                    }
                }
            }
            if (pos >= 0) {
                for (let i = stack.length - 1; i >= pos; i--) {
                    if (callbacks.end) {
                        callbacks.end(stack[i], stack[i] != tagName, this && this.misMatchCase ? this.misMatchCase : null, ((seenSvgMiddleMenBefore>0)?0:seenSVGBefore));
                    }
                }
                stack.length = pos;
            }
            // </br> handled this here
            else if (tagName == "br") {
                parseStartTag(null, tagName, "", null);
            }
        }
        const replacerFn = function (all, text) {
            // @Handle3055 to get precise line and column number
            let matchRes;
            if (text && (matchRes = text.match(/(?!({{)|"|'.*)\n(?!.*(}})|"|')/g))) {
                lineIndex += matchRes.length;
                colIndex = matchRes[matchRes.length - 1].length;
            }
            
            // if(!seenPreBefore && text){
            //   text = text.replace(/\r?\n|\r/g,' ').replace(/\s+/g,' ');
            // }
            text = text.replace(/<!--([\s\S]*?)-->|<!\[CDATA\[([\s\S]*?)]]>/g, "$1$2");
            let col = colIndex;
            colIndex += text.length;

            if (callbacks.chars) {
                callbacks.chars(text, lineIndex, col, checkClosingTag);
            }
            return "";
        }
        if (emberFlag && htmlString.indexOf("{{!--")) {
            htmlString = htmlString.replace(/{{!--[\s\S]*?--}}/g, "");
        }
        while (htmlString) {
            hasUnparsedChars = true;
            if (!stack.getLastItem() || !SPECIAL_ELEMENTS[stack.getLastItem()]) {
                
                // Check for Comments
                let checkStr  = htmlString.substring(0,4);
                if (checkStr== "<!--"/*htmlString.indexOf("<!--") == 0*/) {
                    let index = htmlString.indexOf("-->");
                    if (index >= 0) {
                        if (callbacks.comment) {
                            let col = colIndex;
                            colIndex += htmlString.substring(4, index).length + 7;
                            callbacks.comment(htmlString.substring(4, index), lineIndex, col);
                            let matchRes = htmlString.substring(4, index).match(/\n/g)
                            if (matchRes) {
                                lineIndex = lineIndex + matchRes.length;
                                colIndex = matchRes[matchRes.length-1].length;
                            }
                        }
                        htmlString = htmlString.substring(index + 3);
                        hasUnparsedChars = false;
                    }
                } else if (checkStr.indexOf("</") == 0) {
                    match = htmlString.match(regexFor.endTag);
                    // console.log("%c checker ",match[1]);

                    if (match) {
                        let misMatchCase = false;
                        if(match[1] == "p"){
                            paragraphTagStarted = 0;
                        }
                        if(paragraphTagStarted == 2 && match[1] == "template"){
                            paragraphTagStarted = 1;
                        }
                        if (match[1] == "p" && stack.getLastItem() != "p" && willHaveUnclosedClosingTag) {
                            parseStartTag(null, "p", "", null);
                        }
                        if (match[1] == "checkClosingTag") {
                            checkClosingTag = false;
                            htmlString = htmlString.substring(match[0].length);
                            continue;
                        }
                        let check = match[1];
                        if (seenSVGBefore == 0 && check && check.toLowerCase) {
                            check = check.toLowerCase();
                        }
                        if (check != stack.getLastItem() && !EMPTY_ELEMENTS[check]) {
                            // console.error("Issue in Closing tag:)\n\tUnclosed `"+  elemStack.getLastItem()+"` in "+htmlString);
                            let err = new Error("Unclosed `" + elemStack.getLastItem() + "` in " + htmlString.substring(0, 100) + "...");
                            err.fromParser = true;
                            err.lineIndex = lineIndex;
                            err.colIndex = colIndex;
                            throw err;
                            // throw new Error("Issue in Closing tag:)\n\tUnclosed `"+  elemStack.getLastItem()+"` in "+htmlString);
                        }
                        if (match[1] == "template" && elemStack.getLastItem() != "template" && match[1] != "p" && !EMPTY_ELEMENTS[match[1]]) {
                            let match2 = htmlString.match(`<\/\s*` + elemStack.getLastItem() + `\s*>`);
                            if (match2) {
                                // htmlString = htmlString.replace(match2[0], match[0]);
                                htmlString = htmlString.replace(match2[0], "</checkClosingTag>");
                                checkClosingTag = true;
                                htmlString = htmlString.replace(match[0], match2[0]);
                                htmlString = htmlString.substring(0, match2[0].length) + match[0] + htmlString.substring(match2[0].length);
                                match = htmlString.match(regexFor.endTag);
                                stringInPrevLoopState = undefined;
                                misMatchCase = true;
                                // htmlString.replace(/<\/\s*${elemStack.getLastItem()}\s*>/, match[0]);
                            }
                        }
                        htmlString = htmlString.substring(match[0].length);

                        match[0].replace(regexFor.endTag, parseEndTag.bind({
                            misMatchCase: misMatchCase
                        }));
                        hasUnparsedChars = false;
                    } 
                } else if (checkStr.indexOf("<") == 0) {

                    // match = htmlString.match(regexFor.startTag);
                    // let start = Date.now();
                    match = getStartTag(htmlString.slice(1));
                    // errorObj.performance+=(Date.now()-start);
                    if (match.bool) {
                        // console.log(paragraphTagStarted && match[1] != "p" , notAllowedTagsInsideParagraphTag[match[1]],match[1] )
                        if (paragraphTagStarted == 1  && match[1] != "p" && notAllowedTagsInsideParagraphTag[match[1]]) {
                            paragraphTagStarted = 0;
                            parseEndTag(null, "p");
                            willHaveUnclosedClosingTag = true;
                        }
                        htmlString = htmlString.substring(match[0].length);
                        //to remove br tags which are immediate child to template tags
                        if(match[1] == "template" ){
                            while (htmlString.match(/^[^<]*?<\/br\s*>/)) {
                                htmlString = htmlString.replace(/<\/br\s*>/, "");
                            }
                        }
                        //to handle table tags without table as its parent element
                        if (!withoutTableProcessing) {
                            if (stack.getLastItem() != "template" && seenTableBefore == 0 && tableTags[match[1]]) {
                                if (errorObj) {
                                    errorObj.warnings.push({ message: "Warning: Misplaced " + match[1] + " tag in " + match[0] + "....." + "</" + match[1] + ">" + ((fileName && fileName.trim().length != 0) ? "\n\t  at Component: " + fileName : "") });
                                }
                                else{
                                    console.warn( "Warning: Misplaced " + match[1] + " tag in " + match[0] + "....." + "</" + match[1] + ">" + ((fileName && fileName.trim().length != 0) ? "\n\t  at Component: " + fileName : ""));
                                }
                            }
                            // else if (stack.getLastItem() == "template" && seenTableBefore == 0 && tableTags[match[1]]) {
                            //     if (errorObj) {
                            //         errorObj.warnings.push({ message: "Warning: Misplaced "+match[1] + " tag in " + match[0] + "....." + "</" + match[1] + ">" + ((fileName && fileName.trim().length != 0) ? "\n\t  at Component: " + fileName : "") });
                            //     }
                            //     else{
                            //         console.warn("Warning: Misplaced "+match[1] + " tag in " + match[0] + "....." + "</" + match[1] + ">" + ((fileName && fileName.trim().length != 0) ? "\n\t  at Component: " + fileName : ""));
                            //     }
                            //     doCheckUntil = match[1].toLowerCase();
                            // }
                        }
                        // if(match[1] == "code"){
                        //     let codeTagMatch = /<\/code\s*>/gm.exec(htmlString);
                        //     if(codeTagMatch){
                        //         let innerString = htmlString.substring(0,codeTagMatch.index);
                        //         htmlString = htmlString.substring(codeTagMatch.index);
                        //         parseStartTag(match[0], match[1], match[2], match[3],innerString);
                        //     }
                        //     else{
                        //         throw new Error("Error: Unclosed `code` tag");
                        //     }
                        // }
                        // else{
                            parseStartTag(match[0], match[1], match[2], match[3]);
                        // }
                        // match[0].replace(regexFor.startTag, parseStartTag);
                        hasUnparsedChars = false;
                        if(match[1] == "p"){
                            paragraphTagStarted = 1;
                        }
                        if(paragraphTagStarted == 1 && match[1] == "template"){ 
                            paragraphTagStarted = 2;
                        }
                        // paragraphTagStarted = (match[1] == "p");
                    } else {
                        let err =  new Error(match.error + ((match.index) ? " in <" + match.index.substring(0,(match.index.indexOf(">")!=-1)?match.index.indexOf(">")+1:51) + "....." : ""));
                        err.fromParser = true;
                        err.lineIndex = lineIndex;
                        err.colIndex = colIndex;
                        throw err;
                    }
                }
                if (hasUnparsedChars) {
                    
                    // index = htmlString.indexOf("<");
                    let hasSeenOpenMustache = false,newLineCount = 0,index,lastNewLineIndex =undefined,mustacheIndex = {};
                    for (let i = 0; i < htmlString.length; i++) {
                        if(htmlString[i] == "\n"){
                            newLineCount++;
                            lastNewLineIndex = i;
                        }
                        if (htmlString[i] == '{' && htmlString[i + 1] == '{') {
                            hasSeenOpenMustache = true;
                            mustacheIndex = {colIndex:i-newLineCount,lineIndex:lineIndex+newLineCount};
                        }
                        if (htmlString[i] == '}' && htmlString[i + 1] == '}') {
                            hasSeenOpenMustache = false;
                        }
                        // if (htmlString[i] == '<' && !hasSeenOpenMustache) {
                        if (htmlString[i] == '<' && !hasSeenOpenMustache){// && (getStartTag(htmlString.slice(i+1)).bool || htmlString.slice(i).match(regexFor.endTag))) {//@Harish3055 check this
                            index = i;
                            break;
                        }
                    }
                    if(hasSeenOpenMustache){
                        let err = new Error("Unclosed Mustache at "+htmlString.substring(mustacheIndex.colIndex,mustacheIndex.colIndex+50));
                        err.fromParser = true;
                        err.lineIndex = mustacheIndex.lineIndex;
                        err.colIndex = (mustacheIndex.lineIndex == lineIndex)?/* <h1>check{{{}</h1> */colIndex+mustacheIndex.colIndex:/* <h1>che\nck{{{}</h1> */mustacheIndex.colIndex;
                        throw err;
                    }
                    if(!index){
                        mismatchColIndex = {colIndex,lineIndex};
                        index = htmlString.length;
                        newLineCount = 0;
                    }
                    let text = index < 0 ? htmlString : htmlString.substring(0, index);
                    htmlString = index < 0 ? "" : htmlString.substring(index);
                    if (callbacks.chars) {
                        // @Handle3055 to get precise line and column number
                        // if(!seenPreBefore && text){
                        //   text = text.replace(/\r?\n|\r/g,' ').replace(/\s+/g,' ');
                        // }
                        callbacks.chars(text, lineIndex, colIndex, checkClosingTag);
                        colIndex = colIndex + text.length;
                        if (newLineCount) {
                            lineIndex+=newLineCount;
                            colIndex = text.length - lastNewLineIndex;
                        }
                    }
                }
            } else {
                htmlString = htmlString.replace(new RegExp("([\\s\\S]*?)<\/" + stack.getLastItem() + "[^>]*>"), replacerFn);
                parseEndTag("", stack.getLastItem());
            }
            if (htmlString == stringInPrevLoopState) {
                throw "Parse Error: " + htmlString.substring(0,100)+"...";
            }
            stringInPrevLoopState = htmlString;
        }
        if(stack.length>0){
            let err =  new Error("Unclosed `" + elemStack.getLastItem() + "` in " + htmlString.substring(0, 100) + "..."+((fileName && fileName.trim().length != 0) ? "\n\t    at Component: " + fileName : ""));
            err.lineIndex = mismatchColIndex.lineIndex || lineIndex;
            err.colIndex = mismatchColIndex.colIndex || colIndex;
            throw err;
        }
        parseEndTag();
    }
}());
export default HTMLParser;
//ignorei18n_end