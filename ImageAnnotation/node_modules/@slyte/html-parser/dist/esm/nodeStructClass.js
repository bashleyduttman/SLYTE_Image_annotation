import htmlToJsObjectLyteRendered from "./htmlToJsObjectLyteRendered";
function deepCopyObject( obj )  {
    let current, copies = [{source : obj, target : Object.create(Object.getPrototypeOf(obj))}], keys, propertyIndex, descriptor, nextSource, indexOf, sourceReferences = [obj];
    let cloneObject = copies[0].target, targetReferences = [cloneObject];
    while(current = copies.shift()){
        keys = Object.getOwnPropertyNames(current.source);
        for(propertyIndex = 0; propertyIndex < keys.length; propertyIndex++){
            descriptor = Object.getOwnPropertyDescriptor(current.source, keys[propertyIndex]);
            if(!descriptor.value || typeof descriptor.value != "object"){
                Object.defineProperty(current.target, keys[propertyIndex], descriptor);
                continue;
            }
              nextSource = descriptor.value;
              descriptor.value = Array.isArray(nextSource) ? [] : Object.create(Object.getPrototypeOf(nextSource));
              indexOf = sourceReferences.indexOf(nextSource);
              if(indexOf != -1){
                  descriptor.value = targetReferences[indexOf];
                  Object.defineProperty(current.target, keys[propertyIndex], descriptor);
                  continue;
              }
              sourceReferences.push(nextSource);
              targetReferences.push(descriptor.value);
              Object.defineProperty(current.target, keys[propertyIndex], descriptor);
              copies.push({source : nextSource, target : descriptor.value});
          }
      }
    return cloneObject;
}
//   getType = function(val){
//     return  val && ((typeof val == "object")?(Array.isArray(val)? "a":"o"):undefined);
//   }

function deepCopyNode(obj,hasSeenSvg){
	if(!obj){return}
	// let children  = (obj.content)? obj.content.childNodes:obj.childNodes;
	obj = new Node(obj);
	if(hasSeenSvg && obj.tag == "template" && obj.cont){
		let temp = obj.content.childNodes,ls = obj.child = [];
		obj.child = temp;
		delete obj.cont;
	}
	if(!hasSeenSvg && obj.tag == "template" && obj.child /*&& obj.child.length > 0*/ ){
		let temp = obj.child;
		obj.content = obj.createDocumentFragment();
		obj.cont.child=temp;
		delete obj.child;
	}
	if(obj.tag == "svg"){
		hasSeenSvg = hasSeenSvg || true;
	}
	let prev;
	if(obj.content){
		obj.content = new Node(obj.content);
		let ls = [];
		for(let i in obj.content.child){
			let ref = obj.content.child[i] = deepCopyNode(obj.content.child[i],hasSeenSvg);
			if(prev){
				prev.next = ref;
			}
			ref.parent = obj.content;
			ref.prev = prev;
			prev = ref;
			ls.push(ref);
		}
		obj.content.child = ls;
		
	}
	else if (obj.childNodes){
		let ls = [];
		for(let i in obj.child){
			let ref = obj.child[i] = deepCopyNode(obj.child[i],hasSeenSvg);
			if(prev){
				prev.next = ref;
			}
			ref.parent = obj;
			ref.prev = prev;
			prev = ref;
			ls.push(ref);
		}
		obj.child = ls;
	}
	return obj;
}
class Node{
    constructor(obj) {
		this.node = obj.node;
		(obj.hasOwnProperty("parent")) ? this.parent = obj.parent : this.parent = null;
		(obj.hasOwnProperty("prev")) ? this.prev = obj.prev : this.prev = null;
		(obj.hasOwnProperty("next")) ? this.next = obj.next : this.next = null;
		if (obj.hasOwnProperty("tag")) { this.tag = obj.tag; }
		if(obj.hasOwnProperty("text")) { this.text = obj.text; }
		if(obj.hasOwnProperty("attr")) { this.attr = Object.assign({},obj.attr); }
		if(obj.hasOwnProperty("child")) { this.child = obj.child; }
		if(obj.hasOwnProperty("attrType")) { this.attrType = Object.assign({},obj.attrType) }
		// if(obj.hasOwnProperty("style")){this.style = obj.style}
		else if(obj.node == "element"){
			this.attrType = {};
		}
		if(obj.__proto__.Compile){
			this.__proto__.Compile = obj.__proto__.Compile;
		}
		if(obj.hasOwnProperty("errorInfo")){ this.errorInfo = obj.errorInfo}
		if(obj.hasOwnProperty("cont")){this.cont = obj.content}
    }
	refreshNode(NodeStruct = false){
		let nodes = this.querySelectorAll("tbody",true);
		let ds = {};
		let value = null;
        for(let node of nodes){
            let parent = node.parent || node._parent
            let index = parent.child.indexOf(node);
            let temp = null;
            let count = 0;
            if (parent.tag != "table"){
                parent.child.splice(parent.child.indexOf(node), 1);
				let ptr = parent;
                while(parent){
                    if (parent.tag == "table" && temp) {
                        let ls = []
                        index = parent.child.indexOf(temp);
                        if (parent.hasAttribute("haveChangesInTbody")) {
                            value = parent.attr.haveChangesInTbody;
                        }
                        else {
                            count++;
                            parent.setAttribute("haveChangesInTbody", count.toString());
                            value = count.toString();
                        }
                        if(ds[value]){
                            ds[value].push({ node: node, index: index});
                        }
                        else{
                            ds[value] = [{ node: node, index: index}]
                        }
						if(node.next && node.next.node == "#text"){
							ds[value].push({ node: node.next, index: index});
							ptr.child.splice(ptr.child.indexOf(node.next), 1);
						}
                        break;
                    };
                    temp = parent;
                    parent = parent.parent
                }
            }
        }
		let ls = [];
		for(let i in ds){
			let parent = this.querySelector("[haveChangesInTbody=" + i + "]",true);
			let key = parent.attr.haveChangesInTbody;
			let childToAdd = []
			let index = null
			for(let j of ds[i]){
				childToAdd.push(j.node);
				index = j.index
			}
			let child = parent.child
			if (index == child.length - 1) {
				ls = child.concat(childToAdd);//[...child, ...childToAdd];
			}
			else{
				ls = (child.slice(0,index)).concat(childToAdd).concat(child.slice(index));//[...child.slice(0,index),...childToAdd,...child.slice(index)]
			}
			parent.child = []
			for (let j = 0; j < ls.length;j++){
				parent.appendChild(ls[j]);
			}
			parent.removeAttribute("haveChangesInTbody");
		}
		htmlToJsObjectLyteRendered.processTable(this);
		if (NodeStruct) {
			let list = [];
			list.push(this);
			while (list.length > 0) {
				let obj = list.splice(0, 1);
				if (obj.child) {
					for (let child of obj.child) {
						child = new Node(child);
						list.push(child);
					}
				}
			}
		}
	}
	
	get content(){
		return this.cont;
	}
	
	set content(docFag){
		this.cont = docFag;
		docFag._parent = this;
	}
	
    get children(){
		if(this.child){
			let obj = this.child;
			let res = [];
			for(let i=0; i<obj.length; i++){
				if(obj[i].node== "element") { res.push(obj[i]) }
			}
			return res;
		}
		return [];
	}
	
	//.childNodes
	get childNodes(){
		return this.child;
	}
	//.outerObj()
	get outerObj(){
		return (this.node!= "#document-fragment")?/*deepCopyNode(*/this/*)*/:undefined;
	}

	set outerObj(obj){
		if(obj){
			let tagName = this.tagName;
			obj = obj.childNodes;
			// let obj = htmlToJsObjectLyteRendered.toObject(html, { fromInternal:true, enhanced: true,withoutTableProcessing:true,withoutTemplateConversion:true,hasParentSvg:(tagName == tagName.toLowerCase()),fromSub:true ,Compile: this.__proto__.Compile}).childNodes;
			if (this.node != "#document-fragment") {
				let child = this.parent.childNodes;
				let index = child.indexOf(this);
				// child = [child.slice(0, index+1),...obj,child.slice(index+1)];
				let secondHalf = child.slice(index + 1);
				this.parent.child = child.slice(0, index);
				for(let i of obj){
					this.parent.appendChild(deepCopyNode(i,(tagName == tagName.toLowerCase())));
				}
				for(let i of secondHalf){
					this.parent.appendChild(i);
				}
			}
		}
	}
	//.outerHTML()
	get outerHTML(){
		return (this.node!= "#document-fragment")?htmlToJsObjectLyteRendered.toHtml(this):undefined;
	}

	set outerHTML(html){
		let tagName = this.tagName
		let obj = htmlToJsObjectLyteRendered.toObject(html, { fromInternal:true, enhanced: true,withoutTableProcessing:true,withoutTemplateConversion:true,hasParentSvg:(tagName == tagName.toLowerCase()),fromSub:true ,Compile: this.__proto__.Compile}).childNodes;
		if (this.node != "#document-fragment") {
			let child = this.parent.childNodes;
			let index = child.indexOf(this);
			// child = [child.slice(0, index+1),...obj,child.slice(index+1)];
			let secondHalf = child.slice(index + 1);
			this.parent.child = child.slice(0, index);
			for(let i of obj){
				this.parent.appendChild(i);
			}
			for(let i of secondHalf){
				this.parent.appendChild(i);
			}
		}
	}

	//.innerObj()
	get innerObj(){
		// let res = [];
		let obj = this;
		// let obj = deepCopyObject(this);
		obj = (!obj.content) ? obj.childNodes : obj.content.childNodes;
		// for(let i=0; i<obj.length; i++){
			// res += htmlToJsObjectLyteRendered.toHtml(obj[i]);
			// res.push(deepCopyNode(obj[i]));
		// }
		// return res;
		return obj;
	}

	set innerObj(obj){
		let tagName = this.tagName;
		if (tagName == "TEMPLATE") {
			this.content.child = [];
			if(obj.length != undefined){
				for(let i of obj){
					this.content.appendChild(deepCopyNode(i,(tagName == tagName.toLowerCase())));
				}
				// this.content.appendChildArr(obj);
			}
			else{
				this.content.appendChild(deepCopyNode(obj,(tagName == tagName.toLowerCase())));
			}
		}
		else {
			this.child = []
			if(obj.length != undefined){
				for(let i of obj){
					this.appendChild(deepCopyNode(i,(tagName == tagName.toLowerCase())));
				}
			}
			else{
				this.appendChild(deepCopyNode(obj,(tagName == tagName.toLowerCase())));
			}
		}
	}

	//.innerHTML()
	get innerHTML(){
		let res = "";
		let obj = this;
		// let obj = deepCopyObject(this);
		obj = (!obj.content) ? obj.childNodes : obj.content.childNodes;
		for(let i=0; i<obj.length; i++){
			res += htmlToJsObjectLyteRendered.toHtml(obj[i]);
		}
		return res;
	}
	
	set innerHTML(html){
		let tagName = this.tagName
		let obj = htmlToJsObjectLyteRendered.toObject(html, { fromInternal:true, enhanced: true,withoutTableProcessing:true, withoutTemplateConversion:true ,hasParentSvg:(tagName == tagName.toLowerCase()),fromSub:true,Compile: this.__proto__.Compile}).childNodes;
		if (tagName == "TEMPLATE") {
			this.content.child = [];
			this.content.appendChildArr(obj);
		}
		else {
			this.child = []
			this.appendChildArr(obj);
		}
	}
	
	//.appendChild()
	appendChild(child,deleteInPreviousParent){
		if (child.parent && child.parent.child && deleteInPreviousParent) {
			child.remove();
		}
		if(child.node == "#document-fragment"){
			return this.appendChildArr(child.child);
		}
		// let ls
		// for(let i of [...this.child,...(this.parent)?this.parent.child:[]]){
		// 	if(i == child){
		// 		i.remove(child);
		// 	}
		// }
		if (this.child && this.child.length) {
			for(let i of this.child){
				if(i==child){
					i.remove();
					break;
				}
			}
			let prev = this.child[this.child.length-1];
			child.parent = this;
			child.prev = prev;
			child.next = null;
			prev.next = child;
		}
		else {
			this.child = [];
			child.parent = this;
			child.prev = null;
			child.next = null;
		}
		this.child.push(child);
		return this;
	}
	
	appendChildArr(childArr){
        for(let i=0; i<childArr.length;i++){
          this.appendChild(childArr[i]);
        }
        return this;
      }

	//.hasAttribute()
	hasAttribute(attr){
		return (this.attr && this.attr[attr] != undefined)? true : false;
	}
	
	//.hasAttributes()
	hasAttributes(){
		return (this.attr && Object.keys(this.attr).length > 0) ? true : false;
	}
	//.getAttribute()
	getAttribute(attr){
		return (this.attr && this.attr[attr] != undefined) ? this.attr[attr] : null;
	}
	
	//.hasChildNodes()
	hasChildNodes(){
		return (this.childNodes && this.childNodes.length > 0) ? true : false;
	}
	
	get firstChild(){
		return (this.child[0]) ? this.child[0] : null;
	}
	
	//.setAttribute()
	setAttribute(attr,value){
		if(!this.attr) { this.attr = {}; }
		if (typeof value == "string" || typeof value == "number") {
			this.attr[attr] = value.toString();
		}
		else{
			this.attr[attr] =JSON.stringify(value);
		}
		return;
	}

	//.tagName()
	get tagName(){
		if(this.tag){
			let tag = this.tag
			// if(tag == "template"){
			// 	return tag.toUpperCase();
			// }
			if(tag == "svg"){
				return tag.toLowerCase();
			}
			let obj = this;
			if(!obj.replacedNode){
				while(obj){
					if(obj.tag == "svg" || obj.hasParentSvg) { return tag.toLowerCase(); }
					if(obj.tag =="foreignObject"){
						break;
					}
					// if (obj.parent) {
						obj = obj.parent;
					// }
					// else{
					// 	obj = obj._parent;
					// }
				}
			}
			return tag.toUpperCase();
		}
		return null;
	}

	//.nextSibling()
	get nextSibling(){
		return this.next;
	}

	//.nextElementSibling()
	get nextElementSibling(){
		let obj = this.next;
		while (obj) {
			if(obj.node == "element") { return obj; }
			obj = obj.next;
		}
		return null;
	}

	//.previousSibling()
	get previousSibling(){
		return this.prev;
	}

	//.previousElementSibling()
	get previousElementSibling(){
		let obj = this.prev;
		while(obj){
			if(obj.node == "element") { return obj; }
			obj = obj.prev;
		}
		return null;
	}
	updateNode(newNode){
		// let res = findParent(this,this.parent)
		// var parent = (res)?res:this.parent;
		let parent = this.parent
		let ind = parent.child.indexOf(this);
		newNode.prev = this.prev;
		newNode.next = this.next;
		newNode.parent = parent;
		if(this.prev){
			this.prev.next = newNode;
		}
		parent.child.splice(ind,1,newNode)
	}
	//.parentElement()
	get parentElement(){
		return (this.parent && this.parent.node=="element")? this.parent : null;
	}

	//.parentNode()
	get parentNode(){
		return this.parent;
	}

	nodeParentHasSvg() {
		let obj = this
		while(obj){
			if(this.tag == "svg") { return true; }
			obj = obj.parent;
		}
		return false;
	}
	
	deepCopyObject(){
		return new Node(this);
	}
	//.nodeName()
	get nodeName() {
		let obj = this;
		if(this.nodeType==2 || this.nodeType == 3){
			return this.node;		
		}
		if(obj.node && obj.node!="#document-fragment"){
			let node = obj.tagName.toUpperCase();
			while(obj){
				if(obj.tag == "svg") { return node.toLowerCase(); }
				obj = obj.parent;
			}
			return node.toUpperCase();
		}
		return null;
	}

	//.nodeType()
	get nodeType(){
		let check = {element:1,'#text':3,comment:8,attr:2,'#document-fragment':11};
		return check[this.node] || ((this.ownerElement)? 2:undefined);
	}

	//.nodeValue()
	get nodeValue(){
		if(this.nodeType==8 || this.nodeType==3) { return this.text; }
		if(this.nodeType==2){
			return this.value;
		}
		return null;
	}
	
	set nodeValue(textValue){
		if(this.nodeType == 8 || this.nodeType == 3){
			this.text = textValue;
		}
		if(this.nodeType == 2){
			this.ownerElement.setAttribute(this.nodeName, textValue);
		}
	}
	//.remove()
	remove(){
		// if(this.node == "element"){
			let index = this.parent.child.indexOf(this);
			if(this.prev) {
				this.prev.next = this.next;
			}
			if(this.next) {
				this.next.prev = this.prev;
			}
			this.parent.child.splice(index,1);
		// }
	}
	get firstElementSibling(){
		for (let i = 0; i < this.child.length;i++){
			if(this.child[i].node == "element"){
				return this.child[i];
			}
		}
		return undefined;
	}
	//.removeAttribute()
	removeAttribute(attr){
		if (this.attr) {
			delete this.attr[attr];
		}
		if(this.attr && Object.keys(this.attr).length==0) { delete this.attr; }
	}
	//.replaceWith()
	replaceWith(newNode) {
		// if(this.node == "element" && newNode.node == "element"){
			newNode.parent = this.parent;
			newNode.prev = this.prev;
			newNode.next = this.next;
			this.replacedNode = true;
			newNode.replacedNode = true;
			// newNode.attrType = this.attrType;
			let index = this.parent.child.indexOf(this);
			// this.parent.child[index] = newNode;
			this.parent.child.splice(index,1,newNode)
			if(this.next)
				{ this.next.prev = newNode; }
			if(this.prev)
				{ this.prev.next = newNode; }
		// }
	}

	//.attributes()
	get attributes(){
		let attr = this.attr;
		let res = [];
		for(let i in attr){
			res[i] = this.createAttribute(i);
			res[i].value = (attr[i]) ? attr[i] : "";
			res.push(res[i]);
		}
		return (this.attr)?res:[];
	}

	//.localName()
	get localName(){
		return this.tag?this.tag:null;
	}

	//.cloneNode()
	cloneNode(flag){
		let res={}
		res = new Node((flag)?deepCopyObject(this):this);
		
		if(this.attr)
			{ res.attr = Object.assign({},this.attr )};
		if(this.parent)
			{ res.parent = null; }
		if(this.prev)
			{ res.prev = null; }
		if(this.next)
			{ res.next = null; }
		if(res.tagName == "TEMPLATE" && !flag){
			res.content = this.createDocumentFragment();
		}
		return res;
	}
	
	createAttribute(nodeName){
		let temp = new Node({node:nodeName});
		temp.value = "";
		temp.name = nodeName;
		temp.ownerElement = this
		return temp;
	}
	
	createDocumentFragment(){
		let node = new Node({ node: "#document-fragment", child: [], cont: [] });
		if(this.__proto__.Compile){
			node.__proto__.Compile = this.__proto__.Compile;
		}
		return node;
	}
	
	//.createElement()
	createElement(tag,options = {next:null,prev:null,parent:null,attr:{}}){

		let node = {};
		if (options.attr)
			{ node = { node: "element", tag: tag.toLowerCase(),  prev: options.prev, next: options.next, parent: options.parent, attr: options.attr }; }
		else
			{ node = { node: "element", tag: tag.toLowerCase(),  prev: options.prev, next: options.next, parent: options.parent, attr: {}  }; }
		
		if(options.attrType){
			node.attrType = options.attrType
		}
		if (options.errorInfo) { 
			node.errorInfo = options.errorInfo;
		}
		node = new Node(node);
		if(this.__proto__.Compile){
			node.__proto__.Compile = this.__proto__.Compile;
		}
		if(node.tag == "template"){
			node.content = this.createDocumentFragment();
		}else{
			node.child = [];
		}
		return node;
	}
	//.createTextNode()
	createTextNode(text,options = {next:null,prev:null,parent:null}){
		let node = new Node({node:"#text",prev:options.prev,next:options.next,parent:options.parent,text:text});
		if(this.__proto__.Compile){
			node.__proto__.Compile = this.__proto__.Compile;
		}
		node.attrType = options.attrType
		if(options.lineIndex){
            node.lineIndex = options.lineIndex;
        }
        if(options.colIndex){
            node.colIndex = options.colIndex;
        }
		return node;
	}

	//.querySelector()
	findItem(dontCheckTemplate,obj,attr,attrVal,single = 1,tag = undefined){
		if (dontCheckTemplate && obj.tag == "template" && obj.tagName == "TEMPLATE") {
			obj = obj.content.child;
		}
		else {
			obj = obj.child;
		}
		if (!obj || (obj.attr && obj.attr.dontConsiderForDefault == "true")) { return null; }
		let res = null;
		for(let i=0; i<obj.length; i++){
			if (obj[i].attr && obj[i].attr.dontConsiderForDefault == "true") { continue; }
			if(single==1 && obj[i].attr && obj[i].attr[attr]==attrVal) 
				{ return obj[i]; }
			if(single==2 && obj[i].attr && this.find(obj[i].attr, attr))
				{ return obj[i]; }
			if(single==3 && obj[i].tag == attr)
				{ return obj[i]; }
			if(single==4 && obj[i].attr && obj[i].attr[attr]==attrVal && obj[i].tag == tag)
				{ return obj[i]; }
			// if (obj[i] && obj[i].tag == "template" && dontCheckTemplate) { continue; }
			else {
				res = this.findItem(dontCheckTemplate, obj[i], attr, attrVal, single, tag);
			}
			if(res) { break; }
		}
		return res;
	}

	querySelector(selector,dontCheckTemplate=false) {
		if(selector[0]=='.') { return this.findItem(dontCheckTemplate,this,"class",selector.substring(1)); }
		else if(selector[0]=='#') { return this.findItem(dontCheckTemplate,this,"id",selector.substring(1)); }
		else if(selector[0]=='['){
			if(selector.search('=')!=-1){
				let searchItem = selector.substring(1,selector.length-1).split("=");
				let attr = searchItem[0];
				let attrVal = searchItem[1].replace(/^"+|"+$/g, '');
				attrVal = attrVal.replace(/^'+|'+$/g, '');
				return this.findItem(dontCheckTemplate,this,attr,attrVal);
			}
			else {
				let attr = selector.substring(1, selector.length - 1);
				return this.findItem(dontCheckTemplate,this, attr, null, 2);
			}
		}
		else if(selector.match(/^\w+\[.+=.+]$/gm)){
			selector = selector.split("[");
			let tag = selector[0];
			selector = selector[1].split("=");
			let attr = selector[0].replace(/^"+|"+$/g, '').replace(/^'+|'+$/g, '');
			let attrVal = selector[1].substring(0,selector[1].length-1).replace(/^"+|"+$/g, '').replace(/^'+|'+$/g, '');

			return this.findItem(dontCheckTemplate,this, attr, attrVal, 4, tag);
        }
		return this.findItem(dontCheckTemplate,this,selector,null,3);
	}

	find(obj, find){
		if (obj) {
		//   let ls = Object.keys(obj)
		  for (let i in obj) {
			if (i == find) {
			  return true;
			}
		  }
		}
		return false;
	}

	//.querySelectorAll()
	findAll(obj,attr,attrVal,single,result = [],dontCheckTemplate){
		if (obj.tag == "template" && dontCheckTemplate && obj.tagName == "TEMPLATE") {
			obj = obj.content.child;
		} 
		else {
			obj = obj.child;
		}
		if(!obj){ return result;}
		for (let i=0; i<obj.length; i++){
			if(single==1 && obj[i].attr && obj[i].attr[attr]==attrVal) 
				{ result.push(obj[i]); }
			if (single == 2 && obj[i].attr && this.find(obj[i].attr, attr)) {
				{ result.push(obj[i]); }
			}
			if(single==3 && obj[i].tag == attr)
				{ result.push(obj[i]); }
			this.findAll(obj[i],attr,attrVal,single,result,dontCheckTemplate);
		}
		return result;
	}

	querySelectorAll(selector,dontCheckTemplate){
		if(selector[0]=='.') { return this.findAll(this,"class",selector.substring(1),1,[],dontCheckTemplate); }
		else if(selector[0]=='#') { return this.findAll(this,"id",selector.substring(1),1,[],dontCheckTemplate); }
		else if(selector[0]=='['){
			if(selector.search('=')!=-1){
				let searchItem = selector.substring(1,selector.length-1).split("=");
				let attr = searchItem[0];
				let attrVal = searchItem[1].replace(/^"+|"+$/g, '');
				attrVal = attrVal.replace(/^'+|'+$/g, '');
				return this.findAll(this,attr,attrVal,1,[],dontCheckTemplate);
			}
			else {
				let attr = selector.substring(1,selector.length-1);
				return this.findAll(this,attr,null,2,[],dontCheckTemplate);
			}
		};	
		return this.findAll(this,selector,null,3,[],dontCheckTemplate);
	}

	//Cases
	// let defaultCase = node.querySelectorChildren("[default]")
	// let isBreak = currentCase.querySelectorChildren("template[is=break]");
	// let isBreak = dCaseTemplate.querySelectorChildren("template[is=break]");

	querySelectorChildren(string){
		let children = this.child;
			if(string.startsWith("#")){
				return;
			}else if(string.startsWith("[")){
				let attrString = string.slice(1,string.length-1)
				for(let i=0; i<children.length; i++){
					if(children[i].attr && children[i].attr.hasOwnProperty(attrString)){
						return children[i];
					}
				}
			}else if(string.indexOf("[") != -1){
				let arr = string.split("[");
				let tagName = arr[0];
				let attrString = arr[1].slice(0,arr[1].length-1);
				let attrStringArr = attrString.split("=");
				let attrName = attrStringArr[0];
				let attrVal = attrStringArr[1];
				for(let i=0; i<children.length; i++){
					if(children[i].tag && children[i].tag == tagName){
						if(children[i].attr[attrName] && children[i].attr[attrName] == attrVal){
							return children[i];
						}
					}
				}
			}
		// }
	}

	// Cases
	// let cases = node.querySelectorAllChildren("[case]")
	querySelectorAllChildren(string){
		let children = this.child;
		let output = []
		// if(children){
			if(string.startsWith("#")){
				return output;
			}else if(string.startsWith("[")){
				let attrString = string.slice(1,string.length-1)
				for(let i=0; i<children.length; i++){
					if(children[i].attr && children[i].attr[attrString]){
						output.push(children[i])
					}
				}
			}
		// }
		return output;
	}
	json2html(obj) { return htmlToJsObjectLyteRendered.toHtml(obj) }
}

export default Node;