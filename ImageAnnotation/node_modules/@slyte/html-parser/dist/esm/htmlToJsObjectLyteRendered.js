//ignorei18n_start

/*
pageBuilder :  data,callbacks,preventSpaceText
*/
import htmlParser from "../lib/htmlParser.js";
import Node from "./nodeStructClass.js";
import syntaxCheckWorkerNew from "./HandleMustache";
import decodeHtmlEntities from "./decodeHtmlEntities.js";

const createMapFor = function (array) {
  return array.reduce(function (acc, item) {
    acc[item] = true;
    return acc;
  }, {});
}

let observedAttributes = {}
let tagsTable = {
  "table": ["tbody", "thead", "tfoot", "colgroup", "template"],
  "tbody": ["tr", "template"],
  "tr": ["td", "th", "template"],
  "thead": ["tr", "template"],
  "tfoot": ["tr", "template"],
  "colgroup": ["col", "template"]
}
let tagLevel = {
  "td": 0,
  "th": 0,
  "tr": 1,
  "tbody": 2,
  "thead": 2,
  "tfoot": 2,
  "colgroup": 2
}
let tableTags = ["tbody", "thead", "tfoot", "colgroup", "caption"]
let allTableTags = createMapFor(tableTags.concat([ "tr", "th", "td", "col", "table", "template"]))
tableTags = createMapFor(tableTags);
let removedTableTags = ["body"]
let ls = []
let styleTagStarted = false;
let selfClosingTags = createMapFor(["path", "title", "animateTransform", "set", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "animate", "animateColor", "use", "stop", "track", 'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr', 'line', 'rect', 'polyline', 'polygon', 'circle', 'ellipse']);

function removeUnwantedTags(obj) {
  if (!obj || obj.tag == "td" || obj.tag == "th") {
    return
  };
  if (obj.tag != "input" && obj.parent.tag && obj.tag && tagsTable[obj.parent.tag] && tagsTable[obj.parent.tag].indexOf(obj.tag) == -1) {
    if(allTableTags[obj.parent.tag.toLowerCase()] && allTableTags[obj.tag.toLowerCase()] && tagLevel[obj.parent.tag.toLowerCase()] <= tagLevel[obj.tag.toLowerCase()]){
      throw new Error("Invalid tag " + obj.tagName + " inside " + obj.parent.tagName);
    }
    ls.push(obj);
    obj.remove();
  }
  if (obj.tag == "input" && obj.attr.type != "hidden") {
    ls.push(obj);
    obj.remove();
  }
  if(obj.child){
    for (let i of obj.children) {
      removeUnwantedTags(i);
    }
  }
}

function processTable(obj, tag, check) {
  let samp = obj.querySelectorAll(tag, true);
  for (let node of samp) {
    let child = node.child[0]
    let flag = false;
    while (child) {
      if (removedTableTags.indexOf(child.tag) != -1) {
        flag = true;
        let index = node.child.indexOf(child);
        // let temp = [...node.child.slice(0, index), ...child.child, ...node.child.slice(index + 1)]
        let temp = ((node.child.slice(0, index)).concat(child.child)).concat(node.child.slice(index + 1));

        node.child = []
        for (let childToPush of temp) {
          node.appendChild(childToPush);
        }
        child = node.child[index];
        continue;
      }
      child = child.next
    }
    if (flag) {
      child = node.child[0];
      while (child) {
        if (child.next && child.node == "#text" && child.next.node == "#text") {
          child.text = child.text + child.next.text;
          child.next.remove();
        }
        child = child.next
      }
    }
    child = node.child[0]
    if (child && child.node != "element") {
      child = child.nextElementSibling;
    }
    let ptr = child;
    let checkerTemplateAsFirstNode = true;
    let targObj = new Node({
      tag: check,
      node: "element"
    })
    while (child) {

      if ((check == "tr") && child.tag == "template") {
        child = child.nextElementSibling;
        ptr = child
        continue;
      }
      if (checkerTemplateAsFirstNode && child.tag == "template") {
        child = child.nextElementSibling;
        ptr = child
        continue;
      }
      checkerTemplateAsFirstNode = false;
      if (allTableTags[child.tag] && !tableTags[child.tag] && ((child.tag != check && child.tag != "col") || (flag && child.tag == "col"))) {
        let temp = new Node(child);
        if (temp.child) {
          for (let i of temp.child) {
            i.parent = temp;
          }
        }
        targObj.appendChild(temp);

      } else if (child.node != "#text") {
        if (targObj.child && ptr) {
          ptr.replaceWith(targObj);
          targObj = new Node({
            tag: check,
            node: "element"
          })
        }
        while (child) {
          child = child.nextElementSibling;
          if (child && child.tag != check && child.tag !="template") {
            break;
          }
        }
        ptr = child;
        if (!child) {
          break;
        } else {
          continue;
        }
      } else if (child.node == "#text") {

        let temp = new Node(child);
        if (temp.child) {
          for (let i of temp.child) {
            i.parent = temp;
          }
        }
        targObj.appendChild(temp);
      }
      let temp = child.next;
      if (child != ptr) {
        child.remove();
      }
      child = temp;
    }
    if (targObj.child && ptr) {
      ptr.replaceWith(targObj);
    }
  };
  if (check === "tbody") {
    let checkParent = obj.querySelectorAll(check, true);
    for (let tbody of checkParent) {
      let tbodyParent = tbody.parent;
      if (tbodyParent.tag != "table" && tbodyParent.tag != "template") {
        if (tbody.parent.parent) {
          let index = tbody.parent.parent.child.indexOf(tbody.parent);
          let child = tbody.parent.parent.child
          let temp = []
          let tbodyNext = null;
          tbodyParent.child.splice(tbodyParent.child.indexOf(tbody), 1);
          // ;
          if (tbody.next && tbody.next.node == "#text") {
            tbodyNext = tbody.next;
            tbodyParent.child.splice(tbodyParent.child.indexOf(tbody.next), 1);
          }
          for (let i = 0; i < child.length; i++) {
            if (i == index + 1) {
              temp.push(tbody);
              if (tbodyNext) {
                temp.push(tbodyNext)
              };
              temp.push(child[i]);
            } else {
              temp.push(child[i]);
            }
          }
          tbody.parent.parent.child = []
          let parent = tbody.parent.parent
          for (let i = 0; i < temp.length; i++) {
            parent.appendChild(temp[i]);
          }

        }
      }
    }
  }
}

function processUnwantedTags(obj) {
  let samp = obj.querySelectorAll("table", true);
  for (let node of samp) {
    ls = []
    removeUnwantedTags(node);
    let temp = [];
    let index = node.parent.child.indexOf(node);
    // temp = [...node.parent.child.slice(0, index), ...ls, ...node.parent.child.slice(index, node.parent.child.length)];
    temp = (node.parent.child.slice(0, index)).concat(ls).concat(node.parent.child.slice(index, node.parent.child.length));

    node.parent.child = [];
    for (let i of temp) {
      node.parent.appendChild(i);
    }
    // 
  }
}

function processTableTag(obj) {
  processTable(obj, "table", "tbody")
  processTable(obj, "thead", "tr");
  processTable(obj, "tbody", "tr")
  processTable(obj, "table", "colgroup", true)
  processUnwantedTags(obj);

}

function processSelect(obj) {
  let check = {
    "opt": function (obj) {
      if (!obj || !obj.child || !obj.child.length) {
        return;
      }
      let child = (obj.child[0].node == "#text") ? obj.child[0].nextElementSibling : obj.child[0];
      let ptr = undefined;
      let text = ""
      while (child) {
        if (child.tag != "template" && child.node != "#text") {
          let response = this.other(child);
          if (child.node != "#text" && !ptr && child.tag != "template" && typeof response != "object") {
            ptr = child;
          }
          if (typeof response == "object") {
            child.replaceWith(new Node(response))
            if (ptr) {
              let index = ptr.parent.child.indexOf(ptr);
              ptr.replaceWith(new Node({
                node: "#text",
                text: text
              }));
              this.text(ptr.parent.child[index]);
            }
            ptr = undefined;
            text = ""
          } else {
            text += (" " + response.trim() + " ");
            if (child != ptr) {
              child.remove();
            }
          }
        } else if (child.tag == "template") {
          if (ptr) {
            let index = ptr.parent.child.indexOf(ptr);
            ptr.replaceWith(new Node({
              node: "#text",
              text: text
            }));
            this.text(ptr.parent.child[index]);
          }
          ptr = undefined;
          text = ""
        } else if (child.node == "#text" && child.text.trim().length > 0) {
          let index = child.parent.child.indexOf(child);
          this.text(child.parent.child[index]);
        }
        child = child.next;
      }
      if (ptr && text.trim().length > 0) {
        let index = ptr.parent.child.indexOf(ptr);
        ptr.replaceWith(new Node({
          node: "#text",
          text: text
        }));
        this.text(ptr.parent.child[index]);
      }
    },
    "text": function (obj) {
      let child = obj.prev;
      let prevText = "";
      while (child) {
        if (child.node != "#text") {
          break;
        }
        prevText = " " + child.text.trim() + prevText + " ";
        let temp = child;
        child.remove();
        child = temp.prev;
      }
      child = obj.next;
      let nextText = "";
      while (child) {
        if (child.node != "#text") {
          break;
        }
        nextText = " " + nextText + child.text.trim() + " ";
        let temp = child;
        child.remove();
        child = temp.next;
      }
      obj.text = prevText.trim() + obj.text + nextText.trim();
    },
    "other": function (obj, text = "") {
      if (!obj) {
        return text;
      }
      if (obj.tag == "template") {
        return obj;
      }
      if (obj.node == "#text" && obj.text.trim().length > 0) {
        text += (" " + obj.text.trim() + " ");
      }
      if (!obj.child) {
        return text;
      }
      let child = obj.child
      for (let i of child) {
        text = this.other(i, text);
        if (typeof res == "object") {
          return res;
        }
      }
      return text;
    }
  }
  if (obj.child) {
    let child = obj.child[0];
    while (child) {
      if (child.node != "#text") {
        if (child.tag == "option" || child.tag == "optgroup") {
          check.opt(child)
        } else if (child.tag != "template") {
          let response = check.other(child);
          if (typeof response == "object") {
            child.replaceWith(new Node(response))
          } else {
            let index = child.parent.child.indexOf(child);
            child.replaceWith(new Node({
              node: "#text",
              text: response
            }));
            check.text(child.parent.child[index]);
          }
          // child.replaceWith(new Node({ node: "text", text: response }));
        }
      }
      child = child.next;
    }
  }
}

function processSelectTags(obj) {
  let samp = obj.querySelectorAll("select", true);
  for (let select of samp) {
    processSelect(select);
  }
}
export const htmlToJsObjectLyteRendered = (function () {

  function removeDOCTYPE(html) {
    return html
      .replace(/<\?xml.*\?>\n/, '')
      .replace(/<!doctype.*\>\n/, '')
      .replace(/<!DOCTYPE.*\>\n/, '');
  }
  const convertToHtml = function (json, customHooks, checks) {
    if (checks && checks.attrWithoutValue) {
      checks.attrWithoutValue = createMapFor(checks.attrWithoutValue);
    }
    return getHtml(json, customHooks, checks);
  }
  const getHtml = function (json, customHooks, checks ,styleStarted = false) {
    customHooks = customHooks || {
      handlers: {}
    };
    if (typeof json === 'object' && json !== null && !Array.isArray(json)) {
      // Empty Elements - HTML 4.01
      if(json.tag == "style"){
        styleStarted = true;
      }
      let empty = ['area', 'base', 'basefont', 'br', 'col', 'frame', 'hr', 'img', 'input', 'isindex', 'link', 'meta', 'param', 'embed', 'source', "track"];

      let attr = '';
      let attrType = json.attrType;
      if (json.attr) {
        // const appendQuotes = customHooks.addQuotes || addQuotes;
        let errorinfo;
        if (json.attr.errorinfo) {
          errorinfo = Object.assign(json.attr.errorinfo);
          delete json.attr.errorinfo;
        }
        attr = Object.keys(json.attr).map(function (key) {
          let value = json.attr[key],
            closers = '"';
          if (Array.isArray(value)) {
            value = value.join(' ');
          }
          if (!checks || !checks.withoutTemplateConversion) {
            // console.log("attribute", value);
            // return key + '=' + appendQuotes(value);
            value = value.replace(/&lt;/g, "<");
            value = value.replace(/&gt;/g, ">");
            // value = value.replace(/&lt/g, "<");
            // value = value.replace(/&gt/g, ">");

            value = value.replace(/"/g, "&quot;");
            // value = value.replace(/(?!{{.*\(.*)>(?!.*\)}})/gm, "&gt;");
            // value = value.replace(/(?!{{.*\(.*)<(?!.*\)}})/gm, "&lt;");
            value = value.replace(/&apos;/gm, "'");
            value = value.replace(/&(?!quot;)(?!amp;)(?![gl]t;)(?![Oo][Ee]lig;)(?![Ss]caron;)(?!Yuml;)(?!circ;)(?!tilde;)(?!e[mn]sp;)(?!thinsp;)(?!zwnj;)(?!zwj;)(?![hl]rm;)(?!rlm;)(?![mn]dash;)(?![rl]squo;)(?!sbquo;)(?![rbl]dquo;)(?![dD]agger;)(?!permil;)(?![rl]saquo;)(?!euro;)(?!nbsp;)(?!apos;)(?!cent;)(?!pound;)(?!yen;)(?!copy;)(?!reg;)/gm, "&amp;")
          } else {
            if (attrType && attrType.___attrStart___) {
              let valCloser = attrType.___attrStart___[key];
              if (valCloser) {
                closers = (valCloser === "'" || valCloser === '"') ? valCloser : "";
              }
            }
            if (checks.attrWithoutValue && checks.attrWithoutValue[key] && value == "") {
              return key;
            }
          }

          return key + "=" + closers + value + closers;
        }).join(' ');
        if (errorinfo) {
          json.attr.errorInfo = errorinfo;
        }
        if (attr !== '') {
          attr = ' ' + attr;
        }
      }
      // attr = attr.replace(/"/g,"&quot;")
      let child = '';
      const convertChild = function () {
        let ptr = json.child || json.content.child
        if (ptr) {
          child = ptr.map(function (item) {
            return getHtml(item, customHooks, checks,styleStarted);
          }).join('');
        }
      }
      if (json.node === 'element') {
        let tag = json.tag;
        const handler = (customHooks.handlers || {})[json.node];
        if (typeof handler === 'function') {
          const output = handler(json);
          if (output !== null) {
            return output;
          }
        }

        convertChild();
        if (empty.indexOf(tag) > -1) {
          // empty element
          return '<' + json.tag + attr + '>';
        }

        // non empty element
        let open = '<' + json.tag + attr + '>';
        let close = '</' + json.tag + '>';
        return open + child + close;
      }

      if (json.node === '#text') {
        if (!styleStarted && (!checks || !checks.withoutTemplateConversion)) {
          json.text = json.text.replace(/</g, "&lt;");
          json.text = json.text.replace(/>/g, "&gt;");
          json.text = json.text.replace(/&quot;/g, '"');
          json.text = json.text.replace(/&(?!quot;)(?!amp;)(?![gl]t;)(?![Oo][Ee]lig;)(?![Ss]caron;)(?!Yuml;)(?!circ;)(?!tilde;)(?!e[mn]sp;)(?!thinsp;)(?!zwnj;)(?!zwj;)(?![hl]rm;)(?!rlm;)(?![mn]dash;)(?![rl]squo;)(?!sbquo;)(?![rbl]dquo;)(?![dD]agger;)(?!permil;)(?![rl]saquo;)(?!euro;)(?!nbsp;)(?!apos;)(?!cent;)(?!pound;)(?!yen;)(?!copy;)(?!reg;)/gm, "&amp;");
        }
        return json.text;
      }

      if (json.node === 'html') {
        return json.html;
      }

      if (json.node === 'comment') {
        return '<!--' + json.text + '-->';
      }

      if (json.node === 'root') {
        const handler = (customHooks.handlers || {})[json.node];
        if (typeof handler === 'function') {
          const output = handler(json);
          if (output !== null) {
            return output;
          }
        }
        convertChild();
        return child;
      }

    } else {
      throw new Error("Invalid value. Expected object");
    }
  }
  const find = (obj, find) => {
    if (obj) {
      let ls = Object.keys(obj);
      for (let i = 0; i < ls.length; i++) {
        if (ls[i] == find) {
          return true;
        }
      }
    }
    return false;
  }
  const convertToObject = function (html, check = {
    enhanced: false,
    fromSub: false,
    withoutTemplateConversion: false,
    pageBuilder: {},
    withLineIndex: false,
    withColumnIndex: false,
    emberFlag: false,
    fileName: "",
    fromCLI: false,
    withoutTableProcessing: false,
    ide: false
  }, errorObj = {}) {
    observedAttributes = {}
    if (typeof html === "string" || html instanceof String) {
      if (check) {
        check.fromMain = true;
        check.observedAttributes = observedAttributes;
        check.fromParser = true;
        check.syntaxCheckWorkerNew = syntaxCheckWorkerNew;

      }

      let isOptionCallBackPresent = false,
        optionsData,
        optionsCallBacks,preventSpaceText,cliVersion = check.cliVersion;
      // let isOptionDataPresent = false;
      //  if(optionsData && typeof optionsData=='object' && Object.keys(optionsData).length>0)
      // {
      //   isOptionDataPresent = true;
      // }
      if (check.pageBuilder) {
        preventSpaceText = check.pageBuilder.preventSpaceText;
        optionsData = check.pageBuilder.data;
        optionsCallBacks = check.pageBuilder.callbacks;
        if (optionsCallBacks && typeof optionsCallBacks == 'object' && Object.keys(optionsCallBacks).length > 0) {
          isOptionCallBackPresent = true;
        }
      }
      html = removeDOCTYPE(html);
      const bufferArray = [];
      const results = new Node({
        node: 'root',
        child: []
      });
      if (check.Compile) {
        results.__proto__.Compile = check.Compile;
      }
      if (check.fromSub && check.hasParentSvg) {
        results.hasParentSvg = check.hasParentSvg;
      }
      if (check.fromCLI) {
        //To remove body tag inside a component 
        let match = html.match(/<body\s?.*?>/gm);
        if (match) {
          if (errorObj.warnings) {
            errorObj.warnings.push({
              message: "Warning: Misplaced body tag in " + match[0] + "....." + "</body>"
            });
          }
          html = html.replace(/<body\s?.*?>/gm, "");
          html = html.replace(/<\/body\s*>/gm, "");
        }

      }
      if (check.enhanced) {
        results.parent = null;
        results.prev = null;
        results.next = null;
        if (check.withLineIndex) {
          results.lineIndex = 0
        };
        if (check.withColumnIndex) {
          results.colIndex = 0
        };
      }


      htmlParser(html, {
          start: function (tag, attrs, unary, seenSVGBefore, lineIndex, colIndex) {
            let parent = bufferArray[0] || results;
            if (tag == "style") {
              styleTagStarted = true;
            }
            const node = (tag != "template" && (seenSVGBefore > 0 || check.hasParentSvg)) ? new Node({
              node: 'element',
              tag: tag,
              child: [],
              attrType: {}
            }) : new Node({
              node: 'element',
              tag: tag,
              child: [],
              cont: [],
              attrType: {}
            });
            if(node.tag == "table"){
              check.hasSeenTable = true;
            }
            if(node.select == "select"){
              check.hasSeenSelect = true;
            }
            if (check.Compile) {
              node.__proto__.Compile = check.Compile;
            }
            if (tag == "template" && seenSVGBefore == 0 && !check.hasParentSvg) {
              node.content = node.createDocumentFragment();
            }
            if (check.enhanced) {
              node.parent = parent;
              node.prev = (parent.child && parent.child[parent.child.length - 1]) ? parent.child[parent.child.length - 1] : null;
              node.next = null;
              if (check.withLineIndex) {
                node.lineIndex = lineIndex
              };
              if (check.withColumnIndex) {
                node.colIndex = colIndex
              };
              node.attrType = {};
            }
            let attrType = {};
            if(!check.fromInternal && check.withoutTemplateConversion){
              attrType = {
                ___attrStart___: {}
              }
            }
            let errorInfo = undefined;
            if (attrs.length !== 0) {
              // @newChanges
              node.attr = attrs.reduce(function (acc, attr) {
                const name = attr.name;
                let value = attr.value;
                const nodeData = node.data;
                if (attr.errorInfo) {
                  node.errorInfo = attr.errorInfo;
                }
                value = value.replace(/&nbsp;/gm, "@nbsp@").replace(/&#160;?/gm, "@nbsp@").replace(/&#xa0;?/gm, "@nbsp@").replace('.{}', '____lyteinternal____');
                value = decodeHtmlEntities.decode(value);
                let res = syntaxCheckWorkerNew(value, check, errorObj, {
                  lineIndex,
                  colIndex
                },true);
                value = res.text;
                if (!acc[name] || (nodeData && nodeData[name])) {
                  if (isOptionCallBackPresent && optionsCallBacks[name] && typeof optionsCallBacks[name] === 'function') {
                    try {
                      value = optionsCallBacks[name](value);
                    } catch (e) {
                      console.error("Invalid callback");
                      return;
                    }
                  }
                  if (optionsData && optionsData[name]) {
                    const keyVal = optionsData[name];
                    node.data = node.data || {};
                    node.data[keyVal] = value;

                  } else {
                    acc[name] = value;
                    attrType[name] = res.type;
                    if (!check.fromInternal && check.withoutTemplateConversion) {
                      attrType.___attrStart___[name] = attr.startChar;
                    }
                  }
                }
                return acc;
              }, {});
              if (errorInfo) {
                node.errorInfo = errorInfo;
              }

            }

            node.attrType = attrType;
            if (check.enhanced && parent.child && parent.child.length) {
              parent.child[parent.child.length - 1].next = node;
            }

            if (unary) {
              let parent = bufferArray[0] || results;
              if (parent.child === void 0) {
                parent.child = [];
              }
              parent.child.push(node);
            } else {
              bufferArray.unshift(node);
            }

            // if (!find(node.attr, "lyte-if") && svg.includes(node.tag)) {
            //   splitTextNodes(node);
            // }

          },
          end: function (tag, flag, misMatchCase, seenSVGBefore) {
            // merge into parent tag

            if (tag == "style") {
              styleTagStarted = false;
            }
            let node = bufferArray.shift();
            if (node.parent && node.parent.node == "element" && allTableTags[node.parent.tag.toLowerCase()] && allTableTags[node.tag.toLowerCase()] && tagLevel[node.tag] <= 1 && tagLevel[node.parent.tag.toLowerCase()] <= tagLevel[node.tag.toLowerCase()]) {
              let err = new Error("Error: Invalid tag " + node.tagName + " inside " + node.parent.tagName);
              err.fromParser = true;
              throw err;
            }
            if (flag) {
              node.setAttribute("lt-prop-MisMatchLastParent", "true");
            }
            if (misMatchCase) {
              node.setAttribute("lt-prop-MisMatchClosingTags", "true");
            }
            if (node.tag !== tag) {
              let err = new Error('Mismatch in end tag :' + tag);
              err.fromParser = true;
              throw err;
            }
            if (node.tag == "template" && seenSVGBefore == 0 && !check.hasParentSvg) {
              let child = node.child;
              if (!node.content) {
                node.content = node.createDocumentFragment();
              }
              node.content.appendChildArr(child);
              delete node.child;
            }
            if (bufferArray.length === 0) {
              results.child.push(node);
            } else {
              const parent = bufferArray[0];
              if (parent.child === void 0) {
                parent.child = [];
              }
              parent.child.push(node);
            }
            if (node.tag && node.tag == "pre" && node.child[0].node == "#text" && node.child[0].text && node.child[0].text[0] == "\n") {
              node.child[0].text = node.child[0].text.slice(1);
              if (node.child[0].text.length == 0) {
                delete node.child[0];
                node.child = node.child.slice(1);
                node.child[0].prev = null;
              }
            }

            // console.log(node);

          },
          chars: function (text, lineIndex, colIndex, checkClosingTag) {
            if (preventSpaceText==true) {
              text = text.trim();
              if(text==''){
                return;
              }
            } 
            let parent = bufferArray[0] || results;
            const node = new Node({
              node: '#text',
              text: text,
              attrType: ""
            });
            if (check.Compile) {
              node.__proto__.Compile = check.Compile;
            }
            // node.text = decodeHtmlEntities.default.decode(node.text);
            // @newChanges
            if (styleTagStarted) {
              node.style = true;
            }
            text = text.replace(/&nbsp;?/gm, "@nbsp@").replace(/&#160;?/gm, "@nbsp@").replace(/&#xa0;?/gm, "@nbsp@").replace('.{}', '____lyteinternal____');
            node.text = decodeHtmlEntities.decode(text, true);
            // console.log(decodeHtmlEntities.decode(node.text));
            if (check.enhanced) {
              node.parent = parent;
              node.prev = (parent.child && parent.child[parent.child.length - 1]) ? parent.child[parent.child.length - 1] : null;
              node.next = null;
              if (check.withLineIndex) {
                node.lineIndex = lineIndex
              };
              if (check.withColumnIndex) {
                node.colIndex = colIndex
              };
              // if (checkClosingTag) {
              //   node.checkClosingTag = true
              // };
            }
            if (check.enhanced && parent.child && parent.child.length) {
              parent.child[parent.child.length - 1].next = node;
            }
            if (bufferArray.length === 0) {
              results.child.push(node);
            } else {
              const parent = bufferArray[0] || results;
              if (parent.child === void 0) {
                parent.child = [];
              }
              parent.child.push(node);
            }

            let res = syntaxCheckWorkerNew(node.text, check, errorObj, {
              lineIndex,
              colIndex
            });
            if(preventSpaceText==true){
               node.text = text;
            }
            else{
                  node.attrType = (res.type) ? res.type : ""; // changed @3055
              node.text = res.text;

              if (node.prev && node.prev.node == "#text") {
                let text = node.prev.text;
                node.text = text + node.text;
                node.prev.remove();
              }
              let nodeValue = node.text;
              if (nodeValue) {
                let mustacheValues = nodeValue.match(/{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}/g); //'
                if (mustacheValues) {
                  let newNodeArray = [];
                  let lastIndex = 0;
                  let offset = 0;
                  let flag = false;
                  for (let i = 0; i < mustacheValues.length; i++) {
                    let mustacheStartIndex = nodeValue.indexOf(mustacheValues[i]);

                    let mustacheEndIndex = mustacheStartIndex + mustacheValues[i].length;
                    if (mustacheStartIndex) {
                      flag = true;
                      newNodeArray.push(node.createTextNode(nodeValue.substring(0, mustacheStartIndex), {
                        parent: node.parent,
                        lineIndex: (check.withLineIndex) ? lineIndex : undefined,
                        colIndex: (check.withColumnIndex) ? colIndex + offset : undefined,
                        attrType: ""
                      }));
                    }
                    newNodeArray.push(node.createTextNode(nodeValue.substring(mustacheStartIndex, mustacheEndIndex), {
                      parent: node.parent,
                      lineIndex: (check.withLineIndex) ? lineIndex : undefined,
                      colIndex: (check.withColumnIndex) ? colIndex + mustacheStartIndex + offset : undefined,
                      attrType: res.type
                    }));
                    offset = offset + mustacheEndIndex;
                    nodeValue = nodeValue.substring(mustacheEndIndex);
                    lastIndex = colIndex + offset;
                  }
                  newNodeArray.push(node.createTextNode(nodeValue, {
                    parent: node.parent,
                    lineIndex: (check.withLineIndex) ? lineIndex : undefined,
                    colIndex: (check.withColumnIndex) ? lastIndex : undefined,
                    attrType: ""
                  }));
                  for (let i = 0; i < newNodeArray.length - 1; i++) {
                    newNodeArray[i].next = newNodeArray[i + 1];
                  }
                  for (let i = 1; i < newNodeArray.length; i++) {
                    newNodeArray[i].prev = newNodeArray[i - 1];
                  }
                  if (node.parent && node.parent.child) {
                    if (flag && node.prev) {
                      let lastChild = node.prev;
                      lastChild.next = newNodeArray[0];
                      newNodeArray[0].prev = lastChild;
                    }
                    let ls = node.parent.child
                    let index = node.parent.child.indexOf(node)
                    let args = [index, 1].concat(newNodeArray);
                    Array.prototype.splice.apply(ls, args);
                  }
                }
              }
             
            }
            
          },
          comment: function (text, lineIndex, colIndex) {
            if (!check.withoutComment) {
              let par;
              const node = new Node({
                node: 'comment',
                text: text
              });
              par = bufferArray[0] || results;

              if (check.enhanced) {
                node.parent = par;
                node.prev = (par.child && par.child[par.child.length - 1]) ? par.child[par.child.length - 1] : null;
                node.next = null;
                if (check.withLineIndex) {
                  node.lineIndex = lineIndex
                };
                if (check.withColumnIndex) {
                  node.colIndex = colIndex
                };
              }
              if (check.enhanced && par.child && par.child.length) {
                par.child[par.child.length - 1].next = node;
              }
              const parent = bufferArray[0] || results;
              if (parent.child === void 0) {
                parent.child = [];
              }
              parent.child.push(node);
            }
          }
        },
        check.emberFlag, check.fileName, errorObj, check.withoutTableProcessing);
      if (!check.withoutTableProcessing) {
        if(check.hasSeenTable){
          processTableTag(results);
        }
        if(check.hasSeenSelector){
          processSelectTags(results);
        }
      }
      // processTableTag(results);
      let s;
      // <lyte-event-listener/> to process self closing attributes not in the list
      // s = results.querySelectorAll("[singleAttribute]", true);
      // for (let i = 0; i < s.length; i++) {
      //   let childObj = s[i];
      //   if (!selfClosingTags[s[i].tag]) { //
      //     let index = childObj.parent.child.indexOf(childObj);
      //     let ls = childObj.parent.child.slice(index + 1);
      //     let child = childObj.parent.child.splice(0, index + 1);
      //     childObj.parent.child = [];
      //     for (let childOfChild of child) {
      //       childObj.parent.appendChild(childOfChild);
      //     }
      //     childObj.child = []
      //     for (let childOfChild of ls) {
      //       childObj.appendChild(childOfChild);
      //     }
      //   }
      //   s[i].removeAttribute("singleAttribute");
      // }
      if (!check.withoutTemplateConversion) {
        let comp = results.querySelector("[tag-name]")
        let nextElement = comp.nextElementSibling;
        if(cliVersion == 4){
          if (nextElement && nextElement.tagName == "TEMPLATE" && nextElement.hasAttribute("view-port-template")) {
            errorObj.warnings.push({
              message: "Depricated Syntax : 'view-port-template' found in " + check.fileName + " . Migrate your app to using latest slyte-migrator."
            });
            let viewPortIf = comp.createElement("template");
            viewPortIf.setAttribute("lyte-if", "{{lyteViewPort}}");
            viewPortIf.setAttribute("__vp", "c-old");
            viewPortIf.content.appendChild(comp.createElement("dummy-port-element"));
            viewPortIf.content.appendChild(nextElement.content);
            viewPortIf.content.appendChild(comp.createElement("dummy-port-element"));
            let falseCase = comp.createElement("template");
            falseCase.setAttribute("lyte-else", "");
            falseCase.content.appendChild(comp.content);
            comp.innerHTML = "";
            comp.content.appendChild(viewPortIf);
            comp.content.appendChild(falseCase);
            nextElement.remove();
          } else if (nextElement && nextElement.tagName == "TEMPLATE" && nextElement.attributes["@view-out"]) {
            let viewPortIf = comp.createElement("template"); //actual content
            let attrVal = comp.getAttribute("@view-in");
            if (attrVal.startsWith("{{")) {
              attrVal = attrVal.substring(2, attrVal.length - 2);
              viewPortIf.setAttribute("lyte-if", "{{lyteViewPort(" + attrVal + ")}}");
            } else if (attrVal === "") {
              ;
              viewPortIf.setAttribute("lyte-if", "{{lyteViewPort()}}");
            } else {
              viewPortIf.setAttribute("lyte-if", "{{lyteViewPort(" + attrVal + ")}}");
            }
            viewPortIf.setAttribute("__vp", "c-new");
            viewPortIf.content.appendChild(comp.content);
            comp.removeAttribute("@view-in");

            let viewPortElse = comp.createElement("template"); //loading
            viewPortElse.setAttribute("lyte-else", "");

            viewPortElse.content.appendChild(comp.createElement("dummy-port-element"));
            viewPortElse.content.appendChild(nextElement.content);
            viewPortElse.content.appendChild(comp.createElement("dummy-port-element"));

            comp.innerHTML = "";

            comp.content.appendChild(viewPortIf);
            comp.content.appendChild(viewPortElse);
            nextElement.remove();
            comp.setAttribute("__vp", "c-new");
          }
        }
        check.Compile.splitTextNodes(comp.content, errorObj.warnings, undefined, check, errorObj, undefined);
        s = results.querySelectorAll("[lyte-else]", true);
        for (let i = 0; i < s.length; i++) {
          let node = s[i]
          if (node && !(node.previousElementSibling && (find(node.previousElementSibling, "lyte-if") || find(node.previousElementSibling, "lyte-else-if")))) {
            let temp = node.cloneNode();
            temp.innerHTML = "...";
            if (errorObj && errorObj.warnings && check.fromCLI) {
              errorObj.warnings.push({
                message: "Parse Warning : `lyte-else` without `lyte-if` in " + temp.outerHTML
              });
            } else {
              console.warn("Parse Warning : `lyte-else` without `lyte-if` in " + temp.outerHTML);
            }
          }
        }

        s = results.querySelectorAll("[lyte-else-if]", true)
        for (let i = 0; i < s.length; i++) {
          let node = s[i]
          if (node && !(node.previousElementSibling && (find(node.previousElementSibling, "lyte-if") || find(node.previousElementSibling, "lyte-else-if")))) {
            let temp = node.cloneNode();
            temp.innerHTML = "...";
            if (errorObj && errorObj.warnings && check.fromCLI) {
              errorObj.warnings.push({
                message: "Parse Warning : `lyte-else-if` without `lyte-if` in " + temp.outerHTML
              });
            } else {
              console.warn("Parse Warning : `lyte-else-if` without `lyte-if` in " + temp.outerHTML);
            }
          }
        }
      }

      // MisMatch order in closing tags inorder to put all the parent's next sibling as child's next sibling 
      // <div class="mT7 pR {{if( item.isError,'admc_errorMsg','')}}">
      //       <%if(item.type == "dropdown"){%>
      //           </div>
      //       <%}%>
      // s = results.querySelectorAll("[lt-prop-MisMatchLastParent]", true);
      // for (let i = 0; i < s.length; i++) {
      //   let ptr = s[i];
      //   let child = ptr;
      //   let parent = child.parent;
      //   while (parent && parent.tag != "template") {
      //     let ls = [];
      //     if (parent.parent) {
      //       ls = parent.parent.child.slice(parent.parent.child.indexOf(parent) + 1);
      //     } else {
      //       break;
      //     }
      //     for (let i of ls) {
      //       ptr.appendChild(i.deepCopyObject());
      //       i.remove();
      //     }
      //     child = parent;
      //     parent = parent.parent;
      //   }
      //   s[i].removeAttribute("lt-prop-MisMatchLastParent")
      // }

      // s = results.querySelectorAll("[dontConsiderForDefault]",true);
      // for (let i = 0; i < s.length; i++) {
      //   s[i].removeAttribute("dontConsiderForDefault");
      // }
      // s = results.querySelectorAll("[lt-prop-MisMatchClosingTags]", true);
      // for (let i = 0; i < s.length; i++) {
      //   s[i].removeAttribute("lt-prop-MisMatchClosingTags");
      //   let childObj = s[i];
      //   let tagToCheck = childObj.tag;
      //   while (childObj.parent) {
      //     if (childObj.parent.tag == tagToCheck) {
      //       let parent = childObj.parent;
      //       let index = parent.child.indexOf(childObj);
      //       if (parent.parent) {
      //         let ls = parent.child.slice(index + 1);
      //         parent.child.splice(index + 1);
      //         parent.child[index].next = null;
      //         let tempChilds = parent.parent.child.slice(parent.parent.child.indexOf(parent) + 1);
      //         parent.parent.child.splice(parent.parent.child.indexOf(parent) + 1);
      //         for (let node of ls) {

      //           if (!node.hasAttribute("checkClosingTag") && !node.checkClosingTag) {
      //             if (parent.parent.child[parent.parent.child.length - 1].node == "#text" && node.node == "#text" && !node.text.match(/{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}/g) && !parent.parent.child[parent.parent.child.length - 1].text.match(/{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}/g)) {
      //               node.text = parent.parent.child[parent.parent.child.length - 1].text + node.text;
      //               parent.parent.child[parent.parent.child.length - 1].remove();
      //             }
      //             parent.parent.appendChild(node);
      //           } else {
      //             if (node.hasAttribute("checkClosingTag")) {
      //               node.removeAttribute("checkClosingTag")
      //             } else {
      //               delete node.checkClosingTag;
      //             }
      //             parent.appendChild(node);
      //           }
      //         }
      //         if (parent.parent.child[parent.parent.child.length - 1].node == "#text" && tempChilds[0].node == "#text") {
      //           tempChilds[0].text = parent.parent.child[parent.parent.child.length - 1].text + tempChilds[0].text;
      //           parent.parent.child[parent.parent.child.length - 1].remove();
      //         }
      //         for (let node of tempChilds) {
      //           parent.parent.appendChild(node);
      //         }
      //       }
      //     }
      //     if (childObj.parent.tag != "template" || childObj.parent.tag != tagToCheck) {
      //       break;
      //     }
      //     childObj = childObj.parent;
      //   }
      // }

      // s = results.querySelectorAll("[checkClosingTag]", true);
      // for (let i = 0; i < s.length; i++) {
      //   s[i].removeAttribute("checkClosingTag");
      // }
      if (check.emberFlag) {
        let objAttr = check.observedAttributes;
        delete objAttr.this
        results.observedAttributes = Object.keys(objAttr);
      }
      return results;
    } else {
      throw new Error("Error: Invalid value. Expected string");
    }
  }

  const API = {
    toHtml: convertToHtml,
    toObject: convertToObject,
    processTable: processTableTag
  }
  return API;
}());

export default htmlToJsObjectLyteRendered;
//ignorei18n_end