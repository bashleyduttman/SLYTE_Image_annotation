(self["webpackChunktestApp"] = self["webpackChunktestApp"] || []).push([["lyte"],{

/***/ 88249548:
/*!***********************************************************************************!*\
  !*** ./node_modules/@slyte/component/src/ZohoSecurity/lyte-component-security.js ***!
  \***********************************************************************************/
/***/ (() => {

;if(!window.ZSEC) {if(window.ZSEC||Object.defineProperty(window,"ZSEC",{value:{},writable:!1,configurable:!1,enumerable:!1}),Object.defineProperty(ZSEC,"util",{value:{},writable:!1,configurable:!1,enumerable:!1}),function(){if(!Object.defineProperty||!function(){try{return Object.defineProperty({},"x",{}),!0}catch(e){return!1}}()){var e=Object.defineProperty;Object.defineProperty=function(t,r,o){if(e)try{return e(t,r,o)}catch(e){}if(t!==Object(t))throw TypeError("Object.defineProperty called on non-object");return Object.prototype.__defineGetter__&&"get"in o&&Object.prototype.__defineGetter__.call(t,r,o.get),Object.prototype.__defineSetter__&&"set"in o&&Object.prototype.__defineSetter__.call(t,r,o.set),"value"in o&&(t[r]=o.value),t}}}(),ZSEC.util.defineProperty=function(e,t,r,o,n,i,a){if(o||!(t in e))return n=1==n,i=1==i,a=1==a,Object.defineProperty(e,t,{value:r,writable:n,configurable:i,enumerable:a})},ZSEC.util.defineProperty(ZSEC,"version","4.0",!0),ZSEC.util.defineProperty(ZSEC,"constants",ZSEC.constants||{},!0),ZSEC.util.ArrayIndexOf=Array.prototype.indexOf,ZSEC.util.ArrayIndexOf||(ZSEC.util.ArrayIndexOf=function(e){if(void 0===this||null===this)throw TypeError();var t=Object(this),r=t.length>>>0;if(0===r)return-1;var o=0;if(arguments.length>0&&(o=Number(arguments[1]),isNaN(o)?o=0:0!==o&&o!==1/0&&o!==-1/0&&(o=(o>0||-1)*Math.floor(Math.abs(o)))),o>=r)return-1;for(var n=o>=0?o:Math.max(r-Math.abs(o),0);n<r;n++)if(n in t&&t.charAt(n)===e)return n;return-1}),String.prototype.codePointAt)ZSEC.util.defineProperty(String.prototype,"codePointAt",String.prototype.codePointAt,!0);else{var codePointAt=function(e){if(null==this)throw TypeError();var t=String(this),r=t.length,o=e?Number(e):0;if(o!=o&&(o=0),!(o<0||o>=r)){var n,i=t.charCodeAt(o);return i>=55296&&i<=56319&&r>o+1&&(n=t.charCodeAt(o+1))>=56320&&n<=57343?1024*(i-55296)+n-56320+65536:i}};ZSEC.util.defineProperty(String.prototype,"codePointAt",codePointAt,!1)}if(String.fromCodePoint)ZSEC.util.defineProperty(String,"fromCodePoint",String.fromCodePoint,!0);else{var stringFromCharCode=String.fromCharCode,floor=Math.floor,fromCodePoint=function(){var e,t,r=[],o=-1,n=arguments.length;if(!n)return"";for(var i="";++o<n;){var a=Number(arguments[o]);if(!isFinite(a)||a<0||a>1114111||floor(a)!=a)throw RangeError("Invalid code point: "+a);a<=65535?r.push(a):(e=55296+((a-=65536)>>10),t=a%1024+56320,r.push(e,t)),(o+1==n||r.length>16384)&&(i+=stringFromCharCode.apply(null,r),r.length=0)}return i};ZSEC.util.defineProperty(String,"fromCodePoint",fromCodePoint,!1)}!function(){var e={log:function(e){if(navigator&&navigator.userAgent){var t=navigator.userAgent.match(/opera|chrome|safari|firefox|msie|trident(?=\/)/i);if(t&&t[0].search(/trident|msie/i)<0)return window.console.log("%cSTOP!","color:red;font-size:xx-large;font-weight:bold;"),void window.console.log("%cThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\nSee https://en.wikipedia.org/wiki/Self-XSS for more details","font-size:large;")}window.console.log("STOP!\nThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\nSee https://en.wikipedia.org/wiki/Self-XSS for more details")}};ZSEC.util.defineProperty(ZSEC,"Console",e,!0,!1,!1,!0)}(),ZSEC.Console.log();};window.DOMPurifyCopy = window.DOMPurify ? window.DOMPurify : undefined;;if(!window.ZSEC.HTMLPurifier) {function addToSet(e,t){for(var r=t.length;r--;)e[t[r]]=!0;return e}function addObjsToSet(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=!0);return e}function removeFromSet(e,t){var r={};for(var o in e)e.hasOwnProperty(o)&&o!=t&&(r[o]=e[o]);return r}!function(e){window.DOMPurify=e(window)}(function e(t){var r=function(t){return e(t)};if(r.version="0.8.5",r.removed=[],!t||!t.document||9!==t.document.nodeType)return r.isSupported=!1,r;var o=t.document,n=o,T=t.DocumentFragment,i=t.HTMLTemplateElement,a=t.Node,A=t.NodeFilter,_=t.NamedNodeMap||t.MozNamedAttrMap,E=t.Text,O=t.Comment,L=t.DOMParser;if("function"==typeof i){var s=o.createElement("template");s.content&&s.content.ownerDocument&&(o=s.content.ownerDocument)}var l=o.implementation,d=o.createNodeIterator,u=o.getElementsByTagName,c=o.createDocumentFragment,R=n.importNode,S={};r.isSupported=void 0!==l.createHTMLDocument&&9!==o.documentMode;var f=function(e,t){for(var r=t.length;r--;)"string"==typeof t[r]&&(t[r]=t[r].toLowerCase()),e[t[r]]=!0;return e},p=null,B=f({},[]),m=null,N=f({},[]),D=null,I=null,h=!0,U=!0,v=!1,b=!1,y=!1,g=/\{\{[\s\S]*|[\s\S]*\}\}/gm,G=/<%[\s\S]*|[\s\S]*%>/gm,F=!1,w=!0,M=!1,C=!1,P=!1,W=!0,J=!0,x=f({},["audio","head","math","script","svg","video","style"]),H=f({},["audio","video","img","source","image"]),k=f({},["alt","class","for","id","label","name","pattern","placeholder","summary","title","value","style","xmlns"]),Y=null,z=o.createElement("form"),V=function(e){"object"!=typeof e&&(e={}),p="ALLOWED_TAGS"in e?f({},e.ALLOWED_TAGS):B,m="ALLOWED_ATTR"in e?f({},e.ALLOWED_ATTR):N,D="FORBID_TAGS"in e?f({},e.FORBID_TAGS):{},I="FORBID_ATTR"in e?f({},e.FORBID_ATTR):{},h=!1!==e.ALLOW_ARIA_ATTR,U=!1!==e.ALLOW_DATA_ATTR,v=e.ALLOW_UNKNOWN_PROTOCOLS||!1,b=e.SAFE_FOR_JQUERY||!1,y=e.SAFE_FOR_TEMPLATES||!1,F=e.WHOLE_DOCUMENT||!1,M=e.RETURN_DOM||!1,C=e.RETURN_DOM_FRAGMENT||!1,P=e.RETURN_DOM_IMPORT||!1,w=!1!==e.FORCE_BODY,W=!1!==e.SANITIZE_DOM,J=!1!==e.KEEP_CONTENT,y&&(U=!1),C&&(M=!0),e.ADD_URI_SAFE_ATTR&&f(k,e.ADD_URI_SAFE_ATTR),J&&(p["#text"]=!0),Object&&"freeze"in Object&&Object.freeze(e),Y=e},j=function(e){r.removed.push({element:e});try{e.parentNode.removeChild(e)}catch(t){e.outerHTML=""}},Q=function(e,t){r.removed.push({attribute:t.getAttributeNode(e),from:t}),t.removeAttribute(e)},X=function(e){var t,r;w&&(e="<remove></remove>"+e);try{t=(new L).parseFromString(e,"text/html")}catch(e){}return t&&t.documentElement||((r=(t=l.createHTMLDocument("")).body).parentNode.removeChild(r.parentNode.firstElementChild),r.outerHTML=e),"function"==typeof t.getElementsByTagName?t.getElementsByTagName(F?"html":"body")[0]:u.call(t,F?"html":"body")[0]},Z=function(e){return d.call(e.ownerDocument||e,e,A.SHOW_ELEMENT|A.SHOW_COMMENT|A.SHOW_TEXT,function(){return A.FILTER_ACCEPT},!1)},K=function(e){return!(e instanceof E||e instanceof O)&&!("string"==typeof e.nodeName&&"string"==typeof e.textContent&&"function"==typeof e.removeChild&&e.attributes instanceof _&&"function"==typeof e.removeAttribute&&"function"==typeof e.setAttribute)},q=function(e){return"object"==typeof a?e instanceof a:e&&"object"==typeof e&&"number"==typeof e.nodeType&&"string"==typeof e.nodeName},$=function(e){var t,o;if(ae("beforeSanitizeElements",e,null),K(e))return j(e),!0;if(t=e.nodeName.toLowerCase(),ae("uponSanitizeElement",e,{tagName:t,allowedTags:p}),!p[t]||D[t]){if(J&&!x[t]&&"function"==typeof e.insertAdjacentHTML)try{e.insertAdjacentHTML("AfterEnd",e.innerHTML)}catch(e){}return j(e),!0}return "style"!=t?(!b||e.firstElementChild||e.content&&e.content.firstElementChild||!/</g.test(e.textContent)||(r.removed.push({element:e.cloneNode()}),e.innerHTML=e.textContent.replace(/</g,"&lt;")),y&&3===e.nodeType&&(o=(o=(o=e.textContent).replace(g," ")).replace(G," "),e.textContent!==o&&(r.removed.push({element:e.cloneNode()}),e.textContent=o))):!b||e.firstElementChild||e.content&&e.content.firstElementChild||!/</g.test(e.textContent)||(r.removed.push({element:e.cloneNode()}),e.innerHTML=e.textContent.replace(/</g,"\\3c ")),ae("afterSanitizeElements",e,null),!1;},ee=/^data-[-\w.\u00B7-\uFFFF]/,te=/^aria-[-\w]+$/,re=/^(?:(?:https?|mailto|tel):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i,oe=/^(?:\w+script|data):/i,ne=/[\x00-\x20\xA0\u1680\u180E\u2000-\u2029\u205f\u3000]/g,Te=function(e){var t,n,T,i,a,A,_,E;if(ae("beforeSanitizeAttributes",e,null),A=e.attributes){for(_={attrName:"",attrValue:"",keepAttr:!0,allowedAttributes:m},E=A.length;E--;)if(t=A[E],n=t.name,T=t.value.trim(),i=n.toLowerCase(),_.attrName=i,_.attrValue=T,_.keepAttr=!0,ae("uponSanitizeAttribute",e,_),T=_.attrValue,"name"===i&&"IMG"===e.nodeName&&A.id?(a=A.id,A=Array.prototype.slice.apply(A),Q("id",e),Q(n,e),A.indexOf(a)>E&&e.setAttribute("id",a.value)):("id"===n&&e.setAttribute(n,""),Q(n,e)),_.keepAttr&&(!W||"id"!==i&&"name"!==i||!(T in o||T in z))){y&&(T=(T=T.replace(g," ")).replace(G," "));if(U&&ee.test(i))!0;else if(h&&te.test(i))!0;else{if(!m[i]||I[i])continue;if(k[i])!0;else if(re.test(T.replace(ne,"")))!0;else if("src"!==i&&"xlink:href"!==i||0!==T.indexOf("data:")||!H[e.nodeName.toLowerCase()])if(v&&!oe.test(T.replace(ne,"")))!0;else{if(T)continue;!0}else!0}try{e.setAttribute(n,T),r.removed.pop()}catch(e){}}ae("afterSanitizeAttributes",e,null)}},ie=function(e){var t,r=Z(e);for(ae("beforeSanitizeShadowDOM",e,null);t=r.nextNode();)ae("uponSanitizeShadowNode",t,null),$(t)||(t.content instanceof T&&ie(t.content),Te(t));ae("afterSanitizeShadowDOM",e,null)},ae=function(e,t,o){S[e]&&S[e].forEach(function(e){e.call(r,t,o,Y)})};return r.sanitize=function(e,o){var i,A,_,E,O,L;if(e||(e="\x3c!--\x3e"),"string"!=typeof e&&!q(e)){if("function"!=typeof e.toString)throw new TypeError("toString is not a function");e=e.toString()}if(!r.isSupported){if("object"==typeof t.toStaticHTML||"function"==typeof t.toStaticHTML){if("string"==typeof e)return t.toStaticHTML(e);if(q(e))return t.toStaticHTML(e.outerHTML)}return e}if(V(o),r.removed=[],e instanceof a)1===(A=(i=X("\x3c!--\x3e")).ownerDocument.importNode(e,!0)).nodeType&&"BODY"===A.nodeName?i=A:i.appendChild(A);else{if(!M&&!F&&-1===e.indexOf("<"))return e;if(!(i=X(e)))return M?null:""}for(w&&j(i.firstChild),O=Z(i);_=O.nextNode();)3===_.nodeType&&_===E||$(_)||(_.content instanceof T&&ie(_.content),Te(_),E=_);if(M){if(C)for(L=c.call(i.ownerDocument);i.firstChild;)L.appendChild(i.firstChild);else L=i;return P&&(L=R.call(n,L,!0)),L}return F?i.outerHTML:i.innerHTML},r.addHook=function(e,t){"function"==typeof t&&(S[e]=S[e]||[],S[e].push(t))},r.removeHook=function(e){S[e]&&S[e].pop()},r.removeHooks=function(e){S[e]&&(S[e]=[])},r.removeAllHooks=function(){S={}},r}),function(e){var t={};t.ALLOW_ARIA_ATTR=!0,t.ALLOW_DATA_ATTR=!0,t.ALLOW_UNKNOWN_PROTOCOLS=!1,t.SAFE_FOR_JQUERY=!1,t.SAFE_FOR_TEMPLATES=!1,t.WHOLE_DOCUMENT=!1,t.RETURN_DOM=!1,t.RETURN_DOM_FRAGMENT=!1,t.RETURN_DOM_IMPORT=!1,t.FORCE_BODY=!0,t.SANITIZE_DOM=!0,t.KEEP_CONTENT=!0,t.STYLE_VALIDATION=!0,t.REMOVE_ONEVENTS=!0,t.ALLOWED_STYLE="NONE",t.ALLOWED_TAGS="a|abbr|acronym|address|area|article|aside|audio|b|bdi|bdo|big|blink|blockquote|body|br|button|canvas|caption|center|cite|code|col|colgroup|content|data|datalist|dd|decorator|del|details|dfn|dir|div|dl|dt|element|em|fieldset|figcaption|figure|font|footer|form|h1|h2|h3|h4|h5|h6|head|header|hgroup|hr|html|i|img|input|ins|kbd|label|legend|li|main|map|mark|marquee|menu|menuitem|meter|nav|nobr|ol|optgroup|option|output|p|pre|progress|q|rp|rt|ruby|s|samp|section|select|shadow|small|source|spacer|span|strike|strong|sub|summary|sup|table|tbody|td|template|textarea|tfoot|th|thead|time|title|tr|track|tt|u|ul|var|video|wbr|#text".split("|"),t.ALLOWED_ATTR="accept|action|align|alt|autocomplete|background|bgcolor|border|cellpadding|cellspacing|checked|cite|class|clear|color|cols|colspan|coords|datetime|default|dir|disabled|download|enctype|face|for|headers|height|hidden|high|href|hreflang|id|ismap|label|lang|list|loop|low|max|maxlength|media|method|min|multiple|name|noshade|novalidate|nowrap|open|optimum|pattern|placeholder|poster|preload|pubdate|radiogroup|readonly|rel|required|rev|reversed|role|rows|rowspan|spellcheck|scope|selected|shape|size|span|srclang|start|src|step|summary|tabindex|title|target|type|usemap|valign|value|width|xmlns|sandbox".split("|"),t.ALLOWED_STYLE_PROPS="azimuth|background|background-attachment|background-color|background-image|background-position|content|background-repeat|border-collapse|border-color|border-top-color|border-right-color|border-bottom-color|border-left-color|bottom|caption-side|clear|color|cue-after|cue-before|direction|display|elevation|empty-cells|float|font-size|font-size-adjust|font-stretch|font-style|font-variant|font-weight|height|left|letter-spacing|line-height|list-style-image|list-style-position|list-style-type|marker-offset|max-height|max-width|min-height|min-width|orphans|outline-color|overflow|page-break-after|page-break-before|page-break-inside|pause-after|pause-before|pitch|pitch-range|position|richness|right|size|speak|speak-header|speak-numeral|speak-punctuation|speech-rate|stress|table-layout|text-indent|text-transform|top|unicode-bidi|vertical-align|visibility|volume|white-space|widows|width|word-spacing|border-style|border-top-style|border-right-style|border-bottom-style|border-left-style|border-top-width|border-right-width|border-bottom-width|border-left-width|border-width|margin|margin-top|margin-right|margin-bottom|margin-left|outline-style|outline-width|padding|padding-top|padding-right|padding-bottom|padding-left|border|border-top|border-right|border-bottom|border-left|cue|list-style|marks|outline|pause|text-decoration|border-spacing|clip|counter-increment|clip|cursor|text-shadow|font|font-family|page|play-during|text-align|voice-family".split("|"),t.FORBID_TAGS=[],t.FORBID_ATTR=[],t.ALLOWED_TAGS_OBJ={},t.ALLOWED_ATTR_OBJ={},t.FORBID_TAGS_OBJ={},t.FORBID_ATTR_OBJ={},t.ADD_URI_SAFE_ATTR=[],t.EXTENDS=["GLOBAL_ATTRIBUTES","GLOBAL_TAGS","FORBID_TAGS","FORBID_ATTR","GLOBAL_APPEND_ATTRIBUTES","GLOBAL_ATTRIBUTE_RULES","ADD_URI_SAFE_ATTR","TAG_RULES"],t.TAG_RULES={a:{APPEND_ATTRIBUTES:[{NAME:"rel",VALUE:"noopener noreferrer",CRITERIA:[{NAME:"target",CONTAINS:"_blank"}]}]}},t.GLOBAL_APPEND_ATTRIBUTES=[],t.GLOBAL_ATTRIBUTE_RULES={},ZSEC.util.defineProperty(ZSEC,"HTMLPurifier",e(t,DOMPurify(window)),!0,!1,!1,!0),delete window.DOMPurify}(function e(t,r){function o(e){if(!e||e.constructor!==Object)return t;var r={};for(var o in t)t.hasOwnProperty(o)&&(o in e?o in m&&(1==e[o]||0==e[o]?r[o]=e[o]:r[o]=t[o]):r[o]=t[o]);return r.SAFE_FOR_TEMPLATES&&(r.ALLOW_DATA_ATTR=!1),r.RETURN_DOM_FRAGMENT&&(r.RETURN_DOM=!0),r.KEEP_CONTENT&&(r.ALLOWED_TAGS_OBJ["#text"]=!0),r}function n(e){for(var t in e)e.hasOwnProperty(t)&&e[t].constructor==String&&(e[t]&&b[t]?v=!0:e[t]&&("cssText"==t||/^\d.*/.test(t)||(e[t]="",I=!0)))}function T(e){for(var t=e.length-1;t>=0;t--){var r=e[t];1==r.type&&r.selectorText||8==r.type&&r.keyText?r.style&&n(r.style):4!=r.type&&7!=r.type||!r.cssRules||T(r.cssRules)}}function i(e,t){for(var r=t.length-1;r>=0;r--)1!=t[r].type&&4!=t[r].type&&7!=t[r].type||e.push(t[r].cssText)}function a(e,t,r){var r=void 0==r?e.IS_MANDATORY:r;if(e.NAME&&!t.hasAttribute(e.NAME.toLowerCase()))return e.IS_FORBIDDEN||!r;if(e.IS_FORBIDDEN)return!1;var o=t.getAttribute(e.NAME.toLowerCase());if(void 0!==o&&null!==o||(o=""),o.constructor==String){if(e.DONT_TRIM||(o=o.trim()),e.CASE_SENSITIVE||!1||(o=o.toLowerCase()),e.MAX_LENGTH&&o.length>e.MAX_LENGTH)return!1;if(e.MIN_LENGTH&&o.length<e.MIN_LENGTH)return!1;if(void 0!=e.REGEX){if(e.REGEX.constructor==RegExp&&-1==o.search(e.REGEX))return!1;if(e.REGEX.constructor==Array)for(T=0;T<e.REGEX.length;T++)if(-1==o.search(e.REGEX[T]))return!1}}if(e.LIST&&-1==e.LIST.indexOf(o))return!1;if("INTEGER"==e.TYPE||"FLOAT"==e.TYPE){var n;try{n="INTEGER"==e.TYPE?window.parseInt(o,10):window.parseFloat(o)}catch(e){return!1}if(window.isNaN(n))return!1;if(void 0!=e.GREATER_THAN&&n<=e.GREATER_THAN)return!1;if(void 0!=e.GREATER_THAN_OR_EQUAL&&n<e.GREATER_THAN_OR_EQUAL)return!1;if(void 0!=e.LESSER_THAN&&n>=e.LESSER_THAN)return!1;if(void 0!=e.LESSER_THAN_OR_EQUAL&&n>e.LESSER_THAN_OR_EQUAL)return!1;if(void 0!=e.EQUAL&&n!=e.EQUAL)return!1;if(void 0!=e.NOT_EQUAL&&n==e.NOT_EQUAL)return!1}else if(o.constructor==String){if(void 0!=e.STARTS_WITH&&0!=o.indexOf(e.STARTS_WITH))return!1;if(void 0!=e.ENDS_WITH&&o.lastIndexOf(e.ENDS_WITH)!=o.length-e.ENDS_WITH.length)return!1;if(void 0!=e.CONTAINS){if(e.CONTAINS.constructor==String&&-1==o.indexOf(e.CONTAINS))return!1;if(e.CONTAINS.constructor==Array)for(T=0;T<e.CONTAINS.length;T++)if(-1==o.indexOf(e.CONTAINS[T]))return!1}if(void 0!=e.NOT_CONTAINS){if(e.NOT_CONTAINS.constructor==String&&o.indexOf(e.NOT_CONTAINS)>-1)return!1;if(e.NOT_CONTAINS.constructor==Array)for(var T=0;T<e.NOT_CONTAINS.length;T++)if(o.indexOf(e.NOT_CONTAINS[T])>-1)return!1}if(void 0!=e.EQUAL&&o!==e.EQUAL)return!1;if(void 0!=e.NOT_EQUAL&&o===e.NOT_EQUAL)return!1}return!0}function A(e){if(!e)return e;if(e.constructor==Object)for(var t in e)e.hasOwnProperty(t)&&(e[t]=E(e[t]));return e}function _(e){if(!e)return e;if(e.constructor==Array)for(var t=0;t<e.length;t++)if(e[t].CRITERIA)for(var r=0;r<e[t].CRITERIA.length;r++)e[t].CRITERIA[r]=E(e[t].CRITERIA[r]);return e}function E(e){if(e){var t=["STARTS_WITH","ENDS_WITH","CONTAINS","EQUAL","NOT_EQUAL","LIST"];if(!(e.CASE_SENSITIVE||!1))for(var r=0;r<t.length;r++){var o=t[r];e[o]&&(e[o]=O(e[o]))}}return e}function O(e){if(e&&e.constructor==String)return e.toLowerCase();if(e.constructor==Array)for(var t=0;t<e.length;t++)e[t]=O(e[t]);return e}function L(e,t){if(!e||e.constructor==Object)return e;for(var r={},o=0;o<e.length;o++){var n=e[o];r[n[t]]=n}return r}function s(e,t){if(e)for(var r=0;r<e.length;r++){var o=e[r];if(!t.hasAttribute(o.NAME.toLowerCase())){var n=!0;if(o.CRITERIA)for(var T=0;T<o.CRITERIA.length;T++)if(!a(o.CRITERIA[T],t,!0)){n=!1;break}n?t.setAttribute(o.NAME,o.VALUE):void 0!=o.DEFAULT_VALUE&&t.setAttribute(o.NAME,o.DEFAULT_VALUE)}}}function l(e,t){if(!t||t.constructor!==Object)return e;if(!e||e.constructor!==Object)return t;for(var r in t)t.hasOwnProperty(r)&&r in e?(void 0==e[r].APPEND_ATTRIBUTES&&(e[r].APPEND_ATTRIBUTES=t[r].APPEND_ATTRIBUTES),void 0==e[r].ATTRIBUTE_RULES&&(e[r].ATTRIBUTE_RULES=t[r].ATTRIBUTE_RULES)):e[r]=t[r];return e}function d(e,t,r){return!(t&&!a(t,e))||(void 0!==t.DEFAULT_VALUE?e.setAttribute(r,t.DEFAULT_VALUE):e.removeAttribute(r),!1)}function u(e){if("object"==typeof e){e.ALLOWED_TAGS=e.GLOBAL_TAGS,e.ALLOWED_ATTR=e.GLOBAL_ATTRIBUTES;for(var r in h)!h.hasOwnProperty(r)||void 0!=e[r]||r in D||(e[r]=t[r]);if(e.TAG_RULES=L(e.TAG_RULES,"NAME"),e.TAG_RULES&&e.TAG_RULES.constructor==Object)for(var o in e.TAG_RULES)if(e.TAG_RULES.hasOwnProperty(o)){var n=e.TAG_RULES[o];n.ATTRIBUTE_RULES=A(L(n.ATTRIBUTE_RULES,"NAME")),n.APPEND_ATTRIBUTES=_(n.APPEND_ATTRIBUTES)}if(e.GLOBAL_ATTRIBUTE_RULES=A(L(e.GLOBAL_ATTRIBUTE_RULES,"NAME")),e.GLOBAL_APPEND_ATTRIBUTES=_(e.GLOBAL_APPEND_ATTRIBUTES),e.EXTENDS)for(var T=0;T<e.EXTENDS.length;T++){var i=e.EXTENDS[T];switch("GLOBAL_TAGS"==i&&(i="ALLOWED_TAGS"),"GLOBAL_ATTRIBUTES"==i&&(i="ALLOWED_ATTR"),i){case"ALLOWED_TAGS":case"ALLOWED_ATTR":case"FORBID_TAGS":case"FORBID_ATTR":e[i+="_OBJ"]={},t[i]&&(e[i]=addObjsToSet(e[i],t[i]));break;case"ADD_URI_SAFE_ATTR":case"GLOBAL_APPEND_ATTRIBUTES":if(e[i]||(e[i]=[]),!t[i]||t[i].constructor!==Array)break;e[i]=e[i].concat(t[i]);break;case"GLOBAL_ATTRIBUTE_RULES":if(e.GLOBAL_ATTRIBUTE_RULES||(e.GLOBAL_ATTRIBUTE_RULES={}),t.GLOBAL_ATTRIBUTE_RULES&&t.GLOBAL_ATTRIBUTE_RULES.constructor==Object)for(var a in t.GLOBAL_ATTRIBUTE_RULES)t.GLOBAL_ATTRIBUTE_RULES.hasOwnProperty(a)&&!e.GLOBAL_ATTRIBUTE_RULES[a]&&(e.GLOBAL_ATTRIBUTE_RULES[a]=t.GLOBAL_ATTRIBUTE_RULES[a]);break;case"TAG_RULES":e.TAG_RULES||(e.TAG_RULES={}),e.TAG_RULES=l(e.TAG_RULES,t.TAG_RULES)}}for(var E in N)N.hasOwnProperty(E)&&(e[E+"_OBJ"]||(e[E+"_OBJ"]={}),void 0!=e[E]?e[E].constructor===Array&&(e[E+"_OBJ"]=addToSet(e[E+"_OBJ"],e[E])):e[E]=[]);for(var O=0;O<B.length;O++){var s=B[O];e[s]||(e[s]=[])}"ALL"==e.ALLOWED_STYLE?(e.FORBID_TAGS_OBJ=removeFromSet(e.FORBID_TAGS_OBJ,"style"),e.FORBID_ATTR_OBJ=removeFromSet(e.FORBID_ATTR_OBJ,"style"),e.ALLOWED_TAGS_OBJ=addToSet(e.ALLOWED_TAGS_OBJ,["style"]),e.ALLOWED_ATTR_OBJ=addToSet(e.ALLOWED_ATTR_OBJ,["style"])):"INLINE"==e.ALLOWED_STYLE?(e.FORBID_ATTR_OBJ=removeFromSet(e.FORBID_ATTR_OBJ,"style"),e.ALLOWED_ATTR_OBJ=addToSet(e.ALLOWED_ATTR_OBJ,["style"]),e.FORBID_TAGS_OBJ=addToSet(e.FORBID_TAGS_OBJ,["style"]),e.ALLOWED_TAGS_OBJ=removeFromSet(e.ALLOWED_TAGS_OBJ,"style")):"INTERNAL"==e.ALLOWED_STYLE?(e.FORBID_TAGS_OBJ=removeFromSet(e.FORBID_TAGS_OBJ,"style"),e.ALLOWED_TAGS_OBJ=addToSet(e.ALLOWED_TAGS_OBJ,["style"]),e.FORBID_ATTR_OBJ=addToSet(e.FORBID_ATTR_OBJ,["style"]),e.ALLOWED_ATTR_OBJ=removeFromSet(e.ALLOWED_ATTR_OBJ,"style")):"NONE"==e.ALLOWED_STYLE&&(e.FORBID_TAGS_OBJ=addToSet(e.FORBID_TAGS_OBJ,["style"]),e.FORBID_ATTR_OBJ=addToSet(e.FORBID_ATTR_OBJ,["style"]),e.ALLOWED_TAGS_OBJ=removeFromSet(e.ALLOWED_TAGS_OBJ,"style"),e.ALLOWED_ATTR_OBJ=removeFromSet(e.ALLOWED_ATTR_OBJ,"style"));for(var d in N)if(N.hasOwnProperty(d)){for(var u in e[d+"_OBJ"])e[d+"_OBJ"].hasOwnProperty(u)&&e[d].push(u);e[d+"_OBJ"]=addToSet(e[d+"_OBJ"],e[d])}ZSEC.configValidator&&ZSEC.configValidator.HTMLPurifierValidation(e,h,N,c,R)}else{e={};for(var S in t)t.hasOwnProperty(S)&&(e[S]=t[S].valueOf())}return e}var c=addToSet({},["script"]),R=addToSet({},[]),S=["ALLOW_ARIA_ATTR","ALLOW_DATA_ATTR","ALLOW_UNKNOWN_PROTOCOLS","SAFE_FOR_JQUERY","SAFE_FOR_TEMPLATES","WHOLE_DOCUMENT","RETURN_DOM","RETURN_DOM_FRAGMENT","RETURN_DOM_IMPORT","FORCE_BODY","SANITIZE_DOM","KEEP_CONTENT","ALLOWED_STYLE_PROPS"],f=["ALLOWED_TAGS","ALLOWED_ATTR","FORBID_TAGS","FORBID_ATTR"],p=["ALLOWED_TAGS_OBJ","ALLOWED_ATTR_OBJ","FORBID_TAGS_OBJ","FORBID_ATTR_OBJ"],B=["ADD_URI_SAFE_ATTR","GLOBAL_APPEND_ATTRIBUTES","GLOBAL_ATTRIBUTE_RULES","TAG_RULES"],m=addToSet({},S),N=addToSet({},f),D=(addToSet({},p),addToSet({},B));D=addToSet(D,f),D=addToSet(D,p);var I,h=addToSet({},S.concat(["STYLE_VALIDATION","ALLOWED_STYLE","EXTENDS","REMOVE_ONEVENTS","GLOBAL_ATTRIBUTES","GLOBAL_TAGS"],f,p,B)),U={iframe:{NAME:"iframe",ATTRIBUTE_RULES:{sandbox:{NAME:"sandbox",NOT_CONTAINS:["allow-top-navigation","allow-popups-to-escape-sandbox"],DEFAULT_VALUE:"allow-popups allow-forms allow-scripts allow-same-origin"}},APPEND_ATTRIBUTES:[{NAME:"sandbox",VALUE:"allow-popups allow-forms allow-scripts allow-same-origin"}]}},v=!1,b=addToSet({},t.ALLOWED_STYLE_PROPS);!function(){t.FORBID_TAGS_OBJ=addObjsToSet(t.FORBID_TAGS_OBJ,c),t.FORBID_ATTR_OBJ=addObjsToSet(t.FORBID_ATTR_OBJ,R);for(var e in N)N.hasOwnProperty(e)&&(t[e+"_OBJ"]=addToSet(t[e+"_OBJ"],t[e]));r.removeAllHooks(),I=!1,"NONE"==t.ALLOWED_STYLE&&(t.FORBID_TAGS_OBJ=addToSet(t.FORBID_TAGS_OBJ,["style"]),t.FORBID_ATTR_OBJ=addToSet(t.FORBID_ATTR_OBJ,["style"])),"INLINE"!=t.ALLOWED_STYLE&&"ALL"!=t.ALLOWED_STYLE||(t.STYLE_VALIDATION&&r.addHook("afterSanitizeAttributes",function(e){if(!e.ownerDocument.baseURI){var t=document.createElement("base");t.href=document.baseURI,e.ownerDocument.head.appendChild(t)}if(e.hasAttribute("style")){var r="";I=!1,n(e.style),(r=I?e.style.cssText:e.getAttribute("style")).length?e.setAttribute("style",r):e.removeAttribute("style")}}),"INLINE"==t.ALLOWED_STYLE&&(t.FORBID_TAGS_OBJ=addToSet(t.FORBID_TAGS_OBJ,["style"]),t.FORBID_ATTR_OBJ=removeFromSet(t.FORBID_ATTR_OBJ,"style"))),"INTERNAL"!=t.ALLOWED_STYLE&&"ALL"!=t.ALLOWED_STYLE||(t.STYLE_VALIDATION&&r.addHook("uponSanitizeElement",function(e,t){if("style"===t.tagName&&null!=e.sheet){var r=e.sheet.cssRules;if(I=!1,T(r),I){var o=[];i(o,r),e.textContent=o.join("\n")}}}),"INTERNAL"==t.ALLOWED_STYLE&&(t.FORBID_ATTR_OBJ=addToSet(t.FORBID_ATTR_OBJ,["style"]),t.FORBID_TAGS_OBJ=removeFromSet(t.FORBID_TAGS_OBJ,"style"))),"ALL"==t.ALLOWED_STYLE&&(t.FORBID_TAGS_OBJ=removeFromSet(t.FORBID_TAGS_OBJ,"style"),t.FORBID_ATTR_OBJ=removeFromSet(t.FORBID_ATTR_OBJ,"style")),(t.GLOBAL_ATTRIBUTE_RULES||t.TAG_RULES)&&r.addHook("afterSanitizeAttributes",function(e){for(var r=e.nodeName.toLowerCase(),o=t.GLOBAL_ATTRIBUTE_RULES,n=t.TAG_RULES&&t.TAG_RULES[r]&&t.TAG_RULES[r].ATTRIBUTE_RULES,T=U&&U[r]&&U[r].ATTRIBUTE_RULES,i=e.attributes.length;i--;){var a=e.attributes[i].name;d(e,n&&n[a]||o&&o[a],a)&&d(e,T&&T[a],a)}}),(t.GLOBAL_APPEND_ATTRIBUTES||t.TAG_RULES)&&r.addHook("afterSanitizeAttributes",function(e){var r=e.nodeName.toLowerCase();s(t.TAG_RULES&&t.TAG_RULES[r]&&t.TAG_RULES[r].APPEND_ATTRIBUTES,e),s(t.GLOBAL_APPEND_ATTRIBUTES,e),s(U&&U[r]&&U[r].APPEND_ATTRIBUTES,e)}),t.REMOVE_ONEVENTS&&r.addHook("uponSanitizeAttribute",function(e,t){0==t.attrName.indexOf("on")&&(t.keepAttr=!1)})}();var y=function(t){return t=u(t),e(t,r(window))};return y.isSupported=r.isSupported,y.removed="",ZSEC.util.defineProperty(y,"sanitize",function(e,t){var n=o(t),T=r.sanitize(e,n);return y.removed=r.removed,T},!1,!1,!0),y});};;if(window.DOMPurifyCopy) { window.DOMPurify = window.DOMPurifyCopy; window.DOMPurifyCopy = undefined; };;if(!window.ZSEC.Encoder) {!function(r){function e(r){for(var e=[],a=0;a<r.length;a++)e.push(r[a].charCodeAt(0));return e}var a={},t="34=&quot|38=&amp|60=&lt|62=&gt|160=&nbsp|161=&iexcl|162=&cent|163=&pound|164=&curren|165=&yen|166=&brvbar|167=&sect|168=&uml|169=&copy|170=&ordf|171=&laquo|172=&not|173=&shy|174=&reg|175=&macr|176=&deg|177=&plusmn|178=&sup2|179=&sup3|180=&acute|181=&micro|182=&para|183=&middot|184=&cedil|185=&sup1|186=&ordm|187=&raquo|188=&frac14|189=&frac12|190=&frac34|191=&iquest|192=&Agrave|193=&Aacute|194=&Acirc|195=&Atilde|196=&Auml|197=&Aring|198=&AElig|199=&Ccedil|200=&Egrave|201=&Eacute|202=&Ecirc|203=&Euml|204=&Igrave|205=&Iacute|206=&Icirc|207=&Iuml|208=&ETH|209=&Ntilde|210=&Ograve|211=&Oacute|212=&Ocirc|213=&Otilde|214=&Ouml|215=&times|216=&Oslash|217=&Ugrave|218=&Uacute|219=&Ucirc|220=&Uuml|221=&Yacute|222=&THORN|223=&szlig|224=&agrave|225=&aacute|226=&acirc|227=&atilde|228=&auml|229=&aring|230=&aelig|231=&ccedil|232=&egrave|233=&eacute|234=&ecirc|235=&euml|236=&igrave|237=&iacute|238=&icirc|239=&iuml|240=&eth|241=&ntilde|242=&ograve|243=&oacute|244=&ocirc|245=&otilde|246=&ouml|247=&divide|248=&oslash|249=&ugrave|250=&uacute|251=&ucirc|252=&uuml|253=&yacute|254=&thorn|255=&yuml|338=&OElig|339=&oelig|352=&Scaron|353=&scaron|376=&Yuml|402=&fnof|710=&circ|732=&tilde|913=&Alpha|914=&Beta|915=&Gamma|916=&Delta|917=&Epsilon|918=&Zeta|919=&Eta|920=&Theta|921=&Iota|922=&Kappa|923=&Lambda|924=&Mu|925=&Nu|926=&Xi|927=&Omicron|928=&Pi|929=&Rho|931=&Sigma|932=&Tau|933=&Upsilon|934=&Phi|935=&Chi|936=&Psi|937=&Omega|945=&alpha|946=&beta|947=&gamma|948=&delta|949=&epsilon|950=&zeta|951=&eta|952=&theta|953=&iota|954=&kappa|955=&lambda|956=&mu|957=&nu|958=&xi|959=&omicron|960=&pi|961=&rho|962=&sigmaf|963=&sigma|964=&tau|965=&upsilon|966=&phi|967=&chi|968=&psi|969=&omega|977=&thetasym|978=&upsih|982=&piv|8194=&ensp|8195=&emsp|8201=&thinsp|8204=&zwnj|8205=&zwj|8206=&lrm|8207=&rlm|8211=&ndash|8212=&mdash|8216=&lsquo|8217=&rsquo|8218=&sbquo|8220=&ldquo|8221=&rdquo|8222=&bdquo|8224=&dagger|8225=&Dagger|8226=&bull|8230=&hellip|8240=&permil|8242=&prime|8243=&Prime|8249=&lsaquo|8250=&rsaquo|8254=&oline|8260=&frasl|8364=&euro|8465=&image|8472=&weierp|8476=&real|8482=&trade|8501=&alefsym|8592=&larr|8593=&uarr|8594=&rarr|8595=&darr|8596=&harr|8629=&crarr|8656=&lArr|8657=&uArr|8658=&rArr|8659=&dArr|8660=&hArr|8704=&forall|8706=&part|8707=&exist|8709=&empty|8711=&nabla|8712=&isin|8713=&notin|8715=&ni|8719=&prod|8721=&sum|8722=&minus|8727=&lowast|8730=&radic|8733=&prop|8734=&infin|8736=&ang|8743=&and|8744=&or|8745=&cap|8746=&cup|8747=&int|8756=&there4|8764=&sim|8773=&cong|8776=&asymp|8800=&ne|8801=&equiv|8804=&le|8805=&ge|8834=&sub|8835=&sup|8836=&nsub|8838=&sube|8839=&supe|8853=&oplus|8855=&otimes|8869=&perp|8901=&sdot|8968=&lceil|8969=&rceil|8970=&lfloor|8971=&rfloor|10216=&lang|10217=&rang|9674=&loz|9824=&spades|9827=&clubs|9829=&hearts|9830=&diams";t=t.split("|");for(var i=0;i<t.length;i++){var n=t[i].split("=");a[n[0]]=n[1]}var u={characterToEntityMap:a,IMMUNE_HTML:e(new Array(",",".","-","_"," ")),IMMUNE_HTMLATTR:e(new Array(",",".","-","_")),IMMUNE_CSS:e(new Array),IMMUNE_JAVASCRIPT:e(new Array(",",".","_"))};ZSEC.util.defineProperty(ZSEC,"Encoder",r(u),!0,!1,!1,!0)}(function(r){function e(r,e,a,t){if(null==e||void 0==e||"string"!=typeof e)return e;for(var i="",n=0;n<e.length;n++)if(t){var u=e.codePointAt(n);i+=a(r,u,t),u>65535&&n++}else i+=a(r,e.charCodeAt(n));return i}for(var a={},t=r.characterToEntityMap,i=[],n=0;n<255;n++)i[n]=n>=48&&n<=57||n>=65&&n<=90||n>=97&&n<=122?null:n.toString(16);var u=function(r){return r<256?i[r]:r.toString(16)},o=function(r,e){if(-1!=ZSEC.util.ArrayIndexOf.call(r,e))return String.fromCodePoint(e);var a=u(e);if(null==a)return String.fromCodePoint(e);if(e<=31&&"\t"!=e&&"\n"!=e&&"\r"!=e||e>=127&&e<=159||" "==e)return" ";var i=t[e];return null!=i?i+";":"&#x"+a+";"},l=function(r,e){if(-1!=ZSEC.util.ArrayIndexOf.call(r,e))return String.fromCharCode(e);if(null==u(e))return String.fromCharCode(e);var a=e.toString(16);if(e<256){var t="00".substr(a.length);return"\\x"+t+a.toUpperCase()}return"\\u"+(t="0000".substr(a.length))+a.toUpperCase()},c=function(r,e){if(-1!=ZSEC.util.ArrayIndexOf.call(r,e))return String.fromCodePoint(e);var a=u(e);return null==a?String.fromCodePoint(e):"\\"+a+" "};return a.encodeForHTML=function(a){return e(r.IMMUNE_HTML,a,o,!0)},a.encodeForHTMLAttribute=function(a){return e(r.IMMUNE_HTMLATTR,a,o,!0)},a.encodeForJavaScript=function(a){return e(r.IMMUNE_JAVASCRIPT,a,l,!1)},a.encodeForCSS=function(a){return e(r.IMMUNE_CSS,a,c,!0)},Object.freeze&&Object.freeze(a),a});};

/***/ }),

/***/ 34550726:
/*!*****************************************************************************!*\
  !*** ./node_modules/@slyte/component/src/compiler/cli/lyte-base-compile.js ***!
  \*****************************************************************************/
/***/ ((module) => {

// function BaseCompiler(){
    let Compile = {};
    Compile.regex = {
        get lyteTemplateType1() { return /if|for|switch/g; },
        get getArrayArgRegex() { return /\[(?=([\s]*[\w-_.]+)([\(\[]))/g; },
        get getArrayArgRegexCLI() { return /\[(?=([\s]*[\w-_]+)([\(\[]))/g; },
        get matchInsideParentheses() { return /\(.*\)$/; },
        get startsAndEndWithNumber() { return /^[0-9]$/; },
        get matchInsideSquareBrackets() { return /\[.*\]/; },
        get getHelperRegex() { return /\((?:[^\)]*|(?:(?:"(?:[^"\\]|\\.)*?")|(?:'([^'\\]|\\.)*?')|[\w\s!@#$%^&*)([\]+=.,_-]*?)*?)\)$/; },
        get matchAllEmptyCharacter() { return /\s/g; },
        get endsWithCloseParantheses() { return /\)$/g; },
        get startWithMustacheWithContent() { return /^{{(?=[\s]*[\w-_\(\$)]+)/; },
        get dynamicValueCheck() { return /[\w!@#\$%\^\&*\)\(+=.,_-]+[\s]*[(]{0,1}(?:"([^"]|\\")*?"|'([^']|\\')*?'|[\w\s!@#\$%\^\&*\)\(\[\]+=.,_-]*?)*?[)]{0,1}[\s]*(?=}})/g; },
        get validMustacheCheck() { return /{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}$/; },
        get mustacheCountCheck() { return /{{[a-zA-Z0-9_.\[\]\(\)]*(?![\\])}}/g; },
        get validateArrayIndexing() { return /[a-zA-z0-9]*\[.*\]/g; },
        get mustache() { return /{{[^}]*?(?:(?:[^\1]*?\1)[^}]*?)*}}/g; },
        get lyteTemplateType2() { return /(for|forIn|if|switch)$/; },
        get splitTextNodesMustache() { return /{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}/g; },
        get tableTags() { return /^(TR|TD|TH|TBODY|THEAD|TFOOT)$/; },
        get tableTagsWithSelect() { return /^(SELECT|TR|TABLE|TBODY|THEAD|TFOOT)$/; },
        get eventListRegexFull() { return /^(onfocus|onfocusin|onfocusout|onresize|onscroll|onclick|ondblclick|onmousedown|onmouseup|onmousemove|onmouseover|onmouseout|onchange|onselect|onsubmit|onkeydown|onkeypress|onkeyup|oncontextmenu|ondragstart|ondrag|ondragenter|ondragleave|ondragover|ondrop|ondragend|onload|onunload|onabort|onerror|onscroll|onreset|onblur|onafterprint|onbeforeprint|ononbeforeunload|onerror|onhashchange|onload|onmessage|onoffline|ononline|onpagehide|onpageshow|onpopstate|onstorage|onunload|oninput|oninvalid|onsearch|ononmousewheel|onwheel|ondrag|ondragend|ondragenter|ondragleave|ondragover|ondragstart|ondrop|onscroll|ondrag|ondragend|ondragenter|ondragleave|ondragover|ondragstart|ondrop|onscroll|ondrag|ondragend|ondragenter|ondragleave|ondragover|ondragstart|ondrop|onscroll|onabort|oncanplay|oncanplaythrough|oncuechange|ondurationchange|onemptied|onended|onloadeddata|onloadedmetadata|onloadstart|onpause|onplay|onplaying|onprogress|onratechange|onseeked|onseeking|onstalled|onsuspend|ontimeupdate|onvolumechange|onwaiting|onpaste)$/; },
        get eventListRegexPart() { return /^(onfocus|onfocusin|onfocusout|onresize|onscroll|onclick|ondblclick|onmousedown|onmouseup|onmousemove|onmouseover|onmouseout|onchange|onselect|onsubmit|onkeydown|onkeypress|onkeyup|oncontextmenu)$/; },
        get keyWordsRegex() { return /((const)|(continue)|(default)|(delete)|(do)|(else)|(enum)|(export)|(extends)|(finally)|(for)|(function)|(if)|(import)|(in)|(instanceof)|(new)|(return)|(super)|(switch)|(try)|(typeof)|(var)|(void)|(while)|(with))(?!\w)/g; },
        get lyteHelperRegex() { return /__LyteHelper(\w*?)__/g; },
        get tableElementRegex() { return /^(TBODY|THEAD|TFOOT)$/; },
        get getTransitionOrderRegex() { return /^f|fI|e|s|cD|cM|i|r|yield$/g; },
        get getChildRegex() { return /^f|fI|e|s|cD|i|r|yield$/g; },
        get startWithMustacheRegex() { return /^{{/; },
        get endWithMustacheRegex() { return /}}$/; },
        get baseCaseMustacheCheck() { return /{{.*}}/; },
        get commentedMustacheCheck() { return /\\{{.*}}/; }
    
    }
    Compile._registryNameList = [];
    Compile.getTrimmedContent = function(content, position, node) {
        let dummyContent = content;
        if(node) {
            position = [];
            let parentNode = node.parentNode;
            while(true) {
                position.$unshift(this.getArrayIndex(parentNode.childNodes,node));
                parentNode = parentNode.parentNode;
                node = node.parentNode;
                if(!parentNode) {
                    break;
                }
            }
        }
        for(let i=0;i<position.length;i++) {
            for(let j=content.childNodes.length-1;j>position[i];j--) {
                content.childNodes[j].remove();
            }
            content = content.childNodes[position[i]];
        }
        return dummyContent;
    }
    Compile.getArrayIndex = function(array,value) {
        for(let i=0;i<array.length;i++) {
            if(array[i] === value) {
                return i
            };
        }
    }

    Compile.splitMixedText = function(str,componentName,errors){
            // console.log("str",str);
        var stack = [],
        start = 0,
        flag = false,
        helper = {
            name: "concat",
            args: []
        };
        for (var i = 0; i < str.length; i++) {
            var j = i;
            if (str[i - 1] !== "\\" && str[i] === "{" && str[++i] === "{") {
                stack.push('{{');
                helper.args.push("'" + str.substr(start, j - start) + "'");
                start = i + 1;
            } else if (str[i] === "}" && str[++i] === "}" && stack.length) {
                stack.pop(start);
                var toPush = str.substr(start, j - start);
                if((toPush.startsWith("'") && toPush.endsWith("'")) || (toPush.startsWith('"') && toPush.endsWith('"'))){
                    console.warn("Rendering string value inside dynamic data (mustache) is depriciated","for the value ",toPush ,"on the attribute value ",str);
                }
                var actObj  =  this.getArray(toPush);  
                if(actObj && actObj == "timeoutError"){
                    errors.push(new Error("(LC:timeout8)Syntax error in node "+node.node+" for the value: "+" - "+node.text));
                    return;
                }else if(actObj === false){
                    errors.push(new Error("(LC:14)Syntax Error in node "+node.node+"for the value:"+node.text));
                    return;
                }
                if(actObj){
                    toPush = actObj;
                    helper.args.push({type:"sq",value:actObj});
                    flag = true;
                }
                if(!actObj){
                    actObj = this.getHelper(toPush);  
                    if(actObj){
                        if(actObj == "timeoutError"){
                            errors.push(new Error("(LC:timeout5)Syntax Error in node "+"  for : "+str));
                            return;
                        }
                        else if(actObj.name == "lbind"){
                            errors.push(new Error("(LC:lbind5) Syntax Error : lbind are not allowed with prepending or appending with texts "+" for : "+str));
                            return;
                        }
                        else if(actObj == "lbindError" || actObj.args == "lbindError"){
                            errors.push(new Error("(LC:lbind6)Syntax Error : lbind are not allowed inside helpers on node "+node.node+" for: "+ str));
                            return;
                        }
                        else if(actObj.name == "lbind" && node.tagName == "TEMPLATE"&& node.hasAttribute("is") && this.regex.lyteTemplateType1.test(node.attr.is)){
                            errors.push(new Error("(LC:lbind7)Syntax Error : lbind not allowed as value in if/for/switch node"+"for: "+str));
                            return;
                        }
                        
                        else if(actObj.name == "action"){
                            errors.push(new Error("(LC:9)Syntax Error : action are not allowed with prepending or appending with texts "+"for :"+str));
                            return;
                        }
                        else if(actObj.name == "method"){
                            errors.push(new Error("(LC:10)Syntax Error : method are not allowed with prepending or appending with texts "+"for :"+str));
                            return;
                        }
                        toPush = actObj;
                        if(!this.fromCLI && this.regex.getArrayArgRegex.test(toPush)){
                            flag = true;
                        }
                        helper.args.push({ type: "helper", value: toPush })
                        if (this.fromCLI) {
                            if (this.defaultImpDetails.helpers.indexOf(actObj.name) == -1 && this.defaultHelpers.indexOf(actObj.name) == -1) {
                                this.defaultImpDetails.helpers.push(actObj.name);
                            }
                            this.getImportedHelpers(actObj.args, this.defaultImpDetails.helpers);
                        }
                    }
                    else if(actObj === false){
                        errors.push(new Error("(LC:13)Syntax error in node "+node.node+" for the attribute:"+node.attributes[x].nodeName+"- "+node.attributes[x].text));
                        return;
                    }
                    else{
                        if((toPush.startsWith("'") && toPush.endsWith("'")) || (toPush.startsWith('"') && toPush.endsWith('"'))){
                            console.warn("Rendering string value inside dynamic data (mustache) is depriciated","for the value ",toPush ,"on the attribute value ",str);
                        }
                        helper.args.push(toPush);
                    }
                    if(this.fromCLI){
                        start = i + 1;  
                    }
                }
                if (!this.fromCLI) {
                    start = i + 1;//checkWithMentor 3055 it should come up one step
                }
                // var actObj = getHelper(toPush, componentName);
                // if (actObj) {
                //     toPush = actObj;
                //     helper.args.push({
                //         type: "helper",
                //         value: toPush
                //     });
                // } else {
                //     helper.args.push(toPush);
                // }
                // start = i + 1;
            }

        }
        if (start < str.length) {
            helper.args.push("'" + str.substr(start, str.length - start) + "'");
        }
        if (flag) {
            helper._t = "hq";
            return helper;
        }
        else {
            return helper;
        }
    }

    Compile.getHelper = function(dynamicValue) {
        let helperValue = this.regex.getHelperRegex.exec(dynamicValue);
        if(helperValue){
            let actObj = this.getHelperInfo(dynamicValue,helperValue);
            if(this.regex.getArrayArgRegex.test(dynamicValue)){
                actObj._t = 'hq';
            }
            // actObj._importHelperArray = importHelperArray;
            return actObj;
        }
        return undefined;
    }
    

    Compile.getHelperInfo = function(dynamicValue, helperValue){
        let helperFunc = {};
        helperFunc.name = dynamicValue.substr(0, helperValue.index).replace(this.regex.matchAllEmptyCharacter, '');
        helperValue = (helperValue) ? helperValue[0].trim() : helperValue;
        let args = this.getHelperArgs(helperValue.substr(1,helperValue.length-2));
        if(helperFunc.name == "lyteViewPort" && helperValue == "()"){
            helperFunc.args = [];
            return helperFunc;
        }
        if (args === false) {
            return false;
        }
        helperFunc.args = args;
        return helperFunc;
    }

    Compile.getHelperArgs = function(str){
        let stack = [],
        escapeQuote = false,
        stringStarted = false,
        bracketStack = [],
         args = [],
          from = 0;
        let lastPushed;
        for(let i=0; i<str.length; i++){
            if(!stack.length && str.charAt(i) === ","){
                let toPush = str.substr(from,i-from);
                toPush = toPush.trim();
                if(toPush && toPush.startsWith("\"") && toPush.endsWith("\"")){
                    toPush = toPush.slice(1,-1);
                    toPush = "'" + toPush + "'";
                }
                try{
                    toPush = this.getHelperArgValue(toPush);
                }
                catch(err){
                    console.log("errr",err);
                    if(err.message == "lbindError"){
                        return "lbindError"
                    }
                }
                args.push(toPush);
                from = i + 1;
            }
            else if(!bracketStack.length && stringStarted && str.charAt(i) === "\\" && /\\|\'|\"/g.test(str.charAt(i+1))){
                str = str.substr(0,i)  + str.substr(i+1,str.length);
            }
            else if(str.charAt(i) === "\\" && /\\/g.test(str.charAt(i+1))){
                // str = str.substr(0,i)  + str.substr(i+1,str.length);
                // continue;
                i++;
            }
            else if(str.charAt(i) === "\\" && /\'|\"/g.test(str.charAt(i+1))){
                escapeQuote = true
            }
            else if(str.charAt(i) === "("){
                if(stack[stack.length - 1] != "'" && stack[stack.length - 1] != "\""){
                    stack.push(str.charAt(i));
                    lastPushed = str.charAt(i);
                    bracketStack.push("(");
                }
            }
            else if(str.charAt(i) === ")"){
                if(stack[stack.length-1] === "("){
                    stack.pop();
                    bracketStack.pop();
                }
            }
            else if(str.charAt(i) === "'"){// && str.charAt(i-1) !== "\\"
                if(escapeQuote){
                    escapeQuote = false;
                    continue;
                }
                else if(stack[stack.length-1] === "'"){
                    stringStarted = false
                    stack.pop();
                }
                else if(stack[stack.length-1] !== "\""){
                    stack.push(str.charAt(i));
                    lastPushed = str.charAt(i);
                    stringStarted = true;
                }
            }
            else if(str.charAt(i) === "\""){// && str.charAt(i-1) !== "\\"
                if(escapeQuote){
                    escapeQuote = false;
                    continue;
                }
                else if(stack[stack.length-1] === "\""){
                    stringStarted = false
                    stack.pop();
    //                  str.replaceAt(i, "'");
                }
                else if(stack[stack.length-1] !== "'"){
                    stack.push(str.charAt(i));
                    lastPushed = str.charAt(i);
                    stringStarted = true;
    //                  str.replaceAt(i, "'");
                }
            }
        }
        if (stack.length) {
            return false;
        }
        let toPush = str.substr(from, str.length - from);
        toPush = toPush.trim();
        if (toPush && toPush.startsWith("\"") && toPush.endsWith("\"")) {
            toPush = toPush.slice(1, -1);
            toPush = "'" + toPush + "'";
        }
        try{
            toPush = this.getHelperArgValue(toPush);
        }
        catch(err){
            console.log("errr",err);
            if(err.message == "lbindError"){
                return "lbindError"
            }
            return false;
        }
        args.push(toPush);
        return args;
    }
    
    Compile.getHelperArgValue = function(argValue) {
        switch (argValue) {
            case "undefined":
                return undefined
            case "true":
                return true;
            case "false":
                return false;
            case "null":
                return null;
            case "":
                return undefined;
            default:
                if (argValue && argValue.startsWith("'") && argValue.endsWith("'")) {
                    return (this.fromCLI)?this.decodeHtmlEntities.decode(argValue):argValue;
                }else if(this.fromCLI && this.regex.getArrayArgRegexCLI.test(argValue) && !this.regex.endsWithCloseParantheses.test(argValue)){// //array //if array inside helepr or array inside array it should work/\w+\[.*\]/g
                    let arg = this.getArrayArg(argValue);
                    return arg.args[0];
                } 
                else if(!this.fromCLI && this.regex.getArrayArgRegex.test(argValue) && !this.regex.endsWithCloseParantheses.test(argValue)){
                    let arg = this.getArrayArg(argValue);
                    return arg.args[0];
                }
                else if(/\([\w\s,')(]*/.test(argValue)) {
                    let arg = this.getHelper(argValue);
                    if(arg === false){
                        throw new Error(argValue);
                    }
                    if(arg.name == "lbind"){
                        throw new Error("lbindError");
                    }
                    return {"type" : "helper" , "value" : arg}
                } else if (!isNaN(argValue)) {
                    return parseInt(argValue);
                } else {
                    return argValue;
                }
        }
    }
    Compile.getMustache = function(value,componentName,syn){
        value=(value && typeof value === "string") ? value.trim() : value;
            if(this.regex.startWithMustacheWithContent.test(value)){
            let arr = value.match(this.regex.mustacheCountCheck);
                if(arr && arr.length > 1){
                    console.log("length>1",value)
                    return undefined;
                }
                // console.log(value);
                if(syn && !syn.bool){
                    console.log("syntax error",syn)
                    return {bool:false,err:syn.err};
                }
                if(!this.regex.validMustacheCheck.test(value)){
                    return undefined;
                }
                let dynamic = value.match(this.regex.dynamicValueCheck); // /* */
                if(dynamic && dynamic.length > 1){
                    return undefined;
                }
                else{
                    dynamic = (dynamic) ? dynamic[0].trim(): dynamic;                
                }
                // console.log("dynamic value before returning ", dynamic);
                return dynamic;
            }
            return undefined;
    }
    Compile.syntaxCheckWorkerNew = function(val){
        var parsingMustache;
        var retObj = {
            "mustache":0,
            bool : true,
            err : null
        }
        for(let i=0;i<val.length;i++){
            if(parsingMustache){
                if(val[i] == "\\"){
                    i=i+1;
                }
                else if(val[i] == "'"){
                    if(lastString != '"'){//val[i-1] != "\\"  && 
                        if(!stringStarted){
                            stringStarted = true;
                            lastString = "'";
                        }else{
                            stringStarted = false;
                            lastString = undefined;
                        }
                    }               
                }
                else if(val[i] == '"'){
                    if(lastString != "'"){//val[i-1] != "\\" &&
                        if(!stringStarted){
                            stringStarted = true;
                            lastString = '"'
                        }else{
                            stringStarted = false;
                            lastString = undefined;
                        }
                    }
                }
                else if(val[i] == "{" && !stringStarted){
                    retObj.bool = false;
                    retObj.err = " unexpected '{' bracket ";
                    return retObj;
                }
                else if(val[i] == "{" && stringStarted && val[i-1] == "{"){
                    retObj.mustache ++;
                }
                else if(val[i] == "}" && val[i-1] == "}" && !stringStarted){
                    if(curlyBracket.length){
                        retObj.bool = false;
                        retObj.err = " error unmatched '(' bracket ";
                        return retObj;
                    }
                    if(squareBracket.length){
                        retObj.bool = false;
                        retObj.err = " unmatched '['bracket ";
                        return retObj;
                    }
                    parsingMustache = false;
                }
                else if(val[i] == "[" && !stringStarted){
                    squareBracket.$push("[");
                }
                else if(val[i] == "]" && !stringStarted){
                    if(squareBracket.length){
                        squareBracket.$pop();
                    }else{
                        retObj.bool = false;
                        retObj.err = " unmatched ']' bracket ";
                        return retObj;
                    }
                }
                else if(val[i] == "(" && !stringStarted){
                    curlyBracket.$push('(');
                }
                else if(val[i] == ")" && !stringStarted){
                    if(curlyBracket.length){
                        curlyBracket.$pop();
                    }else{
                        retObj.bool = false;
                        retObj.err = " unmatched ')' bracket "; 
                        return retObj;
                    }
                }
            }    
            else if((val[i] == "{" && val[i-1] == "{" && val[i-2] != "\\")){
                //start parsing
                var curlyBracket =[] ,squareBracket =[] ,stringStarted ,lastString;
                var parsingMustache = true;
            }
        }
        if(parsingMustache){
            retObj.bool = false;
            retObj.err = " unmatched '{' bracket";
            return retObj;
        }
        return retObj;
    }
    Compile.getArray = function(mustacheVal){
        // becomses true if it is arr[arr[0]] or arr[helper()]
        if(this.regex.getArrayArgRegex.test(mustacheVal) && !this.regex.endsWithCloseParantheses.test(mustacheVal)){
            let arg = this.getArrayArg(mustacheVal);
            if(arg && arg.args[0]){
                arg.args[0].value._t = "sq";
                return arg.args[0].value;
            }else{
                return false;
            }
        }
    }
    Compile.splitMultiDimensionArray = function(val,arrayExtra){
        var openSq = 0,openSqPos = 0,lastString,stringStarted,openSPos,resultStack = [],extra = false,extraPos;
        for(var i=0 ; i<val.length;i++){
            if(val[i] == "\\"){
                i=i+1;
            }
            else if(val[i] == "'"){
                if(lastString != '"'){//val[i-1] != "\\"  &&
                    if(!stringStarted){
                        stringStarted = true;
                        lastString = "'";
                    }else{
                        stringStarted = false;
                        lastString = undefined;
                    }
                }               
            }
            else if(val[i] == '"'){
                if(lastString != "'"){//val[i-1] != "\\" &&
                    if(!stringStarted){
                        stringStarted = true;
                        lastString = '"'
                    }else{
                        stringStarted = false;
                        lastString = undefined;
                    }
                }
            }
            else if(val[i] == "[" && !stringStarted){
                openSq = openSq + 1;
                if(openSq == 1){
                    openSqPos = i;
                }
            }
            else if(val[i] == "]" && !stringStarted){
                openSq = openSq - 1;
                if(!extra && openSq == 0){
                    resultStack.push(val.substring(openSqPos+1,i));//need to handlw []
                    openSq = 0;
                    if(val[i+1]=='.'){
                        extra = true;
                        extraPos = i+1;
                    }
                }
            }
        }
        if(extra){
            arrayExtra.push(val.substring(extraPos,i));//need to handlw []
        }
        return resultStack;
    }
    Compile.getArrayArg = function(argStr){
        //argStr may be 0 or '0' or 'abc' or a() or a[] or a(b[]) or a[b()]
        // var arg = {"type":"sq","value":{"args":[],"name":""}},arrayName;
        if(this.regex.matchInsideParentheses.test(argStr)){
            //if arr comes inside helper
            let arg = this.getHelper(argStr);  
            if(arg === false){
                return false;
            };
            return {"args":[{ "type": "helper", "value": arg }]}
        }
        else if(this.regex.validateArrayIndexing.test(argStr)){
            let arg = {'args':[]}, ret = [], temp,arrayExtra=[],retNew = [];
            let arrayArg = this.regex.matchInsideSquareBrackets.exec(argStr);
            let arrayName = argStr.substr(0,arrayArg.index);
            // arrayArg = arrayArg[0];
            //splitting multi dimensional array a[one][two][three] into array
            var arr = this.splitMultiDimensionArray(argStr, arrayExtra);
            for(var i=0; i<arr.length; i++){
                if(this.regex.getArrayArgRegex.test(arr[i]) || this.regex.matchInsideParentheses.test(arr[i])){
                    temp = this.getArrayArg(arr[i]);
                    ret.push(temp.args[0]);
                }
                else{
                    ret.push(arr[i])
                }
            }
            for(var i=0; i<arrayExtra.length; i++){
                if(this.regex.getArrayArgRegex.test(arrayExtra[i])){
                    temp = this.getArrayArg(arrayExtra[i]);
                    retNew.push(temp.args[0])
                }else{
                    retNew.push(arrayExtra[i])
                }
            }
            ret.forEach(function(item,index){
                if (item && item && typeof item == "string" && item.startsWith("\"") && item.endsWith("\"")) {
                    item = item.slice(1, -1);
                    item = "'" + item + "'";
                }else if(typeof item == "string" && Compile.regex.startsAndEndWithNumber.test(item)){
                    item = "'" + item + "'";
                }
                arg.args.push(item)
            })
            arg.name = arrayName;
            if(retNew && retNew.length > 0){
                arg.extra = retNew;
            }
            return {"args":[{"type" : "sq" , "value" : arg}]};
        } 
    }
    Compile.getDV = function(value){
        var result = [],ref = result,arr = [],data = "",strStack = [],arrayStack = [],refStack = [],strLast,str;
        for(var i=0;i<value.length;i++){
            if(value[i] === "."){
                if(data.length){
                    ref.$push(data);
                }
                data = "";
                continue;
            }
            else if(value[i] === "["){
                arrayStack.$push(i)
                if(data.length){
                    ref.$push(data);
                }
                while(value[i+1] === "\s"){
                    i++;
                }
                if(value[i+1] === "\"" || value[i+1] === "'"){
                    strStack.$push(value[i+1]);
                    strLast = value[i+1];
                    i++;
                }
                else if(arr.length){
                    ref.$push([]);
                    refStack.$push(ref);
                    ref = ref[ref.length-1];
                }else{
                    arr.$push([]);
                    refStack.$push(ref);
                    ref = arr[arr.length-1];
                }
                data = "";
                continue;
            }
            else if((value[i] === "\"" || value[i] === "'" ) && value[i++] === strLast){
                while(value[i] === "\s" && value[i] != "]"){
                    i++;
                }
                strStack.$pop();
                str = true;
            }
            if(value[i] === "]"){
                arrayStack.$pop();
                if(data.length){
                    if(str === true){
                        ref.$push(data);    
                    }
                    else if(!isNaN(parseInt(data))){
                        if(refStack.length){
                            ref = refStack.$pop();
                            if(arr.length && Array.isArray(ref[ref.length-1]) && !ref[ref.length-1].length){
                                ref.$pop();
                            }
                            ref.$push(data);
                            if(!arrayStack.length && arr.length){
                                arr.$shift();
                            }
                        }
                    }
                    else{
                        ref.$push(data);
                    }
                }
                if(!arrayStack.length && arr.length){
                    result.$push(arr.$shift());
                    ref = result;
                }
                else if(refStack.length && !arr.length){ 
                    ref = refStack.$pop();
                }
                data = "";
                str = "";
                continue;
            }
            data = data.concat(value[i]);
        }
        if(data.length){
            result.$push(data);
        }
        if(strStack.length || arrayStack.length){
            console.log("check the syntax",strStack,arrayStack);
        }
        return result;
    }
    // return Compile;
// }

if(  true && typeof module.exports === "object" ) {
    module.exports = Compile;
}else{
    window.BaseCompiler = Compile;
}
// BaseCompiler();


/***/ }),

/***/ 3278586:
/*!********************************************************************!*\
  !*** ./node_modules/@slyte/component/src/directives/lyte-turbo.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _slyte_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/component */ 93270456);
/* harmony import */ var _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @slyte/core/src/service */ 76099455);
/* harmony import */ var _slyte_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @slyte/core */ 46823552);
/* harmony import */ var _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../compiler/cli/lyte-base-compile.js */ 34550726);
/* harmony import */ var _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3__);
//ignorei18n_start




_slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.getFastCompRegistry = function(obj){
    let registryMap = new WeakMap();
    var currentReg = _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.getCurrentRegistryIns();
    if(currentReg){
        if(this.iterateRegistries([currentReg],obj,registryMap)){
            return;
        }
    }else{
        let defRegIns = _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.getDefaultRegistryIns();
        if(defRegIns){
            this.iterateRegistries([defRegIns],obj,registryMap);    
        }else{
            let defaultReg = _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.getDefaultRegistry();
            let defaultRegInsArr = defaultReg._instanceList;
            this.iterateRegistries(defaultRegInsArr,obj,registryMap);
        }
        
    }
}
function noop() {}
/*convert to custom class and register*/
class Turbo extends _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_1__.Service {
    static register(){
        _slyte_component__WEBPACK_IMPORTED_MODULE_0__.ComponentRegistry.addFakeDirective(this,"turbo");
    }
    renderComponent(dynNode, preDefObj, self) {
    	var componentName = dynNode.componentName;
    	var staticAttrs = dynNode.staticAttrs;
        var constr = _slyte_component__WEBPACK_IMPORTED_MODULE_0__.ComponentRegistry._registeredCommonClass[componentName];
        if(!constr) {
          return "";
        }
        if(!_slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.getDefaultRegistry()){
            _slyte_core__WEBPACK_IMPORTED_MODULE_2__.Lyte.error("Component's Default Registry not registered!");
            return;
        }
        var obj = {compName : componentName, type: "component"};
        _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.getFastCompRegistry(obj);
        if(!_slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.verifyDetails(obj)){
            _slyte_core__WEBPACK_IMPORTED_MODULE_2__.Lyte.error(self.localName + " : Component Not found in any registry.");
            return
        }
        var lIns = obj.lIns ,compClass = obj.compClass ,regIns = obj.regIns;
        var component;
        lIns.scopedInstance(compClass,[],function(ins){
            component = preDefObj.component = ins
        },[regIns])
        component._registryClass = compClass._registryClass;
        component.$registry = component.$component = regIns;
    	component.data = {};
    	let data = compClass._data ? compClass._data.apply(component) : {};
    	var def = "default";
    	for(let key in data) {
            component.data[key] = data[key][def];
        }
        component.data.errors = {};
        component.__data = data;
        var obsAttrs = regIns.constructor._registeredComponentClass[componentName]._observedAttributes;
        preDefObj.data = preDefObj.data || {};
		for(var key in staticAttrs) {
			if(obsAttrs.indexOf(key) !== -1) {
				preDefObj.data[key] = staticAttrs[key];
			}
		}
		let initProperties = preDefObj.data;
        if(initProperties) {
            for(let key in initProperties) {
                let actVal;
                if(component.__data[key] && component.__data[key].type !== _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.getDataType(initProperties[key]) && (initProperties[key] !== undefined  || component.__data[key].type === "boolean")) {
                    actVal = _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.typeCast(initProperties[key], component.__data[key].type);
                } else {
                     actVal = initProperties[key];
                }
                let error = _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.handleValidation(component.data, key, actVal, component);
                if(!error) {
                    component.data[key] = actVal;    
                }
                
            }
        }
        if(true) {
            component._methods = {};
			for(var key in compClass._methods) {
			    component._methods[key] = compClass._methods[key];
            }
            component.$node = {"querySelector" : noop, "localName" : componentName};
        	if(component.init) {
            	component.init.apply(component);
            }
            let initCallbacks;
            if(compClass._callBacks && (initCallbacks = compClass._callBacks.init)) {
			    for(let i=0;i<initCallbacks.length;i++) {
			        initCallbacks[i].value.apply(component);
			    }
			}
            preDefObj.unbound = true;
            delete component.$node.querySelector;
        	return this.renderFast(compClass._dynamicNodes, compClass._sta, component, preDefObj, self);
        }
		return "";
    }
    renderFast(dynamicNodes, arr, comp, compPreDef, self) {
        if(!arr){
            _slyte_core__WEBPACK_IMPORTED_MODULE_2__.Lyte.error(comp.$node.localName+" component not supporting fast render. please add @turbo-supported in the component's template tag.");
            return "";
        }
        var fastRenderIndex;
        var prevComp;
        if(comp) {
            prevComp = self.component;
            self.component = comp;
        }
        var compData = self.component.data;
        var str = "";
        var dynamicCompile = arr;
        var dynamicCompileNodes = arr.cc;
        let removeFirstChar = false;
        for(var i=0;i<dynamicCompileNodes.length;i++) {
            let app = self.component.getAppOrAddon();
            if(dynamicCompileNodes[i] != undefined) {
                var inte = dynamicCompileNodes[i];
                var dynNode = dynamicNodes[inte];
                if(dynNode.dynamicValue) {
                    let locVal = _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.getDD(compData, dynNode.newDynamicValue);
                    locVal = (locVal == undefined || locVal == null) ? "" : locVal; 
                    // str = str + ZSEC.Encoder.encodeForHTML(locVal);
                    str = str + app.Security.escape(locVal);
                } else if(dynNode.helperInfo) {
                    _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.ffr = true;
                    let processDetails = {};
                      let helperVal = self.processHelper(self, {name : dynNode.helperInfo.name, args : self.processArgs(self,dynNode, [], undefined, undefined, true, undefined, undefined, processDetails)}, undefined);
                    _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.ffr = false;
                     helperVal = (helperVal == undefined || helperVal == null) ? "" : helperVal;
                    //  str = str + ( (dynNode.helperInfo.name === "unescape") ? helperVal : ZSEC.Encoder.encodeForHTML(helperVal) );
                    str = str + ((dynNode.helperInfo.name === "unescape") ? helperVal : app.Security.escape(helperVal));
                } else if(dynNode.t){
                    switch(dynNode.t) {
                        case "f" : {
                            let prevDynamic = dynamicNodes[inte-1].a.items;
                            var items;
                            if(prevDynamic.dynamicValue) {      
                                items = _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.getDD(compData, prevDynamic.newDynamicValue);
                            } else if(prevDynamic.helperInfo) {
                                let processDetails = {};
                                items = self.processHelper(self, {name : prevDynamic.helperInfo.name, args : self.processArgs(self,prevDynamic, [], undefined, undefined, true, undefined, undefined, processDetails)}, undefined);
                            }
                            var itemKey = dynNode._args.item || "item";
                            var indexKey = dynNode._args.index || "index";
                            let renderedStr = "";
                            if(items && items.length) {
                                var initialItemValue = compData[itemKey];
                                var initialIndexValue = compData[indexKey];
                                for(var indexInd=0;indexInd<items.length;indexInd++) {
                                    let item = items[indexInd];
                                    compData[itemKey] = item;
                                    compData[indexKey] = indexInd;
                                    renderedStr += this.renderFast(dynNode.dN, dynNode._sta, undefined, compPreDef, self);
                                }
                                compData[itemKey] = initialItemValue;
                                compData[indexKey] = initialIndexValue;
                            }
                            str += renderedStr;
                        }
                        break;
                        case "fI" : {
                            let prevDynamic = dynamicNodes[inte-1].a.object;
                            var object;
                            if(prevDynamic.dynamicValue) {
                                object = _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.getDD(compData, prevDynamic.newDynamicValue);
                            } else if(prevDynamic.helperInfo) {
                                let processDetails = {};
                                object = self.processHelper(self, {name : prevDynamic.helperInfo.name, args : self.processArgs(self,prevDynamic, [], undefined, undefined, true, undefined, undefined, processDetails)}, undefined);
                            }
                            var valueKey = dynNode._args.value || "value";
                            var keyKey = dynNode._args.key || "key";
                            let renderedStr = "";
                            let objKeys;
                            if(object && (objKeys = Object.keys(object))) {
                                var initialValueValue = compData[valueKey];
                                var initialKeyValue = compData[keyKey];
                                for(var keyIndex=0;keyIndex < objKeys.length;keyIndex++) {
                                    let key = objKeys[keyIndex];
                                    compData[valueKey] = object[key];
                                    compData[keyKey] = key;
                                    renderedStr += this.renderFast(dynNode.dN, dynNode._sta, undefined, compPreDef, self);
                                }
                                compData[itemKey] = initialValueValue;
                                compData[indexKey] = initialKeyValue;
                            }
                            str += renderedStr;
                        }
                        break;
                        case "e" : 
                        case "s" : {
                            var value;
                            if((dynNode.t == "s" || dynNode.t == "e") && !dynNode.hd){
                                let prevDynamic = dynamicNodes[inte-1].a.value;
                                if(prevDynamic.dynamicValue) {
                                    value = _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.getDD(compData, prevDynamic.newDynamicValue);
                                } else if(prevDynamic.helperInfo) {
                                    let processDetails = {};
                                    value = self.processHelper(self, {name : prevDynamic.helperInfo.name, args : self.processArgs(self,prevDynamic, [], undefined, undefined, true, undefined, undefined, processDetails)}, undefined);
                                }
                            }
                            var currentCaseName;
                            if(value) {
                                currentCaseName = dynNode.t === "e" ? "true" : value.toString();
                            } else {
                                if(dynNode.t=== "e")  {
                                    currentCaseName = "false";
                                } else {
                                    switch(value) {
                                    case undefined : 
                                        currentCaseName = "undefined";
                                        break;
                                    case null : 
                                        currentCaseName = "null";
                                        break;
                                    case false: 
                                        currentCaseName = "false";
                                        break;
                                    case "": 
                                        currentCaseName = '""';
                                        break;
                                    }
                                }
                            }
                            let scope;
                            if(dynNode.hd){
                                var casesList = dynNode.co;
                                var indexStart = 0;
                                for(var j=indexStart; j<casesList.length; j++){
                                    var caseName = casesList[j];
                                    if(dynNode.c[caseName].dcn){
                                        let prevDynamic = dynNode.c[caseName].cdp.a.case;
                                        if(prevDynamic.dynamicValue) {
                                            value = _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.getDD(compData, prevDynamic.newDynamicValue);
                                        } else if(prevDynamic.helperInfo) {
                                            let processDetails = {};
                                            value = self.processHelper(self, {name : prevDynamic.helperInfo.name, args : self.processArgs(self,prevDynamic, [], undefined, undefined, true, undefined, undefined, processDetails)}, undefined);
                                        }
                                        if(value){
                                            scope  = dynNode.c[caseName];
                                            break;
                                        }
                                    }
                                }
                            }
                            else{
                                scope = dynNode.c[currentCaseName];
                            }
                            if(!scope) {
                                if((scope = dynNode.d) && scope._sta) {
                                    str += this.renderFast(scope.dN, scope._sta, undefined, compPreDef, self);
                                }
                            } else {
                                while(scope) {
                                    str += this.renderFast(scope.dN, scope._sta, undefined, compPreDef, self);
                                    if(scope.additional) {
                                        if(scope.additional.next) {
                                            scope = dynNode.c[scope.additional.next];
                                        } else {
                                            scope = dynNode.d;
                                        }
                                        
                                    } else {
                                        break;
                                    }
                                }
                            }
                        }
                        break;
                        case "a" : {
                            let nextDynamic;
                            let fastRenderProp;
                            let dynLength = dynamicNodes.length;
                            for(let k=inte+1;k<dynLength;k++) {
                                let locDyn = dynamicNodes[k];
                                if(locDyn.t !== "r" && locDyn.t !== "cD" && locDyn.t !== "i" && locDyn.t !== "cM") {
                                    break;
                                } else {
                                    if(dynamicNodes[k].t === "cD" || dynamicNodes[k].t === "i" || dynamicNodes[k].t === "cM") {
                                        if(dynamicNodes[k].p.toString() == dynamicNodes[inte].p.toString()) {
                                            if(dynamicNodes[k].t == "cD") {
                                                if(_slyte_component__WEBPACK_IMPORTED_MODULE_0__.ComponentRegistry._registeredCommonClass[dynamicNodes[k].componentName]) {
                                                    nextDynamic = dynamicNodes[k];
                                                    break;
                                                }
                                            } else {
                                                nextDynamic = dynamicNodes[k];
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            let setAttr;
                            if(nextDynamic) {
                                setAttr = nextDynamic.t !== "cM";
                                fastRenderIndex = _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.fRC++;
                                fastRenderProp = _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.fRP[fastRenderIndex] = {"data" : {}};
                            }
                            if(!nextDynamic || nextDynamic.t !== "cM") {
                                str = str.substring(0, str.length - 11);
                            }
                            let attr = dynNode.a;
                            let actionObj = {};
                            for(let key in attr) {
                                if(attr[key].dynamicValue) {
                                    // let nodeValue = this.get(attr[key].dynamicValue);
                                    let nodeValue = attr[key].newDynamicValue ? _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.getDD(compData, attr[key].newDynamicValue) : self.get(attr[key].dynamicValue);
                                    
                                    if(fastRenderProp) {
                                        fastRenderProp.data[attr[key].camelCase] = nodeValue;
                                        if(typeof nodeValue == "string" && setAttr) {
                                            nodeValue = this.formatValue(key, nodeValue, self);
                                            str = str + nodeValue + " ";
                                        }
                                    } else {
                                        nodeValue = this.formatValue(key, nodeValue, self);
                                        str = str + nodeValue + " ";
                                    }
                                } else if(attr[key].helperInfo) {
                                    if(attr[key].helperInfo.name === "action") {
                                        let actionName = attr[key].helperInfo.args[0];
                                        let boundName;
                                        if(actionName.startsWith('"') || actionName.startsWith("'")) {
                                            boundName = actionName.substring(1, actionName.length - 1);
                                        } else {
                                            _slyte_core__WEBPACK_IMPORTED_MODULE_2__.Lyte.warn("Deprecation warning. Action name " + actionName + " must be in quotes");
                                            boundName = actionName;
                                        }
                                        let processDetails = {};
                                        let actArgs = self.processArgs(self, attr[key], [], "__lyteEvent__", "__lyteNode__", undefined, undefined, undefined, processDetails);
                                        let actualAttrName = attr[key].globalEvent ? attr[key].name : (attr[key].name.indexOf("-") !== -1)? attr[key].name : attr[key].name.substr(2);
                                        actionObj[actualAttrName] = {"name" : boundName, "args" : attr[key].helperInfo.args, "actArgs" : actArgs, "globalEvent" : attr[key].globalEvent ? true : false, "skipArgProcessing" : true};
                                    }  else if (attr[key].helperInfo.name === "method") {
                                        var methodsObj = compPreDef ? compPreDef._methods : self.component._methods; 
                                        if(fastRenderProp) {
                                            let methods = fastRenderProp._methods = fastRenderProp._methods || {};
                                            let parentComp = compPreDef ? compPreDef.component : self.component;
                                            let processDetails = {};
                                            let actArgs = self.processArgs(self, attr[key], [], "__lyteEvent__", "__lyteNode__", undefined, undefined, undefined, processDetails);
                                            var methodFunc = function() { //eslint-disable-line no-loop-func
                                                let node = self.$node;
                                                let args = actArgs.slice(1);
                                                let functionName = actArgs[0];
                                                let customArgs = Array.from(arguments);
                                                let mainArgs = args.$concat(customArgs);
                                                return parentComp._methods[functionName].apply(parentComp, mainArgs);
                                            }
                                            methods[attr[key].camelCase] = methodFunc;
                                        }
                                    } else {
                                        let processDetails = {};
                                        let nodeValue = self.processHelper(self, {name : attr[key].helperInfo.name, args : self.processArgs(self,attr[key], [], undefined, undefined, true, undefined, undefined, processDetails)}, undefined);
                                        if(fastRenderProp) {
                                            fastRenderProp.data[attr[key].camelCase] = nodeValue;
                                            if(typeof nodeValue == "string" && setAttr) {
                                                nodeValue = this.formatValue(key, nodeValue, self);
                                                str = str + nodeValue + " ";
                                            }
                                        } else {
                                            nodeValue = this.formatValue(key , nodeValue, self);
                                            str = str + nodeValue + " ";                                        
                                        }
                                    }
                                }
                            }
                            if(Object.keys(actionObj).length) {
                                let locIndex = _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.fRC++;
                                str = str + "lyteaction=" + locIndex + " ";
                                _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.fRP[locIndex] = actionObj;
                                actionObj.componentName = self.component.$node.localName || "undefined";
                                //str = str + "lyteaction=" + ZSEC.Encoder.encodeForHTMLAttribute(JSON.stringify(actionObj)) + " ";
                            }
                            if(fastRenderProp && nextDynamic.t !== "cM" && nextDynamic.t !== "i") {
                                str = str + "_lyteprop=" + fastRenderIndex + " ";
                            }
                            if(!dynNode.attrHandling) {
                                dynamicCompile[i+1] = dynamicCompile[i+1].substr(1);
                                dynNode.attrHandling = true;
                            }
                        }
                        break;
                        case "i" : {
                            let preDefObj = fastRenderIndex !== undefined ? _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.fRP[fastRenderIndex] : undefined;
                            if(preDefObj) {
                                delete _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.fRP[fastRenderIndex];
                                // _LC.$pushFrc(fastRenderIndex);
                            }
                            fastRenderIndex = undefined;
                            let yieldObj;
                            let yieldName = dynNode.yieldName || preDefObj.data.yieldName;
                            if(preDefObj) {
                                delete preDefObj.data.yieldName;
                            }
                            let yieldCallee;
                            if(!compPreDef || !compPreDef.yields) {
                                yieldObj = self._yields[yieldName];
                                if(yieldObj) {
                                    yieldCallee = yieldObj._callee;
                                } else {
                                    break;
                                }
                            } else {
                                yieldObj = compPreDef.yields[yieldName];
                                yieldCallee = compPreDef._yieldCallee;
                            }
                            if(yieldObj) {
                                let parentScope;
                                let locComp;
                                if(yieldCallee instanceof HTMLElement) {
                                    parentScope = yieldCallee;
                                } else {
                                    parentScope = self;
                                    locComp = self.component;
                                    self.component = yieldCallee.component;
                                }
                                let contextSwitch = {};
                                let contextSwitchArray = [];
                                if(yieldObj._cx) {
                                    _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.adCx(yieldObj, contextSwitchArray);
                                }
                                if(preDefObj) {
                                    for(var key in preDefObj.data) {
                                        contextSwitch[key] = parentScope.component.data[key];
                                        parentScope.component.data[key] = preDefObj.data[key];
                                    }
                                }
                                var componentScope = parentScope.component;
                                if(prevComp && prevComp.$node == yieldCallee) {
                                    componentScope = prevComp
                                }
                                // if(componentScope == self.component) {
                                //     componentScope = prevComp;
                                // }
                                str = str + this.renderFast(yieldObj.dN || yieldObj._dynamicNodes, yieldObj._sta, componentScope, yieldCallee, parentScope);
                                for(let key in contextSwitch) {
                                    parentScope.component.data[key] = contextSwitch[key];
                                }
                                if(yieldObj._cx) {
                                    _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.rmCx(yieldObj, contextSwitchArray); 
                                }
                                if(locComp) {
                                    parentScope.component = locComp;
                                }
                            }
                            //str = str + self.renderComponent(dynNode, preDefObj, compData);
                        }
                        break;
                        case "cM" : {
                            if(fastRenderIndex !== undefined) {
                                let preDefObj = _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.fRP[fastRenderIndex];
                                let componentName = preDefObj.data.componentName;
                                if(componentName) {
                                    if(_slyte_component__WEBPACK_IMPORTED_MODULE_0__.ComponentRegistry._registeredCommonClass[componentName]) {
                                        str = str + "<" + componentName + " _lyteprop="+ fastRenderIndex+">";
                                        fastRenderIndex = undefined;
                                        str = str + this.renderComponent({"componentName" : componentName}, preDefObj, self);
                                        str = str + "</" + componentName + ">";
                                    } else {
                                        str = str + "component not registered";
                                        // Handle case where component has not been registered yet. 
                                    }   
                                }
                            }
                        }
                        break;
                        case "cD" : {
                            let preDefObj = fastRenderIndex !== undefined ? _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.fRP[fastRenderIndex] : {};
                            fastRenderIndex = undefined;
                            str = str + this.renderComponent(dynNode, preDefObj, self);
                        }
                        break;
                        case "r" : {    
                            let preDefObj;
                            if(fastRenderIndex !== undefined) {
                                preDefObj = _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.fRP[fastRenderIndex];
                            } else {
                                fastRenderIndex = _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.fRC++;
                                preDefObj = _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.fRP[fastRenderIndex] = {};
                            }
                            preDefObj.yields = preDefObj.yields || {};
                            preDefObj.yields[dynNode._args["yield-name"]] = dynNode;
                            if(!preDefObj._yieldCallee) {
                                preDefObj._yieldCallee = compPreDef ? compPreDef : {"component" : self.component};
                            }
                        }
                    }
                } else {
                    str = str + dynamicCompile[i];
                }
            } else {
                str = str + dynamicCompile[i];
            }
        }
        if(comp) {
            self.component = prevComp;
        }
        return str;
    }
    formatValue(key, nodeValue, self) {
        let type = typeof nodeValue;
        let app = self.component.getAppOrAddon();
        if(nodeValue === "") {
            type = "undefined";
        }
        let retVal;
        let isSpecialAttr = (key == "src") || (key == "href");
        switch(type) {
        case "boolean" : 
            return nodeValue ? key : "";
        case "object" : 
            retVal = ((typeof Record != "undefined" && nodeValue instanceof Record) ? JSON.stringify(nodeValue.$.toJSON()) : JSON.stringify(nodeValue));
            // return key + "=" + (isSpecialAttr ? retVal : ZSEC.Encoder.encodeForHTMLAttribute(retVal));
            return key + "=\"" + (isSpecialAttr ? retVal : app.Security.escape(retVal)) + "\"";
        case "undefined" : 
            return key
        default : 
            {
                // return key + "=" + (isSpecialAttr ? nodeValue : ZSEC.Encoder.encodeForHTMLAttribute(nodeValue) );
                return key + "=\"" + (isSpecialAttr ? nodeValue : app.Security.escape(nodeValue) ) + "\"";
            }
        }
    }
    static caseTx(dynNewCompile,mustache,info,j){
        if(dynNewCompile) {
            var newActObj;
            if(mustache){
                newActObj = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().getArray(mustache);  
                if(!newActObj && mustache){
                    newActObj = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_3___default().getHelper(mustache,true);  
                }
                info.newHelperInfo = newActObj;
                _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.replaceWithPf(dynNewCompile, document.createTextNode("__**--Lyte"+j+"__**"));
            }   
        }
    }
    static caseI(dynNewCompile, info, j){
        // if(dynNewCompile) {
            dynNewCompile.appendChild(document.createTextNode("__**--Lyte"+j+"__**"));
            let yieldAttr = dynNewCompile.attributes["yield-name"];
            info.yieldName = yieldAttr ? yieldAttr.nodeValue : undefined;
        // }
    }
    static caseCD(dynNewCompile, info, j){
        // if(dynNewCompile) {
            dynNewCompile.appendChild(document.createTextNode("__**--Lyte"+j+"__**"));
            info.componentName = dynNewCompile.localName;
            var attrs = Array.from(dynNewCompile.attributes);
            info.staticAttrs = {};
            for(var i=0;i<attrs.length;i++) {
                info.staticAttrs[_slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.String.toCamelCase(attrs[i].nodeName)] = attrs[i].nodeValue;
            }
            delete info.staticAttrs._lyteprop;
        // }
    }
    static setAttribute(node,componentName,actString){
        // dynNewCompile.setAttribute(node.attributes[i].name.substr(2),componentName+" => "+ actString);
        _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.setAttribute(node, componentName, actString);

    }
    static removeAttributeObj(dynNewCompile, attr, j){
        // if(dynNewCompile) {
            for(let key in attr) {
                dynNewCompile.removeAttribute(key);
            }
            dynNewCompile.setAttribute("_lyteAttr" , "__**--Lyte" + j + "__**", "");
        // }
    }
    static removeAttribute(node, name, value){
        node.removeAttribute(name, value);
    }
    static removeAttributeArr(dynNewCompile, toBeRemoved){
        if(toBeRemoved.length){
            for(let i=0; i<toBeRemoved.length;i++){
                dynNewCompile.removeAttribute(toBeRemoved[i]);
                // if(dynNewCompile) {
                //     dynNewCompile.removeAttribute(toBeRemoved[i]);
                // }
            }
        }
    }
    static getDynNewCompile(newCompile,pos){
        return _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.getDynamicNode(newCompile,pos);
    }
    static replaceWithPf(dynNewCompile,j){
        return _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.replaceWithPf(dynNewCompile, document.createTextNode("__**--Lyte"+j+"__**"));
    }
    static cMBefore(dynN, info){
        let dynNewCompile;
        // if(!dynNewCompile && (type == "r" || dynN.hasAttribute("unbound"))) { //af check
            if(_slyte_core__WEBPACK_IMPORTED_MODULE_2__.Lyte._ms) {
                dynNewCompile = document.createElement("div");
                dynNewCompile.innerHTML = info.actualTemplate ? info.actualTemplate : dynN.outerHTML;
                dynNewCompile = dynNewCompile.childNodes[0];
                constr.splitTextNodes(dynNewCompile);
            } else {
                dynNewCompile = dynN.cloneNode(true);
            }
        // }

        let depthTemp;
        let dnNode;
        var actualTemplateNewCompile = dynNewCompile ? (_slyte_core__WEBPACK_IMPORTED_MODULE_2__.Lyte._ie ? dynNewCompile : dynNewCompile.content) : undefined;
        // if(info.actualTemplate) {
        //     if(dynNewCompile) {
        //         actualTemplateNewCompile = _LC.getContentForIE(info.actualTemplate, constr);
        //     }
        // }
        return dynNewCompile//{dynNewCompile : dynNewCompile, actualTemplateNewCompile : actualTemplateNewCompile}
    }
    static cMBefore2(dynNewCompile, info, constr){
        var actualTemplateNewCompile = dynNewCompile ? (_slyte_core__WEBPACK_IMPORTED_MODULE_2__.Lyte._ie ? dynNewCompile : dynNewCompile.content) : undefined;
        if(info.actualTemplate) {
            return _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.getContentForIE(info.actualTemplate, constr);
        }
        return actualTemplateNewCompile;
    }
    static cMAfter(actualTemplateNewCompile, info, type, j, dynNewCompile){
        if(actualTemplateNewCompile) {
            let staticTemp = info.actualTemplate ? actualTemplateNewCompile : dynNewCompile;
            info._sta = _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.processStatic(staticTemp);                      
        }
        if(dynNewCompile) {
            info._args = {};
            if(type === "r") {
                //dynNewCompile.parentNode.parentNode.insertBefore(document.createTextNode("__**--Lyte"+j+"__**"), dynNewCompile.parentNode);
                //dynNewCompile.parentNode.setAttribute("_lyteyield", "");
                //_LC.replaceWithPf(dynNewCompile, document.createTextNode(""));
                _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.replaceWithPf(dynNewCompile, document.createTextNode("__**--Lyte"+j+"__**"));
            } else if(type === "cM") {
                _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.replaceWithPf(dynNewCompile, document.createTextNode((dynNewCompile.hasAttribute("_lyteattr") ? dynNewCompile.getAttribute("_lyteattr"): "" )+ "__**--Lyte"+j+"__**"));
            } else {
                //dynNewCompile.replaceWith(document.createTextNode("__**--Lyte"+j+"__**"))
                _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.replaceWithPf(dynNewCompile, document.createTextNode("__**--Lyte"+j+"__**"));
            }
            Array.from(dynNewCompile.attributes).forEach(function(item) { //eslint-disable-line no-loop-func
                info._args[item.nodeName] = item.nodeValue;
            });
        }
    }
    static caseES(dynNewCompile, info, constr){
        var actualTemplateNewCompile = dynNewCompile ? (_slyte_core__WEBPACK_IMPORTED_MODULE_2__.Lyte._ie ? dynNewCompile : dynNewCompile.content) : undefined;
        if(info.actualTemplate) {
            // dynN = _LC.getContentForIE(info.actualTemplate, constr, undefined);
            if(dynNewCompile) {
                let dummy = _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.getContentForIE(info.actualTemplate, constr);
                actualTemplateNewCompile = _slyte_core__WEBPACK_IMPORTED_MODULE_2__.Lyte._ie ? dummy : dummy.content;
            }
        }
        return actualTemplateNewCompile;
    }
    static getNewCompile(componentClass){
        let newCompile;
        if(_slyte_core__WEBPACK_IMPORTED_MODULE_2__.Lyte._ie) {
            newCompile = document.createElement("div");
            newCompile.innerHTML = componentClass._template.outerHTML;
            newCompile = newCompile.childNodes[0];
        } else {
            newCompile = componentClass._template.cloneNode(true);
        }
        return newCompile;
    }
}
Turbo.__lMod = "Turbo";
Turbo.register();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Turbo);
//ignorei18n_end

/***/ }),

/***/ 93270456:
/*!*************************************************************!*\
  !*** ./node_modules/@slyte/component/src/lyte-component.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Component": () => (/* binding */ Component),
/* harmony export */   "ComponentRegistry": () => (/* binding */ ComponentRegistry),
/* harmony export */   "Helper": () => (/* binding */ Helper),
/* harmony export */   "LyteCustomElement": () => (/* binding */ LyteCustomElement),
/* harmony export */   "RawComponent": () => (/* binding */ RawComponent),
/* harmony export */   "_LC": () => (/* binding */ _LC),
/* harmony export */   "appendChild": () => (/* binding */ appendChild),
/* harmony export */   "arrayUtils": () => (/* binding */ arrayUtils),
/* harmony export */   "customElementPrototype": () => (/* binding */ customElementPrototype),
/* harmony export */   "defProp": () => (/* binding */ defProp),
/* harmony export */   "getNearestApp": () => (/* binding */ getNearestApp),
/* harmony export */   "insertAfter": () => (/* binding */ insertAfter),
/* harmony export */   "insertBefore": () => (/* binding */ insertBeforeFn),
/* harmony export */   "objectUtils": () => (/* binding */ objectUtils),
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "replaceWith": () => (/* binding */ replaceWith),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "shouldIgnoreDisconnect": () => (/* binding */ shouldIgnoreDisconnect)
/* harmony export */ });
/* harmony import */ var _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @slyte/core/src/lyte-utils */ 60768251);
/* harmony import */ var _slyte_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @slyte/core */ 46823552);
/* harmony import */ var _slyte_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @slyte/core */ 17639124);
/* harmony import */ var _slyte_core_src_JsonPath_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @slyte/core/src/JsonPath.js */ 35352898);
/* harmony import */ var _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./compiler/cli/lyte-base-compile.js */ 34550726);
/* harmony import */ var _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _ZohoSecurity_lyte_component_security_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ZohoSecurity/lyte-component-security.js */ 88249548);
/* harmony import */ var _ZohoSecurity_lyte_component_security_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ZohoSecurity_lyte_component_security_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _slyte_data_src_ValidationError__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @slyte/data/src/ValidationError */ 76977460);
/* harmony import */ var _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @slyte/core/src/service */ 76099455);
/* harmony import */ var _slyte_core_src_Utils_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @slyte/core/src/Utils.js */ 95638012);
/* harmony import */ var _slyte_component_src_utils_lyte_sanitizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @slyte/component/src/utils/lyte-sanitizer.js */ 33578235);
/* harmony import */ var _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/lyte-errors.js */ 87044171);
// debugger




 //slicer af
 //slicer store



_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.Sanitizer = _slyte_component_src_utils_lyte_sanitizer_js__WEBPACK_IMPORTED_MODULE_2__.Sanitizer; //for static page builder
//@Slicer.developmentStart

//@Slicer.developmentEnd
if(!window.__lyteConfig){
    window.__lyteConfig = {
        _definedBeforeBridging : [],
        _alreadyDefinedBeforeBridging : [],
        v4 : true,
        Sanitizer : _slyte_component_src_utils_lyte_sanitizer_js__WEBPACK_IMPORTED_MODULE_2__.Sanitizer
    }
}
window.__lyteConfig.v4 = true;
let ltCf = window.__lyteConfig;
if(!ltCf.customElementsDefine){
    ltCf.customElementsDefine = customElements.constructor.prototype.define; 
    Object.defineProperty(customElements.constructor.prototype,"define",{
        value : function(name, compClass, options, _lyteOptions){
            if(customElements.get(name)){
                ltCf._alreadyDefinedBeforeBridging.push({name : name, compClass : compClass, options : options, _lyteOptions : _lyteOptions, scope : this});
            }else{
                ltCf._definedBeforeBridging.push({name : name, compClass : compClass, options : options ,_lyteOptions : _lyteOptions, scope : this});
                ltCf.customElementsDefine.apply(this,arguments);
            }
        },
        enumerable: false
    })
}
/*convert to custom class*/
class ComponentRegistry extends _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_3__.Service {
    isComponentRegistry() {
        return true;
    }
    getDirectiveObj(){
        if(this._directive){
            return this._directive;
        }
        return false;
    }
    static getFastObj(){
        return this.turbo ? this.turbo : false;
    }
    constructor(opt){
        super(opt);
        var registryClass = this.constructor;
        if(!registryClass._registered){
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.RegistryError.error("LC001", registryClass.name);
            //@Slicer.developmentEnd
            return;
        }
        // //@Slicer.afzalStart
        // console.log("aaffff")
        // //@Slicer.$afzalEnd
        /* registering component in app module - for router */
        let app = _LC.getNearestParentApp(this);
        app.$.modules.triggerEvent("add", "component", this);
        if(_LC.getDefaultRegistry() == registryClass){
            //set default registry instance and it can be overrided with app's getRegistryInstance.
            _LC.setDefaultRegistryIns(this)
        }
        registryClass._instanciated = true;
        this.registeredComponents = {};
        this.registeredCeComponents = {}
        this._registeredComponents = {};
        this._registeredCeComponents = {};
        this._defaultDirectives = [];
        this.registeredDirectives = [];
        this._registeredDirectivesClass = {};
        ComponentRegistry.registerAllComponent(registryClass._registeredComponentClass,this);
        ComponentRegistry.registerAllCeComponent(registryClass._registeredCeComponentClass,this);
        registryClass._instanceList.push(this);
        // _LC.setAddedRegistries(this,registryClass.name);
        this.render = _LC.render;     
        // this.renderHTML = _LC.renderHTML;
        this.set = _LC.set;
        this.get = _LC.get;
        let currentAppOrAddon = _LC.getAppOrAddon(this);
        this.setDefaultDirectives(currentAppOrAddon);
        _LC.updateDomApis(this);
        this.replaceWith = _LC.replaceWith;
        this.throwEvent = _LC.throwEvent;
        this.chI = _LC.chI;
        this.chromeBugFix = _LC.chromeBugFix;
        this.lyteComponentsDiv = _LC.lyteComponentsDiv;
        this.String = _LC.String;
        this.addAction = _LC.addAction;
        this.getLyteComponentsDiv = function(){
            return _LC.getComponentsDiv(_LC.lyteComponentsDiv,registryClass.name);
        }
        this._getLyteComponent = function(){
            return _LC;
        }
    }
    setDefaultDirectives(app){ 
        let defaultDirectives = ["directive","shadow","shadow-style","shadow-supported","turbo","turbo-supported","unbound","view"];
        let self = this;
        defaultDirectives.forEach(function(item){
            let directiveIns;
            if(self.constructor[item]){
                app.scopedInstance(self.constructor[item],[self],function(ins){
                    directiveIns = ins;
                },[])
                self["_"+item] = directiveIns;
            }
            self._defaultDirectives.push(item);
        })
    }
    static register(options){
        if(options){
            if(options.app == true){
                if(!_LC.gotDefaultRegistryFrom){
                    _LC.setDefaultRegistry(this);
                    _LC.gotDefaultRegistryFrom = "cli";
                }
            }
            if(options.hash){
                this._hash = options.hash;
            }
            if(options.refHash){
                this._refHash = options.refHash;
            }
        }
        this._definedComponents = {};
        this._registeredComponentClass = Object.assign({},ComponentRegistry._defaultComponents);
        this._registeredCeComponentClass = Object.assign({},ComponentRegistry._defaultCeComponents);
        this._registered = true;
        this.prototype.registeredHelpers = Object.assign({},ComponentRegistry._defaultHelpers,this._beforeRegisteredHelpers ? this._beforeRegisteredHelpers : {});
        this.registeredHelpers = this.prototype.registeredHelpers;
        this.appendChild = _LC.appendChild;//because of ui comps
        this.insertAfter = _LC.insertAfter;
        this.insertBefore = _LC.insertBefore;
        this.replaceWith = _LC.replaceWith;
        this.shouldIgnoreDisconnect = _LC.shouldIgnoreDisconnect;
        this._beforeRegisteredHelpers = {};
        this._instanceList = [];
        var registryClassDef = this;
        ComponentRegistry._registeredRegistries.push({
            name : registryClassDef.name,
            class : registryClassDef
        });
        if((_compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default().needDummyComponentsDiv)){
            _LC.setComponentsDiv(_LC.dummyLyteComponentsDiv,this.name);
        }else{
            _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default()._registryNameList.$push(this.name);
        }
        _LC.setComponentsDiv(_LC.lyteComponentsDiv,this.name);
        if(registryClassDef.idePlugins){
            registryClassDef.idePlugins.forEach(function(plugin){
                plugin(_LC)
            })
        }
        if(this.arrayOverride){
            _LC.arrayOverride();
        }
        let lazyDir = this._lazyRegisterDirectives;
        if(lazyDir){
            for(let key in lazyDir){
                this[key] = lazyDir[key];
                _LC.updateDirectivesInReg(ComponentRegistry, lazyDir[key], key);
            }
        }
        // if(registryClassDef.Compile.needDummyComponentsDiv){
        //     _LC.setComponentsDiv(_LC.dummyLyteComponentsDiv,this.name);
        // }
        /*convert to custom class*/
        this.Component = (function() {
            class newC extends ComponentRegistry._componentApis {
                constructor(){
                    super();
                }
                static register(compName, options){
                    compName = compName || _LC.String.dasherize(this.name);
                    this._registryClass = registryClassDef;
                    registryClassDef.registerComponent(compName, this);
                    if(options){
                        this._hash = options.hash;
                        this._refHash = options.refHash
                    }
                }
                static unregisterComponent(){
                    _LC.unregisterComponent.apply(this,arguments);
                }
            }
            newC.__lMod = "Component";
            newC._registryClass = registryClassDef;

            newC._render = function(){
                return _LC._render.apply(this,arguments);
            };

            return newC;
        })();
        this.registerDirective = function(name,directiveClass){
            var registry = this;
            if(registry._directivesList[name]){
                //@Slicer.developmentStart
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.RegistryError.error("LC002", "Directive", name, registry.name);
                //@Slicer.developmentEnd
                return;
            }
            registry._directivesList[name] = directiveClass;
            directiveClass._registryClass = registry;
            if(registry._instanciated){
                registry._instanceList.forEach(function(ins){
                    directiveClass.actualRegistration(name,directiveClass,ins);
                })
            }
        }
        /*convert to custom class*/
        this.CustomElements = (function() {
            class newCE extends _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_3__.Service {
                constructor(){
                    super();
                }
                static register(compName){
                    compName = compName || _LC.String.dasherize(this.name);
                    this._registryClass = registryClassDef;
                    registryClassDef.registerCeComponent(compName, this, this.options);
                }
            }
            newCE._registryClass = registryClassDef;
            return newCE;
        })();
    }
    static getHash(){
        return this._hash;
    }
    static getRefHash(){
        return this._refHash;
    }
    static generateHash(){
        return this.getHash() + "_Component_" + _LC.counter++;
    }
    static registerCeComponent(name,CompClass, options){
        var registry = this;
        if(registry._registeredCeComponentClass[name]){
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.RegistryError.error("LC002", "Raw Component", name, registry.name);
            //@Slicer.developmentEnd
            return;
        }
        CompClass.activeInstances = 0;
        registry._registeredCeComponentClass[name] = CompClass;//af move below
        CompClass._compName = name;
        CompClass._options = options;
        if(registry._instanciated){
            registry._instanceList.forEach(function(ins){
                registry.registerAllCeComponent({[name] : CompClass},ins);
            })
        }
    }
    static registerComponent(name,CompClass){
        var registry = this;
        if(registry._registeredComponentClass[name] && registry._reRegisteredComponents.indexOf(name) == -1){
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.RegistryError.error("LC002", "Component", name, registry.name);
            //@Slicer.developmentEnd
            return;
        }
        CompClass.activeInstances = 0;
        registry._registeredComponentClass[name] = CompClass;//af move below
        CompClass._compName = name;
        if(registry._instanciated){
            registry._instanceList.forEach(function(ins){
                registry.registerAllComponent({[name] : CompClass},ins);
            })
        }
    }
    static unregisterComponent(){
        _LC.unregisterComponent.apply(this,arguments);
    }
    static registerHelper(name,helper){
        //@Slicer.developmentStart
        if(ComponentRegistry._defaultHelpers[name]){    
            console.warn("Deprecated : Default helpers of Lyte can't be overrided - " + name + "");
        }else if(this._registered && this.prototype.registeredHelpers[name] || this._beforeRegisteredHelpers && this._beforeRegisteredHelpers[name]){
            console.warn("Deprecated : Helper named - " + name + " is already registered");
        }
        //@Slicer.developmentEnd
        if(this == ComponentRegistry){
            //register helpe in global
            //@Slicer.developmentStart
            if(ComponentRegistry._defaultHelpers[name]){    
                console.warn("Deprecated : Default helpers of Lyte can't be overrided - " + name + "");
            }else{
            //@Slicer.developmentEnd
                ComponentRegistry._defaultHelpers[name] = helper;
                //update in all reigstries
                ComponentRegistry._registeredRegistries.forEach(function(obj){
                    let _registryClass = obj.class;
                    if(_registryClass._registered){
                        _registryClass.prototype.registeredHelpers[name] = helper;
                    }else if(_registryClass._beforeRegisteredHelpers){
                        _registryClass._beforeRegisteredHelpers[name] = helper;
                    }else{
                        _registryClass._beforeRegisteredHelpers = {[name] : helper};
                    }
                })
            //@Slicer.developmentStart
            }
            //@Slicer.developmentEnd
        }
        if(this._registered){
            this.prototype.registeredHelpers[name] = helper;
        }else if(this._beforeRegisteredHelpers){
            this._beforeRegisteredHelpers[name] = helper;
        }else{
            this._beforeRegisteredHelpers = {[name] : helper};
        }
    }
    static registerCustomPropHandler(){
        _LC.registerCustomPropHandler.apply(this,arguments);
    }
}
ComponentRegistry.__lMod = "ComponentRegistry";
ComponentRegistry._registeredRegistries = [];

// static _definedComponents = {};
ComponentRegistry._definedCeComponents = {};

ComponentRegistry._registeredCommonClass = {};
ComponentRegistry._registeredCommonCeClass = {};
ComponentRegistry.customPropHandlers = [];
ComponentRegistry.customPropRegex = "";
ComponentRegistry._defaultHelpers = {};
ComponentRegistry._defaultComponents = {};
ComponentRegistry._defaultCeComponents = {};
ComponentRegistry.globalComponents = ["lyte-event-listener", "import-shadow-style"];
ComponentRegistry._unRegisteredComponents = [];
ComponentRegistry._reRegisteredComponents = [];
ComponentRegistry._directivesList = {};
ComponentRegistry._registeredDirectivesClass = {};
ComponentRegistry._lazyRegisterDirectives = {};
ComponentRegistry._preLoadedDirectives = {};

/*convert to custom class*/
ComponentRegistry._componentApis = (function() {
    class apis extends _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_3__.Service {
        constructor(){
            super();
            this.$ = {
                validate : function(){
                    return _LC.validate.apply(this, arguments);
                },
                getError : function(path){
                    return _LC.getErrorStructure(this.ins,path)
                },
                _ins : this
            }
        }
        set(){
            return _LC.componentSet.apply(this, arguments);
        }
        get(){
            return _LC.componentGet.apply(this, arguments);
        }
        throwEvent(){
            return _LC.throwEvent.apply(this, arguments);
        }
        executeMethod(){
            return _LC.executeMethod.apply(this, arguments);
        }
        getData(){
            return _LC.componentGetData.apply(this, arguments);
        }
        setData(){
            return _LC.componentSetData.apply(this, arguments);
        }
        getMethods(){
            return _LC.componentGetMethods.apply(this, arguments);
        }
        setMethods(){
            return _LC.componentSetMethods.apply(this, arguments);
        }
        hasAction(){
            return _LC.componentHasAction.apply(this, arguments);
        }
        getActions(){
            return _LC.componentGetActions.apply(this, arguments);
        }
        getObservers(){
            return _LC.componentGetObservers.apply(this, arguments);
        }
        getApp(){
            return _LC.getApp.apply(this, arguments);
        }
        getAppOrAddon(){
            return _LC.getAppOrAddon.apply(this, arguments);
        }
    }
    return apis;
})();

ComponentRegistry.registerAllComponent = function(compClassList, registryInstance) {
    for(var compName in compClassList){
        let compClass = compClassList[compName];
        // if (registryInstance.constructor._reRegisteredComponents.indexOf(compName) == -1 && registryInstance.registeredComponents[compName]) {
        //     _Lyte.error("Component " + componentName + " already registered");
        //     return;
        // }
    if (registryInstance.constructor._definedComponents[compName] && registryInstance.constructor._reRegisteredComponents.indexOf(compName) == -1 && !registryInstance.constructor._unRegisteredComponents[compName]) {
            //same component class for same reigstry which has multiple registry instance
            registryInstance.registeredComponents[compName] = true;
            continue;
        }
        compClass._compName = compName;
        compClass._data = compClass.prototype.data;
        compClass._actions = compClass.actions();
        compClass._methods = compClass.methods();
        compClass.__observers = _LC.executeObservers(compClass);
        compClass.addRegistries = compClass.prototype.addRegistries;
        if(compClass._dynamicNodes && compClass._dynamicNodes.length && compClass._dynamicNodes[compClass._dynamicNodes.length-1].type == "dc"){
            compClass.dc = compClass._dynamicNodes.$pop();
        }
        compClass._callBacks = {};
        compClass._observers = [];
        _LC.updateCustomCrmComponent(compClass);
        compClass._observedMethodAttributes = compClass._observedMethodAttributes || {};
        _LC.registerComponent(compName, compClass,registryInstance);
        registryInstance.registeredComponents[compName] = true;
        registryInstance._registeredComponents[compName] = compClass;
    }
};

ComponentRegistry.registerAllCeComponent = function(compClassList, registryInstance) {
    for(var compName in compClassList){
        let compClass = compClassList[compName];
        if (registryInstance.constructor._definedCeComponents[compName]) {
            //same component class for same reigstry which has multiple registry instance
            registryInstance.registeredComponents[compName] = true;
            continue;
        }
        compClass._compName = compName;
        compClass.addRegistries = compClass.prototype.addRegistries;
        _LC.registerCeComponent(compName, compClass,registryInstance);
        registryInstance.registeredCeComponents[compName] = true;
        registryInstance._registeredCeComponents[compName] = compClass;
    }
};

/*convert to custom class*/
ComponentRegistry.Component = (function() {
    class newC extends ComponentRegistry._componentApis {
        constructor(){
            super();
        }
        static register(compName){
            compName = compName || _LC.String.dasherize(this.name);
            if(ComponentRegistry.globalComponents.indexOf(compName) != -1){
                let compClass = this;
                compClass._registryClass = ComponentRegistry;
                ComponentRegistry._defaultComponents[compName] = compClass;
                compClass._compName = compName;
                compClass.activeInstances = 0;   
                ComponentRegistry._registeredRegistries.forEach(function(reg){
                    let registry = reg.class;
                    registry._registeredComponentClass[compName] = compClass;
                    if(registry._instanciated){
                        registry._instanceList.forEach(function(ins){
                            registry.registerAllComponent({[compName] : compClass},ins);
                        })
                    }
                })
            }
            //@Slicer.developmentStart
            else{
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.RegistryError.error("LC003" , compName);
            }
            //@Slicer.developmentEnd
        }
    }
    newC.__lMod = "Component";
    newC._registryClass = ComponentRegistry;
    return newC;
})();

ComponentRegistry.addFakeDirective = function(baseClass,name){
    this._lazyRegisterDirectives[name] = baseClass;
    this[name] = baseClass;
    _LC.updateDirectivesInReg(this,baseClass,name);
};

/*convert to custom class*/
class Component extends ComponentRegistry._componentApis {
    constructor(){
        super();
    }
    // static _registryClass = registryClassDef;
    static register(compName, options){
        var _registryClass = _LC.getRegistryClass(options);
        if(!_registryClass){
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.RegistryError.error("LC004", "Component", compName)
            //@Slicer.developmentEnd
            return
        }
        this._hash = options.hash;
        this._refHash = options.refHash
        compName = compName || _LC.String.dasherize(this.name);
        this._registryClass = _registryClass;
        _registryClass.registerComponent(compName, this);
    }
    static unregisterComponent(){
        _LC.unregisterComponent.apply(this,arguments);
    }
}
Component.__lMod = "Component";

Component._render = function(){
    return _LC._render.apply(this,arguments);
};

/*convert to custom class*/
class RawComponent extends _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_3__.Service {
    constructor(){
        super();
    }
    // static _registryClass = registryClassDef;
    static register(compName, options){
        var _registryClass = _LC.getRegistryClass(options);
        if(!_registryClass){
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.RegistryError.error("LC004", "Raw Component", compName)
            //@Slicer.developmentEnd
            return;
        }
        this._refHash = options.refHash
        compName = compName || _LC.String.dasherize(this.name);
        this._registryClass = _registryClass;
        _registryClass.registerCeComponent(compName, this, this.options);
    }
}
RawComponent.__lMod = "RawComponent";
class Helper {
    static register(name, helper, options){
        var _registryClass = _LC.getRegistryClass(options);
        if(!_registryClass){
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.RegistryError.error("LC004", "Helper", name)
            //@Slicer.developmentEnd
            return;
        }
        helper._hash = options.hash;
        helper._refHash = options.refHash;
        //@Slicer.developmentStart
        if(ComponentRegistry._defaultHelpers[name]){    
            console.warn("Deprecated : Default helpers of Lyte can't be overrided - " + name + "");
        }else if(_registryClass._registered && _registryClass.prototype.registeredHelpers[name] || _registryClass._beforeRegisteredHelpers && _registryClass._beforeRegisteredHelpers[name]){
            console.warn("Deprecated : Helper named - " + name + " is already registered");
        }
        //@Slicer.developmentEnd
        if(_registryClass._registered){
            _registryClass.prototype.registeredHelpers[name] = helper;
        }else if(_registryClass._beforeRegisteredHelpers){
            _registryClass._beforeRegisteredHelpers[name] = helper;
        }else{
            _registryClass._beforeRegisteredHelpers = {[name] : helper};
        }
    }
}
Helper.__lMod = "Helper";
function arrayUtils(){
    return _LC.aF.apply(_LC, arguments);
}
function objectUtils(){
    return _LC.oF.apply(_LC, arguments);
}
function set(){
    return _LC.set.apply(_LC.String, arguments);
}
ComponentRegistry._registeredComponentClass = {};
ComponentRegistry._registeredCeComponentClass = {};
_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.$ = {
    assetsDiv : document.createElement("div"),
    shadowDiv : document.createElement("div")
}
_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.$.assetsDiv.setAttribute("id", "lyteAssetsDiv");
_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.$.shadowDiv.setAttribute("id", "lyteShadowDiv");

// ComponentRegistry.Compile = Compile;
let orgArrFns = ["push", "pop", "splice", "shift", "unshift", "concat"];
for(let i=0; i<orgArrFns.length; i++){
    let arrFnName = orgArrFns[i];
    // Array.prototype["$"+orgArrFns[i]] = Array.prototype[orgArrFns[i]]
    Object.defineProperty(Array.prototype, "$"+arrFnName, {
        enumerable: false, 
        value : Array.prototype[arrFnName]
    })
}
var _LC = {
    "counter" : 0,
    "_definedComponents" : {},
    validateRenderData : function(data, _lyteOptions){
        if(_lyteOptions && _lyteOptions.setInnerHTML){
            return true
        }
        //@Slicer.developmentStart
        if( !(data === undefined || data === null || (typeof data == "object" && !Array.isArray(data)) ) ){
            _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.warn("Invalid data passed to render the component from route.");
            // return false;
        }
        //@Slicer.developmentEnd
        return true;
    },
    _render : function(object){
        let compClass = this;
        ltCf.fromV4Render = true;
        let oldLyteV4 = ltCf.lyteV4;
        let outlet = object.outlet;
        let registryInstance = object.registryInstance;
        let data = object.data;
        let options = object.options;
        if(compClass._registered){
            if(_LC.validateRenderData(data)){
                if(data && data.lyteV4){
                    ltCf.lyteV4 = true;
                }
                if(registryInstance){
                    if(!_LC.isValidReg(registryInstance)){
                        //@Slicer.developmentStart
                        _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ApiError.error("LC006");
                        //@Slicer.developmentEnd
                        ltCf.fromV4Render = false;
                        ltCf.lyteV4 = oldLyteV4
                        return;
                    }
                    options = options || {};
                    if(object._route){
                        options._route = object._route;
                    }
                    let ele = registryInstance.render(compClass,data,outlet,options);
                    ltCf.fromV4Render = false;
                    ltCf.lyteV4 = oldLyteV4
                    return ele;
                }else{
                    let registryClass = compClass._registryClass;
                    if(registryClass._instanciated && registryClass._instanceList.length){
                        // if(registryClass._instanceList.length > 1){
                        //     Lyte.error("Registry not instanced for ",compClass.name);
                        // }else{
                            options = options || {};
                            if(object._route){
                                options._route = object._route;
                            }
                            let ele = registryClass._instanceList[0].render(compClass,data,outlet,options);
                            ltCf.fromV4Render = false;
                            ltCf.lyteV4 = oldLyteV4
                            return ele;
                        // }
                    }
                    //@Slicer.developmentStart
                    else{
                        _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ApiError.error("LC007");
                    }
                    //@Slicer.developmentEnd
                }
            }
        }
        //@Slicer.developmentStart
        else{
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ApiError.error("LC008");
        }
        //@Slicer.developmentEnd
    },
    Security : {
        defaultTags : ["link-to"],
        defaultAttr : ["yield-name","lt-prop-route", "lt-prop-dp", "lt-prop-fragment", "lt-prop-qp", "lt-prop", "lt-prop-class", "lt-prop-id", "lt-prop-rel", "lt-prop-title", "lt-prop-style", "lt-prop-target","lt-prop-td","lt-prop-custom","lt-prop-target","lt-prop-id","lt-prop-class","lt-prop-style","lt-prop-rel","lt-prop-title"],
        sanitizeHTML : function(obj){
            let clean;
            let divEle = document.createElement("div");
            let html = obj.html;
            let instance = obj.instance;
            // let options = obj.options;
            let additionalObject = obj.additionalObject ? obj.additionalObject : {};
            if(instance && Object.keys(instance).length){
                if(additionalObject && Object.keys(additionalObject).length){
                    _LC.Security.initializeConfig(additionalObject);
                    _LC.Security.removeConfig(additionalObject);
                    _LC.Security.addLyteComponents(additionalObject);
                    clean = _LC.Security.sanitizeWithConfig(html ,additionalObject, instance);
                }
                else{
                    clean = instance.sanitize(html);
                }
            }else{
                //@Slicer.developmentStart
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ApiError.error("LC009");
                //@Slicer.developmentEnd
                return;
            }
            if(obj && obj.getInnerHTML){
                return clean;
            }
            divEle.innerHTML = clean;
            return divEle;
        },
        createSanitizer : function (obb) {
            _LC.Security.initializeConfig(obb);
            _LC.Security.addConfig(obb);
            _LC.Security.addLyteComponents(obb);
            let instance = ZSEC.HTMLPurifier(obb);
            instance._GLOBAL_TAGS = obb.GLOBAL_TAGS;
            instance._GLOBAL_ATTRIBUTES = obb.GLOBAL_ATTRIBUTES;
            instance._FORBID_TAGS = obb.FORBID_TAGS;
            instance._FORBID_ATTR = obb.FORBID_ATTR;
            return instance;
        },
        sanitizeWithConfig : function(html , additionalObject, instance){
            _LC.Security.addGlobalObject(instance,additionalObject);
            let clean = instance.sanitize(html);
            _LC.Security.removeGlobalObject(instance,additionalObject);
            return clean;
        },
        initializeConfig : function(obb){
            if (!obb.GLOBAL_ATTRIBUTES) {
                obb.GLOBAL_ATTRIBUTES = [];
            }
            if (!obb.FORBID_TAGS) {
                obb.FORBID_TAGS = [];
            }
            if (!obb.FORBID_ATTR) {
                obb.FORBID_ATTR = [];
            }
            if (!obb.GLOBAL_TAGS) {
                obb.GLOBAL_TAGS = [];
          }
        },
        addConfig : function(obb){
            _LC.Security.defaultAttr.forEach(function(item){
                obb.GLOBAL_ATTRIBUTES.$push(item);
            })
            _LC.Security.defaultTags.forEach(function(item){
                obb.GLOBAL_TAGS.$push(item);
            })
        },
        removeConfig : function(obb){
            if(obb && Object.keys(obb) && Object.keys(obb).length > 0){
                if(obb.GLOBAL_ATTRIBUTES && obb.GLOBAL_ATTRIBUTES.length > 0){
                    _LC.Security.defaultAttr.forEach(function(item){
                        var index = obb.GLOBAL_ATTRIBUTES.indexOf(item);
                        if(index != -1){
                            obb.GLOBAL_ATTRIBUTES.$splice(index,1);
                        }
                    })
                }
                if(obb.GLOBAL_TAGS && obb.GLOBAL_TAGS.length > 0){
                    _LC.Security.defaultTags.forEach(function(item){
                        var index = obb.GLOBAL_TAGS.indexOf(item);
                        if(index != -1){
                            obb.GLOBAL_TAGS.$splice(index,1);
                        }
                    })
                }
            }
        },
        addLyteComponents : function(obb){
            var globalTagArr = Array.from(obb.GLOBAL_TAGS);
            var attr = [];
            for(var a=0; a<globalTagArr.length; a++){
                let regComps = ComponentRegistry._registeredCommonClass;
                let rawComps = ComponentRegistry._registeredCommonCeClass;
                if(regComps[globalTagArr[a]]){
                    attr = regComps[globalTagArr[a]].observedAttributes;
                }else if(rawComps[globalTagArr[a]]){
                    if(rawComps[globalTagArr[a]].observedAttributes){
                        attr = rawComps[globalTagArr[a]].observedAttributes;
                    }
                }
                for(var i=0; i<attr.length; i++){
                    if(obb.GLOBAL_ATTRIBUTES.indexOf(attr[i]) == -1){
                        obb.GLOBAL_ATTRIBUTES.$push(attr[i]);
                    }
                }
            }
        },
        addGlobalObject : function(instanceObj,additionalObj){
            for (var property in additionalObj) {
                    if(Array.isArray(additionalObj[property])){
                        additionalObj[property].forEach(function(item){
                            if(instanceObj["_"+property].indexOf(item) == -1){
                                instanceObj["_"+property].$push(item);
                            }
                        });
                }
            }
        },
        removeGlobalObject : function(instanceObj,additionalObj){
            for (var property in additionalObj) {
                if(Array.isArray(additionalObj[property])){
                    additionalObj[property].forEach(function(item){
                        var index = instanceObj["_"+property].indexOf(item);
                        if(index != -1){
                            instanceObj["_"+property].$splice(index,1);
                        }
                    });
            }
            };
        }
    },
    toBeRegistered : [],
    getRegistryClass : function(options){
        let registryClass;
        ComponentRegistry._registeredRegistries.forEach(function(obj){
            let reg = obj.class;
            if(reg._hash == options.refHash){
                registryClass = reg;
                return
            }

        })
        return registryClass;
    },
    "setCurrentRegistryIns" : function(currentReg){
        _LC._currentRegistryInstance = currentReg;
    },
    "setCurrentRegistry" : function(reg){
        _LC._currentRegistry = reg;
    },
    "getCurrentRegistryIns" : function(){
        return _LC._currentRegistryInstance;
    },
    "getCurrentRegistry" : function(){
        return _LC._currentRegistry;
    },
    "getDecidedRegistry" : function(){
        return _LC._decidedRegistry;
    },
    "setDecidedRegistry" : function(reg){
        _LC._decidedRegistry = reg;
    },
    "setDefaultRegistry" : function(reg){
        _LC._defaultRegistry = reg;
    },
    "setDefaultRegistryIns" : function(regIns){
        _LC._defaultRegistryIns = regIns;
    },
    "getDefaultRegistryIns" : function(){
        return _LC._defaultRegistryIns;
    },
    "getDefaultRegistry" : function(){
        return _LC._defaultRegistry;
    },
    "setAddedRegistries" : function(scope,scopeName){
        let addedRegistries = scope.addRegistries ? scope.addRegistries.apply(scope) : [];
        if(addedRegistries){
            let validReg = _LC.validateArrRegistry(addedRegistries,scopeName);
            scope.addedRegistries = validReg ? addedRegistries : [];
        }else{
            scope.addedRegistries = [];
        }
    },
    "validateArrRegistry" : function(arr , moduleName){
        for(let i=0; i<arr.length; i++){
            if(!_LC.validateRegistry(arr[i],moduleName)){
                return false;
            }
        }
        return true;
    },
    "isValidReg" : function(reg){
        return reg && reg.isComponentRegistry && reg.isComponentRegistry()
    },
    "validateRegistry" : function(reg,moduleName){
        if(!_LC.isValidReg(reg)){
            let name =  reg ? reg.constructor ? reg.constructor.name : reg : reg ;
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.RegistryError.error("LC005", name, moduleName);
            //@Slicer.developmentEnd
            return false;
        }
        return true;
    },
    "getApp" : function(node){
        if(node){
            return node.$app ? node.$app : node.$addon.$app;
        }else{
            return this.$app ? this.$app : this.$addon.$app;
        }
    },
    "getNearestParentApp" : function(node){
        let app;
        if(!node){
            node = this;
        }
        while(node){
            if(node.$app){
                app = node.$app;
                break;
            }
            else if(node.$addon){
                if(node.$addon.$app){
                    app = node.$addon.$app
                    break;
                }
            }
            node = node.$addon;
        }
        return app;
    },
    "getAppOrAddon" : function(node){
        // node can be component or registry
        node = node ? node : this;
        if(node){
            return node.$app ? node.$app : node.$addon;
        }
    },
    "migratedv2" : function(app){
        if((app.constructor._migration && app.constructor._migration.version == "2") || (app.constructor.__slyteApp)){
            return true;
        }
    },
    "updateDirectivesInReg" : function(self,dClass,name){
        self._registeredRegistries.forEach(function(regObj){
            let regClass = regObj.class;
            if(regClass._instanciated){
                regClass._instanceList.forEach(function(regIns){
                    let directiveIns;
                    let app = _LC.getAppOrAddon(regIns);
                    app.scopedInstance(dClass,[regIns],function(ins){
                        directiveIns = ins;
                    },[])
                    regIns["_"+name] = directiveIns;
                    regIns._defaultDirectives.push(name);
                })
            }
        })
    },
    "updateDomApis" : function(regIns){
        regIns.appendChild = _LC.appendChild;
        regIns.insertAfter = _LC.insertAfter;
        regIns.insertBefore = _LC.insertBefore
    },
    "getMyScope" : function(node){
        if(node.$app){
            return node.$app;
        }else if(node.$addon){
            return node.$addon;
        }
    },
    "setComponentsDiv" : function(template,name){
        let div = createElement("div");
        div.setAttribute("id",name);
        template.appendChild(div);
        return div;
    },
    "getComponentsDiv" : function(template,name){
        return template.querySelector("#"+name);
    },
    "validateRegistryClass" : function(name, returnClass){
        let regFound,regClass;
        ComponentRegistry._registeredRegistries.forEach(function(regObj){
            if(regObj.name == name){
                regFound = true;
                regClass = regObj.class;
            }
        })
        return returnClass ? regClass : regFound;
    },
    "getCompRegistry" : function(obj,self){
        var initProp = self._initProperties;
        if((initProp && initProp.lyteRegistry) || (self.hasAttribute("lyte-registry"))){
            var reg = (initProp && initProp.lyteRegistry) || self.getAttribute("lyte-registry");
            if(typeof reg == "function"){
                if(_LC.validateRegistryClass(reg.name)){
                    if(reg._instanceList.length){
                        reg = reg._instanceList[0];
                    }else{
                        _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.RegistryError.error("LC012", reg.name ,self.localName);    
                    }
                }else{
                    _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.RegistryError.error("LC011", reg.name, self.localName);
                    return;
                }
            }else if(typeof reg == "string"){
                let regClass = _LC.validateRegistryClass(reg,true)
                if(regClass){
                    if(regClass._instanceList.length){
                        reg = regClass._instanceList[0];
                    }else{
                        _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.RegistryError.error("LC014", reg, self.localName);    
                    }
                }else{
                    _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.RegistryError.error("LC013",reg, self.localName);
                    return;
                }
            }
            var registryMap = new WeakMap();
            if(this.checkInRegistry(reg,obj,registryMap)){
                return;
            }
        }
        var currentReg = _LC.getCurrentRegistryIns();
        if(currentReg){
            this.traverseRegistries([currentReg],obj,self);
        }else{
            let defRegIns = _LC.getDefaultRegistryIns();
            if(defRegIns){
                this.traverseRegistries([defRegIns],obj,self);    
            }else{
                let defaultReg = _LC.getDefaultRegistry();
                if(defaultReg){
                    let defaultRegInsArr = defaultReg._instanceList;
                    this.traverseRegistries(defaultRegInsArr,obj,self);
                }
            }
        }
    },
    "verifyDetails" : function(obj){
        var lIns = obj.lIns ,compClass = obj.compClass ,regIns = obj.regIns;
        if(!lIns || !compClass || !regIns){
            return false;
        }
        return true;
    },
    "isValidateLyteReg" : function(reg,registryMap){
        if(!_LC.isValidReg(reg)){
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.RegistryError.error("LC006", reg.constructor.name);
            //@Slicer.developmentEnd
            return false;
        }else if(registryMap.get(reg)){
            //@Slicer.developmentStart
            // RegistryError.error("LC007", reg.constructor.name);
            //@Slicer.developmentEnd
            return false;
        }
        registryMap.set(reg,reg);
        return true;
    },
    "checkInRegistry" : function(registry,obj,registryMap){
        if(this.isValidateLyteReg(registry,registryMap)){
            obj.compClass = obj.type == "component" ? registry.constructor._registeredComponentClass[obj.compName] : registry.constructor._registeredCeComponentClass[obj.compName];
            if(obj.compClass){
                obj.regIns = registry;
                obj.lIns = registry.$app ? registry.$app : registry.$addon;
                return true;
            }else{
                if(registry.addedRegistries){
                    let addedReg = registry.addedRegistries;
                    for(let i=0; i<addedReg.length; i++){
                        if(this.checkInRegistry(addedReg[i],obj,registryMap)){
                            return true;
                        }
                    }
                }
            }
        }
    },
    "iterateRegistries" : function(baseRegistryArr,obj,registryMap){
        for(let i=0; i<baseRegistryArr.length; i++){
            if(this.checkInRegistry(baseRegistryArr[i],obj,registryMap)){
                return true;
            }
        }
    },
    "traverseRegistries" : function(baseRegistryArr,obj,self){
        let registryMap = new WeakMap();
        if(this.iterateRegistries(baseRegistryArr,obj,registryMap)){
            return
        }
        let parentComp = self._callee || self.getCallee && self.getCallee(self.parentNode);
        if(!parentComp){
            return;
        }
        while(parentComp){
            let parentCompReg = parentComp.$registry;
            registryMap = new WeakMap();
            if(this.checkInRegistry(parentCompReg,obj,registryMap)){
                return;
            }
            if(parentComp.component.addedRegistries){
                let pcAddedReg = parentComp.component.addedRegistries;
                for(let i=0; i<pcAddedReg.length; i++){
                    registryMap = new WeakMap();
                    if(this.checkInRegistry(pcAddedReg[i],obj,registryMap)){
                        return;
                    }
                }
            }
            parentComp = parentComp._callee || parentComp.getCallee && parentComp.getCallee(parentComp.parentNode);
        }
        
    },
    "getCommonClass" : function(componentName){
        var customCrmComponent = ComponentRegistry._registeredCommonClass[componentName];
        return customCrmComponent;
    },
    "getCommonCustomClass" : function(componentName){
        var customCrmComponent = ComponentRegistry._registeredCommonClass[componentName];
        return customCrmComponent;
    },

    "registerCeComponent" : function(componentName, componentClass, registryInstance){
        let customLyteCustomComponent;
        let registry = componentClass._registryClass;
        let registryName = registry.name;
        if(registryInstance.registeredCeComponents[componentName] && ComponentRegistry._registeredCommonCeClass[componentName]._reg[registryName]) {
            customLyteCustomComponent = this.getCommonCustomClass(componentName,registryName);
        }else{
            customLyteCustomComponent = class extends LyteCustomElement {
                constructor(){
                    super()
                }
            }
            customLyteCustomComponent._observedAttributes = componentClass.observedAttributes || [];
            customLyteCustomComponent._deepWatchProperties = componentClass._deepWatchProperties || {};
            registryInstance.registeredCeComponents[componentName] = true;
            if (document.readyState === "complete" || document.readyState === "interactive") {     
                customElements.define(componentName, customLyteCustomComponent, undefined, {v4raw : true});
            }
            else{
                _LC.toBeRegistered.$push({name:componentName, def: customLyteCustomComponent, _lyteOptions : {v4raw : true} });//af check
            }
            ComponentRegistry._definedCeComponents[componentName] = customLyteCustomComponent;
            componentClass._instanciated = true;
            componentClass._registered = true;
            ComponentRegistry._registeredCommonCeClass[componentName] = customLyteCustomComponent;
            registry._registeredCeComponentClass[componentName] = componentClass;
        } 
    },
    "validate" : function() {
        var compInstance = this._ins;
        var data = compInstance.data;
        for(var key in data) {
            _LC.handleValidation(data, key, data[key], compInstance);
        }
    },
    "registerComponent" : function(componentName,componentClass,registryInstance) {
        let customCrmComponent;
        let alreadyRegistered;
        let registry = componentClass._registryClass;
        let registryName = registry.name;
        if(registryInstance.registeredComponents[componentName] && ComponentRegistry._registeredCommonClass[componentName]._reg[registryName]) {
            //think this place wont be called need to remove this check
            customCrmComponent = this.getCommonClass(componentName, registryName);
        }
        else if(ComponentRegistry._unRegisteredComponents[componentName]){
            customCrmComponent = this.getCommonClass(componentName);
            delete ComponentRegistry._unRegisteredComponents[componentName];
            alreadyRegistered = true;
        }
         else {
            customCrmComponent = class extends customElementPrototype {
                constructor(){
                    super()
                }
            }
            registryInstance.registeredComponents[componentName] = true;
            customCrmComponent._reg = {[registryName] : {}};
            customCrmComponent._depthTemp = document.createElement("template");//af check
            customCrmComponent.prototype.throwAction = this.throwAction;
            customCrmComponent._compName = componentName;
            Object.defineProperty(customCrmComponent.prototype, "setData", {
                configurable : true, 
                writable : true,
                value : function(arg0, arg1 ,options) {
                    return this.component.setData(arg0, arg1, options);
                }
            });

            Object.defineProperty(customCrmComponent.prototype, "getData", {
                configurable : true, 
                writable : true,
                value : function(arg0) {
                    return this.component.getData(arg0);
                }
            });

            Object.defineProperty(customCrmComponent.prototype, "setMethods", {
                configurable : true, 
                writable : true, 
                value : function(arg0, arg1) {
                    return this.component.setMethods(arg0, arg1);
                }
            })
            customCrmComponent.prototype.get = this.nodeGet;
            customCrmComponent.prototype.set = this.nodeSet;
        }
        if(componentClass.ssr){
            customCrmComponent._ssr = componentClass.ssr();
            if(customCrmComponent._ssr.config){
                customCrmComponent._config = customCrmComponent._ssr.config;
            }
        }

        customCrmComponent.componentClass = componentClass;
        var Component;
        if(ComponentRegistry._registeredCommonClass[componentName]){
            Component = ComponentRegistry._registeredCommonClass[componentName].component;
            Component.list.push(componentClass);
        }else{
            Component = {list : [componentClass]};
        }
        componentClass._v4 = true;
        customCrmComponent.component = Component;
        customCrmComponent._observedAttributes = componentClass._observedAttributes || [];
        customCrmComponent._deepWatchProperties = componentClass._deepWatchProperties || {};
        // if(!componentClass._registered){
            customCrmComponent._registerComponent(
                componentName,
                customCrmComponent,
                componentClass,
                registry,
                registryInstance
            );
        // }
        customCrmComponent._bindsIds = [];
        if(!_LC._definedComponents[componentName]) {
            if (document.readyState === "complete" || document.readyState === "interactive") {     
                customElements.define(componentName, customCrmComponent, undefined, {v4 : true});
            }
            else{
                _LC.toBeRegistered.$push({name:componentName, def: customCrmComponent, _lyteOptions : {v4 : true}});
            }
        }
        _LC._definedComponents[componentName] = customCrmComponent;
        let depthTemp = customCrmComponent._depthTemp;
        if(depthTemp && depthTemp.content.childNodes.length) { //removed _ie
            depthTemp.setAttribute("data-id", "depthTemp_" + componentName);
            let lyteComponentsDiv = _LC.getComponentsDiv(_LC.lyteComponentsDiv,registry.name);
            lyteComponentsDiv.appendChild(depthTemp);
        } else {
            delete customCrmComponent._depthTemp;
        }
        componentClass._instanciated = true;
        componentClass._registered = true;
        ComponentRegistry._registeredCommonClass[componentName] = customCrmComponent;
        registry._registeredComponentClass[componentName] = componentClass;
        if(alreadyRegistered) {
            var pendingComps = customCrmComponent._pendingComponents || [];
            pendingComps.forEach(function(item) {
                delete item.__lyteIgnore 
                item.actualConstructor();
                var arr = Array.from(item.attributes);
                arr.forEach(function(attr) {
                    if(item.constructor.observedAttributes.indexOf(attr.name) != -1) {
                        item.attributeChangedCallback(attr.name, null, attr.value);
                    }
                    
                });
                item.connectedCallback();
            });
            customCrmComponent._pendingComponents = [];
        }
        return customCrmComponent;
    },
    // "_lyteInstance": Lyte,
    "shadow" : {
        "getHostElement" : function(node){
            if(node){
                let host = node.host;
                if(host && host.tagName){
                    return host;
                }
            }
        },
        "stringToStyle" : function(str){
            var wrapper = document.createElement("wrapper");
            wrapper.innerHTML = str;
            return wrapper.firstChild;
        },
    },
    "directive" : {
        setTagDirectives : function(compClass,comp){
            if(compClass._lyteOptions && compClass._lyteOptions.attributes && compClass._lyteOptions.attributes.length){
                let attr = compClass._lyteOptions.attributes;
                for(let i=0; i<attr.length; i++){
                    if(typeof attr[i] == "object"){
                        if(attr[i].name.startsWith("@")){
                            comp._tagDirectives.push(attr[i]);
                            compClass._lyteOptions.attributes.splice(i,1);
                            i--;
                        }
                    }else{
                        if(attr[i].startsWith("@")){
                            comp._tagDirectives.push(attr[i]);
                            compClass._lyteOptions.attributes.splice(i,1);
                            i--;
                        }
                    }
                }
            }
        },
        checkSameAttrName : function(arr,directiveName,arg){
            let duplicateFound;
            arr.forEach(function(attr){
                if(attr.hookName == directiveName && arg){
                    attr.stringValue = arg;
                }
            })
            return duplicateFound;
        },
        isDirectiveNode : function(node){
            if(node.hookNode || (node.nodeName && node.nodeName.startsWith("@")) || node._isDirectiveNode){
                return true;
            }
            return false;
        },
        getActualTransitionArg : function(attr,node){
            if(attr.hasOwnProperty("dynamicValue") || attr.hasOwnProperty("helperInfo")){
                if(node.hasOwnProperty("_transitionArgs")){
                    if(node._transitionArgs.hasOwnProperty(attr.hookName)){
                        return node._transitionArgs[attr.hookName];
                    }
                }
            }else if(attr.hasOwnProperty("stringValue")){
                if(attr.hasOwnProperty("stringValue")){
                    if(attr.stringValue === ""){
                        return true
                    }if(attr.stringValue === "true"){
                        return true
                    }else if(attr.stringValue === "false"){
                        return false
                    }else{
                        return attr.stringValue;
                    }
                }
            }
        },
        getTransitionArg : function(node,directiveName,returnAttr){
            let transitionArg;
            if(node.component && node.component.constructor._options){
                this.setAttrFromRender(node);
            }
            var self = this;
            if(node._specialAttributeDetails){
                node._specialAttributeDetails.forEach(function(attr){
                    if(directiveName == attr.hookName){
                        transitionArg = returnAttr ? attr : self.getActualTransitionArg(attr,node);
                        return;
                    }
                })
            }
            return transitionArg;
        },
        setAttrFromRender : function(comp,tagDirectives){
            if(tagDirectives.length){
                if(!comp._specialAttributeDetails){
                    comp._specialAttributeDetails = [];
                }
                var self = this;
                tagDirectives.forEach(function(directiveName){
                    if(self.checkSameAttrName(comp._specialAttributeDetails,directiveName,directiveName.value)){
                        return;
                    }
                    let attr;
                    if(typeof directiveName == "string"){ 
                        attr = {
                            hookName : directiveName.slice(1,directiveName.length),
                            hookNode : true,
                            name : directiveName,
                            stringValue : ""
                        }   
                    }else{
                        attr = {
                            hookName : directiveName.name.slice(1,directiveName.name.length),
                            hookNode : true,
                            name : directiveName.name,
                            stringValue : directiveName.value
                        }
                    }
                    comp._specialAttributeDetails.push(attr)
                })
            }
        },
        setNodeArgs : function(node,nodeValue){
            // node.ownerElement._transitionArgs = nodeValue;
            let nodeName = node.nodeName;
            node.ownerElement.removeAttribute(nodeName);
            // node.nodeName = node.nodeName.slice(1,node.nodeName.length);
            if(!node.ownerElement._transitionArgs){
                node.ownerElement._transitionArgs = {};
            }
            let actNodeName = nodeName
            if(nodeName.startsWith("@")){
                actNodeName = nodeName.slice(1,nodeName.length);
            }
            node.ownerElement._transitionArgs[actNodeName] = nodeValue;
            node.ownerElement.setAttribute("lyte-directive-" + actNodeName,"");
        },
        infoA : function(comp,info,dynamicN,helperNode,attr,yieldComp,options){
            this.setSpecialNodes(comp,helperNode,dynamicN,info,options);
            if(dynamicN._specialAttributeDetails && dynamicN._specialAttributeDetails.length){
                dynamicN._specialAttributeDetails.push(attr);
            }else{
                dynamicN._specialAttributeDetails = [attr];
            }
            if(yieldComp){
                yieldComp._transitionAppend.$push(dynamicN);
            }
            else if(comp._transitionAppend.indexOf(dynamicN)==-1 && dynamicN && dynamicN.getAttribute("is") != "component"){
                comp._transitionAppend.$push(dynamicN);
            }
        },
        setSpecialNodes : function(comp,helperNode,dynamicN,info,options){
            if(helperNode && (helperNode._hooksPresent || helperNode._defaultSetSpecialNode)){
                if(helperNode._specialNodes){
                    if(helperNode.getAttribute("is") == "for"){
                        helperNode._specialNodes[options.itemIndex][info.in] = dynamicN;
                    }else if(helperNode.getAttribute("is") == "forIn"){
                        helperNode._specialNodes[options.itemIndex][info.in] = dynamicN;
                    }
                    else if(helperNode && /if|switch/g.test(helperNode.getAttribute("is"))){
                        helperNode._specialNodes[info.in] = dynamicN;  
                    }
                    else if(helperNode && helperNode.tagName == "LYTE-YIELD"){
                        helperNode._specialNodes[info.in] = dynamicN;
                    }
                }
            }else if(dynamicN && dynamicN._hooksPresent && comp._specialNodes){
                comp._specialNodes[info.in] = dynamicN;
                comp._hooksPresent = true;
                comp.hc = true;
            }else if(dynamicN && dynamicN._defaultSetSpecialNode && comp._specialNodes){
                comp._specialNodes[info.in] = dynamicN;
                comp._defaultSetSpecialNode = true;
            }
            if(info.chld){
                dynamicN._chld = info.chld;
            }
            if(info.dc){
                dynamicN.dc = info.dc;
                dynamicN.hc = info.hc;
            }
            if(info.sibl){
                dynamicN._sibl = info.sibl;
            }
        }
    },
    "fRP" : {},
    "fRC" : 0,
    // "frcUnused" : [],
    "customPropRegex" : "",
    // "pushFrc" : function(fastRenderIndex) {
    //     this.frcUnused.$push(fastRenderIndex);
    //     delete _LC.fRP[fastRenderIndex];
    // },
    // "getFrc" : function() {
    //     let frcIndex;
    //     if(this.frcUnused.length) {
    //         frcIndex = this.frcUnused.$shift()
    //     } else {
    //         frcIndex = this.fRC++;
    //     }
    //     return frcIndex;
    // },
    "customPropHandlers" : [],
    "_registeredComponents" : {},
    // "_reRegisteredComponents" : [],
    // "toBeRegistered" : [],
    "updateCustomCrmComponent" : function(componentClass){
        var def = componentClass.__observers;
        for(let key in def) {
            if (def[key] && def[key].type === "observer") {
                def[key].fnName = key;
                componentClass._observers.$push(def[key]);
            } else if (def[key] && def[key].type === "callBack") {
                var props = def[key].properties;
                for (var k = 0; k < props.length; k++) {
                    if (!componentClass._callBacks[props[k]]) {
                        componentClass._callBacks[props[k]] = [];
                    }
                    def[key].fnName = key;
                    componentClass._callBacks[props[k]].$push(def[key]);
                }
                if (def[key].observes) {
                    def[key].observes.fnName = key;
                    componentClass._observers.$push(def[key].observes);
                }
            }
        }
        // delete orgDef.observers;
        // for (let key in orgDef) {
        //     componentClass.prototype[key] = orgDef[key];
        // }
        // return orgDef;
    },
    // "dataFromMixin" : function(mixinsToBeUsed,actionsFromMixin,methodsFromMixin,newDefinition){
    //     var mixinslen = mixinsToBeUsed.length;
    //     for(let i=0; i<mixinslen ; i++) {
    //         for(let item in mixinsToBeUsed[i]){
    //             if(item === "actions") {
    //                 Object.assign(actionsFromMixin, mixinsToBeUsed[i][item]);    
    //             } else if(item === "methods") {
    //                 Object.assign(methodsFromMixin, mixinsToBeUsed[i][item]);    
    //             } else {
    //                 newDefinition[item] = mixinsToBeUsed[i][item];
    //             }
    //         }
    //     }
    //     return{"actionsFromMixin":actionsFromMixin,"methodsFromMixin":methodsFromMixin,"newDefinition":newDefinition}
    //   },
    "throwEvent" : function(eventName){
        let self = this.$node ? this.$node : this;
        const evt = self._actions? self._actions[eventName] : undefined; 
        let customArgs = [];        
        if(arguments.length > 1){        
            for(let i=1;i<arguments.length; i++){            
                customArgs.$push(arguments[i]);                
                }        
            }
            //wait for release
            //eventName = _LC.String.toCamelCase(eventName);
            _LC.throwAction.call(self, self._callee, eventName, undefined, true, customArgs, self);
        if(this.$node) {
            self.dispatchEvent(evt? evt : new CustomEvent(eventName, {"detail" : customArgs}));
        }
    },
    //this and scope reference should be either a node or a route.
    "throwAction" : function(scope,eventName,actObj,isCustom,customArgs, node, event, hasHandled, fromEv){
        let actionsObj;
        let app = _LC.getNearestParentApp(this.component);
        if(this._route && isCustom) {
            // scope = Lyte.Router.getRouteInstance(this._route);
            scope = app.$.modules.router[0].getRouteInstance(this._route)//.__lp.fns;
            var fns = scope.__lp.fns;
            actionsObj = fns.actions || (fns.actions = {});
        } else if(this.routeName) {
            //process for the parent route and get the current component and proceed;
            let parentRoute = this.parent;
            if(parentRoute) {
                if(parentRoute.component && parentRoute.component.component) {
                    scope = parentRoute.component;
                    actionsObj = scope.component.constructor._actions; 
                } else {
                    scope = parentRoute;
                    // actionsObj =  scope.actions || (scope.actions = {});            
                    var fns = scope.__lp.fns;
                    actionsObj = fns.actions || (fns.actions = {});
                }
            }
        } else if(scope){
                actionsObj = scope.component.constructor._actions
        }
        if(!scope) {
            //Only warning is thrown because, we can have a eventListener for the dom directly. 
            //@Slicer.developmentStart
            if(!hasHandled) {
                _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.warn("Nothing handled the action "+ eventName + ".");    
            }
            //@Slicer.developmentEnd
            return;
        }
        actObj = (actObj) ? actObj : this._actions && this._actions[eventName]? this._actions[eventName].processAction : void 0;     
        //wait for release
        /* 
        var dasherizedEventName = _LC.String.dasherize(eventName);
        actObj = (actObj) ? actObj : this._actions && this._actions[dasherizedEventName]? this._actions[dasherizedEventName].processAction : void 0;     
        */
        let args = customArgs ? customArgs : [];
        let processDetails = {};
        if(actObj){
            var contextSwitchArray = [];
            if(node) {
                _LC.adCx(node, contextSwitchArray);
            }
            let concatArgs;
            if(actObj.skipArgProcessing) {
                // concatArgs = deepCopyObject(actObj.args);
                // concatArgs.$shift();
                // var eventIndex = concatArgs.indexOf("__lyteEvent__");
                // var nodeIndex = concatArgs.indexOf("__lyteNode__");
                // if(eventIndex !== -1) {
                //     concatArgs[eventIndex] = event;
                // } 
                // if(nodeIndex !== -1) {
                //     concatArgs[nodeIndex] = target;
                // }
                concatArgs = actObj.args;
            } else {
                concatArgs = this.processArgs(scope,{"helperInfo" : actObj}, undefined, event, node, undefined, undefined, undefined , processDetails);
            }
            args.$splice.apply(args, [0,0].$concat(concatArgs) );
            if(node) {
                _LC.rmCx(node, contextSwitchArray);
            }
            if(actionsObj[actObj.name]){
                if(!isCustom){  
                    //args.$unshift(window.event);
                    let parent = node.parentNode;
                    let val = actionsObj[actObj.name].apply(this.component,args);
                    if(event.currentTarget !== document.body && !_LCSD.getHostElement(event.currentTarget) && !fromEv) {
                        val = false;
                    }
                    hasHandled = true;
                    if(val !== false && !event.cancelBubble){
                        if(actObj.from && node.getAttribute(event.type) && node._boundEvents && node._boundEvents[event.type]) {
                            let actions = node._callee.component.constructor._actions;
                            let actObj = node._boundEvents[event.type];
                            let cloneActObj = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(actObj);
                            // cloneActObj.args.$shift();
                            _LC.skipArgProcessing(cloneActObj, event, node);
                            _LC.throwAction.call(node._callee,node._callee,event.type,cloneActObj, undefined, undefined, node, event, hasHandled);
                        } else {
                            if(_LC.hasLyteEvents(node, eventName)) {
                                let eventStopped = _LC.handleLyteEvents(node, event);
                                val = eventStopped ? false : true;       
                            }
                            if(val === false) {
                                return;
                            }
                            if(_LC.isCustomElement(node)){
                                scope = parent;
                            }
                            if(parent){
                                let eventStopped;
                                while(parent && !_LCSD.getHostElement(parent) && (!parent.getAttribute(eventName) || parent.hasAttribute("disabled") ) && parent.tagName != "BODY"){
                                    if(_LC.hasLyteEvents(parent, eventName)) {
                                        eventStopped = _LC.handleLyteEvents(parent, event);
                                        if(eventStopped) {
                                            break;
                                        }
                                    }
                                    parent = parent.parentNode;
                                }
                                if(eventStopped || !parent || parent.tagName === "BODY"){
                                    return;
                                }
                                if(!parent._callee){
                                    parent._callee = parent.getCallee ? parent.getCallee(parent) : _LC.getCallee(parent);
                                }
                                if(parent && event.type === eventName && !event.cancelBubble){
                                   if(parent._evBoundEvents && parent._evBoundEvents[eventName]) {
                                       let actObj = parent._evBoundEvents[eventName];
                                       let cloneActObj = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(actObj);
                                    //    cloneActObj.args.$shift();
                                        _LC.skipArgProcessing(cloneActObj, event, parent);
                                       _LC.throwAction.call(parent,parent,eventName,cloneActObj,undefined,undefined,parent,event, hasHandled);  
                                   } else if(parent && parent._boundEvents && parent._boundEvents[eventName]) {
                                       let actObj = parent._boundEvents[eventName];
                                       let cloneActObj = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(actObj);
                                       _LC.skipArgProcessing(cloneActObj, event, parent);
                                       _LC.throwAction.call(parent._callee,parent._callee,eventName,cloneActObj,undefined,undefined,parent,event, hasHandled);  
                                   }
                                }
                            }
                        }
                    }
                }            
                else{                
                    actionsObj[actObj.name].apply(this._callee.component,args);
                    hasHandled = true;                                             
                } 
            }
            //@Slicer.developmentStart
            else{
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error(app, "LC004" , actObj.name);
            }
            //@Slicer.developmentEnd
        } else if(isCustom) {
            var eventsObj = actionsObj[eventName]  || actionsObj[_LC.String.toCamelCase(eventName)] || actionsObj[_LC.String.dasherize(eventName)];
            if(eventsObj) {
                var scopeS = _LC.isCustomElement(scope) ? scope.component : scope;   
                let val = eventsObj.apply(scopeS, args);
                //let val = eventsObj.apply(_LC.isCustomElement(scope)? scope.component : scope, args);
                hasHandled = true;
                if(val !== false) {
                    _LC.throwAction.call(scope, scope._callee, eventName, actObj, isCustom, customArgs, undefined, undefined, hasHandled);
                }
            } else {
                _LC.throwAction.call(scope, scope._callee, eventName, actObj, isCustom, customArgs, undefined, undefined, hasHandled);
            }
        }
        
    },
    "isControlHelper" : function(ownerElement) {
        return (ownerElement.tagName === "TEMPLATE" && ownerElement.getAttribute("is") && ownerElement.getAttribute("is") !== "component") || (ownerElement.hasAttribute("lyte-for") || ownerElement.hasAttribute("lyte-if") || ownerElement.hasAttribute("lyte-switch") || ownerElement.hasAttribute("lyte-forin"));
    },
    "isCustomElement" : function(node, isTemplate) {
        return node.hasAttribute && ((( node.tagName ==="TEMPLATE" || node.attributes["lyte-for"] || node.attributes["lyte-if"] || node.attributes["lyte-switch"] || node.attributes["lyte-forin"] ) && isTemplate )  || (node.nodeName && node.nodeName.indexOf('-') !== -1 && (ComponentRegistry._registeredCommonClass[node.localName] || node.tagName === "LYTE-YIELD")));
    },
    "componentSet" : function(key, value, options, forceExecute, fromParent) {
        if(!forceExecute && this.get(key) === value) {
            _LC.clearError(this.data, key);
            //@Slicer.developmentStart
            if(!fromParent){
                if(typeof value == "object"){
                    _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.warn("The data passed to update '" + key + "' is the same reference of the actual data. So component bindings won't be updated.");
                }
            }
            //@Slicer.developmentEnd
            return;
        }
        //temporary fix
        return _LC.set(this.data, key, value, options, undefined, fromParent);
    },
    "componentGet" : function(key) {
        return key ? _LC.get(this.data, key) : this.data;
    },
    "nodeGet" : function(key) {
        return key ? this.component.get(key) : this.component.data;
    },
    "nodeSet" : function(key, value, options, fromParent) {
        this.component.set(key, value, options, undefined, fromParent);
    },
    "registerMixin" : function(name,mixin){
        _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.Mixin.register.call(_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte, name, mixin);
    },
    "sendtoclient": function(prop,server,node){
        var data = server ? prop.component.data : prop;
        var newData = {};
        var data_prop = node;
        for (var i in data){
            if(server){
                var def = prop.component.__data[i];
                if(i == "bindIds"){ 
                    newData[i] = {value : data[i] }
                }
                    if(def && /^(object|array)$/.test(def.type) && prop._attributeDetails && prop._attributeDetails.hasOwnProperty(_LC.String.dasherize(i))){
                        newData[i] = { "fP" : true };
                    }
                    else if(data[i] instanceof Date){
                        newData[i] = { "value" : data[i] , "type" : "Date" }
                    }
                    else if(data_prop[i]){
                        newData[i] = { "value" : data[i] , "type" : data_prop[i].type }
                    }else{
                        var type = typeof(data[i])
                        if(data[i] == undefined){
                            type = undefined;
                        }
                        newData[i] = {"value" : data[i] ,"type":type}
                    }
            }else{
                if(data[i].type=="Date"){
                    newData[i] = new Date(data[i].value);
                }
                else if(!data[i].fP){
                    newData[i]= data[i].value;
                }
            }
        }
        return newData;        	
    },
    "typeCast" : function(value, dataType, obj) {
        if(value === null) {
            return value;
        }
        try {
            switch(dataType) {
            case "string" : 
                return typeof value === "object" ? JSON.stringify(value) : value.toString(); 	
            break;
            case "number" :
                {
                if(value == "") {
                    return undefined;
                }
                let val = +value;
                if(isNaN(val)) {
                    throw "TypeCast exception";
                } 
                return val;
                }
            break;
            case "array" : 
            case "object" :
                return JSON.parse(value);
                break;
            case "boolean" :
                return ( (!value && value !== "") || value=== "false") ? false : true; 
            break;
            default : 
                return value;
            }
        } catch(e) {
            if(obj) {
                obj.isError = true;
            }
            return value;
        }
        
    },
    "getDataType" : function(value) {
        var type = typeof value;
        if(type === "object") {
            if(Array.isArray(value)) {
                return "array";
            }
        }
        return type;
    },
    "handleValidation" : function(object, property, value, component ,init) {
        let error = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.validateData)(object, property, value, component ,this._lyteInstance ,init);
        if(error) {
            _LC.set(component.data.errors, property, error);
            if(component.$node.callback) {
                component.$node.callback("onError", property, error);
            }
        } else {
            _LC.clearError(object, property);
        }
        return error;
    },
    "clearError" : function(data, property) {
        if(data.errors && data.errors[property]) {
            _LC.oF(data.errors, "delete", property);
        }
    },
    "createLyteId" : function(comp){
        comp.__counter++;
        return "__lyteId" + comp.__counter;
    },
    "apdNode" : function(node, comp) {
        _LC.tDiv.content.appendChild(node);
        let id = this.createLyteId(comp);
        comp.__h[id] = node;
        node.__lyteId = id;
    },
    "update":function(object, property, value, options, fromStore,oldValue,setterScope, actualProperty, fromParent ,FromUtils, storeRecord){
        let fromComponent = object.__component__;
        let updateAttr = true;
        let dataType, dataDef, estObjBind = false;
        if(!oldValue){
            oldValue = object[property];
            if(fromComponent && fromComponent.tagName !== "LYTE-YIELD") {
                dataDef = fromComponent.component.__data[property];
                if(dataDef && (dataType = dataDef.type)) {
                    updateAttr = !dataDef.hideAttr;
                    if(dataType !== _LC.getDataType(value) && (value !== undefined || dataType === "boolean")) {
                        value = _LC.typeCast(value, dataType);
                    }
                }
                if(value === oldValue) {
                    _LC.clearError(object, property);
                    return;
                }
                if(!options || (typeof options == "object" && options.skipValidation != true)){
                    let error = _LC.handleValidation(object, property, value, fromComponent.component);

                    if(error) {
                        // //@Slicer.developmentStart
                        // if(fromComponent.component.data.errors && Object.keys(fromComponent.component.data).length){
                        //     ComponentError.error("Error in data passed to component '"+fromComponent.component.$node.localName+"' for the property - "+property);
                        // }
                        // //@Slicer.developmentEnd
                        return false;
                    }
                }
        }
            //object[property] = value;
            if(!object.hasOwnProperty(property) && !(Array.isArray(object))) {
                _LC.oF(object, "add", property, value, true )
            } else {
                object[property] = value;
            }
        }
        let toBeExecuted = fromComponent ? true : false;
        let dasherizedAttr = _LC.String.dasherize(property);
        if(fromComponent && actualProperty && ( (typeof value === "string" && fromComponent.getAttribute(dasherizedAttr) !==  value) || fromComponent.hasAttribute(dasherizedAttr) )) {
            // (customPropRegex && this.customPropRegex)
            let cpr;
            if(fromComponent.tagName == "LYTE-YIELD"){
                cpr = fromComponent._callee.component._registryClass.customPropRegex;
            }else{
                cpr = fromComponent.component._registryClass.customPropRegex;
            }
             if((!cpr.exec(property) || fromComponent.hasAttribute(dasherizedAttr) ) && updateAttr) {
                 if(value && typeof value === "object") {
                     let jsonString;
                     try{
                        jsonString = JSON.stringify(value);
                        fromComponent.attributes.getNamedItem(dasherizedAttr).__lyteIgnore = true;
                        fromComponent.setAttribute(dasherizedAttr, jsonString);
                     } catch(e) {

                     }
                 } else {
                     let attributeString = _LC.typeCast(value, "string");
                     if(fromComponent.getAttribute(dasherizedAttr) !== attributeString) {
                         let detAttr = fromComponent.attributes.getNamedItem(dasherizedAttr);
                         if(detAttr) {
                             detAttr.__lyteIgnore = true;
                         }
                         attributeString = attributeString || "";
                         fromComponent.setAttribute(dasherizedAttr, attributeString);
                     }
                 }
             }
        }
        if(value && typeof value !== "string" && typeof value !== "boolean" && typeof value !== "number" ) {
            //newValue is of type object 
            
            if(oldValue && typeof oldValue === "object" && oldValue._bindings) {
                //Both oldValue and newValue are objects. 
                if(!value._bindings) {
                    defProp(value, "_bindings", {
                        enumerable: false, 
                        writable: true, 
                        value : new Set(),
                        configurable: true
                    });
                }
                //for changing only child component
                if(fromComponent && fromComponent.component.data === object && property.indexOf('.')=== -1) {
                    let bindings = fromComponent.getProperty(property);
                    this.removeSelectedBindingDeep(bindings, oldValue);
                    addBindings(value._bindings,bindings);
                    this.establishBindings(bindings, value);
                    //For removing binding in the object due to forIn Helper ( actual object binding and not the _dynamicNodes binding).
                    if(bindings._forHelpers) {
                        let bindfor = bindings._forHelpers.toArrayLyte();
                        for(var i=0;i<bindfor.length;i++){
                            let item = bindfor[i];
                            if(item._propBindingObject) {
                                this.removeSelectedBindingDeep(item._propBindingObject, oldValue);
//                                  value._bindings.add(item._propBindingObject);
//                                  this.establishBindings(item._propBindingObject, value);
                            }
                        }
                    }
                    let stack = [];
                    this.affectChanges(bindings,undefined,oldValue,setterScope,object[property],stack);
                    this.executeObserver(stack);
                } else {
                    //To change only the bindings present in the object and not all the bindings present in the oldValue.
                    if(object._bindings) {
                        let oldbind = object._bindings.toArrayLyte();
                        for(let i=0; i<oldbind.length;i++){
                            let item = oldbind[i][property];
                            if(item) {
                                this.removeSelectedBindingDeep(item, oldValue);
                                addBindings(value._bindings,item);
                                this.establishBindings(item, value);
                                //For removing binding in the object due to forIn Helper ( actual object binding and not the _dynamicNodes binding).
                                if(item._forHelpers) {
                                    let forbind = item._forHelpers.toArrayLyte();
                                    for(let j=0;j<forbind.length;j++){
                                        let itemBinding = forbind[j];
                                        if(itemBinding._propBindingObject) {
                                            this.removeSelectedBindingDeep(itemBinding._propBindingObject, oldValue);
                                        }
                                    }
                                }
                                let stack = [];
                                this.affectChanges(item,undefined,oldValue,setterScope,object[property],stack);
                                this.executeObserver(stack);
                            }
                        }
                    }
                
                
                }
            } else {
                //newValue is object and oldValue is string. Hence establish bindings from oldValue's object and place it in the newValue. 
                if(object._bindings) {
                    makeSet(value, "_bindings");
                    let objbind = object._bindings.toArrayLyte();
                    for(let i=0;i<objbind.length;i++){
                        let item = objbind[i];
                        if(item[property]) {
                            addBindings(value._bindings,item[property]);
                            this.establishBindings(item[property], value);
                            let stack = [];
                            this.affectChanges(item[property],undefined,oldValue,setterScope,object[property],stack);
                            this.executeObserver(stack);
                        }
                    }
                }
            }
            dataDef = dataDef || (fromComponent && fromComponent.tagName !== "LYTE-YIELD" ? fromComponent.component.__data[property] : undefined); 
            if((fromStore && (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.isEntity)(object)) || (object && object.hasOwnProperty("_scp") && object._scp.size) || (dataDef && (/^(object|array)$/.test(dataDef.type)) && (dataDef.watch || dataDef.hasOwnProperty("items") || dataDef.hasOwnProperty("properties")))){
                estObjBind = true;
            }
        } else {
            //newValue is string
            
            if(oldValue && typeof oldValue === "object" && oldValue._bindings && object._bindings) {
                //newValue is string and oldValue is object 
                let objbind = object._bindings.toArrayLyte();
                for(let i=0;i<objbind.length;i++){
                    let item = objbind[i];
                    if(item[property]) {
                        //oldValue._bindings.delete(item[property]);
                        //if(oldValue._bindings.size === 0) {
                        //  delete oldValue._bindings;
                        //  break;
                        //}
                    this.removeSelectedBindingDeep(item[property], oldValue);
                        if(item[property]._forHelpers) {
                            let forbind = item[property]._forHelpers.toArrayLyte();
                            for(let j=0;j<forbind.length;j++){
                                let itemBinding =forbind[j];
                                if(itemBinding._propBindingObject) {
                                    this.removeSelectedBindingDeep(itemBinding._propBindingObject, oldValue);
                                }
                            }
                        }
                    }
                }
            }
            
            //when newValue and oldValue , both are string, no need to change bindings. 
            if(object._bindings) {
                let objbind = object._bindings.toArrayLyte();
                for(let i=0;i<objbind.length;i++){
                    let item = objbind[i];
                    if(item[property]) {
                        let stack = [];
                        this.affectChanges(item[property],undefined,oldValue,setterScope,object[property],stack);
                        this.executeObserver(stack);
                    }
                }
            }
        }
        if(object._scp){
            if(!(0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.cmpData)(oldValue, value)){
                this.callDeepObservers(object, { type:"deepChange", oldValue:oldValue, newValue : value }, property);
            }
            if(oldValue && (Array.isArray(oldValue) || typeof oldValue == "object")){
                var keys = Array.from(object._scp.keys());
                keys.forEach(function(id){
                    var nestObj = _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.nestScp[id];
                    var isCyclic = nestObj.cyclic;
                    (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.removeNestScp)(oldValue, id);
                    if(isCyclic){
                        (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.bindObj)(nestObj._data, undefined, id, [], new Map());
                    }
                });
            }
        }
        if(((0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.isEntity)(object) && object.$.__scpObj) || (object.hasOwnProperty("__component__") && object.__component__.__scpObj)){
            var _scpObj, kmpKey;
            if((0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.isEntity)(object)){
                _scpObj = object.$.__scpObj;
                kmpKey = object;
            }else{
                _scpObj = object.__component__.__scpObj;
                kmpKey = object.__component__;
            }
            if(_scpObj.hasOwnProperty(property)){
                var _sId = _scpObj[property].split("_");
                (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.removeNestScp)(oldValue, _sId[0], _sId[1], undefined, kmpKey, undefined, (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.isEntity)(value) || Array.isArray(value) && value.model && value.add ? value : undefined);
                delete _scpObj[property];
            }
        }
        if (!FromUtils) {
            _LC.callObjectObservers(object, { type: "change", "oldValue": oldValue, "newValue": value, item: property });
        }
        var customDtype = false;
        if(dataDef && dataDef.type instanceof Function){
            dataDef = dataDef.type;
            customDtype = true;
        }
        if(estObjBind || customDtype){
            // establishObjectBinding(object, property, fromStore, true);
            (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.establishObjectBinding)(
                object,
                property,
                fromStore,
                true,
                storeRecord,
                (dataDef && dataDef.watch)?dataDef.watch:undefined
            );
        }
        if(toBeExecuted && !fromParent && fromComponent._attributeDetails && fromComponent._callee) {
            //let syntaxValue = fromComponent.getAttributeNode(property).syntaxValue;
            let attrDetail = fromComponent._attributeDetails[_LC.String.dasherize(property)];
            let syntaxValue;
            if(attrDetail && attrDetail.isLbind) {
                syntaxValue = attrDetail.dynamicValue;
            }
            if(syntaxValue) {
                let contextSwitchArray;
                if(fromComponent._cx) {
                    contextSwitchArray = [];
                    _LC.changeContext(fromComponent._cx.node, contextSwitchArray, fromComponent._cx )
                }
                let obj = _LC.getNew(fromComponent._callee.component.data, syntaxValue);
                if(!obj.context){
                    return;
                }
                let exec = false;
                if(obj.context === fromComponent._callee.component.data) {
                    if(fromComponent._callee._properties[obj.lastKey] && fromComponent._callee._properties[obj.lastKey].__fromComponent) {
                        exec = true;
                    }
                } else {
                    exec = true;
                }
                //self.setData(this._lbind,this.value);
                if(exec) {
                    let lastKeyIndex = +obj.lastKey;
                    if(Array.isArray(obj.context) && typeof lastKeyIndex == "number") {
                        _LC.aF(obj.context, lastKeyIndex < obj.context.length ? "replaceAt" : "insertAt", lastKeyIndex, value);
                    } else {
                        _LC.set(obj.context, obj.lastKey, value, options);
                    }
                }
                if(contextSwitchArray) {
                    _LC.removeContext(fromComponent._cx.node, contextSwitchArray, fromComponent._cx )
                }
            }
        }
    },
    "getContentForIE" : function getContentForIE(content, constr, newlyCreated, info) {
        if(typeof content === "string") {
            newlyCreated = true;
            var div = createElement("div");
            div.innerHTML = content;
            content = div.childNodes[0];
            constr.splitTextNodes(content);
        }
        if(content.getAttribute && content.getAttribute("depth")) {
            if(info) {
                info._content = div;
            }
            var itr = parseInt(content.getAttribute("depth"));
            content =  newlyCreated ? content.content : content.content.cloneNode(true);
            // content = Lyte._ie ? content : (newlyCreated ? content.content : content.content.cloneNode(true));
            for(var i=0;i<itr;i++) {
                content = content.childNodes[0];
            }
        }
        return content;
    },
    "replaceWithPf" : function(node1, node2) {
        // if(Lyte._rwpf) {
        //     _LC.insertBeforeNative(node1.parentNode,node2, node1);
        //     node1.remove();
        // } else {
            node1.replaceWith(node2);
        // }
    },
    "getCallee" : function(callee, self){
        while(callee &&  !_LC.isCustomElement(callee) && callee.tagName !== "LYTE-YIELD") {
            if(callee.tagName === "BODY") {
                callee = null;
                break;
            }
            let hostEle = _LCSD.getHostElement(callee)
            if(!callee.parentNode && hostEle){
                callee = hostEle;
            }
            else{
                callee = callee.parentNode;
            }
        }
        if(callee && callee.tagName === "LYTE-YIELD") {
        return callee._registerYield? callee._registerYield._callee : undefined;
        }
        return ((self ===  callee) ? undefined : callee);
    },
    "set" : function(object, property, value, options, fromStore, fromParent, FromUtils, skipTypeError) {
        let lastIndex = -1;
        var s_rec,check={},recDottedProp;
        if((0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.isEntity)(object) && fromStore){
            s_rec=object;
        }
        if(!(typeof property === "object") || !property){
            property = property+"";
            lastIndex = property.lastIndexOf('.');
        }
        let actualProperty = property;
        if(lastIndex !== -1) {
            let outerPropertyPath = property.substring(0, lastIndex);
            property = property.substring(lastIndex + 1);
            object = _LC.get(object, outerPropertyPath);
            recDottedProp = true;
        }
        if(typeof property === "string" && object[property] === value) {
            if(object.__component__) {
                _LC.clearError(object, property);
            } else if((0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.isEntity)(object)) {
                if(!object.$.isCloned){
                    _slyte_data_src_ValidationError__WEBPACK_IMPORTED_MODULE_7__.ValidationError.clrRecErr(object.$, property);
                }
                object.$.emit("set", [object, property]);
                if(object.$.schema){
                    object.$.schema.emit("set", [object.$.schema._name, object, property]);
                    object.$.schema.db.emit("set", [object.$.schema._name, object, property]);
                }
                else if(object.$.model){
                    object.$.model.emit("set", [object.$.model._name, object, property]);
                    object.$.model.db.emit("set", [object.$.model._name, object, property]);
                }

            }
            return;
        }
        let oldValues = [];
        if(object._setterScope){
            var setterScope = object._setterScope;
        }
        var checkSim = false, watch = [];
        if(object._scp && object._scp.size){
            var keys = Array.from(object._scp.keys()), obj;
            keys.forEach(function(id){
                var _obj = object._scp.get(id);
                obj = _obj.paths;
                var recObj = _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.nestScp[id], model, field, rec, attr, wobj = {};
                var pathArr = Object.keys(obj), aPath;
                if(pathArr.length > 1){
                    aPath = "*";
                }
                else if(pathArr.length == 1){
                    aPath = pathArr[0];
                }
                wobj.path = aPath;
                wobj.id = id;
                if(pathArr.length > 1){
                    wobj.paths = pathArr;
                }
                wobj.attr = attr;
                wobj.data = recObj.data;
                wobj.PropsInfo = recObj.PropsInfo||undefined;
                var db = recObj.db;
                if(recObj.model){
                    var mMap = recObj.model;
                    wobj.Error = recObj.Error;
                    var mKeys = Array.from(recObj.model.keys());
                    for(var i=0; i<mKeys.length; i++){
                        var mName = mKeys[i];
                        var pkMap = mMap.get(mName);
                        if(pkMap){
                            var pkArr = Array.from(pkMap.keys());
                            var pkLen = pkArr.length;
                            for(var j=0; j<pkLen; j++){
                                var mPk = pkArr[j];
                                var attrMap = pkMap.get(mPk);
                                var attrArr = Array.from(attrMap.keys());
                                var attrLen = attrArr.length;
                                for(k=0; k<attrLen; k++){
                                    var mAttr = attrArr[k];
                                    var mObj = Object.assign({}, wobj);
                                    if(db.getSchema){
                                        var mRec = recObj.db.cache.getEntity({schema:db.getSchema(mName), pK:mPk});
                                    }
                                    else{
                                        var mRec = recObj.db.cache.getEntity({model:db.getModel(mName), pK:mPk});
                                    }
                                    if(mRec){
                                        model = mRec.$.schema ? mRec.$.schema : mRec.$.model;
                                        field = model.fieldList[mAttr];
                                        if((field && field.watch == true) || field.type instanceof Function){
                                            mObj.data = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(mRec[mAttr]);
                                            mObj.rec = mRec;
                                            mObj.isRec = true;
                                            mObj.attr = mAttr;
                                            mObj.dtype = model.fieldList[mAttr];
                                            mObj._cmpErr=mRec.$.error;
                                        }
                                        watch.$push(mObj);
                                    }
                                }
                            }
                        }
                    }
                } 
                else{
                    watch.$push(wobj);
                }         
            });
            watch.forEach(function(val){
                if((!options || (typeof options == "object" && options.skipValidation != true)) ){
                    var id = val.id,path=val.path.split("."),dtype=val.dtype,errs;
                    if(val.isRec){
                        // path.shift();
                        // path = path.length == 1 && path[0] == property ? []:path;
                        check.Prop = dtype;
                        (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.checkNestedProp)(id,path,dtype,val,object,property,value,check,fromStore); 
                    }
                    if(val.PropsInfo){
                        val.PropsInfo.forEach(function(props){
                            props.path = val.path;
                            props.attr = val.attr;
                            dtype = props.dtype;
                            check.Prop = dtype;
                            (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.checkNestedProp)(id,path,dtype,props,object,property,value,check,fromStore);
                        })
                    }
                }
            })
            //@Slicer.developmentStart
            if (check.value && check.value.code) {
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error("LC019", check.Prop.type.name);
                return { code: "LC019", message: _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.getErrorMessage("LC019", check.Prop.type.name)};
            }
            //@Slicer.developmentEnd
        }
        actualProperty = actualProperty === property ? actualProperty : undefined;
        var shareObj = {};
        if(typeof property === "object"){
            if(value && value.hasOwnProperty("skipTypeError")){
                skipTypeError = value.skipTypeError;
            }
            if((0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.isEntity)(object) && !fromStore && !object.$.isCloned) {
                    // for(let key in property){
                    //     if(Array.isArray(object[key])){
                    //         oldValues.$push({key:key,oldValue:object[key].slice(0)});    
                    //     }
                    //     else{
                    //         oldValues.$push({key:key,oldValue:object[key]});
                    //     }
                    // }
                    for(let key in property) {
                        let locValue = property[key];
                        let dataType = object.$.schema ? object.$.schema.fieldList[key] : object.$.model.fieldList[key];
                        dataType = dataType ? dataType.type : undefined;
                        if(dataType && (locValue !== undefined || dataType === "boolean") && dataType !== _LC.getDataType(locValue)) {
                            property[key] = _LC.typeCast(locValue, dataType);
                        }
                    }
                    var db = object.$.db;
                    let record;
                    if(db){
                        record = db.$.__sD(object.$, property, undefined, options, undefined, undefined, shareObj);
                    }
                    // if(record.$.isError){
                    //     return record;
                    // }
                    // for(let i=0; i<oldValues.length; i++){
                    //     _LC.update(object,oldValues[i].key,object[oldValues[i].key],fromStore,(oldValues[i].oldValue === undefined)?null:oldValues[i].oldValue ,setterScope, actualProperty, fromParent);
                    // }
            } else {
                //object[property] =  value;
                var errAttr = [];
                for(let key in property){
                    //_LC.update(object,key,property[key],fromStore,undefined,setterScope, actualProperty, fromParent);
                    //value is option here
                    var ret = _LC.set(object, key, property[key], value, fromStore, fromParent, undefined, true);
                    if(ret && ret.code){
                        errAttr.push(property);
                    }
                }
                if(!skipTypeError && errAttr.length){
                    var fromComponent = object.__component__;
                    //@Slicer.developmentStart
                    if(fromComponent && fromComponent.component.data.errors && Object.keys(fromComponent.component.data.errors).length){
                        var eKeys = Object.keys(fromComponent.component.data.errors), kStr;
                        if(eKeys.length){
                            kStr = eKeys.toString();
                            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error("LC006", fromComponent.component.$node.localName, kStr);
                        }
                        return { code: "LC006", message: _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.getErrorMessage("LC006", fromComponent.component.$node.localName, kStr), properties:kStr};
                    }
                    //@Slicer.developmentEnd
                }
            }
        }
        else{
            if(options && options.hasOwnProperty("skipTypeError")){
                skipTypeError = options.skipTypeError;
            }
            if((0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.isEntity)(object) && (!fromStore || (fromStore && recDottedProp)) && !object.$.isCloned) {
                let old = object[property];
                let dataType = object.$.schema ? object.$.schema.fieldList[property] : object.$.model.fieldList[property];
                dataType = dataType ? dataType.type : undefined;
                if(dataType && (value !== undefined || dataType === "boolean") && dataType !== _LC.getDataType(value)) {
                    value = _LC.typeCast(value, dataType);
                }
                var db = object.$.db;
                let record;
                if(db){
                    record = db.__sD(object.$, property,value, options, undefined, undefined, shareObj);
                }
                // if(record.$.isError){
                //     return record;
                // }
                //Commented because update will happend when "set" is called from setData of store. 
                //_LC.update(object,property,value,fromStore,(old === undefined) ? null : old,setterScope , actualProperty);    
            } else {
                var ret = _LC.update(object,property,value,options,fromStore,undefined,setterScope,actualProperty, fromParent, FromUtils, s_rec);
                if(ret == false){
                    var fromComponent = object.__component__;
                    //@Slicer.developmentStart
                    if( !skipTypeError && fromComponent && fromComponent.component.data.errors && Object.keys(fromComponent.component.data.errors).length){
                        var eKeys = Object.keys(fromComponent.component.data.errors);
                        if(eKeys.length){
                            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error("LC006", fromComponent.component.$node.localName,property);
                        }
                    }
                    //@Slicer.developmentEnd
                    return {code: "LC006", message: _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.getErrorMessage("LC006", fromComponent.component.$node.localName, property)};                 
                }
                 
            }
        }
        if(watch && watch.length){
            watch.forEach(function(obj){
                if(obj.isRec){
                  var db = obj.rec.$.db;
                  if(db){
                      db.__dVC(obj.rec, obj.attr, obj.rec[obj.attr], obj);
                  }
                }
            });
        }
        // return true;
    },
    "adCx" : function(node, contextSwitchArray) {
        let isYield = node.tagName === "LYTE-YIELD";
        if(node._cx && (!isYield || node._cx.node.tagName !== "LYTE-YIELD")) {
            _LC.changeContext(node._cx.node, contextSwitchArray, node._cx, isYield);
        } else if(isYield && node._callee._cx) {
            _LC.changeContext(node._callee._cx.node, contextSwitchArray, node._callee._cx, true);
        }
    }, 
    "rmCx" : function(node, contextSwitchArray) {
        let isYield = node.tagName === "LYTE-YIELD";
        if(node._cx && (!isYield || node._cx.node.tagName !== "LYTE-YIELD")) {
            _LC.removeContext(node._cx.node, contextSwitchArray, node._cx, isYield);
        } else if(isYield && node._callee._cx) {
            _LC.removeContext(node._callee._cx.node, contextSwitchArray, node._callee._cx, true);
        }
    },
    "changeContext" : function(node, contextSwitchArray, contextSwitchInfo, proceedFurther) {
        if(!contextSwitchInfo) {
            return;
        }
        let isYield = node.tagName === "LYTE-YIELD";
        if(node._cx && (!isYield || node._cx.node.tagName !== "LYTE-YIELD")) {
            _LC.changeContext(node._cx.node, contextSwitchArray, node._cx, node.tagName === "LYTE-YIELD" || proceedFurther);
        } else if((node.tagName === "LYTE-YIELD" || proceedFurther) && node._callee && node._callee._cx) {
            _LC.changeContext(node._callee._cx.node, contextSwitchArray, node._callee._cx);
        }
        if(isYield) {
            let insertYield = node._registerYield;
            let callee = insertYield._callee;
            if(callee && callee._cx) {
                _LC.changeContext(callee._cx.node, contextSwitchArray, callee._cx);
            }
        }
        let indexValue, itemValue;
        if(contextSwitchInfo.type) {
            if(contextSwitchInfo.type === "for") {
                indexValue = node.getAttribute("index");
                itemValue = node.getAttribute("item");
                if(node._items.length === 0) {
                    return;
                }
            } else {
                indexValue = node.getAttribute("key");
                itemValue = node.getAttribute("value");
                if(Object.keys(node._items).length === 0) {
                    return;
                }
            }
            let callee = node._callee;
            let initialItemValue = callee.component.data[itemValue];
            let initialIndexValue = callee.component.data[indexValue];
            let initialItemProp = callee._properties[itemValue];
            let initialIndexProp = callee._properties[indexValue];
             let items = contextSwitchInfo.type === "for" ? node._currentItems : node._currentObject;
            callee.component.data[itemValue] = items[contextSwitchInfo.itemIndex];
            callee.component.data[indexValue] = contextSwitchInfo.itemIndex;
            callee._properties[itemValue] = node._items[contextSwitchInfo.itemIndex].itemProperty;
            callee._properties[indexValue] = node._items[contextSwitchInfo.itemIndex].indexProperty;
            let dummyObject = {"initialItemValue" : initialItemValue , "initialIndexValue" : initialIndexValue, "initialItemProp" : initialItemProp, "initialIndexProp" : initialIndexProp};
            contextSwitchArray.$push(dummyObject);
        } else {
            //handling for yield
            let dummyObject = {};
            let callee = node._registerYield._callee;
            Object.keys(contextSwitchInfo.node._properties).forEach(function(key) {
                dummyObject[key] = {};
                dummyObject[key].value = callee.component.data[key];
                dummyObject[key].property = callee._properties[key];
                callee._properties[key] = contextSwitchInfo.node._properties[key];
                callee.component.data[key] = contextSwitchInfo.node.component.data[key];
            }); 
            contextSwitchArray.$push(dummyObject);
        }
    },
    "removeContext" : function(node, contextSwitchArray, contextSwitchInfo, proceedFurther) {
        if(!contextSwitchInfo) {
            return;
        }
        let isYield = node.tagName === "LYTE-YIELD";
        if(node._cx && (!isYield || node._cx.node.tagName !== "LYTE-YIELD")) {
            _LC.removeContext(node._cx.node, contextSwitchArray, node._cx, node.tagName === "LYTE-YIELD" || proceedFurther);
        } else if((node.tagName === "LYTE-YIELD" || proceedFurther) && node._callee && node._callee._cx) {
            _LC.removeContext(node._callee._cx.node, contextSwitchArray, node._callee._cx)
        }
        if(isYield) {
            let insertYield = node._registerYield;
            let callee = insertYield._callee;
            if(callee && callee._cx) {
                _LC.removeContext(callee._cx.node, contextSwitchArray, callee._cx);
            }
        }
        let indexValue, itemValue;
        if(contextSwitchInfo.type) {
            if(contextSwitchInfo.type === "for") {
                indexValue = node.getAttribute("index");
                itemValue = node.getAttribute("item");
                if(node._items.length === 0) {
                    return;
                }
            } else {
                indexValue = node.getAttribute("key");
                itemValue = node.getAttribute("value");
                if(Object.keys(node._items).length === 0) {
                    return;
                }
            }
            let callee = node._callee;
            let items = node._attributes.items;
            let removedObject = contextSwitchArray.$shift();
            callee.component.data[itemValue] = removedObject.initialItemValue;
            callee.component.data[indexValue] = removedObject.initialIndexValue;
            callee._properties[itemValue] = removedObject.initialItemProp;
            callee._properties[indexValue] = removedObject.initialIndexProp;
        } else {
            let callee = node._registerYield._callee;
            let removedObject = contextSwitchArray.$shift();
            Object.keys(contextSwitchInfo.node._properties).forEach(function(key) {
                callee.component.data[key] = removedObject[key].value;
                callee._properties[key] = removedObject[key].property;
            });
        }
    },
    "objectUtils" : function(){
        return _LC.oF.apply(_LC, arguments);
    },
    "sortCommands" : function(array1, arrayB) {
        var retVal = {};
        var arrayA = array1.slice();
        retVal.origianlArray = array1;
        var commands = [];
        
        for (let i = 0; i < arrayB.length; i++) {
            // var targetIndex = arrayA.findIndex((element) => element === arrayB[i]);
            var targetIndex = arrayA.indexOf(arrayB[i]);
        
            if (targetIndex === -1) {
            commands.push({
                type: 'Add',
                element: arrayB[i], 
                toIndex : i
            });
            arrayA.splice(i, 0, arrayB[i]);
            } else {
            if (targetIndex !== i) {
                commands.push({
                type: 'Move',
                element: arrayB[i],
                fromIndex: targetIndex,
                toIndex: i
                });
                arrayA.splice(targetIndex, 1);
                arrayA.splice(i, 0, arrayB[i]);
            }
            }
        }
        
        for (let i = arrayA.length - 1; i >= arrayB.length; i--) {
            commands.push({
            type: 'Remove',
            element: arrayA[i]
            });
            arrayA.splice(i, 1);
        }
        retVal.commands = commands;
        retVal.changedArray = arrayB;
        return retVal;
    },
    "oF" : function() {
        let object = arguments[0];
        let functionName = arguments[1];
        let property = arguments[2];
        let newValue = arguments[3];
        let fromComponent = arguments[4];
        let fromStore = arguments[5];
        if(functionName === "add" && !fromComponent) {
            let obj = {type:"change","oldValue":object[property],"newValue":newValue,"item":property};
            _LC.set(object, property, newValue,undefined, fromStore,undefined,true);
            _LC.callObjectObservers(object,obj);
            return;
        }
        let options = {};
        options.type = functionName;
        options.property = property;
        if(!/^(add|delete)$/.test(functionName)) {
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ApiError.error("LC001", functionName);
            //@Slicer.developmentEnd
            return;
        }
        let bindings = object._bindings;
        if(functionName === "delete") {
            let obj = {type:"change","oldValue":object[property],"newValue":newValue,"item":property};
            _LC.set(object, property, undefined, undefined, fromStore,undefined,true);
            _LC.callObjectObservers(object,obj);
        } else {
            object[property] = newValue;
        }
        if(bindings) {
            let bind = bindings.toArrayLyte();
            for(let i=0;i<bind.length;i++) {
                let binding = bind[i];
                let forHelpers = binding._forHelpers;
                if(forHelpers) {
                    let helperBind = forHelpers.toArrayLyte();
                    for(let j=0;j<helperBind.length;j++) {
                        let forHelper = helperBind[j];
                        if(forHelper.getAttribute("is") != "forIn"){
                            continue;
                        }
                        let itemValue = forHelper.getAttribute("key");
                        //Need to check
//                            _LC.removeSelectedBindingDeep({[itemValue] :                        forHelper._items[property].itemProperty}, {[itemValue] : object[property]});
                        let contextSwitchArray = [];
                        if(functionName === "add") {
                            _LC.adCx(forHelper, contextSwitchArray);
                        }
                        forHelper._callee.updateForInHelper(forHelper, options);
                        if(functionName === "add") {
                            _LC.rmCx(forHelper, contextSwitchArray);
                        }
                    }
                }
            }
        }
        if(functionName === "delete") {
            delete object[property];
        }
    },
    "arrayUtils" : function(){
        return _LC.aF.apply(_LC, arguments);
    },
    "aF" : function() {
        var argumentsArr = Array.from(arguments);
        var fromOverride = false;
        if(argumentsArr[0] && typeof argumentsArr[0] == "object" && argumentsArr[0].fromOverride){
            argumentsArr.$shift();
            fromOverride = true;
        }
        let array = argumentsArr[0];
        let initialArrLength = array.length;
        let callLengthObserver = true;
        let functionName = argumentsArr[1];
        let value = arguments[3],check={};
        if(/^(replaceAt|removeAt|shift)$/.test(functionName) && !array.length) {
            //@Slicer.developmentStart
            _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.warn(functionName + " operation cannot be performed on empty array");
            //@Slicer.developmentEnd
            return;
        }
        let commands;
        if(functionName == "sort") {
            var originalArray = arguments[0];
            var sortFunction = arguments[2];
            var addedArguments = arguments[3] || [];
            var dummyArray = originalArray.slice();
            addedArguments.forEach(function(item) {
                dummyArray.push(item);
            });
            if(typeof arguments[2] == "function") {
                dummyArray.sort(sortFunction);
            } else {
                var obj = arguments[2];
                var key = obj.sortBy;
                var order = obj.sortOrder;
                function sorting(item1, item2) {
                    var item1 = key ? item1[key] : item1;
                    var item2 = key ? item2[key] : item2;
                    if(item1 > item2) {
                        return order ? 1 : -1;
                    } else if(item1 < item2) {
                        return order ? -1 : 1;
                    } else {
                        return 0;
                    }
                }
                dummyArray.sort(sorting)
            }
            commands = this.sortCommands(originalArray, dummyArray).commands;
        }
        let commArgs = arguments[2], oldVal, obsObj, watch = [];
        if(array._scp && /^(replaceAt|splice|removeAt|remove|insertAt)$/.test(functionName)){
            array._scp.forEach(function(_obj, id){
                var rec, attr, wobj = {};
                var recObj = _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.nestScp[id];
                var obj = _obj.paths;
                var pathArr = Object.keys(obj), aPath;
                if(pathArr.length > 1){
                    aPath = "*";
                }
                else if(pathArr.length == 1){
                    aPath = pathArr[0];
                }
                wobj.path = aPath;
                wobj.id = id;
                if(pathArr.length > 1){
                    wobj.paths = pathArr;
                }
                wobj.attr = attr;
                wobj.data = recObj.data;
                wobj.reInit = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.isEntity)(recObj.data) || (Array.isArray(recObj.data) && (recObj.data.schema || recObj.data.model) && recObj.data.add);
                wobj.PropsInfo = recObj.PropsInfo || undefined;
                wobj.index=commArgs;
                if(recObj.model){
                    var mMap = recObj.model;
                    wobj.Error = recObj.Error;
                    var mKeys = Array.from(recObj.model.keys());
                    for(var i=0; i<mKeys.length; i++){
                        var mName = mKeys[i];
                        var pkMap = mMap.get(mName);
                        if(pkMap){
                            var pkArr = Array.from(pkMap.keys());
                            var pkLen = pkArr.length;
                            for(var j=0; j<pkLen; j++){
                                var mPk = pkArr[j];
                                var attrMap = pkMap.get(mPk);
                                var attrArr = Array.from(attrMap.keys());
                                var attrLen = attrArr.length;
                                for(k=0; k<attrLen; k++){
                                    var mAttr = attrArr[k];
                                    var mObj = Object.assign({}, wobj);
                                    if(recObj.db.getSchema){
                                        var mRec = recObj.db.cache.getEntity({schema:recObj.db.getSchema(mName), pK:mPk});
                                    }
                                    else{
                                        var mRec = recObj.db.cache.getEntity({model:recObj.db.getModel(mName), pK:mPk});
                                    }
                                    if(mRec){
                                        var model = mRec.$.schema ? mRec.$.schema : mRec.$.model;
                                        var field = model.fieldList[mAttr];
                                        if(field && (field.properties || field.items || field.watch == true)){
                                            mObj.data = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(mRec[mAttr]);
                                            mObj.rec = mRec;
                                            mObj.isRec = true;
                                            mObj.attr = mAttr;
                                            mObj.dtype = model.fieldList[mAttr];
                                            mObj._cmpErr=mRec.$.error;
                                            mObj.key=mAttr;
                                        }
                                        // mObj.reInit = true;
                                        watch.push(mObj);
                                    }
                                }
                            }
                        }
                    }
                } 
                else{
                    wobj.reInit = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.isEntity)(recObj.data) || (Array.isArray(recObj.data) && (recObj.data.schema || recObj.data.model ) && recObj.data.add);
                    watch.push(wobj);
                }
            });
            watch.forEach(function(val){
                var id = val.id,
                path=val.path == "" ? [] : val.path.split("."),
                dtype=val.dtype || undefined;
                if(val.isRec){
                    // path.shift();
                    // path = path.length == 1 && path[0] == property ? []:path;
                    check.Prop = dtype;
                    (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.checkNestedProp)(id,path,dtype,val,array,path,value,check);
                }
                if(val.PropsInfo){
                    val.PropsInfo.forEach(function(props){
                        props.path = val.path ;
                        dtype = props.dtype;
                        props.index = val.index;
                        check.Prop = dtype;
                        (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.checkNestedProp)(id,path,dtype,props,array,path,value,check);
                    })
                }
            })
            //@Slicer.developmentStart
            if (check.value && check.value.code) {
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error("LC019", check.Prop.type.name);
                // return { code:"LC019", message: ComponentError.getErrorMessage("LC019", check.Prop.type.name) };
            }
            //@Slicer.developmentEnd
        }  
        switch(functionName) {
        case "replaceAt" : 
            {
            let index = parseInt(argumentsArr[2]);
            if(index > array.length) {
                _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.warn("index provided for replaceAt is greater than array length");
                return [];
            }
            //let args = Array.prototype.slice.call(argumentsArr, 3);
            let args = argumentsArr[3];
            if(!(Array.isArray(args))) {
                args = [args];
            }
            else if(fromOverride){
                args = [args];
            }
            let deletedItems = array.$splice.apply(array, [index, 1].$concat(args));
            let options = {"firstIndex" : index, "secondIndex" : args.length, "type" : "replace"};
            //All references updated by now
            if(options.secondIndex == 1){
                callLengthObserver = false;
            }
            //remove binding from previous object
            if(array._bindings) {
                let objbind = array._bindings.toArrayLyte();
                for(let i=0;i<objbind.length;i++){
                    let item = objbind[i];
                    if(item._forHelpers) {
                        let helperbind = item._forHelpers.toArrayLyte();
                        for(let j=0;j<helperbind.length;j++){
                            let helper = helperbind[j];
                            if(helper.getAttribute("is") != "for"){
                                continue;
                            }
                            /*if(helper.hasAttribute("unbound")) {
                                continue;
                            }*/
                            let finalIndex = index + deletedItems.length;
                            let itemValue = helper.getAttribute("item");
                            for(let i=index, j=0;i<finalIndex;i++,j++) {
                                _LC.removeSelectedBindingDeep({[itemValue] : helper._items[i].itemProperty}, {[itemValue] : deletedItems[j]});
                            }
                            let contextSwitchArray = [];
                            _LC.adCx(helper, contextSwitchArray);
                            helper._callee.updateForHelper(helper, options);
                            _LC.rmCx(helper, contextSwitchArray);
                        }
                    }
                    for(let key in item) {
                        let parsedKey = parseInt(key);
                        let cond = (options.secondIndex == 1) ? (parsedKey == options.firstIndex) : (parsedKey >= options.firstIndex);
                        if(!isNaN(parsedKey) && cond) {
                            let diff = parsedKey - options.firstIndex;
                            let oldObject;
                            if(diff < 1) {
                                oldObject = deletedItems[diff];
                            } else {
                                oldObject = array[options.firstIndex - 1  + options.secondIndex + diff];
                            }
                            this.removeSelectedBindingDeep(item[key], oldObject);
                            if(item[key]._forHelpers) {
                                let bindfor = item[key]._forHelpers.toArrayLyte();
                                for(var j=0;j<bindfor.length;j++){
                                    let item1 = bindfor[j];
                                    if(item1._propBindingObject) {
                                        this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);
//                                          value._bindings.add(item._propBindingObject);
//                                          this.establishBindings(item._propBindingObject, value);
                                    }
                                }
                            }
                            if(array[parsedKey] && typeof array[parsedKey] === "object") {
                                makeSet(array[parsedKey], "_bindings");
                            this.establishBindings({"dummy" : item[key]},{"dummy" : array[parsedKey]});
                            }
                            this.affectChanges(item[key],undefined,oldObject,undefined,array[parsedKey]);
                            if(options.secondIndex == 1){
                                break; 
                            }
                        }
                    }
                }
            }
            obsObj = {type:"array",insertedItems:args, removedItems:deletedItems, index:index};
            _LC.bindWatchObj(watch, array, args, deletedItems, index);
            _LC.callArrayObservers(array,obsObj,callLengthObserver,initialArrLength);
            return deletedItems[0];
            }
            break;
        case "splice" : {
            let index = parseInt(argumentsArr[2]);
            if(index > array.length) {
                _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.warn("index provided is greater than array length");
                return [];
            }
            let toBeDeleted = argumentsArr.length > 3 ? argumentsArr[3] : array.length - index;
            let args;
            let skip = false;
            if(argumentsArr.length > 4){
                args = argumentsArr[4]
            }else{
                args = []
                skip = true;
            }
            if(!(Array.isArray(args))) {
                args = [args];
            }
            else if(!skip && fromOverride){
                args = [args];
            }
            let deletedItems = array.$splice.apply(array, [index, toBeDeleted].$concat(args));
            let options = {"firstIndex" : index, "secondIndex" : args.length, "thirdIndex" : toBeDeleted, "type" : "splice"};
            //All references updated by now
            if(options.secondIndex == options.thirdIndex){
                callLengthObserver = false
            }
            //remove binding from previous object
            if(array._bindings) {
                let objbind = array._bindings.toArrayLyte();
                for(let i=0;i<objbind.length;i++){
                    let item = objbind[i];
                    if(item._forHelpers) {
                        let helperbind = item._forHelpers.toArrayLyte();
                        for(let j=0;j<helperbind.length;j++){
                            let helper = helperbind[j];
                            /*if(helper.hasAttribute("unbound")) {
                                continue;
                            }*/
                            if(helper.getAttribute("is") != "for"){
                                continue;
                            }
                            let finalIndex = index + deletedItems.length;
                            let itemValue = helper.getAttribute("item");
                            for(let i=index, j=0;i<finalIndex;i++,j++) {
                                _LC.removeSelectedBindingDeep({[itemValue] : helper._items[i].itemProperty}, {[itemValue] : deletedItems[j]});
                            }
                            let contextSwitchArray = [];
                            _LC.adCx(helper, contextSwitchArray);
                            helper._callee.updateForHelper(helper, options);
                            _LC.rmCx(helper, contextSwitchArray);
                        }
                    }
                    for(let key in item) {
                        let parsedKey = parseInt(key);
                        var cond = options.secondIndex == options.thirdIndex ? key >= options.firstIndex && key < (options.firstIndex+options.secondIndex) : parsedKey >= options.firstIndex;
                        if(!isNaN(parsedKey) && cond) {
                            let diff = parsedKey - options.firstIndex;
                            let oldObject;
                            if(diff < options.thirdIndex) {
                                oldObject = deletedItems[diff];
                            } else {
                                oldObject = array[options.firstIndex - options.thirdIndex  + options.secondIndex + diff];
                            }
                            this.removeSelectedBindingDeep(item[key], oldObject);
                            if(item[key]._forHelpers) {
                                let bindfor = item[key]._forHelpers.toArrayLyte();
                                for(var j=0;j<bindfor.length;j++){
                                    let item1 = bindfor[j];
                                    if(item1._propBindingObject) {
                                        this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);
//                                          value._bindings.add(item._propBindingObject);
//                                          this.establishBindings(item._propBindingObject, value);
                                    }
                                }
                            }
                            if(array[parsedKey] && typeof array[parsedKey] === "object") {
                                makeSet(array[parsedKey], "_bindings");
                            this.establishBindings({"dummy" : item[key]},{"dummy" : array[parsedKey]});
                            }
                            this.affectChanges(item[key],undefined,oldObject,undefined,array[parsedKey]);
                        }
                    }
                }
            }
            obsObj = {type:'array',index:index,insertedItems:args, removedItems:deletedItems};
            _LC.bindWatchObj(watch, array, args, deletedItems, index);
            _LC.callArrayObservers(array,obsObj,callLengthObserver ,initialArrLength);
            return deletedItems;
        }
        break;
        case "push" : 
            {
            let toPush = argumentsArr[2];
            if(fromOverride && argumentsArr.length > 3){
                toPush = argumentsArr.$splice(2,argumentsArr.length);
            }
            else if(!(Array.isArray(toPush))) {
                toPush = [toPush];
            }
            else if(fromOverride){
                toPush = [toPush];
            }
            _LC.aF(array, 'insertAt', array.length, toPush);
            }
            break;
        case "pop" : 
               return _LC.aF(array, 'remove', array.length -1)[0];
            break;
        case "shift" : 
        case "shiftObject" :
              return _LC.aF(array, 'remove', 0)[0];
              break;
        case "removeAt" : 
        case "remove" : 
            {
            let index = parseInt(argumentsArr[2]);
            if(index > array.length) {
                _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.warn("index provided for removeAt is greater than array length");
                return [];
            }
            let length = argumentsArr[3] ? parseInt(argumentsArr[3]) : 1;
            let options = {"firstIndex" : index, "secondIndex" : length, "type" : "remove"};
            let deletedItems = array.$splice(index,length);
            if(array._bindings) {
                let objbind = array._bindings.toArrayLyte();
                for(let i=0;i<objbind.length;i++){
                    let item = objbind[i];
                    if(item._forHelpers) {
                        let helperbind = item._forHelpers.toArrayLyte();
                        for(let j=0;j<helperbind.length;j++){
                            let helper = helperbind[j];
                            /*if(helper.hasAttribute("unbound")) {
                                continue;
                            }*/
                            if(helper.getAttribute("is") != "for"){
                                continue;
                            }
                            let finalIndex = index + deletedItems.length;
                            let itemValue = helper.getAttribute("item");
                            for(let i=index, j=0;i<finalIndex;i++,j++) {
                                _LC.removeSelectedBindingDeep({[itemValue] : helper._items[i].itemProperty}, {[itemValue] : deletedItems[j]});
                            }
                            let contextSwitchArray = [];
                            _LC.adCx(helper, contextSwitchArray);
                            helper._callee.updateForHelper(helper, options);
                            _LC.rmCx(helper, contextSwitchArray);
                        }
                       }
                        for(let key in item) {
                        let parsedKey = parseInt(key);
                        if(!isNaN(parsedKey) && parsedKey >= options.firstIndex) {
                            let diff = parsedKey - options.firstIndex;
                            let oldObject;
                            if(diff < options.secondIndex) {
                                oldObject = deletedItems[diff];
                            } else {
                                oldObject = array[options.firstIndex - options.secondIndex + diff];
                            }
                            this.removeSelectedBindingDeep(item[key], oldObject);
                            if(item[key]._forHelpers) {
                                let bindfor = item[key]._forHelpers.toArrayLyte();
                                for(var j=0;j<bindfor.length;j++){
                                    let item1 = bindfor[j];
                                    if(item1._propBindingObject) {
                                        this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);
//                                          value._bindings.add(item._propBindingObject);
//                                          this.establishBindings(item._propBindingObject, value);
                                    }
                                }
                            }
                            if(array[parsedKey] && typeof array[parsedKey] === "object") {
                                makeSet(array[parsedKey], "_bindings");
                            this.establishBindings({"dummy" : item[key]},{"dummy" : array[parsedKey]});
                            }
                            this.affectChanges(item[key],undefined,oldObject,undefined,array[parsedKey]);
                        }
                    }
                }
            }
            obsObj = {type:"array",removedItems:deletedItems,index:index};
            _LC.bindWatchObj(watch, array, undefined, deletedItems, index);
            _LC.callArrayObservers(array,obsObj,callLengthObserver ,initialArrLength); 
            return deletedItems;
            }
            break;
        case "removeObject" : 
                commArgs = [commArgs];
        case "removeObjects" :
            if(!(Array.isArray(commArgs))) {
                commArgs = [commArgs];
            }
            else if(fromOverride){
                commArgs = [commArgs];
            }
            if(commArgs == array){
                commArgs = Array.from(commArgs);// both array are same instance so cloning
            }
            for(var i=0;i<commArgs.length;i++) {
                let inde = array.indexOf(commArgs[i]);
                if(inde !== -1) {
                   _LC.aF(array, 'removeAt', inde);                         
                }
            }
            //Lyte.arrayUtils(array, 'removeObject', actObj);
            //Lyte.arrayUtils(array, 'removeObjects', []);
        break;
        case "unshift" : 
        case "unshiftObject" : 
        case "unshiftObjects" : 
            //_LC.aF.apply(_LC, [array, 'insertAt', 0].$concat(Array.prototype.slice.call(argumentsArr, 2)));
            {
            let toPush = argumentsArr[2];
            if(!(Array.isArray(toPush))) {
                toPush = [toPush];
            }
            else if(fromOverride){
                toPush = [toPush];
            }
            _LC.aF(array, 'insertAt', 0, toPush);
            }
            break;
        case "insertAt" : 
            {
            let index = parseInt(argumentsArr[2]);
            //let args = Array.prototype.slice.call(argumentsArr, 3);
            let args = argumentsArr[3];
            let len = args.length;
            if(!(Array.isArray(args))) {
                args = [args];
            }
            else if(fromOverride){
                args = [args];
            }
            for(let i=index;i>array.length;i--) {
                args.$unshift(undefined);
                index--;
            }
            let options = {"firstIndex" : index, "secondIndex" : args.length, "type" : "insert"};
            array.$splice.apply(array, [index, 0].$concat(args));
            if(array._bindings) {
                let arrbind = array._bindings.toArrayLyte();
                for(let i=0;i<arrbind.length;i++){
                    let item = arrbind[i];
                    if(item._forHelpers) {
                        let forbind = item._forHelpers.toArrayLyte();
                        for(let j=0;j<forbind.length;j++){
                            /*if(forbind[j].hasAttribute("unbound")) {
                                continue;
                            }*/
                            let helper = forbind[j];
                            if(helper.getAttribute("is") != "for"){
                                continue;
                            }
                            let contextSwitchArray = [];
                            _LC.adCx(helper, contextSwitchArray);
                            helper._callee.updateForHelper(helper, options);
                            _LC.rmCx(helper, contextSwitchArray);
                        }
                    }
                    for(let key in item) {
                        let parsedKey = parseInt(key);
                        if(!isNaN(parsedKey) && parsedKey >= options.firstIndex) {
                            this.removeSelectedBindingDeep(item[key], array[parsedKey+options.secondIndex]);
                            if(item[key]._forHelpers) {
                                let bindfor = item[key]._forHelpers.toArrayLyte();
                                for(var j=0;j<bindfor.length;j++){
                                    let item1 = bindfor[j];
                                    if(item1._propBindingObject) {
                                        this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);
//                                          value._bindings.add(item._propBindingObject);
//                                          this.establishBindings(item._propBindingObject, value);
                                    }
                                }
                            }
                            if(array[parsedKey] && typeof array[parsedKey] === "object") {
                                makeSet(array[parsedKey], "_bindings");
                            this.establishBindings({"dummy" : item[key]},{"dummy" : array[parsedKey]});    
                            }
                            this.affectChanges(item[key],undefined,array[parsedKey + options.secondIndex],undefined,array[parsedKey]);
                        }
                    }
                }
            }
            let position = parseInt(argumentsArr[2]);
            obsObj = {type:"array",insertedItems:(!(Array.isArray(argumentsArr[3]))) ? [argumentsArr[3]]: argumentsArr[0].slice(position,position+len),index:position};
            _LC.bindWatchObj(watch, array, args, undefined, position);
            _LC.callArrayObservers(array,obsObj,callLengthObserver ,initialArrLength);                
            }
            break;
        case "concat" : 
            //_LC.aF.apply(_LC, [array, 'insertAt',array.length].$concat(argumentsArr[2]));
            _LC.aF(array, 'insertAt', array.length, argumentsArr[2]);
            break;
        case "sort" : 
            let optionsArray = [];
            commands.forEach(function(command) {
                switch(command.type) {
                    case "Remove" : {
                        let removedItems = array.splice(command.toIndex, 1);
                        optionsArray.push({"firstIndex" : command.toIndex, "secondIndex" : 1, "type" : "remove", "removedItem" : removedItems[0]});
                    }
                    break;
                    case "Move" : {
                        let removedItems = array.splice(command.fromIndex, 1);
                        array.splice(command.toIndex, 0, command.element);
                        optionsArray.push({"firstIndex" : command.fromIndex, "secondIndex" : 1, "type" : "remove", "removedItem" : removedItems[0]});
                        // optionsArray.push({"firstIndex" : command.toIndex, "secondIndex" : 1, "thirdIndex" : 0, "type" : "splice"});
                        optionsArray.push({"firstIndex" : command.toIndex, "secondIndex" : 1, "type" : "insert"});
                    }
                    break;
                    case "Add" : {
                        array.splice(command.toIndex, 0, command.element);
                        // optionsArray.push({"firstIndex" : command.toIndex, "secondIndex" : 1, "thirdIndex" : 0, "type" : "splice"});
                        optionsArray.push({"firstIndex" : command.toIndex, "secondIndex" : 1, "type" : "insert"});
                    }
                    break;
                }
            });
            if(array._bindings) {
                let arrbind = array._bindings.toArrayLyte();
                for(let i=0;i<arrbind.length;i++){
                    let item = arrbind[i];
                    if(item._forHelpers) {
                        let forbind = item._forHelpers.toArrayLyte();
                        for(let j=0;j<forbind.length;j++){
                            /*if(forbind[j].hasAttribute("unbound")) {
                                continue;
                            }*/
                            let helper = forbind[j];
                            if(helper.getAttribute("is") != "for"){
                                continue;
                            }
                            let contextSwitchArray = [];
                            _LC.adCx(helper, contextSwitchArray);
                            for(let j=0;j<optionsArray.length;j++) {
                                let optionItem = optionsArray[j];
                                // Removal of bindings
                                let itemValue = helper.getAttribute("item");
                                if(optionItem.type == "remove") {
                                    this.removeSelectedBindingDeep({[itemValue] : helper._items[optionItem.firstIndex].itemProperty}, {[itemValue] : optionItem.removedItem});
                                }
                                helper._callee.updateForHelper(helper, optionItem);
                            }
                            _LC.rmCx(helper, contextSwitchArray);
                        }
                    }
//                         for(let key in item) {
//                             let parsedKey = parseInt(key);
//                             if(!isNaN(parsedKey) && parsedKey >= options.firstIndex) {
//                                 this.removeSelectedBindingDeep(item[key], array[parsedKey+options.secondIndex]);
//                                 if(item[key]._forHelpers) {
//                                     let bindfor = item[key]._forHelpers.toArrayLyte();
//                                     for(var j=0;j<bindfor.length;j++){
//                                         let item1 = bindfor[j];
//                                         if(item1._propBindingObject) {
//                                             this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);
// //                                          value._bindings.add(item._propBindingObject);
// //                                          this.establishBindings(item._propBindingObject, value);
//                                         }
//                                     }
//                                 }
//                                 if(array[parsedKey] && typeof array[parsedKey] === "object") {
//                                 	makeSet(array[parsedKey], "_bindings");
//                                 this.establishBindings({"dummy" : item[key]},{"dummy" : array[parsedKey]});    
//                                 }
//                                 this.affectChanges(item[key],undefined,array[parsedKey + options.secondIndex],undefined,array[parsedKey]);
//                             }
//                         }
                }
            }
            break;
        default: 
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ApiError.error("LC002", functionName);
            //@Slicer.developmentEnd
            return;
        }
        return array;
    },
    "callDeepObservers" : function (data, args, property ,callLengthObserver){
        var self = this;
        var keys = Array.from(data._scp.keys());
        keys.forEach(function(id){
            var _scp = data._scp.get(id), 
            scp = _scp.paths,
            pathArr = Object.keys(scp), 
            aPath;
            if(pathArr.length == 1){
                aPath = pathArr[0];
            }
            else if(pathArr.length > 1){
                aPath = pathArr;
            }
            var recObj = _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.nestScp[id], 
            attr, 
            rec, 
            isRec = false;
            if(recObj.model){
                var mMap = recObj.model;
                var db = recObj.db;
                var mKeys = Array.from(recObj.model.keys());
                for(var i=0; i<mKeys.length; i++){
                    var mName = mKeys[i];
                    var pkMap = mMap.get(mName);
                    if(pkMap){
                        var pkArr = Array.from(pkMap.keys());
                        var pkLen = pkArr.length;
                        for(var j=0; j<pkLen; j++){
                            var mPk = pkArr[j];
                            var attrMap = pkMap.get(mPk);
                            var attrArr = Array.from(attrMap.keys());
                            var attrLen = attrArr.length;
                            for(k=0; k<attrLen; k++){
                                var mAttr = attrArr[k];
                                if(db.getSchema){
                                    var mRec = db.cache.getEntity({schema:db.getSchema(mName), pK:mPk});
                                }
                                else{
                                    var mRec = db.cache.getEntity({model:db.getModel(mName), pK:mPk});
                                }
                                self.deepObsBind(mRec, true, mAttr, args, pathArr, aPath, data, property, callLengthObserver)                                    
                            }
                        }
                    }
                }
            } 
            else{
                rec = recObj.data;
                self.deepObsBind(rec, isRec, attr, args, pathArr, aPath, data, property, callLengthObserver)
            }
        });
    },
    "deepObsBind":function(rec, isRec, attr, args, pathArr, aPath, data, property, callLengthObserver){
        var type = args.type
        var watchPath , propPath;
        if(rec._bindings){
            var newArgs = Object.assign({},args);
            var objbind = rec._bindings.toArrayLyte();
            for (var _i65 = 0; _i65 < objbind.length; _i65++) {
                propPath = aPath;
                var binding = objbind[_i65], obj = undefined;
                watchPath = objbind[_i65]._path
                if(isRec){
                    if(binding.hasOwnProperty(attr) && binding[attr].hasOwnProperty("*")){
                        obj = binding[attr]["*"];
                        watchPath = binding[attr]._path;
                    } 
                }
                else if(binding.hasOwnProperty("*")){
                    obj = binding["*"];
                }
                if(obj){
                    var obsbind = obj._observers ? obj._observers.toArrayLyte() : [], path;
                    if(property){
                        if(pathArr.length > 1){
                            var len = pathArr.length, nPathArr = [];
                            for(var i=0;i<len;i++){
                                nPathArr.push(pathArr[i] ? pathArr[i]+"."+property : property);
                            }
                            propPath = nPathArr;
                        }
                        else if(pathArr.length == 1){
                            propPath = aPath ? aPath.concat("." + property) : property;
                        }
                    }
                    for (var j = 0; j < obsbind.length; j++) {
                        var observer = obsbind[j];
                        newArgs.path = propPath;
                        newArgs.type = "deepChange";
                        newArgs.data = rec;
                        var argPath = obj._path.split('.');
                        argPath.$pop();
                        newArgs.item = argPath.join('.'); 
                        var exactPath = newArgs.index!=undefined?(propPath!=""?propPath+".":propPath)+newArgs.index:propPath
                        if(observer.callee && observer.callee.component){
                            //  observer.observer.value.call(observer.callee.component, newArgs);
                            var calldeep = true;
                            var _data = observer.callee.component.__data[newArgs.item];
                            var _watch = _data ? _data.watch : undefined;
                            if(_data && typeof _watch != "boolean"){
                                var watchArr = obsbind[j].observer.Jpath[watchPath];
                                calldeep = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.checkWatchPath)(exactPath , watchArr);
                            }
                            if(calldeep){
                                observer.observer.value.call(observer.callee.component, newArgs);
                            }
                        }
                        else{
                            var scope = data._setterScope ? data._setterScope : window;
                            if(Array.isArray(scope)){
                                var sLen = scope.length;
                                for(var k=0;k<sLen;k++){
                                    var itm = scope[k];
                                    var calldeep = true;
                                    if(newArgs.data && newArgs.hasOwnProperty("item")){
                                        var watchArr = newArgs.data.$.schema._fldGrps.watch[newArgs.item].watch
                                        if(Array.isArray(watchArr)){
                                            watchArr = obsbind[j].observer.Jpath[watchPath];
                                            calldeep = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.checkWatchPath)(exactPath , watchArr);
                                        }
                                    }
                                    if(calldeep){
                                        observer.observer.value.call(itm, newArgs);
                                    }
                                }
                            }
                            else{
                                var calldeep = true;
                                if(newArgs.data && newArgs.hasOwnProperty("item")){
                                    var watchArr = newArgs.data.$.schema._fldGrps.watch[newArgs.item].watch
                                    if(Array.isArray(watchArr)){
                                        watchArr = obsbind[j].observer.Jpath[watchPath];
                                        calldeep = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.checkWatchPath)(exactPath , watchArr);
                                    }
                                }
                                if(calldeep){
                                    observer.observer.value.call(scope, newArgs);
                                }
                            }
                        }
                    }
                }
                if (!callLengthObserver && type == "array" && binding.length) {
                    this.affectChanges(binding.length,undefined,initialArrLength,undefined,array.length,callLengthObserver);
                }
            }
        }
    },
    "callArrayObservers" : function(array, args ,callLengthObserver ,initialArrLength) {
        if(array._scp && array._scp.size){
            this.callDeepObservers(array, Object.assign({},args) ,undefined, true);          
        }
        if(array._bindings) {
            let objbind = array._bindings.toArrayLyte();
            for(let i=0;i<objbind.length;i++){
                let binding = objbind[i];
                let path = objbind[i]._path;
                if(binding._observers) {
                    let obsbind = binding._observers.toArrayLyte();
                    for(let j=0;j<obsbind.length;j++){
                        let observer = obsbind[j];
                        if(observer.isArrayObserver) {
                            if(args){
                                args.item = path;
                            }
                            if(observer.callee && observer.callee.component){
                                observer.observer.value.call( observer.callee.component, args);
                            }
                            else{
                                var scope = array._setterScope ? array._setterScope : window;
                                if(Array.isArray(scope)){
                                    var sLen = scope.length;
                                    for(var k=0;k<sLen;k++){
                                        var itm = scope[k];
                                        observer.observer.value.call( itm, args);                                                        
                                    }
                                }
                                else{
                                    observer.observer.value.call(scope, args);
                                }
                            }
                        }
                    }
                }
                if(binding.length) {
                    this.affectChanges(binding.length,undefined,initialArrLength,undefined,array.length,undefined,callLengthObserver);
                }
            }
        }
    },
    "callObjectObservers" : function(obj, args) {
        if(obj._bindings) {
            let objbind = obj._bindings.toArrayLyte();
            if(args.oldValue !== args.newValue){
                for(let i=0;i<objbind.length;i++){
                    let binding = objbind[i];
                    let path = objbind[i]._path;
                    if(binding["{}"]){
                        this.affectChanges(binding["{}"]);
                    }
                    if(binding._objectObservers && binding._observers) {
                        let obsbind = binding._observers.toArrayLyte();
                        for(let j=0;j<obsbind.length;j++){
                            let observer = obsbind[j];
                            if(observer.isObjectObserver) {
                                if(args){
                                    if(args.item){
                                        args.item = path + "." + args.item;
                                    }else{
                                        args.item = path;
                                    }
                                }
                                observer.observer.value.call( observer.callee && observer.callee.component ? observer.callee.component : obj._setterScope? obj._setterScope : window , args);
                            }
                        }
                    }
                }
            }
        }
    },
    "bindWatchObj" : function(watch, data, insItems, remItems, pos){
        if(watch && watch.length){
            watch.forEach(function(wObj){
                if(wObj.isRec){
                    var db = wObj.rec.$.db;
                    if(db){
                        db.__dVC(wObj.rec, wObj.attr, data, wObj);
                    }
                }
                if(remItems){
                    remItems.forEach(function(itm){
                        (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.removeNestScp)(itm, wObj.id, undefined, undefined, undefined, undefined, wObj.reInit ? wObj.data : undefined);
                    });
                }
                if(insItems){
                    insItems.forEach(function(itm,idx){
                        if(itm && ( Array.isArray(itm) || typeof itm == "object" )){
                            var pth = wObj.path.split(',');
                            pth.$push(pos+idx);
                            (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.bindObj)(itm, undefined, wObj.id,  pth && pth.length ? pth : [], undefined, undefined, true);
                        }
                    });
                }
                if(pos !== undefined){
                    var nestObj = _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.nestScp[wObj.id];
                    if(nestObj.cyclic){
                        (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.removeNestScp)(nestObj._data, wObj.id);
                        (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.bindObj)(nestObj._data, undefined, wObj.id, [], undefined, undefined, true);
                    }
                    else{
                        var insLen = insItems ? insItems.length : 0, newInd = pos+insLen;
                        var arr = data.slice(newInd);
                        arr.forEach(function(itm){
                            (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.removeNestScp)(itm, wObj.id);
                        });
                        arr.forEach(function(itm,idx){
                            if(itm && ( Array.isArray(itm) || typeof itm == "object" )){
                                var pth = wObj.path.split(',');
                                pth.$push(newInd+idx);
                                (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.bindObj)(itm, undefined, wObj.id,  pth && pth.length ? pth : [], undefined, undefined, true);
                            }
                        });
                    }
                }
            });
        }
    },
    "establishUpdateBindings" : function(bindings, property, actualData) {
        let objbind = bindings.toArrayLyte();
        for(let i=0;i<objbind.length;i++){
            let item = objbind[i];
            if(item[property]) {
                makeSet(actualData, "_bindings");
                addBindings(actualData._bindings,item[property]);
                this.establishBindings(item[property], actualData);
            }

        }
    },
    "establishSelectedBinding" : function(property, actualData,node) {
        if(!property) {
            return;
        }
        let propName = property._path;
        let props = propName.split('.');
        let currentProp = node.getProperty(props[0]);
        let currentValue = actualData[props[0]];
        for(let i=0;i<props.length;i++) {
            if(!currentValue || typeof currentValue !== "object") {
                break;
            } 
            makeSet(currentValue, "_bindings");
                addBindings(currentValue._bindings,currentProp);
                currentProp = currentProp[props[i+1]];
                currentValue = currentValue[props[i+1]];
        }
    },
    "establishBindings": function(properties, actualData) {
        if(properties._helperNodes) {
            let path = properties._path;
            let arr = properties._helperNodes.toArrayLyte();
            for(let s=0;s<arr.length;s++) {
                let nodes = arr[s]._dynamicProperty ? arr[s]._dynamicProperty[path]: undefined;
                if(nodes) {
                    for(let j=0;j<nodes.length;j++) {
                        let node = nodes[j];
                        let helper = node.ownerElement;
                        if(helper && helper.tagName === "TEMPLATE" && helper.getAttribute("is") === "for") {
                            if(helper._items) {
                                let item = helper.getAttribute("item");
                                for(let i=0;i<helper._items.length;i++) {
                                    let data = actualData[i];
                                    let item = helper.getAttribute("item");
                                    if(data) {
                                        if(typeof helper._items[i] === "object") {
                                            this.establishBindings(helper._items[i].itemProperty, {[item] : data});
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        for(let i in properties) {
            let actData = actualData[i];
            if(!actData || typeof actData === "string" || typeof actData === "number" || typeof actData === "boolean") {
                if(!actualData._bindings) {
                    makeSet(actualData, "_bindings");
                }
                addBindings(actualData._bindings,properties);
            } else {
                if(!actData._bindings) {
                    makeSet(actData, "_bindings");
                }
                addBindings(actData._bindings,properties[i]);
                if(typeof properties[i] === "object") {
                    this.establishBindings(properties[i], actData);
                }
            }
        }
    },
    "removeSelectedBindingDeep" : function(binding, actualData, fromDisConnect) {
        var del = "delete";
        if(!actualData && !fromDisConnect) {
            return;
        }
        if(actualData && actualData._bindings) {
            deleteBindingCheckSize(actualData, "_bindings", binding);
        }
        for(let i in binding) {
            let actData;
            if(actualData){
                actData = actualData[i];
            }   
            if(actData && actData._bindings) {
                deleteBindingCheckSize(actData, "_bindings", binding[i]);
            }
            if(typeof binding[i] === "object") {
                this.removeSelectedBindingDeep(binding[i], actData ,fromDisConnect);
            }
        }
        if(fromDisConnect){
            let dynNodes = binding._dynamicNodes;
            let helperNodes = binding._helperNodes;
            if(dynNodes && dynNodes.length){
                binding._dynamicNodes.$splice(0,dynNodes.length);   
            }
            if(helperNodes && helperNodes.size){
                helperNodes.clear();
            }
        }
        if(binding && binding._forHelpers) {
            let objbind = binding._forHelpers.toArrayLyte();
            for(let i=0;i<objbind.length;i++){
                let fH = objbind[i];
                if(fH.getAttribute("is") === "for") {
                    let item = fH.getAttribute("item");
                    let items = fH._attributes.items;
                    let itemCases = fH._items;
                    for(let i=0;i<itemCases.length;i++) {
                        this.removeSelectedBindingDeep(itemCases[i].itemProperty, items[i], fromDisConnect);
                    }
                } else {
                    if(fH._propBindingObject) {
                        if(actualData && actualData._bindings) {
                            deleteBindingCheckSize(actualData, "_bindings", fH._propBindingObject);
                            this.removeSelectedBindingDeep(fH._propBindingObject, actualData, fromDisConnect);
                        }
                    }
                }
            }
        }
    },
    "removeAllBindings" : function(properties, data) {
        var del = "delete";
        for(let key in properties) {
            if(data[key] && data[key]._bindings) {
//                    data[key]._bindings[del](properties[key]);
//                    if(!data[key]._bindings.size) {
//                        delete data[key]._bindings;
//                    }
                deleteBindingCheckSize(data[key], "_bindings", properties[key]);
            }
            if(data[key] && typeof data[key] !== "string") {
                _LC.removeAllBindings(properties[key], data[key]);
            }
        }
    },
    "affectChanges" : function(item, contextAlreadySwitched,oldValue,setterScope,newValue,stack,callLengthObserver) {
        if(item._dynamicNodes) {
            for(let i=0;i<item._dynamicNodes.length;i++) {
                item._dynamicNodes[i]._callee.updateNode(item._dynamicNodes[i], item._path);
            }
        }
        let propPath = item._path;
        if(item._helperNodes) {
            let nodes = [],itemHelperNodes = item._helperNodes.toArrayLyte();
            for(let s=0;s<itemHelperNodes.length;s++){
                if(!item._helperNodes.has(itemHelperNodes[s])) {
                    continue;
                }
                if(itemHelperNodes[s].getAttribute("is") === "for" && itemHelperNodes[s]._items) {
                    let innerContextSwitchArray = [];
                    _LC.adCx(itemHelperNodes[s], innerContextSwitchArray);
                    let  indexValue = itemHelperNodes[s].getAttribute("index");
                    let itemValue = itemHelperNodes[s].getAttribute("item");
                    let callee = itemHelperNodes[s]._callee;
                    let initialItemValue = callee.component.data[itemValue];
                    let initialIndexValue = callee.component.data[indexValue];
                    let initialItemProp = callee._properties[itemValue];
                    let initialIndexProp = callee._properties[indexValue];
                    let items = itemHelperNodes[s]._attributes.items;
                    for(let i=0;i<itemHelperNodes[s]._items.length;i++) {
                        callee.component.data[itemValue] = items[i];
                        callee.component.data[indexValue] = i;
                        callee._properties[itemValue] = itemHelperNodes[s]._items[i].itemProperty;
                        if(itemHelperNodes[s]._items[i]._dynamicProperty[propPath]) {
                            nodes = itemHelperNodes[s]._items[i]._dynamicProperty[propPath];
                            for(let i=0;i<nodes.length;i++) {
                                nodes[i]._callee.updateNode(nodes[i], propPath);
                            }
                        }
                    }
                    callee.component.data[itemValue] = initialItemValue;
                    callee.component.data[indexValue] = initialIndexValue;
                    callee._properties[itemValue] = initialItemProp;
                    callee._properties[indexValue] = initialIndexProp;
                    _LC.rmCx(itemHelperNodes[s], innerContextSwitchArray);                                    
                } else if(itemHelperNodes[s].getAttribute("is") === "forIn" && itemHelperNodes[s]._items) {
                    let innerContextSwitchArray = [];
                    _LC.adCx(itemHelperNodes[s], innerContextSwitchArray);
                    let  indexValue = itemHelperNodes[s].getAttribute("key");
                    let itemValue = itemHelperNodes[s].getAttribute("value");
                    let callee = itemHelperNodes[s]._callee;
                    let initialItemValue = callee.component.data[itemValue];
                    let initialIndexValue = callee.component.data[indexValue];
                    let initialItemProp = callee._properties[itemValue];
                    let initialIndexProp = callee._properties[indexValue];
                    let object = itemHelperNodes[s]._attributes.object;
                    for(let key in itemHelperNodes[s]._items) {
                        callee.component.data[itemValue] = object[key];
                        callee.component.data[indexValue] = key;
                        callee._properties[itemValue] = itemHelperNodes[s]._items[key].itemProperty;
                        if(itemHelperNodes[s]._items[key]._dynamicProperty[propPath]) {
                            nodes = itemHelperNodes[s]._items[key]._dynamicProperty[propPath];
                            for(let i=0;i<nodes.length;i++) {
                                nodes[i]._callee.updateNode(nodes[i], propPath);
                            }
                        }
                    }
                    callee.component.data[itemValue] = initialItemValue;
                    callee.component.data[indexValue] = initialIndexValue;
                    callee._properties[itemValue] = initialItemProp;
                    callee._properties[indexValue] = initialIndexProp;
                    _LC.rmCx(itemHelperNodes[s], innerContextSwitchArray);    
                } else {
                    nodes = itemHelperNodes[s]._dynamicProperty[item._path] || [];
                    let contextSwitchArray = [];
                    if(nodes.length) {
                        _LC.adCx(itemHelperNodes[s], contextSwitchArray);
                        for(let i=0;i<nodes.length;i++) {
                            nodes[i]._callee.updateNode(nodes[i], item._path);
                        }
                        _LC.rmCx(itemHelperNodes[s], contextSwitchArray);    
                    }
                    
                }
            }
        }
        if(item._observers) {
            let objbind = item._observers.toArrayLyte();
            let cond = callLengthObserver == false ? false : oldValue != undefined || newValue != undefined;
            if(cond){
                for(let i=0;i<objbind.length;i++){
                    let observer = objbind[i];
                    let obsObj = {type:"change",oldValue:oldValue,newValue:newValue, item: item._path};
                    if(observer.callee && observer.callee.component){
                        if(stack && observer.isObjectObserver){
                            obsObj.observer = observer;
                            stack.$push(obsObj);
                        }else{
                            observer.observer.value.call(  observer.callee.component, obsObj);                      
                        }
                    }
                    else{
                        var scope = setterScope ? setterScope : window;
                        if(Array.isArray(scope)){
                            var sLen = scope.length;
                            for(var k=0;k<sLen;k++){
                                var itm = scope[k];
                                observer.observer.value.call( itm, obsObj);
                            }
                        }
                        else{
                            observer.observer.value.call( scope, obsObj);                      
                        }
                    }
                }
            }
        }
        if(Array.isArray(item)){
            for(var i=0;i<item.length;i++){
                for(let key in item[i]) {
                    this.affectChanges(item[i][key], true,oldValue?(oldValue[i]?oldValue[i][key]:oldValue[i]):oldValue,setterScope,newValue?(newValue[i]?newValue[i][key]:newValue[i]):newValue);
                }
            }
        }
        else{
            for(let key in item) {
                var oldV = oldValue ? oldValue[key] : oldValue, newV = newValue ? newValue[key] : newValue;
                if(key == "*" && item[key].hasOwnProperty("_observers")){
                    oldV = oldValue;
                    newV = newValue
                }
                this.affectChanges(item[key], true, oldV, setterScope, newV,stack);
            }
        }
    },
    "executeObserver": function(stack){
        stack.forEach(function(obj){
            obj.observer.observer.value.call( obj.observer.callee && obj.observer.callee.component ? obj.observer.callee.component : setterScope ? setterScope : window ,{type:obj.type,oldValue:obj.oldValue,newValue:obj.newValue, item: obj.item});   
        });
    },
    "skipArgProcessing" : function(cloneActObj,ev,target) {
        if(cloneActObj.skipArgProcessing) {
            let args = cloneActObj.args = cloneActObj.actArgs;
            args.$shift();
            var eventIndex = args.indexOf("__lyteEvent__");
            var nodeIndex = args.indexOf("__lyteNode__");
            if(eventIndex !== -1) {
                args[eventIndex] = ev;
            } 
            if(nodeIndex !== -1) {
                args[nodeIndex] = target;
            }
        } else {
            cloneActObj.args.$shift();
        }
    },
    // getDV added
    // "getDV" : function(value){    
    //     var result = [],ref = result,arr = [],data = "",strStack = [],arrayStack = [],refStack = [],strLast,str;
    //     for(var i=0;i<value.length;i++){
    //         if(value[i] === "."){
    //             if(data.length){
    //                 ref.$push(data);
    //             }
    //             data = "";
    //             continue;
    //         }
    //         else if(value[i] === "["){
    //             arrayStack.$push(i)
    //             if(data.length){
    //                 ref.$push(data);
    //             }
    //             while(value[i+1] === "\s"){
    //                 i++;
    //             }
    //             if(value[i+1] === "\"" || value[i+1] === "'"){
    //                 strStack.$push(value[i+1]);
    //                 strLast = value[i+1];
    //                 i++;
    //             }
    //             else if(arr.length){
    //                 ref.$push([]);
    //                 refStack.$push(ref);
    //                 ref = ref[ref.length-1];
    //             }else{
    //                 arr.$push([]);
    //                 refStack.$push(ref);
    //                 ref = arr[arr.length-1];
    //             }
    //             data = "";
    //             continue;
    //         }
    //         else if((value[i] === "\"" || value[i] === "'" ) && value[i++] === strLast){
    //             while(value[i] === "\s" && value[i] != "]"){
    //                 i++;
    //             }
    //             strStack.$pop();
    //             str = true;
    //         }
    //         if(value[i] === "]"){
    //             arrayStack.$pop();
    //             if(data.length){
    //                 if(str === true){
    //                     ref.$push(data);    
    //                 }
    //                 else if(!isNaN(parseInt(data))){
    //                     if(refStack.length){
    //                         ref = refStack.$pop();
    //                         if(arr.length && Array.isArray(ref[ref.length-1]) && !ref[ref.length-1].length){
    //                             ref.$pop();
    //                         }
    //                         ref.$push(data);
    //                         if(!arrayStack.length && arr.length){
    //                             arr.$shift();
    //                         }
    //                     }
    //                 }
    //                 else{
    //                     ref.$push(data);
    //                 }
    //             }
    //             if(!arrayStack.length && arr.length){
    //                 result.$push(arr.$shift());
    //                 ref = result;
    //             }
    //             else if(refStack.length && !arr.length){ 
    //                 ref = refStack.$pop();
    //             }
    //             data = "";
    //             str = "";
    //             continue;
    //         }
    //         data = data.concat(value[i]);
    //     }
    //     if(data.length){
    //         result.$push(data);
    //     }
    //     if(strStack.length || arrayStack.length){
    //         console.log("check the syntax",strStack,arrayStack);
    //     }
    //     return result;
    // },
    "ccDelay" : [],
    "callCC" : function() {
        this.ccDelay.forEach(function(item) {
            if(item.component) {
                item.actualConnectedCallback();
            }
        });
        this.ccDelay = [];
    },
    "getDD":function(context,dataArr){
        var self = context;
        dataArr.forEach(function(item,index){
            if(Array.isArray(item)){
                if(context == undefined){
                    return undefined;
                }
                var inner = _LC.getDD(self,item);
                if(inner == undefined){
                    return undefined;
                }
                context = context[inner];
            }else{
                if(context == undefined){
                    return undefined;
                }
                context = context[item];
            }
        });
        return context;
    },

    "processStatic" : function(temp) {
        let arr = temp.innerHTML.split("__**");
        let newArr = [];
        for(var i=0;i<arr.length;i++) {
            if(arr[i].startsWith("--Lyte")) {
                newArr.$push(parseInt(arr[i].substring(6)));
            } else {
                newArr.$push(undefined);
            }
        }
        arr.cc = newArr;
        return arr;
    },
    "findLastNodeL" : function(lastNode1,count,node){
        var totalNodeIndex = 0;
        if(count != undefined){
            totalNodeIndex = count; 
        }
        var helperNode;
        switch(node.getAttribute("is")) {
            case "for" : 
                if(node._helpers[totalNodeIndex]){
                    helperNode = node._helpers[totalNodeIndex][0];   
                }
                if(!lastNode1) {
                    if(node._forContent[0]){
                        lastNode1 = node._forContent[0][0];
                    }
                }
                break;
            case "forIn" : 
                if(node._helpers[node._keysArray[0]]){
                    helperNode = node._helpers[node._keysArray[0]][0];
                }
                if(!lastNode1) {
                    if(node._forContent[node._keysArray[0]]){
                        lastNode1 = node._forContent[node._keysArray[0]][0];
                    }
                }                   
                break;
            case "if" : 
            case "switch" : 
                helperNode = node._helpers[totalNodeIndex];
                if(!lastNode1) {
                    lastNode1 = node._caseContent[0];
                }
            break;
            case "component" : 
                lastNode1 = lastNode1._renderedComponent[lastNode1._currentComponent] || lastNode1;
                return lastNode1;
        }
        if(!lastNode1){
            lastNode1 = node._placeHolder;
        }
        if(helperNode && (lastNode1 == helperNode._placeHolder)) {
            lastNode1 =  this.findLastNodeL(undefined, undefined, helperNode);
        }
        return lastNode1;
    },
    "processAction" : function(node) {
        Array.from(node.querySelectorAll('[lyteaction]')).forEach(function(item) { 
            let locIndex = item.attributes.lyteaction.value;
            item._boundEvents = _LC.fRP[locIndex];
            delete _LC.fRP[locIndex];
            // _LC.$pushFrc(locIndex);
            // item._boundEvents = JSON.parse(item.attributes.lyteaction.value);
            var _cx = item._boundEvents._cx;
            let boundEvents = item._boundEvents;
            delete boundEvents._cx;
            let componentName = boundEvents.componentName;
            delete boundEvents.componentName;
            for(var key in item._boundEvents) {
                if(key.indexOf("-") !== -1) {
                    item._actions = item._actions || {};
                    item._actions[key] = new CustomEvent(key);
                    item._actions[key].processAction = item._boundEvents[key];
                    item._boundEvents[key].actArgs.$shift();
                    let nodeIndex = item._boundEvents[key].actArgs.indexOf("__lyteNode__");
                    if(nodeIndex !== -1) {
                        item._boundEvents[key].actArgs[nodeIndex] = item;
                    }
                    item._boundEvents[key].args = item._boundEvents[key].actArgs;
                    delete item._boundEvents[key];
                } else {
                    let actArgs = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(item._boundEvents[key].args);
                    let actName = actArgs.$splice(0,1)[0];
                    actName = actName.startsWith("'")? actName.replace(/'/g,''):  actName;
                    let actString = getArgString(actName, actArgs);
                    item.setAttribute(key.startsWith("on") ? key.substr(2) : key ,componentName+" => "+ actString);
                    if(!item._boundEvents[key].globalEvent) {
                        item.addEventListener(key,globalEventHandler);
                    }
                }
            }
            item._boundEvents._cx = _cx;
            item.removeAttribute("lyteaction");
            //item._boundEvents = item.
        });
    },
    "getCtxVal" : function(context,val){
        if(context != undefined){
            return context[val];
        }else{
            return undefined;
        }
    },
    "get" : function(context, path, ac,cache) {
        if(!ac) {
            ac = [];
        }
        if(cache && cache.hasOwnProperty(path)){// cache.cacheData[path]
            var nodeValue = cache[path]._data; /* put as local variable due to error. plz cross check - christo */
            if(cache[path]._dyn){
                cache[path]._dyn.forEach(function(item){
                    ac.$push(item);
                });
            }
            return nodeValue;
        }
        else{
        try{
            if(path.search(/^\$\./g)!=-1){
                return (0,_slyte_core_src_JsonPath_js__WEBPACK_IMPORTED_MODULE_8__.Jwalk)(context,path);
            }
            else if(path == "$data"){
                return context;
            }
            let arr = path.match(/([^[\]]+|\[\])/g);
            let initialContext = context;
            ac.$push(arr[0]);
            let locArr = arr[0].split('.'); 
            for(let k=0;k<locArr.length;k++) {
                context = _LC.getCtxVal(context,locArr[k])
            }
            for(let i=1;i<arr.length;i++) {
                let locVal = arr[i];
                //this is context switching
                if(locVal.startsWith(".")) {
                    //direct context switching
                    let locArr = locVal.substring(1).split('.');
                    for(let k=0;k<locArr.length;k++) {
                        context = _LC.getCtxVal(context,locArr[k])
                    }
                    // ac[ac.length -1] = ac[ac.length - 1] + locVal;
                    ac[0] = ac[0] + locVal;
                } else if(locVal.startsWith("'") || locVal.startsWith('"') || !isNaN(locVal)) {
                    if(!isNaN(locVal)) {
                        // ac[ac.length-1] = ac[0] + "." + locVal;
                        ac[0] = ac[0] + "." + locVal;
                        context = _LC.getCtxVal(context,locVal)
                    } else {
                        // ac[ac.length-1] = ac[0] + "." + locVal.substring(1, locVal.length -1);
                        ac[0] = ac[0] + "." + locVal.substring(1, locVal.length -1);
                        context = _LC.getCtxVal(context,locVal.substring(1, locVal.length -1))
                    } 
                } else {
                    let length = ac.length;
                    let val = _LC.get(initialContext, locVal, ac);
                    ac[0] = ac[0] + "." + val;
                    context = _LC.getCtxVal(context,val)
                }
                }
                if(cache){
                    cache[path] = {};
                    cache[path]._data = context;  
                    cache[path]._dyn = ac;
                }
            return context;
        } catch(e) {
            return undefined;
        }
        }
    },
    "getNew" : function(context, path) {
        try{
            let arr = path.match(/([^[\]]+|\[\])/g);
            let initialContext = context;
            let locArr = arr[0].split('.'); 
            if(arr.length < 2) {
                if(locArr.length <2) {
                    return {"context": initialContext, "lastKey" : locArr[0]};
                } else {
                    for(var k=0;k<locArr.length-1;k++) {
                        context = context[locArr[k]];
                    }
                    return {"context" : context, "lastKey" : locArr[k]}
                }
            }
            for(let k=0;k<locArr.length;k++) {
                context = context[locArr[k]];
            }
            for(var i=1;i<arr.length - 1;i++) {
                let locVal = arr[i];
                //this is context switching
                if(locVal.startsWith(".")) {
                    //direct context switching
                    let locArr = locVal.substring(1).split('.');
                    for(let k=0;k<locArr.length;k++) {
                        context = context[locArr[k]];
                    }
                } else if(locVal.startsWith("'") || locVal.startsWith('"') || !isNaN(locVal)) {
                    context = context[locVal.substring(1, locVal.length -1)];
                } else {
                    let val = this.get(initialContext, locVal);
                    context = context[val];
                }
                }
            let lastKey = arr[i];
            if(lastKey.startsWith(".")) {
                //direct context switching
                let locArr = lastKey.substring(1).split('.');
                let k=0
                for(;k<locArr.length - 1;k++) {
                    context = context[locArr[k]];
                }
                lastKey = locArr[k];
            } else if(lastKey.startsWith("'") || lastKey.startsWith('"') || !isNaN(lastKey)) {
                lastKey = lastKey.substring(1, lastKey.length -1);
            } else {
                lastKey = this.get(initialContext, lastKey);
            }
            return {"context" : context, "lastKey" : lastKey };
        } catch(e) {
            return undefined;
        }
    },
    "componentGetData" : function(key){
        if(key) {
            return this.get(key);
        } else {
            return this.data;
        }
    },
    "componentSetData" : function(arg0, arg1 ,options) {
        var arr = [];
        if(typeof arg0 === "string") {
            options = options || {}
            var ret = this.set(arg0, arg1 ,Object.assign(options,{skipTypeError:true}));
            if(ret && ret.code){
                arr.push(arg0);
            }
        } else if(typeof arg0 === "object") {
            var ret, arr=[];
            arg1 = arg1 || {};
            for(let key in arg0) {
                ret = this.set(key, arg0[key],Object.assign(arg1,{skipTypeError:true}));
                if(ret && ret.code){
                    arr.push(key);
                }
            }
        }
        if(arr.length){
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error("LC006", this.$node.localName, arr.toString());
            //@Slicer.developmentEnd
            return {code:"LC006", message:_utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.getErrorMessage("LC006", this.$node.localName, arr.toString())};
        }
        return true;
    },
    "componentGetMethods" : function(key) {
        if(key) {
            return this._methods[key];
        } else {
            return this._methods;
        }
    }, 
    "componentHasAction" : function(key) {
        if(key && this.$node._actions[key]) {
            return true;
        } else {
            return false;
        }
    }, 
    "componentGetActions" : function(key) {
        if(key) {
            return this.constructor._actions[key];
        } else {
            return this.constructor._actions;
        }
    }, 
    "componentGetObservers" : function() {
        return this.constructor._observers;
    },
    "componentsetActions" : function(arg0,arg1) {
        let actions = this.$node.constructor._actions;
        if(typeof arg0 === "string") {
            actions[arg0] = arg1;
        } else if(typeof arg0 === "object") {
            for(let key in arg0) {
                actions[key] = arg0[key];
            }
        }
    },
    "componentSetMethods" : function(arg0, arg1) {
        if(typeof arg0 === "string") {
            this._methods[arg0] = arg1;
        } else if(typeof arg0 === "object") {
            for(let key in arg0) {
                this._methods[key] = arg0[key];
            }
        }
    },
    "String" : {
        "cache_c":{},
        "cache_d":{},
        "upperCaseFirstLetter" : function(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        },
        "lowerCaseFirstLetter" : function(string) {
            return string.charAt(0).toLowerCase() + string.slice(1);
        }, 
        "toCamelCase" : function(string) {
            if(!this.cache_c[string]){
                this.cache_c[string] = string.replace(/(-\w)/g, function(m){return m[1].toUpperCase();});
            }
            return this.cache_c[string];
        }, 
        "dasherize" : function(string) {
            if(!this.cache_d[string]){
                this.cache_d[string] = string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
            }
            return this.cache_d[string];
        }
    },
    "appendChild" : function(outlet, component) {
        _LC.ignoreDisconnect = _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.ignoreDisconnect = true;
        outlet.appendChild(component);
        _LC.ignoreDisconnect = _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.ignoreDisconnect = false;
    },
    "replaceWith" : function() {
        var argumentsArr = Array.from(arguments);
        var oldNode = argumentsArr.$shift();
        _LC.ignoreDisconnect = true;
        var parentNode = oldNode.parentNode;
        for(var i=0,node;node=argumentsArr[i];i++) {
            _LC.insertBeforeNative(parentNode, node, oldNode);
        }
        oldNode.remove();
        _LC.ignoreDisconnect = false;
    },	
    // "removeIfCaseContent" : function(comp,node,direct){
    //     if(!direct){
    //         for(let tempName in node._tempList) {
    //             this.removeDynamicNodes(node._tempList[tempName],comp);
    //         }
    //     }
    // },
    // "removeYieldContent" : function(node,){
    //     if(!direct){
    //         for(let tempName in node._tempList) {
    //             this.removeDynamicNodes(node._tempList[tempName]);
    //         }
    //     }
    // },
    "insertBeforeNative" : function(parent, newNode, refNode) {
        parent.insertBefore(newNode, refNode);
    },
    "insertBefore" : function(referenceNode, newNode, parentNode) {
        _LC.ignoreDisconnect = true;
        if(!parentNode) {
            if(!referenceNode) {
                //@Slicer.developmentStart
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ApiError.error("LC005");
                //@Slicer.developmentEnd
                _LC.ignoreDisconnect = false;
                return;
            } else {
                parentNode = referenceNode.parentNode;
            }
        }
        _LC.insertBeforeNative(parentNode , newNode, referenceNode ? referenceNode : null);
        _LC.ignoreDisconnect = false;
    },
    "insertAfter" : function() {
        var argumentsArr = Array.from(arguments);
        var referenceNode = argumentsArr.shift();
        _LC.ignoreDisconnect = true;
        referenceNode.after.apply(referenceNode, argumentsArr);
        _LC.ignoreDisconnect = false;
    },
    "executeMethod" : function() {
        let args = Array.prototype.slice.call(arguments, 1);
        var methodName = _LC.String.toCamelCase(arguments[0]);
        if(!this._methods[methodName]) {
            //@Slicer.developmentStart
            let app = _LC.getNearestParentApp(this);
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error(app, "LC005", methodName, this.$node.tagName);
            //@Slicer.developmentEnd
            return;
        }
        return this._methods[methodName].apply(this, args);
    },
    // "getProperData" : function(obj) {
    //     var dataType = obj.dataType;
    //     var attr = obj.attr;
    //     var newValue = obj.newValue;
    //     var tagName = obj.tagName;
    //     switch(dataType) {
    //     case "boolean" : 
    //         {
    //             if(!newValue || newValue === "false") {
    //                 newValue= false;
    //             } else {
    //                 newValue = true;
    //             }
    //         }
    //         break;
    //     case "object" : 
    //         try{
    //             newValue = JSON.parse(newValue);
    //             if(!(newValue instanceof Object)) {
    //                 Lyte.warn("data type of the value provided for attribute "+ attr + " of " + tagName + " is not valid");
    //             }
    //         } catch(e) {
    //             Lyte.warn("attribute "+attr+ " is not a valid JSON string.");
    //             return;
    //         }
    //         break;
    //     case "array":
    //         try{
    //             newValue = JSON.parse(newValue);
    //             if(!(newValue instanceof Array)) {
    //                 Lyte.warn("data type of the value provided for attribute "+ attr + " of " + tagName + " is not valid");
    //             }
    //         } catch(e) {
    //             Lyte.warn("attribute "+attr+ " is not a valid JSON string.");
    //             return;
    //         }
    //         break;
    //     case "number":
    //         {
    //     let numValue = +newValue;
    //         if(newValue === numValue+"") {
    //             newValue = numValue;
    //         } else {
    //             Lyte.warn("data type of the value provided for attribute "+ attr + " of " + tagName + " is not valid");
    //             return;
    //         }
    //     }
    //         break;
    //     }
    //     obj.newValue = newValue;
    //     return true;
    // }, 
    "cssEscape" : function(string) {
        if(string) {
            return string.replace(/['"]/g, "\\$&");    
        } else {
            return string;
        }
        
    },
    "arrayOverride" : function(){
        let allArrFns = ["push","pop","splice","shift","unshift","concat","replaceAt","shiftObject","remove","removeAt","removeObject","removeObjects","unshiftObject","unshiftObjects","insertAt"];
        for(let i=0; i<allArrFns.length; i++){
            let fnName = allArrFns[i];
            Array.prototype[fnName] = (function() {
                return function() {
                    let actArgs = Array.from(arguments);
                    if(_LC){
                        let opt = {fromOverride : true};
                        actArgs.$unshift(opt,this,fnName);
                        return _LC.aF.apply(_LC, actArgs);
                    }else{
                        return this["$"+fnName].apply(this,actArgs);
                    }
                };
            })();
        }
    },
    "render" : function(componentName, data, outlet, _lyteOptions) {
        var component;
        ltCf.fromV4Render = true;
        let oldLyteV4 = ltCf.lyteV4;
        let setInnerHTML = false;
        if(_LC.validateRenderData(data,_lyteOptions)) {
            var currentReg = _LC.getCurrentRegistryIns();
            var currentRegClass = _LC.getCurrentRegistryIns();
            _LC.setCurrentRegistryIns(_lyteOptions && _lyteOptions.registryInstance ? _lyteOptions.registryInstance : this);
            _LC.setCurrentRegistry(_lyteOptions && _lyteOptions.registry ? _lyteOptions.registry : undefined);
            if(data && data.lyteV4){
                ltCf.lyteV4 = true;
            }
            if(componentName && typeof componentName == "string") {
                if(_lyteOptions && _lyteOptions.setInnerHTML){
                    setInnerHTML = true;
                    if(outlet) {
                        let actOutlet;
                        if(typeof outlet == "string"){
                            actOutlet = document.querySelector(outlet);
                        }else{
                            actOutlet = outlet;
                        }
                        if(actOutlet) {
                            actOutlet.innerHTML = componentName;
                        } else {
                            _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.error("LC008", outlet);
                        }
                    }
                }else{
                    //@Slicer.developmentStart
                    if(!this._registeredComponents[componentName]){
                        _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.warn("Invalid Lyte Component name : '" + componentName + "'. It is not registered with Lyte.");
                    }
                    _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.warn("Passing component name '" +componentName+ "' as string is depricated.");
                    //@Slicer.developmentEnd
                    component = createElement(componentName);
                }
            } else if(componentName && componentName._compName) {
                componentName._lyteOptions = _lyteOptions;
                component = createElement(componentName._compName);
                if(componentName._lyteOptions && componentName._lyteOptions.attributes && componentName._lyteOptions.attributes.length){
                    componentName._lyteOptions.attributes.forEach(function(attr){
                        if(typeof attr == "object"){
                            component.setAttribute(attr.name,attr.value);
                        }else{
                            component.setAttribute(attr,"");
                        }
                    })
                }
                componentName._lyteOptions = undefined;
            } else {
                //@Slicer.developmentStart
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ApiError.error("LC003");    
                //@Slicer.developmentEnd
                _LC.setCurrentRegistryIns(currentReg); 
                _LC.setCurrentRegistry(currentRegClass);
                ltCf.fromV4Render = false;
                ltCf.lyteV4 = oldLyteV4
                return;
            }
        } else {
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ApiError.error("LC0010");
            //@Slicer.developmentEnd
            _LC.setCurrentRegistryIns(currentReg);
            _LC.setCurrentRegistry(currentRegClass)
            ltCf.fromV4Render = false;
            ltCf.lyteV4 = oldLyteV4
            return;
        }
        
        if(data && !setInnerHTML){ 
            component.setData(data);
        }
        if(!setInnerHTML && _lyteOptions && _lyteOptions.methods){
            component.setMethods(_lyteOptions.methods);
        }
        if(_lyteOptions && _lyteOptions._route){
            component._route = _lyteOptions._route;
        }
        if(!setInnerHTML && outlet) {
            let actOutlet;
            if(typeof outlet == "string"){
                actOutlet = document.querySelector(outlet);
            }else{
                actOutlet = outlet;
            }
            if(actOutlet) {
                if(_lyteOptions && _lyteOptions.clearOutlet){
                    actOutlet.innerHTML = "";    
                }
                actOutlet.appendChild(component);
                component._callee = component.getCallee ? component.getCallee(actOutlet) : undefined;
            } 
            //@Slicer.developmentStart
            else {
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ApiError.error("LC004", outlet);
            }
            //@Slicer.developmentEnd
        }
        _LC.setCurrentRegistryIns(currentReg);
        _LC.setCurrentRegistry(currentRegClass);
        ltCf.fromV4Render = false;
        ltCf.lyteV4 = oldLyteV4
        return component;
    },
    // "renderHTML" : function(string,outlet,options){
    //     var currentReg = _LC.getCurrentRegistryIns();
    //     _LC.setCurrentRegistryIns(options && options.registryInstance ? options.registryInstance : this)
    //     if(typeof string == "string") {
    //         if(outlet) {
    //             let actOutlet;
    //             if(typeof outlet == "string"){
    //                 actOutlet = document.querySelector(outlet);
    //             }else{
    //                 actOutlet = outlet;
    //             }
    //             if(actOutlet) {
    //                 actOutlet.innerHTML = string;
    //             } else {
    //                 Lyte.error("LC008", outlet);
    //             }
    //         }
    //     }
    //     _LC.setCurrentRegistryIns(currentReg);
    // },
    "removeForContent" : function(node){
        for(let s=0;s<node._forContent.length;s++) {
            for(let i=0;i<node._forContent[s].length; i++ ) {
                node._forContent[s][i].remove();
            }
        }
    },
    "removeForInContent" : function(node){
        for(var ind in node._forContent) {
            for(let i=0;i<node._forContent[ind].length; i++ ) {
                node._forContent[ind][i].remove();
            }
        }
    },
    "removeIfContent" : function(node){
        for(let i=0;i<node._caseContent.length; i++ ) {
            node._caseContent[i].remove();
        }
    },
    "removeIfCaseContent" : function(comp,node,direct){
        if(!direct){
            for(let tempName in node._tempList) {
                this.removeDynamicNodes(node._tempList[tempName],comp);
            }
        }
    },
    "removeYieldContent" : function(node){
        if(!direct){
            for(let tempName in node._tempList) {
                this.removeDynamicNodes(node._tempList[tempName]);
            }
        }
    },
    "removeDynamicNodes" : function(node,comp){
        for(let key in node._dynamicProperty) {
            if(node._dynamicProperty[key].isActualNode) {
                node._dynamicProperty[key].isActualNode._helperNodes[del](node);
            }else {
                let helperNodes = comp.getProperty(key)._helperNodes;
                if(helperNodes) {
                    helperNodes.delete(node);
                }
            }
        }
        node._dynamicProperty = {};
    },
    "insertInDom" : function(placeHolder,lastNode,toAppendMain){
        if(placeHolder) {
            _LC.insertBeforeNative(placeHolder.parentNode, toAppendMain, placeHolder);                	
        } else {
            _LC.insertBeforeNative(lastNode.parentNode,toAppendMain, lastNode);                
        } 
    },
    "appendInDom" : function(comp,content){
        comp.appendChild(content);
    },
    "instantiateSecurity" : function(lyteIns){
        lyteIns.Security = {
            "_ourSanitizerInstance_" :{},
            "_userSanitizerInstance_":{}, 
            "_eM" : {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#x27;',
                '`': '&#x60;',
                '=': '&#x3D;'
              }, 
            "_eR" : /[&<>"'`=]/g,
            "_eF" : function(str) {
                return this._eM[str];
            }, 
            "escape" : function(string) {
                if (typeof string !== 'string') {
                    string = '' + string;
                }
                return string.replace(this._eR, this._eF.bind(this));
            }
        };
        var sec = {};
        lyteIns.Security._ourSanitizerInstance_ = _LC.Security.createSanitizer(sec);
        lyteIns.Security.createSanitizer = function (obb) {
            return _LC.Security.createSanitizer(obb);
        };
    },
    "setAttribute" : function(node,name,val){
        node.setAttribute(name,val);
    },
    "getErrorStructure": function (componentIns, key) {
        var cmpData = componentIns.data, data_Error = componentIns.data.errors;
        if (key.includes("$")) {
            key = key.replace("$.", "")
        }
        var cmpDataKey = key.split(".")
        var keyData = cmpData[cmpDataKey[0]];
        var _scpId = _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.__nestScp__.get(keyData);
        if (_scpId) {
            var cmpDataIns = _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.nestScp[_scpId];
            var propInfo = cmpDataIns.PropsInfo || undefined;
            if (propInfo) {
                for (var i_err = 0; i_err < propInfo.length; i_err++) {
                    var _cp = propInfo[i_err];
                    if (_cp._cmpErr == data_Error && _cp.key == cmpDataKey[0]) {
                        if (_cp.Error[_cp.key] && _cp.Error[_cp.key].nested && cmpDataKey.length > 1) {
                            key = key.replaceAll("[", ".").replaceAll("]", "");
                            var errorPath = ""
                            cmpDataKey.splice(0, 1)
                            errorPath = cmpDataKey.join(".")
                            return _LC.get(_cp.Error[_cp.key].nested, errorPath)
                        }
                        else if (data_Error[cmpDataKey[0]]) {
                            return data_Error[cmpDataKey[0]]
                        }
                    }
                }
            }
        }
        // if(data_Error.hasOwnProperty(key)){
        //     var errorData=data_Error[key];
        //     if(errorData.hasOwnProperty("nested")){
        //         var nestedArrayError = [];
        //         _LC.collectErrorMessage(errorData.nested,nestedArrayError,key,"");
        //         return nestedArrayError;
        //     }else{
        //         return data_Error[key]
        //     }
        // }else{
        //     return;
        // }
    },
}
_LC.setData = function(arg0, arg1) {
    this._initProperties = this._initProperties || {};
    if(typeof arg0 === "string") {
        this._initProperties[arg0] = arg1
    } else if(typeof arg0 === "object") {
        for(let key in arg0) {
            this._initProperties[key] = arg0[key];
        }
    }
}
_LC.setMethods = function(arg0, arg1) {
    this._initMethods = this._initMethods || {};
    if(typeof arg0 === "string") {
        this._initMethods[arg0] = arg1
    } else if(typeof arg0 === "object") {
        for(let key in arg0) {
            this._initMethods[key] = arg0[key];
        }
    }
}
_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.$.shadowDiv._duplicateStyle = [];
_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.$.assetsDiv._duplicateStyle = [];
_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.$.shadowDiv._compList = [];
_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.$.shadowDiv._shadowChild = [];
var div = document.createElement("div");
div.setAttribute("id","lessDiv");
_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.$.shadowDiv._lessDiv = div;
div._impNames = [];

_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte._component.init = function(lyteIns){
    _LC.instantiateSecurity(lyteIns);
    lyteIns.addEventListener("afterRouteTransition", function() {
        _LC.chromeBugFix();
    });
}
_slyte_core__WEBPACK_IMPORTED_MODULE_9__.LyteAddon._component.init = function(addOnIns){
    _LC.instantiateSecurity(addOnIns);
}
_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte._component.didConnect = function(lyteIns){
    //will be called after afterlookups
    if(lyteIns.getDefaultRegistry){
        let regIns = lyteIns.getDefaultRegistry();
        if(!_LC.isValidReg(regIns)){
            let name =  regIns ? regIns.constructor ? regIns.constructor.name : regIns : regIns ;
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.RegistryError.error("LC008", name, name);
            //@Slicer.developmentEnd
            return false;
        }
        _LC.setDefaultRegistryIns(regIns);
        _LC.setDefaultRegistry(regIns.constructor);
        _LC.gotDefaultRegistryFrom = "user";
    }
    ComponentRegistry._registeredRegistries.forEach(function(obj){
        let regClass = obj.class;
        let name = obj.name;
        if(regClass._instanceList){
            regClass._instanceList.forEach(function(regIns){
                _LC.setAddedRegistries(regIns,regClass.name);
            })
        }
    })
}
//var toArrayLyte = "toArrayLyte";
//var bindStr = "_bindings";
//var compStr = "component";
//var forHelperStr = "_forHelpers";
//var dynamicNodesStr = "_dynamicNodes";
//var calleeStr = "_callee";
//var getAttributeStr = "getAttribute";
//var hasAttributeStr = "hasAttribute";
//var removeAttributeStr ="removeAttribute";
//var setAttributeStr = "setAttribute";
//var parentNodeStr = "parentNode";
//var nodeNameStr = "nodeName";
//var ownerElementStr = "ownerElement";
var globalDOMEvents = [
    "focus",
    "focusin",
    "focusout",
    "resize",
    "scroll",
    "click",
    "dblclick",
    "mousedown",
    "mouseup",
    "mousemove",
    "mouseover",
    "mouseout",
    "change",
    "select",
    "submit",
    "keydown",
    "keypress",
    "keyup",
    "contextmenu"
];
// var registerHelperStr = "registerHelper";
var delStr = "delete";

function defProp() {
	Object.defineProperty.apply(Object, arguments);
}

function makeSet(obj, key) {
	if(!obj[key]) {
		defProp(obj, key, {
			value : new Set(),
			enumerable : false,
			writable : true,
			configurable : true
		})
	}
}
function addBindings(bindings, property) {
    bindings.add(property);
}

function makeArray(obj, key) {
	if(!obj[key]) {
		defProp(obj, key, {
			value : [],
			enumerable : false,
			writable : true,
			configurable : true
		})
	}
}

function createDocFragment() {
	return document.createDocumentFragment();
}

function createElement(elm) {
	return document.createElement(elm);
}

// function insertBefore(parent, newNode, refNode) {
// 	parent.insertBefore(newNode, refNode);
// }

function deleteBindingCheckSize(obj, key, valToDelete) {
	obj[key][delStr](valToDelete);
	if(!obj[key].size) {
		delete obj[key];
	}
}

/*	IE Browser
	Lyte._ie 
	Edge Browser
	Lyte._ed 
	Replace with needed;
	Lyte._rwpf 
	IE / Edge Browser
	Lyte._ms
*/

let userAgent = navigator.userAgent;
// //temporary fix for IE 11
// if(userAgent.match(/rv:11\.0/) && userAgent.match(/Trident/)) {
// 	Lyte._ie = true;
//     window.action = function() {
//         return;
//     }
// }
// if(userAgent.match('Edge')) {
//     var s = createElement("div");
//     s.innerHTML= "<template><div>c</div></template>";
//     if(s.querySelector("template").childNodes.length) {
//         Lyte._ie = true;
//     } else {
//         Lyte._ed = true;    
//     }
//     s.remove()
// }

class Test extends HTMLElement {
    constructor() {
        super();
        if(!this.attributes.t) {
            _LC.frSpecial = true;
        }
    }
}

// if(Lyte._ie || Lyte._ed) {
// 	var doc = createDocFragment();
// 	doc.appendChild(document.createTextNode("  dummy "));
// 	doc.childNodes[0].replaceWith(document.createTextNode("changed"));
// 	if(doc.childNodes[0].textContent !== "changed") {
// 		Lyte._rwpf = true;
// 	}
// 	Lyte._ms = true;
// }

// Lyte.Component = {}//mainClass;
// Lyte.compile = {};//af check
// var _LyteComponent = Lyte.Component;

// let arrayUtils =  function() {
// 	//arrayFunctions
//     return _LC.aF.apply(_LC, arguments);
// };
// let objectUtils =  function() {
// 	//objectFunctions
//     return _LC.oF.apply(_LC, arguments);
// }

_LC.errorNodeDetails = function(node) {
    var str = node.cloneNode(true);
    str.innerHTML = ".....";
    return str.outerHTML;
}
// _LyteComponent.register = function() {
//     _LC.registerComponent.apply(_LC, arguments);
// }
// _LyteComponent.directive = {
//     register : function() {
//         _LC.registerDirective.apply(_LC, arguments);
//     }
// }
// _LyteComponent.destroy = function() {
//     _LC.destroy.apply(_LC, arguments);
// }

// _LyteComponent.registerDirective = function() {
//     _LC.registerDirective.apply(_LC, arguments);
// }

// _LyteComponent.registerHelper = function() {
//     _LC.registerHelper.apply(_LC, arguments);
// }
// _LyteComponent.set = function() {
//     _LC.set.apply(_LC, arguments);
// }
// _LyteComponent.registeredHelpers = {};
// _LyteComponent.registeredComponents = {};
// _LyteComponent.registeredDirectives = [];
function noop() {

}
_LC.customPropHandlersList = {};
_LC.registerCustomPropHandler = function(propName) {
    let dasherized = _LC.String.dasherize(propName);
    propName = _LC.String.toCamelCase(propName);
    if(this.customPropHandlers.indexOf(propName) === -1) {
        this.customPropHandlers.$push(propName);
        let customPropHanlderFn = customElementPrototype.prototype[propName] = function() {
            _LC.customPropRegex = this.component._registryClass.customPropRegex;
            let argsLength = arguments.length;
            let arg0 = arguments[0];
            let options = arguments[2];
            let compData = this.component.data;
            if(!arg0) {
                //Read all the values
                let obj = {};
                for(let key in compData) {
                    if(key.startsWith(propName)) {
                        let objKey = key.substring(propName.length);
                        objKey = _LC.String.lowerCaseFirstLetter(objKey);
                        obj[objKey] = compData[key];
                    }
                }
                return obj;
                
            } else if(typeof arg0 === "string") {
                if(argsLength > 1) {
                    //Set a value
                    this.set(propName+ _LC.String.upperCaseFirstLetter(arg0), arguments[1], options);
                } else {
                    //Read a value
                    let actKey = propName + _LC.String.upperCaseFirstLetter(arg0);
                    return compData[actKey];
                }
            } else if(typeof arg0 === "object") {
                //Write a set of values
                for(let key in arg0) {
                    let objKey = propName + _LC.String.upperCaseFirstLetter(key);
                    this.set(objKey, arg0[key], arguments[1]);
                }
            }
            _LC.customPropRegex  = "";
        }
        _LC.customPropHandlersList[propName] = customPropHanlderFn;
        this.customPropRegex = new RegExp("^(" + this.customPropHandlers.join("|")+ ")");
    }
}
_LC.unregisterComponent = function(componentName) {//af check
    if(typeof componentName != "string"){
        componentName = componentName._compName;
        if(!componentName){
            return;
        }
    }
    if(componentName && this._registeredComponentClass[componentName]) {
        var compClass = this._registeredComponentClass[componentName];
        var commonClass = this._registeredCommonClass[componentName];
        if(compClass.activeInstances > 0) {
            //@Slicer.developmentStart
            _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.warn(
                "There are active instances of the component " + componentName + " and hence cannot be unregistered"
            );
            //@Slicer.developmentEnd
        } else {
            // comp._properties = {};
            let ind = commonClass.component.list.indexOf(compClass);
            if(ind != -1){
                commonClass.component.list.splice(ind,1);
            }
            delete commonClass.componentClass;
            compClass._actions = compClass._template = compClass._dynamicNodes = compClass.__observers = null;            
            compClass._callBacks = {};
            compClass._observers = [];
            compClass._data = undefined;
            compClass._methods = {};
            compClass._classFunc = null;
            compClass._registered = false
            compClass.prototype.get = noop;
            compClass.prototype.set = noop;
            Object.defineProperty(commonClass.prototype, "setData", {
                configurable : true, 
                writable : true, 
                value : function(arg0, arg1) {
                    this._initProperties = this._initProperties || {};
                    if(typeof arg0 === "string") {
                        this._initProperties[arg0] = arg1
                    } else if(typeof arg0 === "object") {
                        for(let key in arg0) {
                            this._initProperties[key] = arg0[key];
                        }
                    }
                }
            });

            Object.defineProperty(commonClass.prototype, "setMethods", {
                configurable : true, 
                writable : true, 
                value : function(arg0, arg1) {
                    this._initMethods = this._initMethods || {};
                    if(typeof arg0 === "string") {
                        this._initMethods[arg0] = arg1
                    } else if(typeof arg0 === "object") {
                        for(let key in arg0) {
                            this._initMethods[key] = arg0[key];
                        }
                    }
                }
            });

            delete this._registeredComponentClass[componentName];
            this._instanceList.forEach(function(registryIns){
                delete registryIns._registeredComponents[componentName];
                delete registryIns.registeredComponents[componentName];
            })
            // var template = document.querySelector("template[tag-name="+componentName+ "]")
            var lyteComponentsDiv = _LC.getComponentsDiv(_LC.lyteComponentsDiv, this.name);
            var template = lyteComponentsDiv.querySelector("template[tag-name="+componentName+ "]");
            if(template) {
                template.remove();
            }
            // lyteht -> lyteHelperTemplates
            var helperTemplate = compClass._helperTemplate;
            if(helperTemplate) {
                helperTemplate.remove();
            }
            if(commonClass._depthTemp) {
                commonClass._depthTemp.remove();    
            }
            if(compClass._style){
                compClass._style = undefined;
            }
        }
        ComponentRegistry._unRegisteredComponents[componentName] = true;
    } 
    //@Slicer.developmentStart
    else {
        _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.warn("Component "+ componentName + " not yet registered");
    }
    //@Slicer.developmentEnd
}

var elementPrototype = typeof HTMLElement !== "undefined" ? HTMLElement : Element;

_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.$.appendTemplateDiv = function() {
    document.body.appendChild(_LC.tDiv);
    document.body.appendChild(_LC.h1Div);
}

function onDomContentForLyte() {
    // if(!Lyte._ie){//_ie
    	document.body.appendChild(_LC.lyteComponentsDiv);
        //document.body.appendChild(_LC.tDiv);
    // }
    document.body.appendChild(_LC.hDiv);
    let bodyEvents = globalDOMEvents;    
    for(let i=0; i<bodyEvents.length; i++){    
        var evnt = bodyEvents[i];    
        document.body.addEventListener(evnt,globalEventHandler, true);    
    }    
    
    let comp = _LC.toBeRegistered;    
    if(comp.length){    
        for(let j=0; j<comp.length;j++){
            customElements.define(comp[j].name, comp[j].def, undefined, comp[j]._lyteOptions);    
        }    
        _LC.toBeRegistered = [];    
    }
    if(/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
        var style = createElement("style");
        style.innerHTML = "* { cursor : pointer}";
        document.head.appendChild(style);
    }
    document.head.appendChild(_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.$.shadowDiv._lessDiv);
}

var changeEventhandler = function(event) {
	var target = event.target || event.srcElement;
	if(!target._attributeDetails) {
		return;
	}
	var attributeName = "value";
	if(target.type === "checkbox" || target.type=== "radio") {
		attributeName = "checked";
	}
	let contextSwitchArray = [];
	var attrNode ;
	var attrDetail = target._attributeDetails[attributeName]
	if(!attrDetail || !attrDetail.isLbind) {
		return;
	}
	//attrNode = (attributeName === "checked") ? target._attributeDetails[attributeName].bindedNode : target.getAttributeNode(attributeName);
	var callee = target;
	if(!target._callee){
		while(callee && !_LC.isCustomElement(callee) && callee.tagName !== "LYTE-YIELD") {
			if(callee.tagName === "BODY") {
				callee = null;
				break;
			}
			callee = callee.parentNode;
		}
		if(callee && callee.tagName === "LYTE-YIELD"){
			target._callee = callee._registerYield._callee;
		} else {
			target._callee = callee;
		}
	}
	let self = target._callee;
	if(target) {
		_LC.adCx(target, contextSwitchArray);
	}
    let obj = _LC.getNew(self.component.data, attrDetail.dynamicValue);
    if(!obj.context){
        return;
    }
    let lastKeyIndex = +obj.lastKey;
    if(Array.isArray(obj.context) && typeof lastKeyIndex == "number") {
        _LC.aF(obj.context, lastKeyIndex < obj.context.length ? "replaceAt" : "insertAt", lastKeyIndex, target[attributeName]);
    } else {
        _LC.set(obj.context, obj.lastKey, target[attributeName]);
    }
	// _LC.set(obj.context, obj.lastKey, target[attributeName]);
	if(target) {
		_LC.rmCx(target, contextSwitchArray);
	}		
}
document.addEventListener("change", changeEventhandler);
var globalEventHandler = function(ev){
	var evnt = ev.type;
    var target = ev.target,toRemove;
    if(ev.target.shadowRoot){
        return;
    }
    if(/^(click|dblclick|mouseover|mouseout|mousemove|mousedown|mouseup|contextmenu|keydown|keyup|keypress|submit|reset|focus|blur|input|change|select|load|resize|scroll|unload|beforeunload|DOMContentLoaded|readystatechange|touchstart|touchmove|touchend|touchcancel|play|pause|ended|volumechange|durationchange|ratechange|dragstart|drag|dragenter|dragleave|dragover|drop|dragend)$/g.test(evnt) && target.getAttribute && target.getAttribute("lyte-state") != null){
        ev.preventDefault();
		return;
	}
    if(ev.currentTarget !== document.body && !_LCSD.getHostElement(ev.currentTarget)) {
        target = ev.currentTarget;
    }
	if(!window.event){
		toRemove = true;
		window.event = ev;
	}
    let eventStopped = false;
    while(target && target.getAttribute && (!target.getAttribute(evnt) || (target.hasAttribute("disabled") && evnt != "blur")) && target.tagName != "BODY"){
		if(_LC.hasLyteEvents(target, evnt)) {
            eventStopped = _LC.handleLyteEvents(target, ev);
            if(eventStopped) {
                break;
            }
        }
        target = target.parentNode;
	}
    if(eventStopped || !target) {
        return;
    }
 	var callee = target;
    if((target._callee && target._callee.component && target._callee.component.constructor._v3) || (target.component && target.component.constructor && target.component.constructor._v3)){
        return;
    }
	if(!target._callee){
		while(callee && !_LC.isCustomElement(callee) && callee.tagName !== "LYTE-YIELD") {
			if(callee.tagName === "BODY") {
				callee = null;
				break;
			}
			callee = callee.parentNode;
		}
		if(callee && callee.tagName === "LYTE-YIELD"){
			target._callee = callee._registerYield._callee;
		} else {
			target._callee = callee === target ? undefined : callee;
		}
	}
    if(target._callee && !target._callee.component){
        _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.warn("Component of the target node is destroyed and so "+ evnt +" wont be triggered.");    
        return;
    }
    event.$lTarget = target;
	if(target._evBoundEvents && target._evBoundEvents[evnt]) {
        //Not needed - but check and remove
		// let actions = target._callee? target._callee.component.constructor._actions : target.component.constructor._actions ;
        //let actions = target.component.constructor._actions;
		let actObj = target._evBoundEvents[evnt];
        let cloneActObj = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(actObj);
        _LC.skipArgProcessing(cloneActObj, ev, target);
		_LC.throwAction.call(target,target,evnt,cloneActObj, undefined, undefined, target, ev, undefined, true);
	} else if(target.getAttribute && target.getAttribute(evnt) && target._boundEvents && target._boundEvents[evnt]){
		// let actions = target._callee.component.constructor._actions;
        // let func = target.getAttribute(evnt).split(" => ")[1];
        let actObj = target._boundEvents[evnt];
		let cloneActObj = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(actObj);
		_LC.skipArgProcessing(cloneActObj, ev, target);
		_LC.throwAction.call(target._callee,target._callee,evnt,cloneActObj, undefined, undefined, target, ev);
	}
	if(target.tagName === "LABEL"){
		var input = target.querySelector("input");
		if(input && input.getAttribute(evnt)){
			// let actions = target._callee.component.constructor._actions;
			// let func = input.getAttribute(evnt).split(" => ")[1];
			//	let actObj = target._callee.constructor.getHelper(func);
            let actObj = target._boundEvents[evnt];
            let cloneActObj = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(actObj);
			_LC.skipArgProcessing(cloneActObj, ev, target);
			_LC.throwAction.call(target._callee,target._callee,evnt,cloneActObj, undefined, undefined, input,ev);
		}
	}
	if(toRemove){
		window.event = undefined;
	}
}
class LyteYield extends HTMLElement {
    constructor() {
        super();   
        this.decideConstructor();
    }
    decideConstructor(){
        if(ltCf.versionBridge){
            let V3Registry = ltCf.versionBridge.component.V3Registry;
            let foundInV3List = V3Registry.allList.v3[this.localName]
            let foundInV4List = V3Registry.allList.v4[this.localName]
            if(foundInV3List){
                if(!foundInV4List || (!(this.hasAttribute("lyte-v4") || this.hasAttribute("lyte-registry")) && !ltCf.lyteV4 && !ltCf.v4Render && (ltCf.fromV3Render || _LC.getCurrentRegistry() == V3Registry || foundInV3List))){
                    //v3
                    let v3CompClass = foundInV3List;
                    let self = this;
                    LyteYield._V3InsApi.forEach(function(apiName){
                        self[apiName] = v3CompClass.prototype[apiName];
                    })
                }
            }
        }
    }
    connectedCallback(){
        this._connectedCallback();
    }
    _connectedCallback() {
        this._callee = this._callee || _LC.getCallee(this.parentNode, this);
        let registry,shadowObj,directiveObj;
        if(this._callee){
            registry = this._callee.$component;
           if(registry){
            shadowObj = registry._shadow;
            directiveObj = registry._directive;
           }
        }
        if(directiveObj){
            this._transitionAppend = []
        }
        if(shadowObj && this.shadowRoot){
            shadowObj.insertInLessDiv(this._shadowParent,this._lessDiv)
            shadowObj.updateLessDiv(this._lessDiv,this.shadowRoot._compList);
        }
        if(!this._registerYield && this._callee) {
            var yieldName;
            if(this._callee._fR && this._callee._fR._yieldCallee) {
                this._registerYield = {"_callee" : this._callee._fR._yieldCallee.component.$node};
            } else if(this._callee._yields &&  (yieldName=this.attributes["yield-name"]) && (yieldName = yieldName.nodeValue) && this._callee._yields[yieldName]) {
                this._registerYield = {"_callee" : this._callee._yields[yieldName]._callee};
            }
        }
    }
    disconnectedCallback(){
        this._disconnectedCallback();
    }
    _disconnectedCallback(){
        if(_LC.ignoreDisconnect || this._deleted) {
            return;
        }
        let shadowObj = this._callee.getShadowObj();
        shadowObj && shadowObj.destroyRef(this);
        let registry = this._callee.$component;
        let directiveObj = registry._directive;
        this._deleted = true;
        if(!this._properties) {
            return;
        }
        var nodeContextSwitchArray = [];
        _LC.adCx(this, nodeContextSwitchArray);
        _LC.removeSelectedBindingDeep(this._properties, this.component.data, true);
        let node = this._registerYield;
        if(!node) {
        _LC.rmCx(this, nodeContextSwitchArray);
        return;
        }
        var toAppendContextSwitchArray = [];
        //newContext not needed
        var del = "delete";//for ie 11.0
        _LC.adCx(node, toAppendContextSwitchArray);
        for(let key in this._dynamicProperty) {
            if(this._dynamicProperty[key].isActualNode) {
                this._dynamicProperty[key].isActualNode._helperNodes[del](this);
            }else {
                let helperNodes = node._callee.getProperty(key)._helperNodes;
                if(helperNodes) {
                    helperNodes[del](this);
                }
            }
        }
        this._dynamicProperty = {};
        for(let i=0;i<this._helpers.length;i++) {
            node._callee.removeHelpers(this._helpers[i]);
        }
        this._helpers = [];
        _LC.rmCx(node, toAppendContextSwitchArray);
        _LC.rmCx(this, nodeContextSwitchArray);
        directiveObj && directiveObj.destroyPromises(this);
        // var self = this;
        // setTimeout(function() {
        //     self._registerYield = null
        //     self._callee = null;
        // },0);
    }
    getProperty(key) {
            var arr = key.match(/([^[\].]+|\[\])/g);
            let property = this;
            if(!property._properties[arr[0]]) {
                    property._properties[arr[0]] = {};
            } 
            property = property._properties[arr[0]];
        
            defProp(property, '_path', {enumerable: false, value : arr[0]});
            for(let i=1;i<arr.length;i++) {
                if (arr[i].startsWith("'") || arr[i].startsWith('"')) {//added check
                    arr[i] = arr[i].substring(1, arr[i].length -1);
                }
                    if(!property[arr[i]]) {
                        property[arr[i]] = {};
                        defProp(property[arr[i]], '_path', {enumerable: false, value : property._path + "." + arr[i]});
                }
                property = property[arr[i]];
            }
            return property;
        }
}
LyteYield._V3InsApi = ["_connectedCallback", "getProperty","_disconnectedCallback"]; //no i18n
ltCf._LyteYield = LyteYield;
customElements.define("lyte-yield", LyteYield, undefined, {v4 : true});
ltCf.v3 && !ltCf.instanctiatedBridge && ltCf.instanciateBridge();
//v4 class code
class LyteCustomElement extends HTMLElement {
    constructor(){
        super();
        this.decideConstructor();
    }
    decideConstructor(){
        if(ltCf.versionBridge){
            let V3Registry = ltCf.versionBridge.component.V3Registry;
            let foundInV3List = V3Registry.allList.v3raw[this.localName];
            let foundInV4List = V3Registry.allList.v4raw[this.localName];
            if(foundInV3List){
                if(!foundInV4List || (!(this.hasAttribute("lyte-v4") || this.hasAttribute("lyte-registry")) && !ltCf.lyteV4 && !ltCf.fromV4Render && (ltCf.fromV3Render || _LC.getDecidedRegistry() == V3Registry || foundInV3List))){
                    //v3
                    let v3CompClass = V3Registry.allList.v3raw[this.localName];
                    let self = this;
                    LyteCustomElement._V3InsApi.forEach(function(apiName){
                        self[apiName] = v3CompClass.prototype[apiName];
                    })
                }
            }
        }
        //v4 
        this.actualConstructor();
    }
    actualConstructor(){
        this.__lyteCustomElement = true;
        if(this.isClonedNode()){
            this.__cloned = true;
            let attrList = this.attributes;
            for(let i=0; i<attrList.length; i++){
              let attrNode = attrList[i];
              attrNode._lyte = {cloned : true,userCloned : true, name : attrNode.nodeName ,value : attrNode.nodeValue};
            }
        }
        if(!_LC.getDefaultRegistry() && !_LC.getCurrentRegistry()){
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.RegistryError.error("LC009");
            //@Slicer.developmentEnd
            return;
        }
        var obj = {compName : this.localName, type : "customComponent"};
        _LC.getCompRegistry(obj,this);
        if(!_LC.verifyDetails(obj)){
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.RegistryError.error("LC010", "Raw Component", this.localName);
            //@Slicer.developmentEnd
            return
        }
        var lIns = obj.lIns ,compClass = obj.compClass ,regIns = obj.regIns;
        var compInstance;
        lIns.scopedInstance(compClass,[this],function(ins){
            compInstance = ins;
        },[regIns])
        this.$component = this.$registry = regIns;
        compInstance.$component = compInstance.$registry = regIns;
        compInstance._registryClass = compClass._registryClass;
        this._registryClass = compClass._registryClass;
        _LC.setAddedRegistries(compInstance,this.localName);
        this.component = compInstance;
        compInstance.$node = this;
        let options = compClass._options;
        if(options && options.clone){
            this._allCallbacks = options.clone.allCallbacks;
            if(typeof options.clone.attributeChangedCallback == "object"){
                this._duringClone = options.clone.attributeChangedCallback.duringClone;
                this._afterClone = options.clone.attributeChangedCallback.afterClone;
            }else{
                this._allAttributesCallback = options.clone.attributeChangedCallback;
            }
            this.__connectedCallback = options.clone.connectedCallback;
            this.__disconnectedCallback = options.clone.disconnectedCallback;
        }
        this._actualConnectedCallback = compClass.prototype.connectedCallback;
        this._actualAttributeChangedCallback = compClass.prototype.attributeChangedCallback;
        this._actualDisconnectedCallback = compClass.prototype.disconnectedCallback;
        this._reconnectedCallback = compClass.prototype.reconnectedCallback;
        this._removedCallback = compClass.prototype.removedCallback;
    }
    executeLyteCallbacks(callBack,argArr){
        if(callBack) {
            callBack.apply(this.component, Array.from(argArr));
        }
    }
    isClonedNode(){
        if(this.hasAttribute("lyte-rendered-ce") && !this.LyteConnected || this.__cloned){
            return true;
        }
        return false;
    }
    _isClonedAttribute(attrName,oldVal,newVal){
        let attrNode = this.attributes[attrName];
        if(attrNode._lyte && attrNode._lyte.cloned && attrNode._lyte.name == attrName && attrNode._lyte.value == newVal && oldVal === null){
            return true;
        }
        return false;
    }
    isClonedAttribute(attrName){
        let attrNode = this.attributes[attrName];
        if(attrNode._lyte && attrNode._lyte.userCloned){
            return true;
        }
        return false;
    }
    connectedCallback(){
        this._connectedCallback();
    }
    _connectedCallback(){
        if(_LC.ignoreDisconnect || _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.ignoreDisconnect){
            if(this._reconnectedCallback){
                this.executeLyteCallbacks(this._reconnectedCallback,arguments);
            }
            return;
        }
        if(this.isClonedNode() && (this._allCallbacks == false || this.__connectedCallback == false)){
            return;
        }
        this.executeLyteCallbacks(this._actualConnectedCallback,arguments);
        this.setAttribute("lyte-rendered-ce", "");
        this.LyteConnected = true;
    }
    static get observedAttributes() {
        return this._observedAttributes;	
    }
    attributeChangedCallback(attr, oldValue, newValue) {
        this._attributeChangedCallback(attr, oldValue, newValue);
    }
    _attributeChangedCallback(attr, oldValue, newValue){
        var cloneStatus;
        var clonedNode = this.isClonedNode();
        if(clonedNode){
            if(this._allCallbacks == false || this._allAttributesCallback == false){
                return;
            }else{
                let attrName = arguments[0];
                let oldVal = arguments[1];
                let newVal = arguments[2];
                let attrNode = this.attributes[attrName];
                cloneStatus = this.attributes[arguments[0]]._lyte.userCloned;
                let isClonedAttribute = this._isClonedAttribute(attrName,oldVal,newVal,attrNode);
                if(isClonedAttribute){
                    this.attributes[arguments[0]]._lyte.userCloned = true;
                    if(this._duringClone == false){
                        return;
                    }
                }else{
                    this.attributes[arguments[0]]._lyte.userCloned = false;
                    if(this._afterClone == false){
                        return;
                    }
                }
            }
        }
        this.executeLyteCallbacks(this._actualAttributeChangedCallback,arguments);
        if(clonedNode && this.attributes[arguments[0]] && this.attributes[arguments[0]]._lyte){
            this.attributes[arguments[0]]._lyte.userCloned = cloneStatus;
        }
    }
    disconnectedCallback() {
        this._disconnectedCallback();
    }
    _disconnectedCallback(){
        if(_LC.ignoreDisconnect || _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.ignoreDisconnect){
            if(this._removedCallback){
                this.executeLyteCallbacks(this._removedCallback,arguments);
            }
            return;
        }
        if(this.isClonedNode() && (this._allCallbacks == false || this.__disconnectedCallback == false)){
            return;
        }
        this.executeLyteCallbacks(this._actualDisconnectedCallback,arguments);
    }
}
LyteCustomElement._V3InsApi = ["_connectedCallback", "_attributeChangedCallback" ,"_disconnectedCallback","actualConstructor","executeCallbacks","isNewComp"];
ltCf._LyteCustomElement = LyteCustomElement;
ltCf.v3 && !ltCf.instanctiatedBridge && ltCf.instanciateBridge();
//v4 class code
class customElementPrototype extends elementPrototype {
    constructor() {
        super();
        this.decideConstructor();
    }
    decideConstructor(){
        let self = this;
        if(ltCf.versionBridge){
            let V3Registry = ltCf.versionBridge.component.V3Registry;
            let foundInV3List = V3Registry.allList.v3[this.localName]
            let foundInV4List = V3Registry.allList.v4[this.localName]
            if(foundInV3List){
                if((!foundInV4List) || (!(this.hasAttribute("lyte-v4") || this.hasAttribute("lyte-registry")) && !ltCf.lyteV4 && !ltCf.fromV4Render && (ltCf.fromV3Render || _LC.getDecidedRegistry() == V3Registry || foundInV3List ))){
                    //v3
                    let v3CompClass = foundInV3List;
                    customElementPrototype._V3InsApi.forEach(function(apiName){
                        self[apiName] = v3CompClass.prototype[apiName];
                    })
                    self.component = self.constructor.component = v3CompClass.component;
                    this.setData = v3CompClass.component.prototype.setData;
                    this.setMethods = v3CompClass.component.prototype.setMethods;
                }else if(foundInV4List){
                    //v4
                    let v4CompClass = foundInV4List;
                    customElementPrototype._v4RegClassApi.forEach(function(apiName){
                        self.constructor[apiName] = v4CompClass[apiName];
                    })
                    customElementPrototype._v4RegProtoApi.forEach(function(apiName){
                        self[apiName] = v4CompClass.prototype[apiName];
                    })
                }
            }
        }
        //v4 
        this.actualConstructor();
    }
    actualConstructor() {
        // this.setData = _LC.setData;
        // this.setMethods = _LC.setMethods;
        if(this.hasAttribute("lyte-rendered") || this._ccCalled) {//aaf check
            this.__lyteIgnore = true;
        	return;
        } else if(ComponentRegistry._unRegisteredComponents[this.localName]){
            this.__lyteIgnore = true;
            var origClass = ComponentRegistry._registeredCommonClass[this.localName];
            origClass._pendingComponents = origClass._pendingComponents || [];
            origClass._pendingComponents.push(this);
            return;
        }
        if(!_LC.getDefaultRegistry() && !_LC.getCurrentRegistry()){
            //@Slicer.developmentStart
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.RegistryError.error("LC009");
            //@Slicer.developmentEnd
            return;
        }
        let fastRenderIndex;
        let lytePropAttr = this.attributes._lyteprop;
        lytePropAttr = lytePropAttr ? lytePropAttr.nodeValue : undefined;
        let fastRenderedProp = (fastRenderIndex = lytePropAttr) ? _LC.fRP[fastRenderIndex] : undefined;
        let compInstance;// = this.component = new this.constructor.component.list[0]();//this.component = fastRenderedProp ? fastRenderedProp.component : new this.constructor.component();
        var self = this;
        if(!fastRenderedProp){
            var obj = {compName : this.localName, type : "component"};
            _LC.getCompRegistry(obj,this);
            if(!_LC.verifyDetails(obj)){
                //@Slicer.developmentStart
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.RegistryError.error("LC010", "Component", this.localName);
                //@Slicer.developmentEnd
                return
            }
            var lIns = obj.lIns ,compClass = obj.compClass ,regIns = obj.regIns;
            lIns.scopedInstance(compClass,[],function(ins){
                compInstance = self.component = ins
            },[regIns])
            this.$component = this.$registry = regIns;
            compInstance.$component = compInstance.$registry = regIns;
            compInstance._registryClass = compClass._registryClass;
            this._registryClass = compClass._registryClass;
            _LC.setAddedRegistries(compInstance,this.localName);
        }else{
            compInstance = self.component = fastRenderedProp.component;
            var compClass = this.constructor.component.list[0];
            this.$component = this.$registry = compInstance.$component;
            this._registryClass = compInstance._registryClass;
        }
        this._properties = {};
        this._compClass = compClass;
        this._tagDirectives = [];
        for(let propName in _LC.customPropHandlersList){
            this[propName] = _LC.customPropHandlersList[propName];
        }
        _LC.directive.setTagDirectives(compClass,this);
        _LC.directive.setAttrFromRender(this,this._tagDirectives);
        compInstance._methods = {};
        
        compInstance._config = this.constructor._config;
        compInstance.actions = Object.assign({},compClass._actions);
        //@Slicer.developmentStart
        var act = compInstance.actions;
        Object.defineProperty(compInstance,"actions",{
            get : function() {
        		_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.warn("Accessing actions directly is deprecated. Move the required common code from action block to a common function and access it.");
        		return act;
        	}   
        });
        var met = compInstance.methods;
        Object.defineProperty(compInstance,"methods",{
            get : function() {
        		_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.warn("Accessing methods directly is deprecated. Kindly make use of 'this.executeMethod' Api.");
        		return met;
        	}   
        });
        //@Slicer.developmentEnd
        compClass.activeInstances++; 
        let compData;
        
        if(!fastRenderedProp) {
            compData = compInstance.data = {};
            let data = compClass._data ? compClass._data.apply(compInstance) : {};
            var def = "default";
            defProp(compData, '__component__', {
                value : this,
                configurable : true,
                writable: true,
                enumerable : false
            });
            compInstance.__data = data;
            compData.errors = {};
            for(let key in data) {
                var obj = data[key];
                compData[key] = obj[def];
                var customDtype = false;
                if(typeof obj.type == "function"){
                    var customDatatype = obj.type;
                    if(/^(object|array)$/.test(customDatatype.type) && (customDatatype.hasOwnProperty("properties") || customDatatype.hasOwnProperty("items") ) ){
                        customDtype = true;
                    }
                }
                if((/^(object|array)$/.test(obj.type) && (obj.watch || (obj.hasOwnProperty("items") || obj.hasOwnProperty("properties")) ) || customDtype)){
                    (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.establishObjectBinding)(compData, key, false,undefined,undefined,obj.watch?true:undefined);
                }
            }
            compData.errors = {};
            compInstance.__data = data;
        }
        
        for(let key in compClass._methods) {
            compInstance._methods[key] = compClass._methods[key];
        }
        if(compInstance.$node) {    
            for(var key in compInstance.$node) {
                if(key != "localName"){
                    this[key] = compInstance.$node[key];
                }
            }
        }
        compInstance.$node = this;
        let _overrides;
        let _config_flag;
        if(compInstance._ssr && compInstance._ssr.config){
            if( compInstance._ssr.config.clientLifeCycleHooks != undefined ){
                _config_flag = compInstance._ssr.config.clientLifeCycleHooks == true || ( typeof compInstance._ssr.config.clientLifeCycleHooks == 'object' ? compInstance._ssr.config.clientLifeCycleHooks.includes('init') : false );
            }
        }
        
        if(!fastRenderedProp) {
            // this.callback("constructor"); //af check // no need
            this._actions = this._actions ? this._actions : {};
            this._callee = this._callee || this.getCallee(this.parentNode);

            //check if it is called from server || to ssr bind
            
            //check if it has ssr contructor for ssr
            //ssrcode_client
            if( _config_flag || !this.hasAttribute( 'server-rendered' ) ){
                if( _overrides && _overrides.constructor && this.serverCall ){
                    _overrides.constructor.apply( this.component );
                }
            } 

            //checking lyte.attr ytpe and given default value type
            for (var key in compData) {
                var field = compData.__component__.component.__data[key];
                var error = _LC.handleValidation(compData, key, compData[key], compInstance ,true);
                if (error) {
                    compData[key] = undefined;
                    var field = compData.__component__.component.__data[key]; 
                    if(field && /^(object|array)$/.test(field.type)){
                        (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.establishObjectBinding)(compData, key, undefined,undefined,undefined,field.watch ? true:undefined);
                    }
                }
            }
            // if(compData.errors && Object.keys(compData.errors).length){
            //     Lyte.error("Error in data passed to component '"+ this.localName +"' for the properties - "+Object.keys(compData.errors).toString());
            // }
        } else {
            this._fR = fastRenderedProp;
            delete _LC.fRP[fastRenderIndex];
            // _LC.$pushFrc(fastRenderIndex);
        }
    }
    getDirectiveObj(){
        if(!_LC.directive.bundled){
            return false;
        }
        return _LC.directive;
    }
    getShadowObj(){
        if(this.$registry._shadow){
            return this.$registry._shadow;
        }
        return false;
    }
    getFastObj(){
        if(this.$registry["_turbo"]){
            return this.$registry["_turbo"];
        }
        return false;
    }
    getViewObj(){
        if(this.$registry["_view"]){
            return this.$registry["_view"];
        }
        return false;
    }
    getMethods(arg0) {
        return this.component.getMethods(arg0);
    }
    hasAction(arg0) {
        return this.component.hasAction(arg0);
    }
    setActions(arg0,arg1){
        return this.component.setActions(arg0,arg1);
    }
    getActions(arg0) {
        return this.component.getActions(arg0);
    }
    getObservers() {
        return this.component.getObservers();
    }
    setMethods(arg0, arg1) {
        return this.component.setMethods(arg0, arg1);
    }
    // getData(arg0) {
    //     return this.component.getData(arg0);
    // }
    // setData(arg0, arg1 ,options) {
    //     return this.component.setData(arg0, arg1, options);
    // }
    getCallee(callee){
        return _LC.getCallee(callee, this);
    }
    afterConnected(fastRenderProp,ssrBind) {
        let constr = this.component.constructor;
        //initProperties is used because, we may have cases where the component wouldn't have been registered but 
        //it would be in dom already with some attributes. In those cases we can store the data in _initProperties as key, value.
        //These properties would then be applied to the component, once it gets instantiated. 
        
        //This is done, in order to solve when on a string value update of an if helper, the binding in the true or false case must be established. 
        //Without this, we won't establish the _properties in the component to the actual Data. 
        if(this.getAttribute("_lyteprop")) {
        	return "";
        }
        let obsattr = this.constructor._observedAttributes;
        for(let i=0;i<obsattr.length;i++){
            let key = obsattr[i];
            let prop = this.getProperty(key);
            defProp(prop, '__fromComponent', {
            	value : true,
                enumerable : false
            });
        }
        this.getProperty("errors");
        let app = this.component.getAppOrAddon();
        var $lg = app.__gl, 
        compInstance = this.component,
        compData = compInstance.data;
        compData.$lg = $lg;
        this.component.constructor.prototype.$lg = $lg;
        if(this._initProperties) {
            let initProperties = this._initProperties;
            // if(initProperties["lyteUnbound"] && _LC.migratedv2(app)){ //devmode
            //     Lyte.error("lyteUnbound is moved to directive. so please make use of @unbound");
            // }
            let wholeData = initProperties.$data;
            if(wholeData){
                if(typeof wholeData === "object") {
                    for(let key in wholeData) {
                        initProperties[key] = wholeData[key];
                    }
                }else{
                    _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error("LC018",this.localName);
                }
                delete initProperties.$data;
            }
            var eKeys = [];
            for(let key in initProperties) {
                let actVal;
                let field = compInstance.__data[key]; 
                if(field && field.type !== _LC.getDataType(initProperties[key]) && (initProperties[key] !== undefined  || field.type === "boolean")) {
                    actVal = _LC.typeCast(initProperties[key], compInstance.__data[key].type);
                } else {
                     actVal = initProperties[key];
                }
                let error = _LC.handleValidation(compData, key, actVal, compInstance ,true);
                if(!error) {
                    compData[key] = actVal; 
                    var customDtype = false;
                    if(field && typeof field.type == "function"){
                        var customDatatype = field.type;
                        if(/^(object|array)$/.test(customDatatype.type) && (customDatatype.hasOwnProperty("properties") || customDatatype.hasOwnProperty("items"))){
                            customDtype = true;
                        }
                    }   
                    if((field && /^(object|array)$/.test(field.type) && (field.watch || (field.hasOwnProperty("items") || field.hasOwnProperty("properties"))) )|| customDtype){
                        (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.establishObjectBinding)(compData, key, undefined,undefined,undefined,field.watch ? true : undefined);
                    }
                }
                else{
                    eKeys.push(key);
                }
            }
            this._initProperties = undefined;
            //@Slicer.developmentStart
            if(eKeys.length){
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error("LC006",this.component.$node.localName,eKeys.toString())
            }
            //@Slicer.developmentEnd
        }
        if(this._initMethods) {
            let initMethods = this._initMethods;
            for(let key in initMethods) {
                compInstance._methods[key] = initMethods[key];
            }
            this._initMethods = undefined;
        }
        let _config_flag;
        if( compInstance._ssr && compInstance._ssr.config ){
            if( compInstance._ssr.config.clientLifeCycleHooks != undefined ){
                _config_flag = compInstance._ssr.config.clientLifeCycleHooks == true || ( typeof compInstance._ssr.config.clientLifeCycleHooks == 'object' ? compInstance._ssr.config.clientLifeCycleHooks.includes('init') : false );
            }
        }
        let _overrides;      
        
        //ssrcode client        
        ssrBind && this.cmpBind(fastRenderProp);
        if( _config_flag || !this.hasAttribute( 'server-rendered' ) )
        {
            if( _overrides && _overrides.init && this.serverCall ){
                _overrides.init.apply( this.component );
            }else{        
                this.callback('init');
            }
            this.onCallBack('init');
        }
        // this.callback('init');
        // this.onCallBack('init');
        let templateAttributes = this.component.constructor._templateAttributes;
        if(templateAttributes && templateAttributes.a) {
        	for(let key in templateAttributes.a) {
//        		let attr = templateAttributes.attr[i];
				let attr = templateAttributes.a[key];
        		if((!this.hasAttribute(attr.name) && !compData.hasOwnProperty(attr.name) ) || attr.globalEvent) {
        			if(attr.helperInfo && attr.helperInfo.name === "action") {
                        this._evBoundEvents = this._evBoundEvents || {};
                        let actionName = attr.helperInfo.args[0];
					    let boundName;
					    if(actionName.startsWith('"') || actionName.startsWith("'")) {
						boundName = actionName.substring(1, actionName.length - 1);
					    } else {
						//Lyte.warn("Deprecation warning. Action name should be in quotes");
						boundName = actionName;
                        }
                        let actualAttrName = attr.globalEvent ? attr.name : (attr.name.indexOf("-") !== -1)? attr.name : attr.name.substr(2);
                        this._evBoundEvents[actualAttrName] = {"name" : boundName, "args" : attr.helperInfo.args, "from" : "component"};
                        let prevAttribute = this.getAttribute(attr.name);
                        let currentAttribute = this.component.constructor._template.getAttribute(attr.name);
                        //this.setAttribute("ev:"+attr.name, this.component.constructor._template.getAttribute(attr.name));
                        this.setAttribute(attr.name, currentAttribute + (prevAttribute ? " ; " + prevAttribute : ""));
                    }
                    if(!attr.globalEvent) {
                        attr.from = "component";
                        if(attr.staticValue) {
                            this.setAttribute(templateAttributes.a[key].name, attr.staticValue);
                        }
                        else if(_LC.directive.isDirectiveNode(attr)){
                            let actAttrName = attr.name;
                            let attrName = actAttrName;
                            let duplicateFound;
                            if(!this._specialAttributeDetails){
                                this._specialAttributeDetails = [];
                            }else{
                                this._specialAttributeDetails.forEach(function(oldAttr){
                                    if(oldAttr.hookName == actAttrName){
                                        duplicateFound = true;
                                    }
                                })
                            }
                            if(attr.hasOwnProperty("stringValue")){
                                
                                if(!duplicateFound){
                                    let strAttr = {
                                        hookName : attr.hookName,
                                        hookNode : attr.hookNode,
                                        name : attr.name,
                                        stringValue : attr.stringValue
                                    }
                                    this._specialAttributeDetails.push(strAttr);
                                }
                            }else if(attr.hasOwnProperty("dynamicValue")){
                                this.setAttribute(attr.hookName, "{{dummy}}");
                                let attrNode = this.attributes.getNamedItem(attr.hookName);
                                attr._isDirectiveNode = true;
							    this.bindNode(attrNode, [], undefined, {}, attr, undefined, undefined, true );
                                if(!this._specialAttributeDetails){
                                    this._specialAttributeDetails = [];
                                }
                                let dynAttr = {
                                    hookName : attr.hookName,
                                    hookNode : attr.hookNode,
                                    name : attr.name,
                                    dynamicValue : attr.dynamicValue
                                }
                                this._specialAttributeDetails.push(dynAttr);
                            }
                            
                        }
                        //@Slicer.developmentStart
                        else if(key.startsWith("@")){
                            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error("LC007")
                        }
                        //@Slicer.developmentEnd
                        else{
                            this.setAttribute(templateAttributes.a[key].name, "{{dummy}}");
							this.bindNode(this.attributes.getNamedItem(templateAttributes.a[key].name), [], undefined, {}, templateAttributes.a[key], undefined, undefined, true );
                        }
                    }
        			
        		}
        	}
        }
        this.registerYields();
        let dumFlg;
        if(compData.lyteUnbound && !_LC.migratedv2(app)) {
        	_LC.unbound = true;
            dumFlg = true
        }
        let unboundDirective = _LC.directive.getTransitionArg(this,"unbound");
        if(unboundDirective){
            _LC.unbound = true;
        }
        if(!dumFlg){
            this.component.data.lyteUnbound = unboundDirective;//add in future   
        }
        let content = "";
        let fastRender,fastRenderSupported
        let unboundBeta = compData.lyteFastRender;
        fastRender = _LC.directive.getTransitionArg(this,"turbo");
        this.component.data.lyteFastRender = fastRender;
        if(fastRender){
            fastRenderSupported = _LC.directive.getTransitionArg(this,"unbound-supported") || _LC.directive.getTransitionArg(this,"turbo-supported");
            if(!fastRenderSupported){
                //@Slicer.developmentStart
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error("LC008", this.localName)
                //@Slicer.developmentEnd
                this.component.data.lyteFastRender = false;
            }
        }
        
        let fastObj = this.getFastObj();
        if((unboundBeta && !(_LC.migratedv2(app))) || (fastRender && fastRenderSupported && fastObj)){
            content = fastObj.renderFast(constr._dynamicNodes, constr._sta, compInstance, undefined, this);
            requestAnimationFrame(function() {
                requestAnimationFrame(function() {
                    _LC.callCC();
                });
            });
        }
        else {
            content = this.renderNodes(constr._template, constr._dynamicNodes,undefined,undefined, undefined, undefined, this.component.constructor._tC);
        }
        return content;
    }

    //RN
    renderNodes(toAppend, dynamicNodes, helperNode, options, establishBindings, returnVal, templateContent ,yieldComp) {
        options = options || {};
        let content;
        let constr = this.constructor;
        // let Compile = this.component.constructor.Compile;
        let directiveObj = this.getDirectiveObj();
        /*if(Lyte._ie){
            let newFrag = toAppend.cloneNode(true, "lyte");
            this.constructor.splitTextNodes(newFrag);
            content = newFrag;
        }
        else{
            content = toAppend.cloneNode(true, "lyte");
        }*/
        let templateDepthHandlingNeeded = false;
        if (!toAppend) {
            templateDepthHandlingNeeded = true;
            content = _LC.getContentForIE(templateContent , constr);
        } else if(toAppend.hasAttribute("depth")) {
        	templateDepthHandlingNeeded = true;
        	content = _LC.getContentForIE(toAppend , constr);
        } else {
            content = toAppend.content.cloneNode(true, "lyte");
        }
        let updateHelpers = [],processLast = [],helperFunc,stoppedNode;
        
        let toBeInsMap = new Map();
        for(let i=0;i<dynamicNodes.length;i++) {
            let info = dynamicNodes[i], type = info.t, pos = info.p, dynamicN = content, helperInfo;
            dynamicN = getDynamicNode(dynamicN,pos);
            if(directiveObj && info.trans){
                dynamicN._hooksPresent = true;
            }
            if(!dynamicNodes._cache){
                dynamicNodes._cache = {};
            }
            if(type ===  "cD") {
            	if(options.node) {
            		dynamicN._cx = options;
            	} else if(helperNode) {
            		dynamicN._cx	= helperNode._cx;
            	}
                  
                if(directiveObj){
                    directiveObj.infoCD(this,info,dynamicN,helperNode,options);
                }
                // dynamicN._callee = this//af check
            } 
            else if(type === "tX"){
                 this.bindNode(dynamicN, undefined, helperNode, options, dynamicNodes[i], processLast, establishBindings,undefined,dynamicNodes._cache,type,undefined,toBeInsMap);
            }
            else if(type === "a"){
            	dynamicN._attributeDetails = info.a;            	
                if(dynamicN.nodeName === "LYTE-YIELD") {
                    dynamicN._callee = this;
                    dynamicN.component = {}
                    dynamicN.component.data = {};
                    defProp(dynamicN.component.data, "__component__", {
                    	value : dynamicN,
                    	configurable : true,
                    	writable : true,
                        enumerable : false
                    });
                    dynamicN._properties = {};
                    for(let j=0;j<dynamicN.attributes.length;j++) {
                        let attr = dynamicN.attributes[j];
                        if(attr.nodeName !== "is" && attr.nodeName !== "yield-name") {
                            dynamicN._properties[_LC.String.toCamelCase(attr.nodeName)] = {};
                        }
                    }
                }
                let toBeRemoved = [];
				for(let key in info.a) {
                	let attr = info.a[key];
                	attr._depthTemp = info._depthTemp;
                	let attrName = key;
                    if(attr && (attr.dynamicValue || attr.helperInfo)) {
                        if(options.node) {
                                dynamicN._cx = options;
                        }
                        else if(helperNode) {
                            dynamicN._cx = helperNode._cx;
                        }
                        let actionName, boundName;
                        if(attr.helperInfo && attr.helperInfo.name === "action") {
                            dynamicN._boundEvents = dynamicN._boundEvents || {};
                            actionName = attr.helperInfo.args[0];
                            if(actionName.startsWith('"') || actionName.startsWith("'")) {
                                boundName = actionName.substring(1, actionName.length - 1);
                            } else {
                                // Lyte.warn("Deprecation warning. Action name " + actionName + " must be in quotes");
                                boundName = actionName;
                            }
                            let actualAttrName = attr.globalEvent ? attrName : (attrName.indexOf("-") !== -1)? attrName : attrName.substr(2);
                            dynamicN._boundEvents[actualAttrName] = {"name" : boundName, "args" : attr.helperInfo.args};
                            //to bind actions in ssr components
                            let id;
                               
                        }            
			            if(!attr.globalEvent) {
                            /*this.bindNode(dynamicN.getAttributeNode(attrName), toBeRemoved, helperNode, options, attr, undefined, establishBindings);
                             */
                            if(!dynamicN.hasAttribute(attrName)) {
                                dynamicN.setAttribute(attrName, "{{dummy}}");
                            }
                        	var node = this.bindNode(dynamicN.attributes.getNamedItem(attrName), toBeRemoved, helperNode, options, attr, undefined, establishBindings,undefined,dynamicNodes._cache,type,i);
                            if(node !== dynamicN.attributes.getNamedItem(attrName)) {
                            	dynamicN._removedAttributes = dynamicN._removedAttributes || {};
                            	dynamicN._removedAttributes[attrName] = node;
                            }
                        }
                    }
                    if(attr.hookNode){
                        if(directiveObj){
                            directiveObj.infoA(this,info,dynamicN,helperNode,attr,yieldComp,options);
                        }else if(attr.hookName == "unbound" || attr.hookName == "turbo" || attr.hookName == "shadow" || attr.hookName == "shadow-style" || attr.hookName == "shadow-deep"){
                            if(!dynamicN._transitionAppend){
                                dynamicN._transitionAppend = []
                            }
                            if(yieldComp && !yieldComp._transitionAppend){
                                yieldComp._transitionAppend = []
                            }
                            if(this && !this._transitionAppend){
                                this._transitionAppend = []
                            }
                            _LC.directive.infoA(this,info,dynamicN,helperNode,attr,yieldComp,options);
                        }
                    }
                }
                //Added now
                if(info.a && Object.keys(info.a).length) {
                	dynamicN._callee = this;
                }
                for(let d=0;d<toBeRemoved.length;d++) {
                    dynamicN.removeAttribute(toBeRemoved[d]);
                }
            }
            else if(/^(f|fI|cM)$/.test(type)){
            	if(options.node) {
            		dynamicN._cx = options;
            	} else if(helperNode) {
            		dynamicN._cx	= helperNode._cx;
            	}
                if(directiveObj){
                    directiveObj.infoF(this,info,dynamicN,helperNode,type,options);
                }
                dynamicN._dynamicNodes = info.dN;
                // if(Lyte._ms) {
                //     dynamicN._tC = info.templateContent;  
                // }
                if(info.actualTemplate) {
                    dynamicN._tC = info.actualTemplate;
                }
                let returnVal;
                switch(type) {
                case "f" : 
                    dynamicN._ht = info._ht;
                	returnVal = this.updateForHelper(dynamicN,{"type" : "default"} , options.node? options : undefined, establishBindings, info._sta ,yieldComp);
                	break;
                case "fI" : 
                    dynamicN._ht = info._ht;
                	returnVal = this.updateForInHelper(dynamicN,{"type" : "default"} , options.node? options : undefined, establishBindings ,yieldComp);
                	break;
                case "cM" : 
                	returnVal = this.updateDynamicComponent(dynamicN, false, options.node ? options : undefined, establishBindings ,yieldComp);
                }
                if(returnVal) {
                	updateHelpers.$push(returnVal);
                }
            }
            else if(/^(e|s)$/.test(type)){
                var def ="default";
                dynamicN._cases = info.c; 
                dynamicN._hd = info.hd;
                dynamicN._co = info.co
                dynamicN._default = info.d;
                dynamicN._ht = info._ht;
                if(options.node) {
            		dynamicN._cx = options;
            	} else if(helperNode) {
            		dynamicN._cx	= helperNode._cx;
            	}
                if(directiveObj){
                    directiveObj.infoE(this,helperNode,dynamicN,info,options);
                }
                if(info.actualTemplate) {
                    dynamicN._tC = info.actualTemplate;
                    if(!dynamicN._origTemplate) {
                    	// if(Lyte._ie) {
                    	// 	dynamicN._origTemplate = createElement("template")
                    	// } else {
        	            	dynamicN._origTemplate = info._depthTemp.cloneNode(true);
                    	// }
                    	if(dynamicN.hasAttribute("value")) {
                    		dynamicN._origTemplate.setAttribute("value", dynamicN.getAttribute("value"));
                    	}
                        if(dynamicN.hasAttribute("l-c")) {
                    		dynamicN._origTemplate.setAttribute("l-c", dynamicN.getAttribute("l-c"));
                    	}
                    }
                }
                let id,obj;
                
                
                let returnVal = this.updateSwitchHelper(type, dynamicN, options.node ? options : undefined, undefined, establishBindings ,yieldComp,undefined,helperNode,id,i);
                if( !_LC.unbound && ( this._ssrBind || ( this._callee && this._callee._ssrBind ) )){
                    // delete obj.node;
                    // obj.case = dynamicN._currentCase || dynamicN._currentScope; 
                    if(dynamicN.getAttribute("l-c")){
                        obj._new = dynamicN.getAttribute("_new") ? true:undefined;
                        obj.lc = true;
                        obj.case = dynamicN._currentScope;
                    }else{
                        obj.case = dynamicN._currentCase; 
                    }
                }
                if(returnVal) {
                	updateHelpers.$push(returnVal);
                	let isBreak = returnVal.toAppendMain.querySelector("template[is=break]");
                	if(isBreak) {
                		dynamicN._isStopped = "break";
                		content = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default().getTrimmedContent(content, info.p,undefined);
                		stoppedNode = info.p;
                		break;
                	}
                	let isContinue = returnVal.toAppendMain.querySelector("template[is=continue]");
                	if(isContinue) {
                		dynamicN._isStopped = "continue";
                		content = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default().getTrimmedContent(content, info.p,undefined);
//                		stoppedNode = info.position;
                		break;
                	}
                }
            } else if(type === "r") {
                dynamicN._childPromise = [];
                
                dynamicN._dynamicNodes = info.dN;
                dynamicN._sta = info._sta;
                dynamicN._ht = info._ht;
                // if(Lyte._ms) {
                //     dynamicN._tC = info.templateContent;  
                // }
//                updateHelpers.$push(dynamicN);
                if(directiveObj){
                    dynamicN._childPromise = [];
                    directiveObj.infoE(this,helperNode,dynamicN,info,options);
                }
                if(options.node) {
                    dynamicN._cx = options;
                }
                else if(helperNode) {
                    dynamicN._cx = helperNode._cx;
                }
                //Added now                
                dynamicN._callee = this;
            } else if(type === "i") {
            	if(options.node) {
            		dynamicN._cx = options;
            	} else if(helperNode) {
            		dynamicN._cx	= helperNode._cx;
            	}
                
                dynamicN.component = dynamicN.component || {"data" : {}};
                dynamicN._properties = dynamicN._properties || {};
                if(directiveObj){
                    directiveObj.infoI(this,info,dynamicN,helperNode,options);
                }
                for(let x=0; x<dynamicN.attributes.length; x++) {
                    let attrObj = dynamicN.attributes[x];
                    let attrName = attrObj.name;
                    let attrValue = attrObj.value;
                    if(attrName !== "yield-name") {
                        if(dynamicN._properties && !dynamicN._properties[attrName]){
                            dynamicN._properties[attrName] = {};
                        }
                        if(dynamicN._attributeDetails && !dynamicN._attributeDetails[attrName]){
                            dynamicN.component.data[attrName] = attrValue;
                        }
                    }
                }
                this.updateYield(dynamicN, false, options.node? options : undefined,helperNode);
                if(info.chld){
                    dynamicN._chld = info.chld;
                }
                if(info.sibl){
                    dynamicN._sibl = info.sibl;
                }
            }
        }
        dynamicNodes._cache = undefined;
        for(let i=0;i<processLast.length;i++) {
             let dynamicPosition = processLast[i].dynamicPositions;
                 let processNode = dynamicPosition.initialNode;
                 let nodeValue = dynamicPosition.dynamicNodeValue;
                 let childLen = nodeValue.childNodes.length;
                 if(!childLen) {
                    nodeValue.appendChild(document.createTextNode(""));
                        childLen = 1;
                 }
                 let startingNode = nodeValue.childNodes[0];
                 if(processNode.parentNode.nodeName === "#document-fragment") {
                 	while(nodeValue.childNodes.length) {
                 		_LC.insertBeforeNative(processNode.parentNode, nodeValue.childNodes[0], processNode);
                    }
                 	processNode.remove();
                 } else {
                	 processNode.replaceWith.apply(processNode,nodeValue.childNodes);
                 }
                 processLast[i].dynamicPositions = {startingNode : startingNode, length: childLen}
        }
        if(toBeInsMap.size){
            toBeInsMap.forEach(function(val, key){
                val.pN.insertBefore(key, val.cN);
                if(val.cN.nextSibling){
                    val.pN.insertBefore(document.createElement("textend"), val.cN.nextSibling);
                }
                else{
                    val.pN.appendChild(document.createElement("textend"));
                }
            })
        }  
        if(stoppedNode) {
        	returnVal = returnVal || {};
        	returnVal.stop = true;
        }
        if(helperNode) {
            if(options.type) {
                helperNode._helpers[options.itemIndex] = updateHelpers;
                if(templateDepthHandlingNeeded) {
                    content = constr.createDocFragment1(content);  
                }
                return content;
            } else {
                helperNode._helpers = helperNode._helpers || [];
                helperNode._helpers.$push.apply(helperNode._helpers, updateHelpers);
                if(templateDepthHandlingNeeded) {
                    content = constr.createDocFragment1(content);  
                }
                return content;
            }
        }
        this.executeBlockHelpers(updateHelpers);
        if(templateDepthHandlingNeeded) {
            content = constr.createDocFragment1(content);  
        }
        return content;
    }

    executeBlockHelpers(updateHelpers, node) {
	    for(let i=0;i<updateHelpers.length;i++) {
            var lastNode = updateHelpers[i].lastNode;
            var parentNode = lastNode.parentNode; 
                
            if(lastNode._placeHolder) {
                lastNode = lastNode._placeHolder;
                parentNode = lastNode.parentNode;
            }
            //parentNode = updateHelpers[i].lastNode.parentNode || updateHelpers[i].lastNode._placeHolder.parentNode;
            _LC.insertBeforeNative(parentNode, updateHelpers[i].toAppendMain, lastNode);
            updateHelpers[i] = updateHelpers[i].lastNode;
	    		// updateHelpers[i].lastNode.parentNode.insertBefore(updateHelpers[i].toAppendMain, updateHelpers[i].lastNode);
	    		// updateHelpers[i] = updateHelpers[i].lastNode;
	    		//updateHelpers[i]._parentIf = node;
//	    		if(!updateHelpers[i]._cx && node) {
//	    			updateHelpers[i]._cx = node._cx;
//	    		}
	    }	
    }

    updateBlockHelpers(updateHelpers,contextSwitchInfo){
        for(let i=0;i<updateHelpers.length;i++) {
            switch(updateHelpers[i].getAttribute('is')) {
            case "f" :
                this.updateForHelper(updateHelpers[i], {"type" : "default"},contextSwitchInfo);
                break;
            case "e" : 
                this.updateSwitchHelper("e",updateHelpers[i],contextSwitchInfo);
                break;
            case "fI" : 
                this.updateForInHelper(updateHelpers[i] , {"type" : "default"},contextSwitchInfo);
                break;
            case "s" :
                this.updateSwitchHelper("s",updateHelpers[i],contextSwitchInfo);
                break;
            case "cM" : 
                this.updateDynamicComponent(updateHelpers[i], false, contextSwitchInfo);
                break;
            case "i" : 
//              this.updateYield(updateHelpers[i], false, contextSwitchInfo);
                break;
            case "yield" : 
            case "r" : 
                if(contextSwitchInfo) {
                    updateHelpers[i]._cx = contextSwitchInfo;
                }
                break;
            default: 
                if(updateHelpers[i].tagName === "LYTE-YIELD") {
                    this.updateYield(updateHelpers[i], false, contextSwitchInfo);
                }
                
            }
         }
    }
    //AttributeChangedCallback will be called for the attributes mentioned in the this._observedAttributes array. 
    static get observedAttributes() {
    		let newArr = [];
            for(let i=0;i<this._observedAttributes.length;i++) {
                newArr[i] = _LC.String.dasherize(this._observedAttributes[i]);
            }
            let customPropHandlers;
            if(this.componentClass){
                customPropHandlers = this.componentClass._registryClass.customPropHandlers
            }else{
                customPropHandlers = _LC.customPropHandlers;
            }
            customPropHandlers.forEach(function(item,index) {
                newArr.$push(_LC.String.dasherize(item));
            })
            return newArr;	
    }

    //Callback from browser, whenever any of the observed attribute changes. 
    //We call the component set, in order to affect the related changes. 
    attributeChangedCallback(attr, oldValue, newValue) {
        this._attributeChangedCallback(attr, oldValue, newValue);
    }
    _attributeChangedCallback(attr, oldValue, newValue){
        if(!this._registryClass || !this.$registry.registeredComponents[this.localName]) {
            return;
        }
        let constr = this.constructor;
       	if((constr._observedMethodAttributes && constr._observedMethodAttributes[attr]) || this.__lyteIgnore) {
   		 	return;
    	}
        let actualAttr = _LC.String.toCamelCase(attr);
        let isCustomProp = this.component._registryClass.customPropHandlers.indexOf(actualAttr);
        if(isCustomProp !== -1) {
            let propValue = this.component._registryClass.customPropHandlers[isCustomProp];
            let lyteProps = newValue;
            if(lyteProps) {
                try{
                    lyteProps = JSON.parse(lyteProps);
                    for(let key in lyteProps) {
                        let actKey = propValue + _LC.String.upperCaseFirstLetter(key);
                        this.set(actKey, lyteProps[key]);
                    }
                } catch (e) {
                    //@Slicer.developmentStart
                    _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error("LC001", attr, this.localName);
                    //@Slicer.developmentEnd
                }
            }
            return;
        }
        if(oldValue === newValue) {
            return;
        }
        var attrNode = this.attributes.getNamedItem(attr);
        if(attrNode) {
            if(attrNode.__lyteIgnore) {
                this.attributes.getNamedItem(attr).__lyteIgnore = false;
                return;    
            }
        } else if(this["__"+attr]) {
            this["__"+attr] = false;
            return;
        }
        let compInstance = this.component;
        let dataType = compInstance.__data[actualAttr].type;
        if(dataType !== "string") {
        	let obj = {"attr" : attr, "tagName" : this.tagName};
        	newValue = _LC.typeCast(newValue, dataType, obj);
        	if(obj.isError) {
                //@Slicer.developmentStart
        		_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.warn(
                    "data type of the value provided for attribute "+attr+ " of " + this.tagName + " is not valid"
                );
                //@Slicer.developmentEnd
        		return;
        	}
        }
        let compData = compInstance.data;
        if(compData[actualAttr] !== newValue) {
            // Null check is done because when we do a removeAttribute directly on a component, the corresponding value expected is that of undefined and not null.
            this.set(actualAttr, newValue === null ? undefined: newValue);
        } else {
            _LC.clearError(compData, actualAttr);
        }
    }

    //Used to remove helpers of specific index in a for helper. 
    removeHelpersSpecificIndex(node, index,totalProms,fakeRemove,previousPromise) {
        if(node.hc){
            fakeRemove = true;
        }
        if(node._helpers[index]) {
            for(let j=0;j<node._helpers[index].length;j++) {
                    this.removeHelpers(node._helpers[index][j],undefined,undefined,totalProms,fakeRemove,previousPromise);
            }
        }
        let directiveObj = this.getDirectiveObj();
        if(directiveObj && node.hc && node._forContent[index] && node._specialNodes){
            directiveObj.removeForIndexContent(this,node,totalProms,previousPromise,index);
        }else if(node._forContent[index]) {
            if(!fakeRemove){
                // this.rmOtherNodes(node,node._forContent[index],totalProms);
                // if(node._helpers[index]) {
                //     for(let j=0;j<node._helpers[index].length;j++) {
                //         directiveObj.removeFromDomNormal(node._helpers[index][j]);
                //     }
                // }
                if(node._forContent[index]) {
                    for(let i=0;i<node._forContent[index].length; i++ ) {
                        node._forContent[index][i].remove();
                    }
                }
            }
            var self = this;
            Object.keys(node._items[index]._dynamicProperty).forEach(function(key) {
                node._dynProps[key]--;  
                if(!node._dynProps[key]) {
                    let prop  = self.getProperty(key);
                    if(prop._helperNodes) {
                        prop._helperNodes[delStr](node);
                    }
                }
            });
            node._items[index] = {"_dynamicProperty" : {}, "itemProperty" : {}, "indexProperty": {}};
        }
    }
    //Used to remove all the helpers within an helper. 
    removeHelpers(node, update, direct,totalProms,fakeRemove,previousPromise) {
        
        if(!direct) {
            node.remove();
            var helpersObj = node.getAttribute("is") === "component" ? this.__dc : this.__h;
            let nodeId = node.__lyteId;
            delete helpersObj[nodeId];
        }
        if(direct && node.hc){
            fakeRemove = true;
        }
        var del = "delete";
        let parent;
        var contextSwitchArray = [];
        let directiveObj = this.getDirectiveObj();
        _LC.adCx(node, contextSwitchArray);
        if(node._forContent) {
            if(node.getAttribute("is") === "for") {
        	if(node._helpers) {
                for(let i=0;i<node._helpers.length;i++) {
                    for(let j=0;j<node._helpers[i].length;j++) {
                            this.removeHelpers(node._helpers[i][j],undefined,undefined,totalProms,fakeRemove,previousPromise);
                    }
                    directiveObj && directiveObj.checkFakeForAndRemove(fakeRemove,node,i);
                }
            }
            if(directiveObj){
                directiveObj.removeForContent(this,direct,fakeRemove,node,totalProms);
            }else{
                _LC.removeForContent(node);
            }
            let key = node.getAttribute("item");
            if(node._items.length) {
                let prop = node._items[0].itemProperty;
                for(let i=0;i<node._items.length;i++) {
                    let dynProp = node._items[i]._dynamicProperty;
                    for(let dP in dynProp) {
                        let property = this.getProperty(dP); 
                        if(property._helperNodes){
                            property._helperNodes[del](node);                    
                        }
                    }    
                }
                if(prop) {
                    for(let i=0;i<node._items.length;i++) {
                        this.removeBindings({[key] : node._items[i].itemProperty}, {[key] : node._attributes.items[i]});
                    }
                }
            }
            if(!update) {
            	if(node._actualBinding) {
            		if(node._attributes.items && node._attributes.items._bindings && node._actualBinding._createdBinding) {
                        node._attributes.items._bindings[del](node._actualBinding);
                    } 
                    if(node._actualBinding._forHelpers) {
                        node._actualBinding._forHelpers[del](node);
                    }
                    var multiplePrpty = node._removedAttributes.items._multipleProperty;
                    if(node._removedAttributes && node._removedAttributes.items && !node._removedAttributes.items.helperValue && multiplePrpty && multiplePrpty[0].actProp._forHelpers) {
                    	multiplePrpty[0].actProp._forHelpers[del](node);
                    }
            	}
            }
            node._items = [];
        } else {
        	if(node._helpers) {
                let keys = Object.keys(node._helpers);
                for(let i=0;i<keys.length;i++) {
                    for(let j=0;j<node._helpers[keys[i]].length;j++) {
                        this.removeHelpers(node._helpers[keys[i]][j],undefined,undefined, totalProms, fakeRemove, previousPromise);
                    }
                    directiveObj && directiveObj.checkFakeForAndRemove(fakeRemove,node,keys[i]);
                }
            }
            if(directiveObj){
                directiveObj.removeForInContent(this,direct,fakeRemove,node,totalProms);
            }else{
                _LC.removeForInContent(node);
            }
            let items = node._items;
            let key = node.getAttribute("key");
            for(let index in items){
                let item = items[index];
                let prop = item.itemProperty;
                let dynamicProp = item._dynamicProperty;
                for(let dP in dynamicProp) {
                    let property = this.getProperty(dP); 
                    if(property._helperNodes){
                        property._helperNodes[del](node);                    
                    }
                }
                if(prop) {
                    this.removeBindings({[key] : node._items[index].itemProperty}, {[key] : node._attributes.object[index]});
                }

            }
            if(!update) {
                if(node._actualBinding) {
                    if(node._attributes.object && node._attributes.object._bindings && node._actualBinding._createdBinding) {
                        node._attributes.object._bindings[del](node._actualBinding);
                    } 
                    if(node._actualBinding._forHelpers) {
                        node._actualBinding._forHelpers[del](node);
                    }
                }
                var multiplePrpty = node._removedAttributes.object._multipleProperty;
                if(node._removedAttributes.object && !node._removedAttributes.object.helperValue && multiplePrpty && multiplePrpty[0].actProp._forHelpers) {
                    multiplePrpty[0].actProp._forHelpers[del](node);
                }
                if(node._propBindingObject && node._attributes.object && node._attributes.object._bindings) {
                    node._attributes.object._bindings[del](node._propBindingObject);
                }
            }
            node._items= {};
          }
        } else if(node._caseContent || node._yieldContent) {
        	if(node._helpers) {
                for(let j=0;j<node._helpers.length;j++) {
                    this.removeHelpers(node._helpers[j],undefined,undefined, totalProms, fakeRemove, previousPromise);
                }
                directiveObj && directiveObj.checkFakeIfAndRemove(fakeRemove,node);
            }
            if(directiveObj){
                directiveObj.removeIfContent(this,direct,fakeRemove,node,totalProms,previousPromise,this);
            }else{
                _LC.removeIfContent(node)
                _LC.removeIfCaseContent(this,node,direct);
                if(node._yieldContent){
                    for(let i=0;i<node._yieldContent.length; i++ ) {
                        node._yieldContent[i].remove();
                    }
                }
            }
            if(node._caseContent){
                for(let key in node._dynamicProperty) {
                    if(node._dynamicProperty[key].isActualNode) {
                        node._dynamicProperty[key].isActualNode._helperNodes[del](node);
                    }else {
                        let helperNodes = this.getProperty(key)._helperNodes;
                        if(helperNodes) {
                            helperNodes[del](node);
                        }
                    }
                }
            }
            node._dynamicProperty = {};
            let viewObj = this.getViewObj()
            if(viewObj){
                viewObj.rmCaseContent(node)
            }
        } else if(node._renderedComponent) {
            for(let key in node._renderedComponent) {
                if(node._renderedComponent[key]) {
                    var renderedComponent = node._renderedComponent[key];
                    if(directiveObj && direct && renderedComponent._hooksPresent){
                        directiveObj.removeRenderedComponent(comp,node,previousPromise);
                    }else{
                        if(!fakeRemove){
                            node._renderedComponent[key].remove();
                            node._renderedComponent[key] = null;
                        }
                    }
                }
            }
        }
          _LC.rmCx(node, contextSwitchArray);
          if(!fakeRemove){
            node._helpers = [];
          }
    }
    updateYield(node, update, contextSwitchInfo,helperNode) {
        let shadowObj = this.getShadowObj();
        let directiveObj = this.getDirectiveObj();
        let app = this.component.getAppOrAddon();
        if(directiveObj){
            node._childPromise = [];
            node._specialNodes = [];
        }
        let constr = this.constructor;
        if(!node._callee) {
            node._callee = this;
        }        
        let toAppend = node._callee._yields[this.getYieldName(node)];
        if(!toAppend) {
        	return;
        }
        node._registerYield = toAppend;
        //ADded now
        let parentScope = toAppend._callee || node._callee._callee;
        if(!parentScope) {
            // if(Lyte._ms) {
            //     var div = createElement("div");
            //     div.innerHTML = toAppend.outerHTML;
            //     // if(Lyte._ie){
            //     //     div.firstChild.innerHTML = toAppend.innerHTML;
            //     //  }
            //     var content1 = div.childNodes[0];
            //     constr.splitTextNodes(content1);
            //     content1 = constr.createDocFragment1(content1);
            //     if(shadowObj && directiveObj && directiveObj.getTransitionArg(this,"shadow-supported") && directiveObj.getTransitionArg(this,"shadow") == true){
            //         shadowObj.updateYield(this,node,toAppend,content1);
            //     }else if(content1){
            //         node.appendChild(content1);
            //     }
            //     else{
            //         node.appendChild(toAppend.content.cloneNode(true, "lyte"));
            //     }
            // } else {
                 if(shadowObj && directiveObj && directiveObj.getTransitionArg(this,"shadow-supported") && directiveObj.getTransitionArg(this,"shadow") == true){
                    shadowObj.updateYield(this,node,toAppend);
                }else{
                    node.appendChild(toAppend.content.cloneNode(true, "lyte"));
                }
            // }
            
            node._helpers = [];
            return;
        }    
	    if(!toAppend._callee) {
    		toAppend._callee = parentScope;
    	} 
        node._dynamicProperty = node._dynamicProperty || {};
        //set values from child component. 
        let obj = {},contextSwitchingArray = {},self = this,contextSwitchArray = [];
        _LC.adCx(toAppend, contextSwitchArray);
        Object.keys(node._properties).forEach(function(key) {
            contextSwitchingArray[key] = {};
            contextSwitchingArray[key].value = parentScope.component.data[key];
            contextSwitchingArray[key].property = parentScope._properties[key];
            parentScope._properties[key] = node._properties[key];
            parentScope.component.data[key] = node.component.data[key];
        }); 
        // htA -> helpertemplateApplied
        if(toAppend._ht && !toAppend._htA) {
            toAppend._htA = true;
            toAppend.content.append(toAppend._ht.content.cloneNode(true));
        }
        let yieldComp = node._callee;
        let content = parentScope.renderNodes(toAppend, toAppend._dynamicNodes || [], node, {"node" : node}, true, undefined, toAppend._tC , yieldComp);
        directiveObj && directiveObj.updateSpecialNodeRef(this,node,toAppend,helperNode);
        if(!_LC.directive.getTransitionArg(node,"unbound")) {
        	_LC.establishBindings(node._properties, node.component.data);
        }else if(!node.component.data.lyteUnbound && !_LC.migratedv2(app)) {        	
        	_LC.establishBindings(node._properties, node.component.data);
        }
        parentScope.executeBlockHelpers(node._helpers);
        Object.keys(node._properties).forEach(function(key) {
            parentScope.component.data[key] = contextSwitchingArray[key].value;
            parentScope._properties[key] = contextSwitchingArray[key].property;
        });
        _LC.rmCx(toAppend, contextSwitchArray); 
        if(shadowObj  && _LC.directive.getTransitionArg(this,"shadow-supported") && _LC.directive.getTransitionArg(this,"shadow") == true){
            shadowObj.updateYield(this,node,toAppend,content,parentScope);
        }else if(content){
            node.appendChild(content);
        }
        else{
            node.appendChild(toAppend.content.cloneNode(true, "lyte"));
        }
    }
    //upddc
    updateDynamicComponent(node, update, contextSwitchInfo, establishBindings) {
    	let returnVal;
        // let registryClass = this._registryClass;
        let directiveObj = this.getDirectiveObj();
        node._callee = this;
        let keepAlive = node.hasAttribute("lyte-keep-alive");
        if(!node._renderedComponent) {
            node._renderedComponent = {};
            let id = _LC.createLyteId(this);
            this.__dc[id] = node;
            node.__lyteId = id;
        }
        
        node._cx = contextSwitchInfo || node._cx;
        node._dynamicProperty = node._dynamicProperty || {};
        let componentName = node.getAttribute("component-name") || (node._attributes ? node._attributes["component-name"] : undefined);
        let componentClass =  node._attributes ? node._attributes["component-class"] : undefined;
        let registryInstance = (node._initProperties ? node._initProperties.lyteRegistry : undefined) || (node._attributes ? node._attributes["lyte-registry"] : undefined);
        let regClass;
        if(!componentName && !componentClass) {
            return;
        }
        //@Slicer.developmentStart
        // else if(componentName){
        //     ComponentError.warn("LC016",componentName);
        // }
        //@Slicer.developmentEnd
        else if(componentClass){
            componentName = componentClass._compName;
            regClass = componentClass._registryClass
        }
        if(directiveObj){
            node._childPromise = []
            directiveObj.checkOngoingPromises(node);
            node._totalPromise = [];
        }
        let component,newComponent = false;
        if(update) {
        	if(keepAlive) {
        		_LC.ignoreDisconnect = true;
        	}
            if(node._renderedComponent[node._currentComponent]) {
                var activeComponent = node._renderedComponent[node._currentComponent];
                if(activeComponent){
                    if(directiveObj && activeComponent._specialNodes && activeComponent._specialNodes.length>0){
                        directiveObj.updateRenderedComp(this,activeComponent,node,keepAlive)
                    }else{
                        if(keepAlive){
                            _LC.hDiv.content.appendChild(activeComponent) 
                        }else{
                            activeComponent.remove();
                        }
                        
                    }
                }
            }
            _LC.ignoreDisconnect = false;
            if(!keepAlive) {
                node._dynamicProperty = {};
            }
            if(node._renderedComponent[componentName] && keepAlive) {
                component = node._renderedComponent[componentName];
            } else {
                if(registryInstance){
                    component = registryInstance.render(componentClass,{});
                }else if(regClass && regClass._instanceList && regClass._instanceList[0]){
                    component = regClass._instanceList[0].render(componentClass,{});
                }
                else{
                    component = createElement(componentName);
                }
                newComponent = true;
            }
        }  else {
            // var flag = false;
            // if(node._initProperties && node._initProperties.lyteRegistry){
            //     _LC.setCurrentRegistryIns(node._initProperties.lyteRegistry);
            //     flag = true;
            // }
            // component = createElement(componentName);
            // if(flag){
            //     _LC.setCurrentRegistryIns(undefined);
            // }
            if(registryInstance){
                component = registryInstance.render(componentClass,{});
            }else if(regClass && regClass._instanceList && regClass._instanceList[0]){
                component = regClass._instanceList[0].render(componentClass,{});
            }
            else{
                component = createElement(componentName);
            }
            newComponent = true;
        }
        if(!keepAlive && node._currentComponent) {
            node._renderedComponent[node._currentComponent] = null;
        }
        if(newComponent) {
//          let componentData = {};
            for(let i=0;i<node.attributes.length;i++) {
                if(node.attributes[i].name !== "is" && node.attributes[i].name !== "component-name" && node.attributes[i].name !== "component-class" && node.attributes[i].name !== "lyte-keep-alive" && !node.attributes[i].name.startsWith("@")) {
                    component.setAttribute(node.attributes[i].name, node.attributes[i].value);
                }
            }
//          componentData = component._attributes;
            if(node._attributes) {
                for(var key in node._attributes) {
                    if(key == "$data"){
                        component.setData(node._attributes[key]);
                    }
                	else if(key!== "component-name" && key!== "component-class") {
                		component.setData(_LC.String.toCamelCase(key), node._attributes[key]);
                	}
                }
            }
            let toAppend = this.renderNodes(node, node._dynamicNodes, node, undefined, establishBindings, undefined, node._tC);
            component.appendChild(toAppend);
            if(directiveObj && activeComponent){
                component._dependentPromise = activeComponent._totalPromise;
            }
            component._toRegEvnts = node._toRegEvnts;
        }
        if(directiveObj){
            returnVal = directiveObj.updateDynamicComp(this,update,component,activeComponent,node,newComponent);
        }else{
            if(!update) {
                returnVal = {"toAppendMain" : component, "lastNode" : node};
            } else {
                _LC.ignoreDisconnect = true;
                _LC.insertBeforeNative(node.parentNode,component, node);
                _LC.ignoreDisconnect = false;
            }
        }
        component._dynComp = true;
        node._renderedComponent[componentName] = component;
        node._currentComponent = componentName;
	    component._callee = this;
        
	    component._actions = node._actions;
        component.setMethods(node._initMethods);
        component._attributeDetails = node._attributeDetails;
        component._boundEvents = node._boundEvents;
        component._cx = node._cx;
        return returnVal;
    }
    // It constructs/updates the for helper. 
    updateForHelper(node, options, contextSwitchInfo, establishBindings, staticTempArr,yieldComp) {
        let directiveObj = this.getDirectiveObj();
        directiveObj && directiveObj.instanciateForPromises(node);
        let app = this.component.getAppOrAddon();
        if(node.tagName !== "TEMPLATE") {
            Object.keys(node).forEach(function(item) {
            	if(item !== "innerHTML" && item !== "innerText") {
	                node._origTemplate[item] = node[item];            	
            	}
            });
            // if(Lyte._ie) {
            // 	var div = createElement("div");
            //     div.innerHTML = node._tC;
            //     node._origTemplate.innerHTML = div.children[0].innerHTML;
            //     this.constructor.splitTextNodes(node._origTemplate);
            //     if(node.hasAttribute("depth")) {
            //         node._origTemplate.setAttribute("depth", node.getAttribute("depth"));    
            //     }
            // }
            let placeHolder = node._origTemplate._placeHolder = document.createTextNode("");
            node._origTemplate.setAttribute("item", node.getAttribute("item"));
            node._origTemplate.setAttribute("index", node.getAttribute("index"));
            
            if(!_LC.migratedv2(app) && node.hasAttribute("unbound")) {
                //What if unbound is dynamic attribute ? It will be set in _attributes of node._origTemplate -> So No worries (y)
                node._origTemplate.setAttribute("unbound", "true");
            }
            //node.replaceWith(node._origTemplate._placeHolder);
            _LC.replaceWithPf(node, node._origTemplate._placeHolder);
            // node = _LC.replaceWithOrigTemplate(node)
            node = node._origTemplate;
            node.setAttribute("is", "for");
            _LC.apdNode(node, this);
            placeHolder._helper = node;
            
        } else if(!node._placeHolder){
            var emptyTextNode;
            
                emptyTextNode = document.createTextNode("");
                
            //node.replaceWith(emptyTextNode);
            _LC.replaceWithPf(node, emptyTextNode)
            node._placeHolder = emptyTextNode;
            emptyTextNode._helper = node;
            _LC.apdNode(node, this);
        }
        node._sta = node._sta || staticTempArr;
        let callee = this;
        node._callee = this;
        node._attributes = node._attributes || {};
        if(options.type === "update" && node._currentItems === node._attributes.items) {
            return {};
        }
        node._cx = contextSwitchInfo || node._cx;
        let  indexValue = node.getAttribute("index");
        if(!indexValue) {
            node.setAttribute("index", "index");
            indexValue = "index";
        }
        let itemValue = node.getAttribute("item");
        if(!itemValue) {
            node.setAttribute("item", "item");
            itemValue = "item";
        }
        let initialItemValue = callee.component.data[itemValue],initialIndexValue = callee.component.data[indexValue];
        let initialItemProp = callee._properties[itemValue],initialIndexProp = callee._properties[indexValue];
        callee._properties[itemValue] = callee._properties[indexValue] = {};
        let items = node._attributes.items,content = node.content,dynamicNodes = node._dynamicNodes,lastNode = node;
        if(!node._items) {
            node._items = [];
        }
        node._dynProps = node._dynProps || {};
        let lastIndexForIteration;
        let firstIndexForIteration;
        let firstIndex = options.firstIndex;
        let secondIndex = options.secondIndex;
        let thirdIndex = options.thirdIndex;
        var totalNodeIndex = firstIndex + secondIndex;
        var updateIndexProperty = true;
        var indexPropertyStartIndex = 0;
        if(options) {
            switch(options.type) {
            case "remove"  :{
                lastIndexForIteration = firstIndex;
                indexPropertyStartIndex = firstIndex;
                let totalProms = node._totalPromise;
                for(let i=secondIndex; i>0; i--) {
                    let ind = firstIndex + i-1;
                    directiveObj && directiveObj.onGoingForPromise(node,ind)
                    this.removeHelpersSpecificIndex(node, ind, totalProms, undefined,totalProms && totalProms.length ? totalProms[totalProms.length-1] : undefined);
                }
                //ln
                /*for(let i=(firstIndex)?firstIndex-secondIndex:firstIndex;i<node._items.length;i++) {
                    let forItem = node._items[i].itemProperty;
                    if(forItem._helperNodes){
                        for (var item of forItem._helperNodes){
                            let ind = item._cx.itemIndex;
                            item._cx.itemIndex = (ind)? ind- secondIndex : ind;
                        }
                    }
                }*/
                for(let i=firstIndex + secondIndex; i<node._items.length;i++) {        
                    node._items[i]._cx.itemIndex = node._items[i]._cx.itemIndex - secondIndex;        
                }
                node._items.$splice(firstIndex, secondIndex);
                node._helpers.$splice(firstIndex, secondIndex);
                node._forContent.$splice(firstIndex, secondIndex);
                node._specialNodes && node._specialNodes.$splice(firstIndex, secondIndex);
                break;
            }
            case "insert" : {
                firstIndexForIteration = firstIndex;
                lastIndexForIteration = secondIndex;
                indexPropertyStartIndex = firstIndex + secondIndex;
                if(node._forContent[firstIndex]) {
                    lastNode = node._forContent[firstIndex][0];
                }
                let newArr = [], newObj = [], newArr1 = [];
                for(let v=secondIndex, k=firstIndex;v>0;v--, k++) {
                    newArr.$push([]);
                    newObj.$push({});
                    newArr1.$push([]);
                }
                node._helpers.$splice.apply(node._helpers, [firstIndex, 0].$concat(newArr));
                node._items.$splice.apply(node._items, [firstIndex, 0].$concat(newObj));
                //ln
//                  for(let i=firstIndex + secondIndex;i<node._items.length;i++) {
//                      let forItem = node._items[i].itemProperty;
//                      for (var item of forItem._helperNodes){
//                          item._cx.itemIndex = item._cx.itemIndex + secondIndex;
//                      }
//                  }
                for(let i=firstIndex + secondIndex; i<node._items.length;i++) {
                    node._items[i]._cx.itemIndex = node._items[i]._cx.itemIndex + secondIndex;
                }
                node._forContent.$splice.apply(node._forContent, [firstIndex, 0].$concat(newArr1));
                node._specialNodes && node._specialNodes.$splice.apply(node._specialNodes,  [firstIndex, 0].$concat(newArr1));
            }
                break;
            case "replace" : {
                firstIndexForIteration = firstIndex;
                lastIndexForIteration = secondIndex;
                indexPropertyStartIndex = firstIndex + secondIndex;
                let totalProms = node._totalPromise;
                directiveObj && directiveObj.onGoingForPromise(node,firstIndex)
                this.removeHelpersSpecificIndex(node, firstIndex, totalProms, undefined, totalProms && totalProms.length ? totalProms[totalProms.length-1] : undefined);
                let toAppendMain = createDocFragment();
                if(node._forContent[firstIndex+1]) {
                    lastNode = node._forContent[firstIndex+1][0];
                }
                let newArr = [], newObj = [], newArr1 = [];
                for(let v=secondIndex, k=firstIndex;v>0;v--, k++) {
                    newArr.$push([]);
                    newArr1.$push([]);
                    newObj.$push({});
                }
                node._helpers.$splice.apply(node._helpers,[firstIndex, 1].$concat(newArr));
                node._items.$splice.apply(node._items, [firstIndex, 1].$concat(newObj));
//                  for(let i=firstIndex + secondIndex;i<node._items.length;i++) {
//                      let forItem = node._items[i].itemProperty._forItem;
//                      forItem.itemIndex = forItem.itemIndex + secondIndex - 1 ;
//                  }
                for(let i=firstIndex + secondIndex; i<node._items.length;i++) {
                    node._items[i]._cx.itemIndex = node._items[i]._cx.itemIndex + secondIndex - 1;
                }
                node._forContent.$splice.apply(node._forContent, [firstIndex, 1].$concat(newArr1));
                node._specialNodes && node._specialNodes.$splice.apply(node._specialNodes,  [firstIndex, 1].$concat(newArr1));
                if(options.secondIndex == 1){
                    updateIndexProperty = false;
                }
                break;
            }
            case "splice" : {
                firstIndexForIteration = firstIndex;
                lastIndexForIteration = secondIndex;
                indexPropertyStartIndex = firstIndex + secondIndex;
                let totalProms = node._totalPromise;
                for(let i=thirdIndex;i>0;i--) {
                    let ind = i + firstIndex-1;
                    directiveObj && directiveObj.onGoingForPromise(node,ind)
                    this.removeHelpersSpecificIndex(node, ind, totalProms, undefined, totalProms && totalProms.length ? totalProms[totalProms.length-1] : undefined);
                }
                let toAppendMain = createDocFragment();
                if(node._forContent[firstIndex+thirdIndex]) {
                    lastNode = node._forContent[firstIndex+thirdIndex][0];
                }
                let newArr = [], newObj = [], newArr1 = [];
                for(let v=secondIndex, k=firstIndex;v>0;v--, k++) {
                    newArr.$push([]);
                    newArr1.$push([]);
                    newObj.$push({});
                }
                node._helpers.$splice.apply(node._helpers,[firstIndex, thirdIndex].$concat(newArr));
                node._items.$splice.apply(node._items, [firstIndex, thirdIndex].$concat(newObj));
//                  for(let i=firstIndex + secondIndex;i<node._items.length;i++) {
//                      let forItem = node._items[i].itemProperty._forItem;
//                      forItem.itemIndex = forItem.itemIndex + secondIndex - 1 ;
//                  }
                for(let i=firstIndex + secondIndex; i<node._items.length;i++) {
                    node._items[i]._cx.itemIndex = node._items[i]._cx.itemIndex + secondIndex - thirdIndex;
                }
                node._forContent.$splice.apply(node._forContent, [firstIndex, thirdIndex].$concat(newArr1));
                node._specialNodes && node._specialNodes.$splice.apply(node._specialNodes,  [firstIndex, thirdIndex].$concat(newArr1));
                if(options.secondIndex == options.thirdIndex){
                    updateIndexProperty = false;
                }
                break;
            }
            break;
            case "update" : 
            {
                let key = node.getAttribute("item");
//                  this.removeHelpers(node, true);
                let totalProms = node._totalPromise;
                for(let i=node._items.length-1;i>=0;i--) {
                    directiveObj && directiveObj.onGoingForPromise(node,i)
                    this.removeHelpersSpecificIndex(node, i, totalProms, undefined,totalProms && totalProms.length ? totalProms[totalProms.length-1] : undefined);
                }
//                  if(node._attributes.items) {
//                      for(let i=0;i<node._attributes.items.length && node._items[i];i++) {
//                          _LC.removeSelectedBindingDeep(node._items[i].itemProperty[key], node._attributes.items[i]);
//                      }
//                  }
                node._items = [];
        }
            case "default" : 
            {
                node._forContent = [];
                if(directiveObj){
                    node._specialNodes = [];
                }
                node._helpers = [];
                firstIndexForIteration = 0;
                lastIndexForIteration = items? items.length : 0 ;
                indexPropertyStartIndex = items? items.length : 0 ;
            }
            //@Slicer.developmentStart
            break;
            default: 
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error("LC009","updateForHelper")
            //@Slicer.developmentEnd
            }
        }
        if(!lastNode) {
            lastNode = node;
        }
        if(lastNode != node && node._helpers.length > 0  && (options.type == "insert" ||"replace"|| 0) ){
            lastNode = _LC.findLastNodeL(lastNode,totalNodeIndex,node);
        }
        let returnVal;
        var localUnbound = false;
        var initialUnbound = _LC.unbound;
        if((node.hasAttribute("unbound") || (node._attributes && node._attributes.unbound && node._attributes.unbound !== "false")) && !_LC.migratedv2(app)) {
            localUnbound = true;
            _LC.unbound = true;
        }
        if((!node._fRender && (node.getAttribute("unbound") == "lyteFastRender" || (node._attributes && node._attributes.unbound == "lyteFastRender"))) && !_LC.migratedv2(app)) {
            node._fRender = true;
        }
        let unboundDirective = _LC.directive.getTransitionArg(node,"unbound");
        if(unboundDirective){
            if(unboundDirective == "lyteFastRender"){
                //@Slicer.developmentStart
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error("LC010", _LC.errorNodeDetails(node))
                //@Slicer.developmentEnd
            }else{ // if(unboundDirective !== "false")
                localUnbound = true;
                _LC.unbound = true;
            }
        }
        let fastDirective = _LC.directive.getTransitionArg(node,"turbo");
        if(fastDirective){
            if(!node._fRender ){//&& fastDirective !== "false"
                node._fRender = true;
                localUnbound = true;
                _LC.unbound = true;
            }
        }
        node._currentItems = items;        
        if((lastIndexForIteration - firstIndexForIteration) > 0) {
            if(node._ht && !node._htA) {
                node.content.append(node._ht.content.cloneNode(true));
                node._htA = true;
            }
        }
        if(options.type !== "remove") {
            var totalString = "";
            var domArr = [];
            var toAppendMain = createDocFragment();
            for(let k = firstIndexForIteration,v=lastIndexForIteration;v>0; k++, v--) {
                node._helpers[k] = [];
                if(directiveObj){
                    node._specialNodes[k] = [];
                }
                node._items[k] = {"_dynamicProperty" : {}, "itemProperty" : {}, "indexProperty": {}};
                callee.component.data[itemValue] = items[k];
                callee.component.data[indexValue] = k;
                var cacheData = {};
                cacheData[itemValue]={}
                cacheData[itemValue]._data = items[k];
                cacheData[itemValue]._dyn = [itemValue];
                cacheData[indexValue]={}
                cacheData[indexValue]._data = k;
                cacheData[indexValue]._dyn = [indexValue];
                callee._properties[itemValue] = {};
                callee._properties[indexValue] = {};
                let optns = {"itemValue" : itemValue, "itemIndex" : k, "type" : "for", "node" : node, "indexValue" : indexValue};
//                  defProp(callee._properties[itemValue], '_forItem', {
//                      enumerable: false, 
//                      writable: true, 
//                      configurable: true, 
//                      value : optns
//                  });
                node._items[k]._cx = optns;
                let breakCheck = {};
                let toAppend;
                if(node._fRender) {
                    let fastObj = this.getFastObj();
                    let str = fastObj.renderFast(dynamicNodes, node._sta, this.component, undefined, this);
                    totalString = totalString + str;
                    // var template = document.createElement("template");
                    // template.innerHTML = str;
                    // toAppend = template.content;
                } else {
                    dynamicNodes._cache = cacheData;
                    toAppend = this.renderNodes(node.hasAttribute("depth") ? node._depthTemp : node, dynamicNodes, node, optns, establishBindings, breakCheck, node._tC,yieldComp);
                }
                //to bind in ssr components
                
                let dynProps = Object.keys(node._items[k]._dynamicProperty);
                for(let d=0;d<dynProps.length;d++) {
                    let key = dynProps[d];
                    node._dynProps[key] ? node._dynProps[key]++ : (node._dynProps[key] = 1);    
                }
                node._items[k].itemProperty = this.getProperty(itemValue);
                node._items[k].indexProperty = this.getProperty(indexValue);    
//                  if(options.type !== "default") {
                if(!_LC.unbound) {
                	_LC.establishBindings({[itemValue] : node._items[k].itemProperty},{[itemValue]:node._attributes.items[k]});
                }
//                  }
                if(!node._fRender){
                    node._forContent[k] = Array.from(toAppend.childNodes);
                } else {
                    domArr.$push(node._forContent[k] = []);
                }
                //Needs to revisit this and make sure it happen within renderNodes function itself;
//                  if(options.type !== "update") {
                this.executeBlockHelpers(node._helpers[k], node);
                if(!node._fRender) {
                    toAppendMain.appendChild(toAppend);
                }
                if(breakCheck.stop) {
                    break;
                }
            }
            if(node._fRender) {
                var s = document.createElement("template");
                s.innerHTML = totalString;
                toAppendMain.appendChild(s.content);
                _LC.processAction(toAppendMain);
                var childrenArr;
                // if(Lyte._ie) {
                //     childrenArr = [];
                //     var childNodes = toAppendMain.childNodes;
                //     for(var i=0;i<childNodes.length;i++) {
                //         if(childNodes[i].nodeType == 1) {
                //             childrenArr.$push(childNodes[i]);
                //         }
                //     }
                // } 
                // else {
                    childrenArr = toAppendMain.children;
                // }
                for(var i=0;i<domArr.length;i++) {
                    domArr[i].$push(childrenArr[i]);
                }
                requestAnimationFrame(function() {
                    requestAnimationFrame(function() {
                        _LC.callCC();
                    });
                });
            }
            //Provided so that before appending the component to DOM it is reset to previous value
            _LC.unbound = initialUnbound;
            if(options.type === "default") {
                returnVal = {"toAppendMain" : toAppendMain, "lastNode" : lastNode};
            } else {
                if(directiveObj){
                    var dependentPromises = [];
                    directiveObj.getAllDependentPromises(this,dependentPromises,node._totalPromise);
                    directiveObj.insertInDom(this,lastNode._placeHolder,lastNode,toAppendMain,undefined,undefined,dependentPromises);
                }else{
                    _LC.insertInDom(lastNode._placeHolder,lastNode,toAppendMain);
                }
            }
            if(!localUnbound && node._removedAttributes && node._removedAttributes.items && !node._removedAttributes.items.helperValue && node._removedAttributes.items._multipleProperty && node._removedAttributes.items._multipleProperty[0]) {
            	_LC.establishBindings({"items" : node._removedAttributes.items._multipleProperty[0].actProp}, {"items" : items});
            }
        }
        _LC.unbound = initialUnbound;
        if(updateIndexProperty){
            for(let i=indexPropertyStartIndex; i<node._items.length; i++) {
                if(node._items[i].indexProperty) {
                    _LC.affectChanges(node._items[i].indexProperty);
                }
            }
        }
        callee.component.data[itemValue] = initialItemValue;
        callee.component.data[indexValue] = initialIndexValue;
        callee._properties[itemValue] = initialItemProp;
        callee._properties[indexValue] = initialIndexProp;
        node._currentItems = items;
        return returnVal;
    }
    //It constructs/updates forIn Helper.
    //updFIH
    updateForInHelper(node, options, contextSwitchInfo, establishBindings,yieldComp) {
        let directiveObj = this.getDirectiveObj();
        directiveObj && directiveObj.instanciateForPromises(node);
        let app = this.component.getAppOrAddon();
        if(node.tagName !== "TEMPLATE") {
            Object.keys(node).forEach(function(item) {
                if(item !== "innerHTML" && item !== "innerText") {
	                node._origTemplate[item] = node[item];            	
            	}
            });
            // if(Lyte._ie) {
            // 	var div = createElement("div");
            //     div.innerHTML = node._tC;
            //     node._origTemplate.innerHTML = div.children[0].innerHTML;
            //     this.constructor.splitTextNodes(node._origTemplate);
            //     if(node.hasAttribute("depth")) {
            //         node._origTemplate.setAttribute("depth", node.getAttribute("depth"));
            //     }
            // }
            let placeHolder = node._origTemplate._placeHolder = document.createTextNode("");
            node._origTemplate.setAttribute("key", node.getAttribute("key"));
            node._origTemplate.setAttribute("value", node.getAttribute("value"));
            if(node.hasAttribute("unbound") && !_LC.migratedv2(app)) {
                //What if unbound is dynamic attribute ? 
                node._origTemplate.setAttribute("unbound", "true");
            }
            
            //node.replaceWith(node._origTemplate._placeHolder);
            _LC.replaceWithPf(node, node._origTemplate._placeHolder)
            // node = _LC.replaceWithOrigTemplate(node)
            node = node._origTemplate;
            node.setAttribute("is", "forIn");
            _LC.apdNode(node, this);
            placeHolder._helper = node;
        } else if(!node._placeHolder){
            var emptyTextNode;
            
                emptyTextNode = document.createTextNode("");
                
            //node.replaceWith(emptyTextNode);
            _LC.replaceWithPf(node, emptyTextNode);
            node._placeHolder = emptyTextNode;
            _LC.apdNode(node, this);
            emptyTextNode._helper = node;
        }
        let callee = this;
        node._callee = this;
        node._attributes = node._attributes || {};
        if(options.type === "update" && node._currentObject === node._attributes.object) {
            return {};
        }
        contextSwitchInfo = contextSwitchInfo ? contextSwitchInfo : node._cx;
        node._cx = contextSwitchInfo;
        let key = node.getAttribute("key");
        if(!key) {
            key = "key";
            node.setAttribute("key", "key");
        }
        let value = node.getAttribute("value");
        if(!value) {
            value = "value";
            node.setAttribute("value", "value");
        }
        let initialKeyValue = callee.component.data[key];
        let initialValueValue = callee.component.data[value];
        let initialKeyProp = callee._properties[key];
        let initialValueProp = callee._properties[value];
        callee._properties[key] = callee._properties[value] = {};
        let object = node._attributes.object;
        let content = node.content;
        let dynamicNodes = node._dynamicNodes;
        let lastNode = node;
        let keysArray = [];
        if(!node._items) {
            node._items = {};
        }
        node._dynProps = node._dynProps || {};
        if(options) {
            switch(options.type) {
            case "delete"  :{
                let totalProms = node._totalPromise;
                directiveObj && directiveObj.onGoingForPromise(node,options.property)
                this.removeHelpersSpecificIndex(node, options.property, totalProms, undefined,totalProms && totalProms.length ? totalProms[totalProms.length-1] : undefined);
                var delIndex = node._keysArray.indexOf(options.property);
                if(delIndex > -1) {
                  node._keysArray.$splice(delIndex,1);
                }
                if(node._helpers) {
                    delete node._helpers[options.property];    
                }
                delete node._propBindingObject[options.property];
            }
            break;
            case "add" : {
                keysArray = [options.property];
                node._keysArray.$push(options.property);
            }
            break;
            case "update" : 
            {
                let totalProms = node._totalPromise;
                let keyObjArr = node._keysArray;
                for(let i=keyObjArr.length-1; i>=0; i--){
                    directiveObj && directiveObj.onGoingForPromise(node,keyObjArr[i])
                    this.removeHelpersSpecificIndex(node, keyObjArr[i], totalProms, undefined,totalProms && totalProms.length ? totalProms[totalProms.length-1] : undefined);
                }
                node._keysArray = keysArray = object ? Object.keys(object) : [];
                node._helpers = {};
                node._items = {};
                node._propBindingObject = {};
            }
            break;
            case "default" : 
            {
                node._forContent = {};
                if(directiveObj){
                    node._specialNodes = {};
                }
                node._helpers = {};
                node._keysArray = keysArray = object? Object.keys(object) : [];
//                  keysArray = Object.keys(object);

            }
            //@Slicer.developmentStart
            break;
            default: 
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error("LC009","updateForInHelper")
            //@Slicer.developmentEnd

            }
        }
        let returnVal;
        if(!object) {
            let toAppendMain = createDocFragment();
            if(options.type !== "default") {
            	_LC.insertBeforeNative(lastNode.parentNode,toAppendMain, lastNode);
            } else {
                returnVal = {"toAppendMain" : toAppendMain, "lastNode" : lastNode};
            }    
        }
        let localUnbound = false;
        let initialUnbound = _LC.unbound;
        if((node.hasAttribute("unbound") || (node._attributes && node._attributes.unbound)) && !_LC.migratedv2(app)) {
            localUnbound = true;
            _LC.unbound = true;
        }
        let unboundDirective = _LC.directive.getTransitionArg(node,"unbound")
        if(unboundDirective){
            localUnbound = true;
            _LC.unbound = true;
        }
        node._currentObject = object;
        if(keysArray.length && node._ht && !node._htA) {
            node.content.append(node._ht.content.cloneNode(true));
            node._htA = true;
        }
        if(object && options.type !== "remove") {
            var toAppendMain = createDocFragment();
            node._propBindingObject = node._propBindingObject || {};
            keysArray.forEach(function(itemKey, index, array) {
                node._helpers[itemKey] = [];
                if(directiveObj){
                    node._specialNodes[itemKey] = [];
                }
                node._items[itemKey] = {"_dynamicProperty" : {}, "itemProperty" : {}};
                callee.component.data[key] = itemKey;
                callee.component.data[value] = object[itemKey];
                callee._properties[key] = {};
                callee._properties[value] = {};
                var cacheData = {};
                cacheData[key] = {}
                cacheData[key]._data = itemKey;
                cacheData[key]._dyn = [key];
                cacheData[value] = {}
                cacheData[value]._data = object[itemKey];
                cacheData[value]._dyn = [value];
                let optns = {"itemIndex" : itemKey, "itemValue" : value, "keyValue" : key, "type" : "forIn", "node" : node};
                node._items[itemKey]._cx = optns;
                dynamicNodes._cache = cacheData;
                let toAppend = this.renderNodes(node.hasAttribute("depth") ? node._depthTemp : node, dynamicNodes, node, optns, establishBindings, undefined, node._tC,yieldComp);
                Object.keys(node._items[itemKey]._dynamicProperty).forEach(function(key) {
                    node._dynProps[key] ? node._dynProps[key]++ : (node._dynProps[key] = 1);    
                })
                node._items[itemKey].itemProperty = this.getProperty(value);
                node._propBindingObject[itemKey] = node._items[itemKey].itemProperty;
                node._forContent[itemKey] = Array.from(toAppend.childNodes);
//                    this.updateBlockHelpers(node._helpers[itemKey], optns);
                this.executeBlockHelpers(node._helpers[itemKey], node);
                //to bind in ssr components
                
                toAppendMain.appendChild(toAppend);
            }, this); 
//              if(options.type !== "update") {
                if(!_LC.unbound && typeof node._attributes.object =='object' && !Array.isArray(node._attributes.object)) {
            		makeSet(node._attributes.object, "_bindings");
                    addBindings(node._attributes.object._bindings,node._propBindingObject);
                    _LC.establishBindings(node._propBindingObject, node._attributes.object);
            	}
//              }
				_LC.unbound = initialUnbound;
                if(options.type !== "default") {
                    if(directiveObj){
                        let dependentPromises = [];
                        directiveObj.getAllDependentPromises(this,dependentPromises,node._totalPromise);
                        directiveObj.insertInDom(this,lastNode._placeHolder,lastNode,toAppendMain,undefined,undefined,dependentPromises);
                    }else{
                        _LC.insertInDom(lastNode._placeHolder,lastNode,toAppendMain);
                    }
                } else {
                    returnVal = {"toAppendMain" : toAppendMain, "lastNode" : lastNode};
                }

        }
        _LC.unbound = initialUnbound; 
        callee.component.data[key] = initialKeyValue;
        callee.component.data[value] = initialValueValue;
        callee._properties[key] = initialKeyProp;
        callee._properties[value] = initialValueProp;
        node._currentObject = object;
        return returnVal;
    }
    rmCaseBindings(node,templInd,currentInd){
        let casesList = node._co;
        for(let i=templInd+1;i<=currentInd;i++){
            let temp = node._tempList[casesList[i]];
            if(temp){
                _LC.removeDynamicNodes(temp,this);
                node._bindedList[casesList[i]] = false;
            }
        }
    }
    getCaseTemplate(node,nodeTemp,caseName,caseStr){
        var dummyTemp;
        var obj = {};//check
        if(!node._tempList[caseName]){
            // if(Lyte._ms){
            //     dummyTemp = _LC.getContentForIE(node._cases[caseName].templateContent , this.constructor,undefined,obj);
            //     if(obj._content){
            //         dummyTemp = obj._content.childNodes[0];
            //     }
            // }else{
                dummyTemp = nodeTemp.content.querySelector(caseStr+_LC.cssEscape(caseName)+'\']');
            // }
            node._tempList[caseName] = dummyTemp;
        }else{
            dummyTemp = node._tempList[caseName];
        }
        return dummyTemp;
    }
    getCaseIndexScope(node,templateCaseNode,casesList,caseName,switchValue,lyteConvertedSwitch){
        var caseName = templateCaseNode.getAttribute("lc-id");
        var templInd = casesList.indexOf(caseName);
        let val = templateCaseNode._attributes.case;
        var currentInd = casesList.indexOf(node._currentScope);
        var scope;
        if(node._currentScope != "default"){
            if(templInd == currentInd){
                if(val){
                    if(lyteConvertedSwitch){
                        return false;
                    }else if(val==templateCaseNode._prevDataVal){ //second check for lyteconvertedtemp
                        return false;
                    }
                    else if(val == switchValue){
                        scope  = node._cases[caseName];
                    }
                }
            }
            else if(templInd > currentInd){
                return false;
            }
            else if(templInd < currentInd){
                if(val){
                    this.rmCaseBindings(node,templInd,currentInd);
                    scope  = node._cases[caseName];
                    scope.cn = caseName;
                }else{
                    return false;
                }
            }
        }else{
            this.rmCaseBindings(node,templInd,casesList.length-1);//templInd+1
        }
        return scope;
    }
    getSwitchScope(node,templateCaseNode,scope,nodeTemp,helperNode,contextSwitchInfo,switchValue,lyteConvertedSwitch,idx,id){
        var caseStr;
        var casesList = node._co;
        var currentInd = -1;//casesList.indexOf(node._currentScope);
        if(templateCaseNode){
            scope = this.getCaseIndexScope(node,templateCaseNode,casesList,caseName,switchValue,lyteConvertedSwitch);
            if(scope == false){
                return false;
            }
        }
        // else{
        //     currentInd = -1;
        // }
        if(!scope){
            var indexStart = node._currentScope ? currentInd + 1 : 0;
            for(var i=indexStart; i<casesList.length; i++){
                var caseName = casesList[i];
                var dummyTemp;
                if(node._cases[caseName].dcn){
                    caseStr = '[lc-id=\'';
                    dummyTemp = this.getCaseTemplate(node,nodeTemp,caseName,caseStr);
                    dummyTemp._parentSwitch = node;
                    dummyTemp._callee = this;
                    if(node._bindedList[caseName]){
                        if((lyteConvertedSwitch && dummyTemp._attributes.case) || (!lyteConvertedSwitch && dummyTemp._attributes.case == switchValue)){
                            scope  = node._cases[caseName];
                            scope.cn = caseName;
                            dummyTemp._prevDataVal = dummyTemp._attributes.case;
                            if(!templateCaseNode && !lyteConvertedSwitch){
                                this.rmCaseBindings(node,i,casesList.length);
                            }
                            break;
                        }
                    }else{
                        var toBeRemoved = [];
                        dummyTemp._dynamicProperty = dummyTemp._dynamicProperty || {};
                        if(lyteConvertedSwitch && helperNode && i==0){
                            this.bindNode(dummyTemp.attributes.getNamedItem("case"), toBeRemoved,  helperNode , helperNode.getAttribute("is")!="switch" && contextSwitchInfo ? contextSwitchInfo :{}, node._cases[caseName].cdp.a.case,undefined,undefined,undefined,undefined,lyteConvertedSwitch?"l":undefined,idx,undefined,id);
                        }else{
                            this.bindNode(dummyTemp.attributes.getNamedItem("case"), toBeRemoved, dummyTemp ,{}, node._cases[caseName].cdp.a.case,undefined,undefined,undefined,undefined,lyteConvertedSwitch?"l":undefined,idx,undefined,id);
                        }
                        // if(this._ssrBind && textNode){
                        //     textNode.setAttribute( "placeHolderId", dummyTemp.getAttribute( 'bindId' ) );
                        // }
                        
                        // debugger;
                        // if(helperNode){
                        //     helpId = helperNode.getAttribute("bindId");
                            
                        //     obj._helperId = helpId;
                        //     if(/^(for|forIn)$/.test(helperNode.getAttribute("is"))){
                        //         obj._forType = this.getssrType(helperNode.getAttribute("is"));
                        //         obj._forIndex = dynamicN._cx.itemIndex;
                        //     }
                        // }
                        // this.component.data.bindIds.push( obj );
                        dummyTemp._cx = contextSwitchInfo;
                        node._bindedList[caseName] = true;
                        dummyTemp._parentSwitch = node;
                        let val;
                        if(dummyTemp.getAttribute("case")=== "" || dummyTemp.getAttribute("case")) {
                            val = dummyTemp.getAttribute("case");
                        }if(dummyTemp._attributes) {
                            val = dummyTemp._attributes.case;
                        }
                        if((lyteConvertedSwitch && val) || (!lyteConvertedSwitch && val == switchValue)){
                            scope  = node._cases[caseName];
                            scope.cn = caseName;
                            dummyTemp.cn = val;
                            break;
                        }
                    }
                }else if(!lyteConvertedSwitch){
                    //might br stattic caseinbetween
                    caseStr = "[case='";
                    dummyTemp = this.getCaseTemplate(node,nodeTemp,caseName,caseStr);
                        let val = dummyTemp.getAttribute("case");
                        if(val == switchValue){
                            scope  = node._cases[caseName];
                            scope.cn = caseName;
                            dummyTemp._prevDataVal = val;
                            break;
                        }
                }
            }      
        }  
        return scope;
    }
    //updSH
    updateSwitchHelper(type,node, contextSwitchInfo, update, establishBindings,yieldComp,templateCaseNode,helperNode,id,idx){
         var lyteConvertedSwitch = node.getAttribute("l-c");
         let directiveObj = this.getDirectiveObj();
         if(directiveObj){
             directiveObj.checkOngoingPromises(node);
             directiveObj.instanciateForPromises(node);//af
         }
         if(node._ht && !node._htA) {
             node.content.append(node._ht.content.cloneNode(true));
             node._htA = true;
         }
         if(node.tagName !== "TEMPLATE") {
             Object.keys(node).forEach(function(item) {
                 if(item !== "innerHTML" && item !== "innerText") {
                     node._origTemplate[item] = node[item];
                 }
             });
             // if(Lyte._ie) {
             // 	var div = createElement("div");
             //     div.innerHTML = node._tC;
             //     node._origTemplate.innerHTML = div.children[0].innerHTML;
             //     this.constructor.splitTextNodes(node._origTemplate);
             //     if(node.hasAttribute("depth")) {
             //         node._origTemplate.setAttribute("depth", node.getAttribute("depth"));    
             //     }
             // }
             let placeHolder = node._origTemplate._placeHolder = document.createTextNode("");
             //node.replaceWith(node._origTemplate._placeHolder);
             _LC.replaceWithPf(node, node._origTemplate._placeHolder);
             node = node._origTemplate;
             // node = _LC.replaceWithOrigTemplate(node)
             node.setAttribute("is", _LC.mappy[type]);
             _LC.apdNode(node, this);
             placeHolder._helper = node;
         } else if(!node._placeHolder){
             var emptyTextNode;
             
                 emptyTextNode = document.createTextNode("");
                 
             //node.replaceWith(emptyTextNode);
             _LC.replaceWithPf(node, emptyTextNode);
             node._placeHolder = emptyTextNode;
             emptyTextNode._helper = node;
             _LC.apdNode(node, this);
         }
         let isNew = false;
         let lastNode = node;
         if(!node._callee) {
             node._callee = this;
             isNew = true;
         }
         node._bindedList = node._bindedList || {};
         node._tempList = node._tempList || {};
         contextSwitchInfo = contextSwitchInfo ? contextSwitchInfo : node._cx;
         node._cx = contextSwitchInfo;
         node._dynamicProperty = node._dynamicProperty ? node._dynamicProperty : {};
         var switchValue;
         if(node.getAttribute("value")=== "" || node.getAttribute("value")) {
             switchValue = node.getAttribute("value");
         } else if(node._attributes) {
             switchValue = node._attributes.value;
         }
         if(!lyteConvertedSwitch && !node._hd){
             if(switchValue) {
                 switchValue = switchValue.toString();
             } else {
                 switch(switchValue) {
                     case undefined : 
                         switchValue = "undefined";
                         break;
                     case null : 
                         switchValue = "null";
                         break;
                     case false: 
                         switchValue = "false";
                         break;
                     case "": 
                         switchValue = '""';
                         break;
                     case 0 : 
                         switchValue = '0';
                 }
             }
         }
         if((!lyteConvertedSwitch && !node._hd) && switchValue === node._currentCase) {
             return;
         }
         let scope,caseStr;
         node._currentCase = switchValue;
         var nodeTemp = node._depthTemp || node;
         if(node._hd){
             scope = this.getSwitchScope(node,templateCaseNode,scope,nodeTemp,helperNode,contextSwitchInfo,switchValue,lyteConvertedSwitch,idx,id);
             if(scope){
                 node._currentCase = scope.cn;
             }
         }
         else{
             caseStr = '[case=\''
             scope = node._cases[switchValue];
         }
         if(scope === false || (!scope && node._previousScope == "default")){
             return;
         }
         if(node._caseContent && node._caseContent.length) {
             this.removeHelpers(node, undefined, true,node._totalPromise);//, node._hd ?{start:templInd+1,end:node._currentScope != "default"?currentInd:casesList.length-1}:false
         }
         node._currentScope = scope && scope.cn;
         let defaultContent;
         if(!scope){
             scope = node._default;
             node._currentScope = "default";
             defaultContent = nodeTemp.content.querySelector('[default]');
             if(scope._ht && !defaultContent._htA) {
                 defaultContent._htA = true;
                 defaultContent.content.append(scope._ht.content.cloneNode(true));
             }
             node._isDefault = true; 
             if(!defaultContent) {
                 // if(node._caseContent && node._caseContent.length) {
                 //     this.removeHelpers(node, undefined, true ,node._totalPromise);
                 // }
                 // node._previousCase = node._currentCase;
                 node._caseContent = [];
                 let emptyTextNode = document.createTextNode("");
                 node._caseContent.$push(emptyTextNode);
                 node._currentCaseName = switchValue;
                 node._helpers = node._helpers || [];
                 if(update) {
                     //lastNode.parentNode.insertBefore(emptyTextNode, node);
                     if(lastNode._placeHolder) {
                         _LC.insertBeforeNative(lastNode._placeHolder.parentNode,emptyTextNode, lastNode._placeHolder);                    
                     } else {
                         _LC.insertBeforeNative(lastNode.parentNode,emptyTextNode, node);
                     }
                     return;
                 } else {
                     let toAppendMain = createDocFragment();
                     toAppendMain.append(emptyTextNode);
                     return {lastNode : lastNode, toAppendMain : toAppendMain};
                 }
             }
         }
         
 //        if(currentCase) {
 //              if(currentCase.tagName === "TEMPLATE" && !currentCase.getAttribute("is")){
 //                  currentCase = currentCase.content;
 //              } else {
 //                  let temp = createElement('template');
 //                  let clone = currentCase.cloneNode(true);
 //                  temp.content.appendChild(clone);
 //                  currentCase.removeAttribute('slot');
 //                  currentCase = temp.content;
 //              }
 //              scope.content = currentCase;
 //        }
  
         // if(node._caseContent && node._caseContent.length) {
         //     this.removeHelpers(node, undefined, true ,node._totalPromise);
         // }
         let dummyScope = scope;
         let additionalContentArr = [];
         let cnt=0;
         let dummyCaseName = switchValue;
         let template;
         if(defaultContent) {
             template = defaultContent
         } else {
             template = nodeTemp.content.querySelector((scope.dcn ? '[lc-id=\'' : '[case=\'') +_LC.cssEscape(scope.cn ? scope.cn : dummyCaseName)+'\']');
         }
         // if(!template._callee){
         //     template._callee = this;
         // }
         let contentArr = [];
         if(directiveObj){
             node._specialNodes = [];
         }
         let nextCaseName;
         while(dummyScope) {
             if(dummyScope._ht && !template._htA) {
                 template._htA = true;
                 template.content.append(dummyScope._ht.content.cloneNode(true));
             }
             let dynamicNodes = dummyScope.dN;
             if(nextCaseName && node._cases[nextCaseName].dcn){
                 caseStr = '[lc-id=\'';
                 var tempNode = this.getCaseTemplate(node,nodeTemp,nextCaseName,caseStr);
                 if(!node._bindedList[nextCaseName]){
                     var toBeRemoved = [];
                     tempNode._dynamicProperty = tempNode._dynamicProperty || {};
                     this.bindNode(tempNode.attributes.getNamedItem("case"), toBeRemoved, tempNode ,{}, node._cases[nextCaseName].cdp.a.case);
                     tempNode._cx = contextSwitchInfo;
                     node._bindedList[nextCaseName] = true;
                     tempNode._parentSwitch = node;
                 }
             }
             let processedContent = this.renderNodes(template, dynamicNodes, node, undefined, establishBindings, undefined, dummyScope.templateContent,yieldComp);
             
             contentArr.$push(processedContent);
             if(dummyScope.additional) {
                 if(node._cases[dummyScope.additional.next] && node._cases[dummyScope.additional.next].dcn){
                     caseStr = '[lc-id=\'';
                 }else{
                     caseStr = '[case=\''
                 }
                 if(dummyScope.additional.next) {
                     nextCaseName = dummyScope.additional.next;
                     template = node.content.querySelector(caseStr+_LC.cssEscape(dummyScope.additional.next)+'\']');
                     dummyScope = node._cases[dummyScope.additional.next];
                 } else {
                     template = node.content.querySelector('[default]');
                     dummyScope = node._default;
                 }
             } else {
                     break;
             }
         }
         node._caseContent = [];
         let toAppendMain = createDocFragment();
         for(let i=0;i<contentArr.length;i++) {
             if(contentArr[i].nodeType == 11){
 //                for(let j=0;j<contentArr[i].childNodes.length;j++) {
 //                    node._caseContent.$push(contentArr[i].childNodes[j]);
 //                }
                 node._caseContent = node._caseContent.$concat(Array.from(contentArr[i].childNodes));
             }
             else{
                 node._caseContent.$push(contentArr[i]);
             }
                 toAppendMain.append(contentArr[i]);
 //            node.parentNode.insertBefore(contentArr[i], node);
         }
           this.executeBlockHelpers(node._helpers, node);
           if(update) {
               let returnVal;
               if(toAppendMain.querySelector("template[is=break]")) {
                   returnVal = "break";
               } else if(toAppendMain.querySelector("template[is=continue]")) {
                   returnVal = "continue";
               }
               if(directiveObj){
                 let dependentPromises = [];
                 directiveObj.getAllDependentPromises(this,dependentPromises,node._totalPromise);
                 directiveObj.insertInDom(this,node._placeHolder,node,toAppendMain,node._previousCase ?false:true,undefined,dependentPromises);
               }else{
                 _LC.insertInDom(node._placeHolder,node,toAppendMain);
               }

               node._previousCase = node._currentCase;
               node._previousScope = node._currentScope;
               return returnVal;
           } else {
                 node._previousCase = node._currentCase;
                 node._previousScope = node._currentScope;
               return {"toAppendMain" : toAppendMain, "lastNode" : node};
           }
     }

    dummy(a,b) {
        let dummy = this.component.constructor._properties[boundValue].observer;
    }

    callObservers(boundValue, key) {
        let property = this.component.constructor._properties[boundValue];
        let observers = property?property.observer: undefined;
        if(observers) {
            for(let i=0;i<observers.length;i++) {
                if(key.indexOf('.') === -1 || observers[i].path === key) {
                    this["_"+observers[i].functionName].apply(this);
                }
            }
        }
    }

    // static updateValue(property, path, value) {
    //     let pathVals = path.split('.');
    //     let context = property;
    //     for(let i=0;i<pathVals.length -1;i++) {
    //         context = context[pathVals[i]];
    //     }
    //     context[pathVals[i]] = value;
    // }

    //    static createDocFragment(template){
    //        let childNodes = template.cloneNode(true,"lyte").childNodes;
    ////           let childNodes = template.childNodes;
    //        let frag = document.createDocumentFragment();
    //        let len = childNodes.length;
    //        for(let i=0; i<len; i++){
    //            frag.appendChild(childNodes[0]);
    //        }
    //        return frag;
    //    }

    static createDocFragment1(template) {
        if(template.content) {
            return template.content;
        }
    	let childNodes = template.childNodes;
    	let frag = createDocFragment();
    	let len = childNodes.length;
    	for(let i=0; i<len; i++){
            frag.appendChild(childNodes[0]);
        }
    	return frag;
    }
    static seperateStyle(componentClass,componentsDiv){
        componentClass._template.replace(/\\'/g,"'");
        let div = createElement("div");
        div.innerHTML = componentClass._template;
        while(div.firstChild){
            if(div.firstChild.nodeName === "STYLE" || div.firstChild.nodeName==="LINK") {
                componentClass._style = div.firstChild.outerHTML;
                div.firstChild.remove();
            } else {
                // div.firstChild.setAttribute("lyte-registry",componentClass._registryClass.name);
                componentsDiv.appendChild(div.firstChild);
            }
        }
    }
    static _registerComponent(a,b,componentClass,registry,registryInstance) {
        let componentsDiv = _LC.getComponentsDiv(_LC.lyteComponentsDiv ,registry.name);
        let origTemplateValue = componentClass._template;
        let app = _LC.getAppOrAddon(registryInstance);
        var clonedDummyTemp;
        if(componentClass._template && typeof componentClass._template === "string"){
            this.seperateStyle(componentClass,componentsDiv);
        }else if(componentClass.template && typeof componentClass.template === "object"){
            componentClass._template = componentClass.template._template;
            componentClass._dynamicNodes = componentClass.template._dynamicNodes;
            componentClass.template = undefined;
            this.seperateStyle(componentClass,componentsDiv);
        }
        componentClass._template = componentsDiv.querySelector("template[tag-name='"+a+"']");
        componentClass._helperTemplate = document.createElement("template");
        componentClass._helperTemplate.setAttribute("_lyteht", a );
        _LC.h1Div.content.appendChild(componentClass._helperTemplate);
        if(!componentClass._template) {
            //@Slicer.developmentStart
            console.error("Template not found for the component : '"+a+"'");
            //@Slicer.developmentEnd
        	return;
        }
        if((_compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default().needDummyComponentsDiv)) {
            // if(Lyte._ie) {
            //     let temp = Compile.getTemplateFromString(origTemplateValue);
            //     // let dummyLyteComponentsDiv = _LC.setComponentsDiv(_LC.dummyLyteComponentsDiv,registry.name);
            //     _LC.getComponentsDiv(_LC.dummyLyteComponentsDiv,registry.name)
            //     dummyLyteComponentsDiv.appendChild(temp);
            // } else {
                clonedDummyTemp = componentClass._template.cloneNode(true);   
            // }
        }
        if(componentClass._template && !componentClass._template.content){
//            var frag = document.createDocumentFragment();
//            let childNodes = this._template.cloneNode(true,"lyte").childNodes;
//            //let childNodes = this._template.childNodes;
//            let len = childNodes.length;
//            for(let i=0; i<len; i++){
//                frag.appendChild(childNodes[0]);
//            }
//            this._template.content = frag;
        }
        // var s = Lyte._ie ? componentClass._template : componentClass._template.content;//)?this._template.content:document.createDocumentFragment(this._template);
        var s = componentClass._template.content; //)?this._template.content:document.createDocumentFragment(this._template);
        //This is used to split text nodes which contain multiple dynamic values 
        //Eg." Name is {{name}} and age is {{age}} "
        //This is used to find the dynamicNodes and helper nodes for the given component. 
        if(!componentClass._dynamicNodes){
            if((_compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default().getDynamicNodes)) {
                var returnVal = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default().getDynamicNodes(a);
                if(returnVal.errors){
                    //@Slicer.developmentStart
                    console.error("Error in the component", returnVal.componentName, returnVal.errors);
                    //@Slicer.developmentEnd
                    return false;
                }else{
                    componentClass._dynamicNodes = returnVal.dynamicNodes;
                    if(componentClass._dynamicNodes && componentClass._dynamicNodes.length && componentClass._dynamicNodes[componentClass._dynamicNodes.length-1].type == "dc"){
                        b.dc = componentClass._dynamicNodes.$pop();
                    }
                }
            } 
            //@Slicer.developmentStart
            else {
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error("LC002", a);  
            }
            //@Slicer.developmentEnd
	    } 
        if(componentClass._dynamicNodes) {
            this.setTemplateAttributes(a, componentClass, clonedDummyTemp);
            var hasUnbound = this.getFastRenderSupported(componentClass._templateAttributes);
            let fastRenderClass = registry.getFastObj();
            // var hasUnbound = b._observedAttributes.indexOf("lyteUnbound") !== -1;
            if(!hasUnbound && !_LC.migratedv2(app)){
                hasUnbound = b._observedAttributes.indexOf("lyteUnbound") !== -1;
            }
            var newCompile;
            if(hasUnbound) {
                if(fastRenderClass){
                    newCompile = fastRenderClass.getNewCompile(componentClass);
                }
                //@Slicer.developmentStart
                // else{
                //     ComponentError.error("LC011")
                // }
                //@Slicer.developmentEnd
                // if(Lyte._ie) {
                //     newCompile = document.createElement("div");
                //     newCompile.innerHTML = componentClass._template.outerHTML;
                //     newCompile = newCompile.childNodes[0];
                // } else {
                //     newCompile = componentClass._template.cloneNode(true);
                // }
            }
            this.splitTextNodes(s);
            if(hasUnbound && fastRenderClass) {
                this.splitTextNodes(newCompile);
            }
            doCompile(s, componentClass._dynamicNodes, a, b, newCompile ? newCompile.content : undefined, componentClass, fastRenderClass);
            // if(Lyte._ed) { 
            //     componentClass._tC = componentClass._template.outerHTML;
            // } 
            // else if(Lyte._ie) {
            //     componentClass._tC = s.outerHTML;
            // }
        }
        if(clonedDummyTemp){
            let dummyRegDiv = _LC.getComponentsDiv(_LC.dummyLyteComponentsDiv,registry.name);
            if(!dummyRegDiv){
                _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default()._registryNameList.forEach(function(regName){
                    let div = document.createElement("div");
                    div.setAttribute("id",regName);
                    _LC.dummyLyteComponentsDiv.appendChild(div);
                    if(regName == registry.name){
                        dummyRegDiv = div;            
                    }
                })
                ;(_compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default()._registryNameList) = [];
            }
            dummyRegDiv.appendChild(clonedDummyTemp);
        }
        componentClass._sta = newCompile ? _LC.processStatic(newCompile) : undefined;
    }
    static getFastRenderSupported(templateAttributes){
        if(templateAttributes && templateAttributes.a){
            for(let attrName in templateAttributes.a){
                if(attrName == "@unbound-supported" || attrName == "@turbo-supported" ){
                    return true;
                }
            }
        }

    }
    static setTemplateAttributes(a, componentClass,clonedDummyTemp){
        componentClass._templateAttributes = {t : "a", "a" : {}, p: []};
        var ta = [componentClass._templateAttributes];
        doCompile(componentClass._template, ta, a, this, undefined, componentClass);
        componentClass._templateAttributes = ta[0];
        if(componentClass._templateAttributes && componentClass._templateAttributes.a) {
            var attributesT = componentClass._template.attributes;
            try{
                for(let i=0;i<attributesT.length;i++) {
                    let attrName = attributesT[i].name;
                    if(!componentClass._templateAttributes.a[attrName] && attrName !== "tag-name" && attrName !== "use-strict" && attrName !== "lyte-registry" && attrName !== "__vp") {
                        componentClass._templateAttributes.a[attrName] = {"name" : attrName, "staticValue" :  attributesT[i].value};
                        componentClass._template.removeAttribute(attrName);
                        clonedDummyTemp && clonedDummyTemp.removeAttribute(attrName);
                        i--;
                    }
                }    
            } catch(e) {
                //@Slicer.developmentStart
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error("LC012")
                //@Slicer.developmentEnd
            }
        }
    }
    //This is used to split text nodes which contain multiple dynamicNodes. 
    static splitTextNodes(node) {
        if(node && node.childNodes && node.childNodes.length) {
            for(let i=node.childNodes.length-1;i>=0;i--) {
                this.splitTextNodes(node.childNodes[i]);
            }
        }
        if(node.tagName === "TEMPLATE") { // && !Lyte._ie
            this.splitTextNodes(node.content);
        }
        if(node.nodeType === node.TEXT_NODE) {
            let nodeValue = node.nodeValue;
            if(nodeValue){
                let mustacheValues = nodeValue.match(/{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}/g); //'
                if(!mustacheValues) {
                    return;
                }
                let newNodeArray = [];
                for(let i=0;i<mustacheValues.length;i++) {
                    let mustacheStartIndex = nodeValue.indexOf(mustacheValues[i]);
                    let mustacheEndIndex = mustacheStartIndex + mustacheValues[i].length;
                    if(mustacheStartIndex) {
                            newNodeArray.$push(document.createTextNode(nodeValue.substring(0, mustacheStartIndex)));
                    }
                    newNodeArray.$push(document.createTextNode(nodeValue.substring(mustacheStartIndex, mustacheEndIndex)));
                    nodeValue = nodeValue.substring(mustacheEndIndex);
                }
                if(!(!nodeValue.trim() && node.nextSibling && node.nextSibling.nodeType === 3 && !node.nextSibling.nodeValue.trim())) {
                    newNodeArray.$push(document.createTextNode(nodeValue));
                }
                //Fix for IE Edge issue with higher versions where node.replaceWith is not working when the parent is a doc fragment.
                if(node.parentNode.nodeName === "#document-fragment") {
                	for(let i=0;i<newNodeArray.length;i++) {
                		_LC.insertBeforeNative(node.parentNode,newNodeArray[i],node);
                      }
                    node.remove();
                } else {
                	node.replaceWith.apply(node, newNodeArray);
                } 
            }
        }
    }
    //It registers the binding of the node with the properties with which the dynamicNode depends. 
    bindNode(node, toBeRemoved, helperNode, options, nodeInfo, processLast, establishBindings, isTemplate,cache,type,idx,toBeInsMap,bId) {
        let lyteConvertedSwitch = false;
        if(type == "l"){
            lyteConvertedSwitch = true;
            type = "a";
        }
        let itemValue = options.itemValue;
        let forIndex = options.itemIndex;
        let forType = options.type;
        let indexValue = options.indexValue;
        let dynamicValue = nodeInfo.dynamicValue;
        let helperFunc = nodeInfo.helperInfo;
        let nodeValue, ownerElement = node.ownerElement;
        let dynamicValuesArray = [];
        let processDetails = {};
        let isDirectiveNode;
        let directiveObj = this.getDirectiveObj();
//        if(node.nodeType === 2 && _LC.isCustomElement(node.ownerElement,true) ) {
//          node = {nodeName : node.nodeName, ownerElement: ownerElement, nodeType : 2, nodeValue : node.nodeValue};
//        }
        if(node.nodeType === 2) {
            node = {nodeName : node.nodeName, ownerElement : node.ownerElement, nodeType : 2, nodeValue : node.nodeValue, _attributeDetails : node._attributeDetails, _isDirectiveNode : nodeInfo._isDirectiveNode};
            // if(directiveObj){
            isDirectiveNode = _LC.directive.isDirectiveNode(node)
            // }
        }
        //to get bindings in ssr components
        
        node._callee = this;
        let isHelper = false;
        if(helperFunc && Object.keys(helperFunc).length) {
            isHelper = true;
            if(helperFunc._t){
                node._sq = true;
            }
            let attrName = node.nodeName;
            nodeValue = node.helperValue = helperFunc;
            let helperArgs = [];
            if(helperFunc.name === "action"){
                let actName = helperFunc.args[0];
                helperFunc.args[0] = actName.startsWith("'")? actName.replace(/'/g,''):  actName;
                // if(forType) {
                //     ownerElement._cx = options;
                // } else if(helperNode) {
                //     ownerElement._cx = helperNode._cx;
                // }
                actName = helperFunc.args.slice(0,1)[0];
                let args = helperFunc.args.slice(1,helperFunc.args.length), isCustom = false;
                let attrName = node.nodeName;
                if(attrName.indexOf("-") != -1){
                    isCustom = true;
                }
                helperArgs = [ownerElement,attrName,isCustom,{name:actName,args:args}];
                this.processHelper(this, {"name" : helperFunc.name, "args" : helperArgs}, node);
                return;
            } else{
                if(helperFunc.name === "method") {
                    helperArgs = helperFunc.args;
                         
                } else {  
                    helperArgs = this.processArgs(this,{"helperInfo" : helperFunc} ,dynamicValuesArray,undefined,node,false,helperFunc._t ?undefined:cache, undefined, processDetails);
                }
            }
            if(helperFunc._t == "sq"){
                nodeValue = this.processArray(this,{"name" : helperFunc.name, "args" : helperArgs},dynamicValuesArray,helperFunc.extra,event, node, undefined, processDetails);
            }
            else{
                nodeValue = this.processHelper(this, {"name" : helperFunc.name, "args" : helperArgs}, node, processDetails);
            }
            if(helperFunc.name === "unescape"){
//              let test = node.replaceWith.apply(node,nodeValue.childNodes);
                let obj = {
                    initialNode : node,
                    dynamicNodeValue : nodeValue
                };
                node = {dynamicPositions : obj, "_callee" : node._callee, helperValue : node.helperValue};
                nodeValue = undefined;
                processLast.$push(node);
            }
        } else {
            helperFunc = {};
            node.syntaxValue = dynamicValue;
            let dynamicValues = [];
            nodeValue = _LC.get(this.component.data, dynamicValue, dynamicValues,cache);
            dynamicValuesArray.$push(dynamicValues);
        }
        //if(node.nodeType === 2 && ( (typeof nodeValue !== "string" && (_LC.isCustomElement(node.ownerElement,true) || typeof nodeValue === "boolean") ) || _LC.isControlHelper(node.ownerElement) )) {
        //	let bindedNode = node;
            //node = {nodeName : node.nodeName, ownerElement: ownerElement, nodeType : 2, nodeValue : node.nodeValue, _callee : this, syntaxValue : node.syntaxValue, helperValue : node.helperValue, _attributeDetails : node._attributeDetails};
        if(node.nodeType == 2) {
            let tagName = node.ownerElement.tagName;
            if(tagName == "INPUT" || tagName == "TEXTAREA" || (tagName == "DIV" && node.ownerElement.hasAttribute("contenteditable") )) {
                var rA = node.ownerElement._rA = node.ownerElement._rA || [];
                node.ownerElement._rA.$push(node);
            }
            if(!ownerElement._origTemplate) {
                if(( ownerElement.hasAttribute("lyte-for") || ownerElement.hasAttribute("lyte-if") || ownerElement.hasAttribute("lyte-switch") || ownerElement.hasAttribute("lyte-forin") ) && ownerElement.tagName !== "TEMPLATE") {
                    // if(Lyte._ie) {
                    //     node.ownerElement = createElement("template");
                    //     node.ownerElement.setAttribute("is", nodeInfo._depthTemp);
                    // } else {
                        node.ownerElement = nodeInfo._depthTemp.cloneNode(true);
                    // }
                    ownerElement._origTemplate = node.ownerElement;
                }
            } else {
                node.ownerElement = ownerElement._origTemplate;
            }
        //	node.ownerElement._attributeDetails[node.nodeName].bindedNode = node;
        //}
        }
        let actMultiProp; 
        if(helperFunc.name !== "unbound" && !_LC.unbound) {
            let dynamicProp;
            if(helperNode) {
                dynamicProp = forType? helperNode._items[forIndex]._dynamicProperty : helperNode._dynamicProperty;
            }
            let obj, helperId;
            for(let d=0;d<dynamicValuesArray.length;d++) {
            	let dynamicValues = dynamicValuesArray[d];
                
            	for(let v=0;v<dynamicValues.length;v++) {
                    //to get binding in ssr components
                    var _nes = false;
                    
                    if(node.__lq){
                        if(!processDetails.lqDyn[d][0]){
                            continue;
                        }
                    }
            		let actProperty = this.getProperty(dynamicValues[v]);
            		if(helperNode) {
            			let ind = dynamicValues[v].search(/\W/);
            			let boundValue;
            			if(ind !== -1) {
            				boundValue = dynamicValues[v].substring(0, ind);
            			} else {
            				boundValue = dynamicValues[v];
            			}
            			if(boundValue !== itemValue && boundValue !== indexValue && (!options.node || !options.node._properties || !options.node._properties[boundValue])) {
            				//to bind for in ssr
                            
                            makeSet(actProperty, "_helperNodes");
            				actProperty._helperNodes.add(
            						helperNode
            				);
            				dynamicProp[dynamicValues[v]] ? dynamicProp[dynamicValues[v]].$push(node): (dynamicProp[dynamicValues[v]] = []).$push(node);
            			} 
            			else {
            				node._cx = options;
//            				if(!actProperty._dynamicNodes) {
//            					actProperty._dynamicNodes = [];
//            					defProp(actProperty, '_dynamicNodes', {
//            						value: [],
//            						enumerable: false, 
//            						writable: true, 
//            						configurable: true
//            					});
//            				}
            				makeArray(actProperty, "_dynamicNodes");
                            if(actProperty._dynamicNodes.indexOf(node) == -1){
            				    actProperty._dynamicNodes.$push(node);
                            }
            				if(boundValue !== indexValue) {
            					actMultiProp = actProperty;
            				}
            			}
            		} else {
//            			if(!actProperty._dynamicNodes) {
//            				defProp(actProperty, '_dynamicNodes', {
//            					value : [], 
//            					enumerable: false, 
//            					writable: true,
//            					configurable: true
//            				});
//            			}
            			makeArray(actProperty, "_dynamicNodes");
                        if(actProperty._dynamicNodes.indexOf(node) == -1){
            			    actProperty._dynamicNodes.$push(node);
                        }
            		}
            		if ((ownerElement && (ownerElement.hasAttribute("lyte-for") || ownerElement.hasAttribute("lyte-if") || ownerElement.hasAttribute("lyte-switch") || ownerElement.hasAttribute("lyte-forin") )) || (ownerElement && ownerElement.tagName === "TEMPLATE" && /^(for|forIn)$/.test(ownerElement.getAttribute("is")) && !isHelper)) {
            			let type= ownerElement.getAttribute("is");
            			if( (type=== "for" && node.nodeName === "items") || (type==="forIn" && node.nodeName === "object")) {
            				if(!actProperty._forHelpers) {
            					makeSet(actProperty, "_forHelpers");
            				}
                            //to bind for in ssr
                            
            				node.ownerElement._actualBinding = actProperty;
            				actProperty._forHelpers.add(node.ownerElement);
            			}
            		}
            		if(establishBindings) {
            			_LC.establishSelectedBinding(actProperty, this.component.data, this );
            		}
                    //to get ssr bindings 
                     
            	}
                
                if(dynamicValues.length > 1 || helperFunc._t) {
            		node._multipleProperty = node._multipleProperty || [];
            		node._multipleProperty.$push({"dynamicProp" : actMultiProp ? undefined : dynamicProp, "actProp" : this.getProperty(dynamicValues[0]), "helperNode" : helperNode, "dynamicValues" : dynamicValues, index:d});
            	}
                
            }
        }
        nodeValue = !typeof nodeValue === "boolean" && !typeof nodeValue === "number" ? (nodeValue? nodeValue : ""): nodeValue;
        if(isDirectiveNode){
            _LC.directive.setNodeArgs(node,nodeValue);
        }
        else if(node.nodeType === 2) {
            let parentNode = node._parentNode? node._parentNode : node.ownerElement;
            if(parentNode.tagName) {
                let is = parentNode.getAttribute("is");
            }
            let isCustomElement = _LC.isCustomElement(parentNode,true);
            if(isCustomElement && !isDirectiveNode) {
                 if(parentNode.set) {
                    parentNode.set(_LC.String.toCamelCase(node.nodeName), nodeValue);
                 } else {
                    parentNode._initProperties = parentNode._initProperties || {};
                     parentNode._initProperties[_LC.String.toCamelCase(node.nodeName)] =nodeValue;
                }
            }
            let origNodeValue = nodeValue;
            // if(directiveNode){
            //     node.ownerElement._transitionArgs = origNodeValue;
            //     node.ownerElement.removeAttribute(node.nodeName);
            //     node.nodeName = node.nodeName.slice(1,node.nodeName.length);
            // }
            //!== "string"
            if(isCustomElement && typeof nodeValue !== "string" && !isTemplate) {
                parentNode._attributes = parentNode._attributes || {};
                parentNode._attributes[node.nodeName] = nodeValue;
                if(parentNode.nodeName === "TEMPLATE" && isHelper) {
                    if((parentNode.getAttribute("is") === "for" && node.nodeName === "items") || (parentNode.getAttribute("is") === "forIn" && node.nodeName === "object") && !_LC.unbound) {
                        //node._actualBinding = {"_forHelpers" : new Set().add(parentNode)};
                        node.ownerElement._actualBinding = {
                            "_forHelpers" : new Set().add(parentNode),
                            "_createdBinding" : true
                        };
                        if(nodeValue && typeof nodeValue !== "number"){
                            makeSet(nodeValue, "_bindings");
                            addBindings(nodeValue._bindings,node.ownerElement._actualBinding);
                        }
                    }
                }
                toBeRemoved.$push(node.nodeName);
            }
            else {
                if(typeof nodeValue === "boolean") {
                    parentNode._attributes = node.ownerElement._attributes || {};
                    parentNode._attributes[node.nodeName] = nodeValue;
                    if(!nodeValue) {
//                      node.ownerElement.removeAttribute(node.nodeName);
                        toBeRemoved.$push(node.nodeName);
                    } else {
                        parentNode.setAttribute(node.nodeName, "");
                    }
                } else {
                    if(nodeValue && typeof nodeValue === "object"){
                        var res;
                        if(typeof Record != "undefined" && nodeValue instanceof Record){
                            res = JSON.stringify(nodeValue.$.toJSON())
                        }
                        else{
                            try{
                                res = JSON.stringify(nodeValue)
                            }
                            catch(exp){
                                //@Slicer.developmentStart
                                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error(
                                    "LC013",
                                    node.nodeName,
                                    node.ownerElement.nodeName.toLocaleLowerCase(),
                                    node.ownerElement.nodeName.toLocaleLowerCase()
                                )
                                //@Slicer.developmentEnd
                            }
                        }
                    }
                    else if(nodeValue== null || nodeValue == undefined){
                        res = ""
                    }
                    else{
                        res = nodeValue;
                    }
                    nodeValue = res;
                    if(_LC.isControlHelper(node.ownerElement)) {
                    	 parentNode._attributes = node.ownerElement._attributes || {};
                         parentNode._attributes[node.nodeName] = nodeValue;
                         toBeRemoved.$push(node.nodeName);
                    } else {
                         let locNodeVal = nodeValue === undefined ? "" : nodeValue;
                         //if(node.nodeName === "style") {
                         //   node.ownerElement.setAttribute("style",locNodeVal);
                         //} else {
                         //   node.nodeValue = locNodeVal;
                         //}
                         node.ownerElement.setAttribute(node.nodeName, locNodeVal);
                    }
                    
                }
            }
            if(parentNode.tagName === "LYTE-YIELD" /*parentNode.getAttribute("is") === "insertYield"*/) {
                parentNode.component.data[_LC.String.toCamelCase(node.nodeName)] = origNodeValue;
            }
            if (/^(INPUT|TEXTAREA|SELECT)$/.test(parentNode.nodeName)) {
                        if (node.nodeName === "value") {
                            parentNode.value = (nodeValue === undefined) ? "" : nodeValue;
                        } else if (node.nodeName === "checked") {
                            parentNode.checked = nodeValue;
                        }
            }
            if(!nodeValue && _LC.booleanAttrList.indexOf(node.nodeName) !== -1) {
                toBeRemoved.$push(node.nodeName);
            }
        } 
        else {
            node.nodeValue = nodeValue === undefined ? '' : nodeValue;
        }
	return node;
    }

    debounce(func, threshold) {
        var timeout;
        return function debounced() {
            var obj = this, args = arguments;
            function delayed() {
            	func.apply(obj, args);
                timeout = null;
            };
            if (timeout){
            	clearTimeout(timeout);
            }
            timeout = setTimeout(delayed, threshold || 100);
            //console.log(timeout,threshold);
        };
    }
    getProperty(key) {
        var arr = key.match(/([^[\].]+|\[\])/g);
        let property = this;
        if(!property._properties[arr[0]]) {
            property._properties[arr[0]] = {};
        } 
        property = property._properties[arr[0]];
        
        defProp(property, '_path', {enumerable: false, value : arr[0]});
        for(let i=1;i<arr.length;i++) {
            if (arr[i].startsWith("'") || arr[i].startsWith('"')) {//added check
			    arr[i] = arr[i].substring(1, arr[i].length -1);
		    }
            if(!property[arr[i]]) {
                property[arr[i]] = {};
                defProp(property[arr[i]], '_path', {enumerable: false, value : property._path + "." + arr[i]});
            }
            property = property[arr[i]];
        }
        return property;
    }
    //updN
    updateNode(node, updatePath) {
        let compInstance = this.component;
        var del = "delete";
        let multiplePropNode = [];
        let multipleProp;
        let nodeHasHelperNode;
        let isDirectiveNode;
        let processDetails = {}
        if(node.nodeType == 2){
            isDirectiveNode = _LC.directive.isDirectiveNode(node)
        }
        if(node._multipleProperty) {
        	for(var i=0;i<node._multipleProperty.length;i++) {
        		if(node._multipleProperty[i]  && (node._multipleProperty[i].dynamicValues.lastIndexOf(updatePath) > 0 || node.__lq)) {
                    var dynStartIndex = node.__lq ? node._multipleProperty[i].dynamicValues.length : node._sq ? node._multipleProperty[i].dynamicValues.lastIndexOf(updatePath) : 1;
                    multiplePropNode[i] = false;
                    multipleProp = node._multipleProperty[i];
		            let nodes;
                    for(var j=0;j<dynStartIndex;j++){
                        var pathName = node.__lq || node._sq ? multipleProp.dynamicValues[j] : multipleProp.actProp._path;
                        if(multipleProp.dynamicProp){
                            nodeHasHelperNode = true;
                            if(!node._sq || multipleProp.dynamicProp[multipleProp.dynamicValues[j]]){
                                multiplePropNode[i] = multipleProp;
                                nodes = multipleProp.dynamicProp[pathName];
                                if(nodes  && pathName.indexOf('.') != -1) {
                                    let index = nodes.indexOf(node);
                                    if(index != -1){
                                        nodes.$splice(index, 1);
                                    }
                                }
                                let helperNode = multipleProp.helperNode;
                                if(nodes.length === 0) {
                                    if(helperNode.getAttribute("is") === "if" || helperNode.getAttribute("is") === "switch" || (helperNode.hasAttribute("lc-id") && helperNode.getAttribute("is") === "case")) {
                                        multipleProp.actProp._helperNodes[del](helperNode);
                                        delete multipleProp.dynamicProp[multipleProp.actProp._path];
                                    } else {
                                        delete multipleProp.dynamicProp[multipleProp.actProp._path];
                                        if(helperNode._items) {
                                            let removeHelper = true;
                                            for(let i=0;i<helperNode._items.length;i++) {
                                                if(helperNode._items[i]._dynamicProperty && helperNode._items[i]._dynamicProperty[pathName]) {
                                                    removeHelper = false;
                                                    break;
                                                }
                                            }
                                            if(removeHelper) {
                                                multipleProp.actProp._helperNodes[del](helperNode);
                                                //console.log('for helper is removed');
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if(!nodeHasHelperNode) {
                            if(multiplePropNode[i] == false){
                                multiplePropNode[i] = ["dynamicNodes"];
                            }else{
                                multiplePropNode[i].$push("dynamicNodes");
                            }
                            var prop = this.getProperty(pathName);
                            nodes = prop._dynamicNodes;
                            if(nodes) {
                                let index = nodes.indexOf(node);
                                if(index != -1 && pathName!=updatePath && pathName.indexOf('.') != -1){
                                    nodes.$splice(index, 1);
                                    if(!nodes.length) {
                                        delete prop._dynamicNodes;
                                    }
                                }
                            }
                        }else{
                            nodeHasHelperNode=false; 
                        }
                    }
		        }
			}
		}
        if(!node.syntaxValue && !node.helperValue) {
            return;
        }
        let contextSwitchInfo;
        let isYieldContext;
        if(node._cx || (node.nodeType === 2 && node.ownerElement._cx)) {
            contextSwitchInfo = node._cx || node.ownerElement._cx;
            var contextSwitchArray = [];
            _LC.changeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo );
        } else if(node.tagName === "LYTE-YIELD" && node._callee._cx) {
        	isYieldContext = true;
        	contextSwitchInfo = node._callee._cx;
        	var contextSwitchArray = [];
        	_LC.changeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo, true);
        }
        let nodeValue;
        let dynamicValues = [];
        var isHelper = false;
        let helperRetVal;
        if(node.helperValue){
            isHelper = true;
            nodeValue = node.helperValue;
                    let helperFunc = nodeValue;
                    if(helperFunc._t){
                        node._sq = true;
                    }
                    let helperArgs = this.processArgs(this,{"helperInfo" : helperFunc} ,dynamicValues,undefined,node, undefined,undefined,undefined,processDetails);    
                    if(helperFunc._t == "sq"){
                        helperRetVal = this.processArray(this,{"name" : helperFunc.name, "args" : helperArgs},dynamicValues,helperFunc.extra,undefined, node, undefined, processDetails);
                    }else{
                        helperRetVal = this.processHelper(this,{"name" : helperFunc.name, "args" : helperArgs}, node, processDetails);
                    }
                    nodeValue = helperRetVal;
                    if(helperFunc.name === "unescape") {
                        let oldDynamicPosition = node.dynamicPositions;
                        let oldStartingNode = oldDynamicPosition.startingNode;
                        let oldChldLen = oldDynamicPosition.length;
                        while(oldChldLen > 1) {
                            let next = oldStartingNode.nextSibling;
                            oldStartingNode.remove();
                            oldStartingNode = next;
                            oldChldLen--;
                        }
                        let childLen = nodeValue.childNodes.length;
                        if(!childLen) {
                            nodeValue.appendChild(document.createTextNode(""));
                            childLen = 1;
                        }
                        let startingNode = nodeValue.childNodes[0];
                        oldStartingNode.replaceWith.apply(oldStartingNode,nodeValue.childNodes);
                        let obj = {startingNode : startingNode, length: childLen};
                        node.dynamicPositions = obj;
                        nodeValue = undefined;
                    }
        } else {
            let boundValue = node.syntaxValue;
            let path;
            if(boundValue.indexOf('.') !== -1 || boundValue.indexOf('[') !== -1) {
                path = boundValue;
                boundValue = boundValue.substring(0,boundValue.indexOf('.'));
            }
            let value = path ? _LC.get(compInstance.data, path, dynamicValues) : compInstance.data[boundValue]; 
            nodeValue = !typeof value === "boolean" && !typeof value === "number" ? (value? value : ""): value;
        }
        let origNodeValue = nodeValue;
		if(!(dynamicValues[0] instanceof Array)) {
        	dynamicValues = [dynamicValues];
		}
        
        if(multiplePropNode) {
        	for(var i=0;i<multiplePropNode.length;i++) {
        		if(multiplePropNode[i]) {
                    var ind = node.__lq ? node._multipleProperty[i].dynamicValues.length : node._sq ? node._multipleProperty[i].dynamicValues.lastIndexOf(updatePath) : 1;
					let multipleProp = node._multipleProperty[i];
                    let dynamicValIndex = node._multipleProperty[i].index;
                    for(var j=0;j<ind;j++){
                        if(node.__lq){
                            let processDynVal = processDetails.lqDyn[dynamicValIndex][0];
                            if(!processDynVal){
                                continue;
                            }
                        }
                        if(node._sq && dynamicValues[dynamicValIndex][j].indexOf('.') == -1){
                            continue;
                        }
                        let prop = this.getProperty(dynamicValues[dynamicValIndex][j]);
                        let totalProp = this.getProperty(node.__lq ? dynamicValues[dynamicValIndex][j] : dynamicValues[dynamicValIndex][j].substring(0, dynamicValues[dynamicValIndex][j].indexOf('.')));
                        var value = this.getData(dynamicValues[dynamicValIndex][j].substring(0, dynamicValues[dynamicValIndex][j].indexOf('.')));                            
                        if(Array.isArray(multiplePropNode) && multiplePropNode[i] && multiplePropNode[i][j] && (multiplePropNode[i][j] === "dynamicNodes")) {
                            makeArray(prop, "_dynamicNodes");
                            if(prop._dynamicNodes.indexOf(node) == -1){
                                prop._dynamicNodes.$push(node);
                            }
                        } else {
                            makeSet(prop, "_helperNodes");
                            prop._helperNodes.add(
                                    multipleProp.helperNode
                            );
                            let dynamicProp = multipleProp.dynamicProp;
                            dynamicProp[prop._path] ? dynamicProp[prop._path].$push(node): (dynamicProp[prop._path] = []).$push(node);
                        }
                        if(value != undefined){
                            _LC.establishBindings(totalProp, value);
                        }
                        if(j==0){
                            if(node.ownerElement && (node.ownerElement.hasAttribute("lyte-for") || node.ownerElement.hasAttribute("lyte-if") || node.ownerElement.hasAttribute("lyte-switch") || node.ownerElement.hasAttribute("lyte-forIn")) || node.ownerElement && node.ownerElement.tagName === "TEMPLATE" && /^(for|forIn)$/.test(node.ownerElement.getAttribute("is")) && !isHelper) {
                                var type = node.ownerElement.getAttribute("is");
                                if (type === "for" && node.nodeName === "items" || type === "forIn" && node.nodeName === "object") {
                                    if(multipleProp.actProp._forHelpers.has(node.ownerElement)){
                                        multipleProp.actProp._forHelpers.delete(node.ownerElement);
                                    }
                                    if(!multipleProp.actProp._forHelpers.size) {
                                        delete multipleProp.actProp._forHelpers;
                                    }
                                    if (!prop._forHelpers) {
                                        makeSet(prop, "_forHelpers");
                                    }
                                    node.ownerElement._actualBinding = prop;
                                    prop._forHelpers.add(node.ownerElement);
                                }
                            }
                            node._multipleProperty[i].actProp = prop;
                            node._multipleProperty[i].dynamicValues = dynamicValues[dynamicValIndex];
                        }
                    }
	        	}
	        }
		}
        if(isDirectiveNode){
            _LC.directive.setNodeArgs(node,origNodeValue);
        }
        else if(node.nodeType === 2) {
        	let parentNodes = [];
            let pN = node._parentNode ? node._parentNode :  node.ownerElement;
            if(pN.tagName === "TEMPLATE" && pN.getAttribute("is") === "component" && node.nodeName !== "component-name" && node.nodeName !== "component-class") {
            	let isKeepAlive = pN.hasAttribute("lyte-keep-alive");
            	if(isKeepAlive) {
            		for(var key in pN._renderedComponent) {
            			parentNodes.$push(pN._renderedComponent[key]);
            		}
            	} else {
                    var compName = pN._currentComponent;
                    if(compName && pN._renderedComponent[compName]){
                        parentNodes.$push(pN._renderedComponent[compName]);
                    }
            	}
            }
            parentNodes.$push(pN);
            for(let i=0;i<parentNodes.length;i++) {
            	let parentNode = parentNodes[i];
            	if(parentNode.set) {
                    // if(parentNode._dynComp && node.nodeName == "component-data"){
                    //     parentNode.set(nodeValue , undefined, undefined,true);    
                    // }else{
                        // parentNode.set(_LC.String.toCamelCase(node.nodeName), nodeValue, undefined,true);
                    // }
                        if(node.nodeName == "$data"){
                            for(let key in nodeValue){
                                parentNode.set(_LC.String.toCamelCase(key), nodeValue[key], undefined,true);
                            }
                        }else{
                            parentNode.set(_LC.String.toCamelCase(node.nodeName), nodeValue, undefined,true);   
                        }
                    } else {
                        parentNode._initProperties = parentNode._initProperties || {};
                        parentNode._initProperties[_LC.String.toCamelCase(node.nodeName)] = nodeValue;
                    }
                    if(parentNode.tagName === "LYTE-YIELD" && parentNode.component.data && node.nodeName && parentNode.component.data[node.nodeName] !== nodeValue /*parentNode.getAttribute("is") === "insertYield"*/) {
                        _LC.set(parentNode.component.data, _LC.String.toCamelCase(node.nodeName), nodeValue,undefined , undefined, parentNode);
                    }
                    parentNode._attributes = parentNode._attributes || {};
                    //!== "string"
                    if(_LC.isCustomElement(parentNode,true) && typeof nodeValue !== "string") {
                        if(node.ownerElement.nodeName === "TEMPLATE") {
                            if(node.helperValue) {
                            	if((node.ownerElement.getAttribute("is") ===  "for" && node.nodeName === "items") || (node.ownerElement.getAttribute("is") ===  "forIn" && node.nodeName === "object")) {
                            		let oldValue = node.ownerElement._attributes[node.nodeName];
                            		let newValue = nodeValue;
                            		_LC.removeSelectedBindingDeep(node.ownerElement._actualBinding, oldValue);
                            		if(newValue  && typeof newValue !== "number") {
                            			makeSet(newValue, "_bindings");
                                        addBindings(newValue._bindings,node.ownerElement._actualBinding);
                            			_LC.establishBindings(node.ownerElement._actualBinding, newValue);
                            		}
                            		if(node.nodeName === "object") {
                            			_LC.removeSelectedBindingDeep(node.ownerElement._propBindingObject, oldValue);
                            		}
                            		//console.log("old Value ", oldValue, " new Value ", newValue);
                            	}
                            }else{
                                if((node.ownerElement.getAttribute("is") ===  "for" && node.nodeName === "items") || (node.ownerElement.getAttribute("is") ===  "forIn" && node.nodeName === "object")) {
                            		let oldValue = node.ownerElement._attributes[node.nodeName];
                            		if(node.nodeName === "object") {
                            			_LC.removeSelectedBindingDeep(node.ownerElement._propBindingObject, oldValue);
                            		}
                            	}
                            }
                            parentNode["__"+node.nodeName] = true;
                            if(node.nodeName != "case"){
                                parentNode.removeAttribute(node.nodeName);
                            }
                        } else {
                            //Needs revisiting
                            //parentNode.removeAttribute(node.nodeName);
                        }

                    } else {
                        if(typeof nodeValue === "boolean") {
                            parentNode._attributes = parentNode._attributes || {};
                            parentNode._attributes[node.nodeName] = nodeValue;
                            if(!nodeValue) {
                                parentNode.removeAttribute(node.nodeName);
                            } else {
                                parentNode.setAttribute(node.nodeName, "");
                            }
                        } else {
                            if(nodeValue && typeof nodeValue === "object"){
                                var res;
                                if(typeof Record != "undefined" && nodeValue instanceof Record){
                                    res = JSON.stringify(nodeValue.$.toJSON())
                                }
                                else{
                                    try{
                                        res = JSON.stringify(nodeValue)
                                    }
                                    catch(exp){
                                        //@Slicer.developmentStart
                                        _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error(
                                            "LC013",
                                            node.nodeName,
                                            node.ownerElement.nodeName.toLocaleLowerCase(),
                                            node.ownerElement.nodeName.toLocaleLowerCase()
                                        )
                                        //@Slicer.developmentEnd
                                    }                                
                                }
                            }
                            else if(nodeValue== null || nodeValue == undefined){
                                res = ""
                            }
                            else{
                                res = nodeValue
                            }
                            nodeValue = res;
                            let locNodeVal = nodeValue === undefined ? "" : nodeValue;
                            // if(node.nodeName === "style") {
                            //     node.ownerElement.setAttribute("style",locNodeVal);
                            // } else {
                            //     node.nodeValue = locNodeVal;
                            // }

                            // if(node instanceof Node) {
                            //Check safari issue once
                            let oE = node.ownerElement;
                            if(oE.hasAttribute(node.nodeName)) {
                                if(oE.tagName != "INPUT" || node.nodeName != "value" || !oE.validity.badInput) {
                                    oE.setAttribute(node.nodeName, locNodeVal);
                                }
                            } else {
                                node.nodeValue = locNodeVal;                              
                            }
                        }
                    }
                    parentNode._attributes[node.nodeName] = nodeValue;
                    if(/^(INPUT|TEXTAREA|SELECT)$/.test(parentNode.nodeName)) {
                        if(node.nodeName === "value") {
                             let val = (nodeValue === undefined) ? "" : nodeValue;
                             if(parentNode.value !== val) {
                                parentNode.value = val;
                             } 
                        } else if(node.nodeName === "checked") {
                            parentNode.checked = nodeValue;
                        }
                    }
                    if(!nodeValue && _LC.booleanAttrList.indexOf(node.nodeName) !== -1) {
                        parentNode.removeAttribute(node.nodeName);
                    }
                    let isStopped = parentNode._isStopped;
                    let result;
                    switch(parentNode.getAttribute("is")) {
                        case "for" :
                            this.updateForHelper(parentNode, {"type" : "update"});
                            break;
                        case "if" : 
                            result = this.updateSwitchHelper("e",parentNode, undefined, true, true);
                            break;
                        case "case" : 
                            result = this.updateSwitchHelper("s",parentNode._parentSwitch, undefined, true, true,undefined,parentNode);
                            break;
                        case "forIn" : 
                            this.updateForInHelper(parentNode , {"type" : "update"});
                            break;
                        case "switch" :
                            this.updateSwitchHelper("s",parentNode, undefined, true, true);
                            break;
                        case "component" : 
                            if(node.nodeName === "component-name" || node.nodeName === "component-class") {
                                this.updateDynamicComponent(parentNode, "update");    
                            }
                            break;
                        default:            
                    }
//                 	let handleBreakOptions;
//                 	if(isStopped &&  isStopped !== result) {
//                 		//console.log("new value is stopped");
//                 		if(!result) {
//                 			//console.log("new value is not stopped");
//                 			if(isStopped === "break") {
//                 				handleBreakOptions = "SM"
//                 			} else {
//                 				handleBreakOptions = "SS"
//                 			}
//                 		} else if(result === "break") {
//                 			handleBreakOptions = "MS";
//                 			//console.log("old value is continue and new value is break");
//                 		} else {
//                 			handleBreakOptions = "SM";
//                 			//console.log("old value is break and new value is continue");
//                 		}
//                 	} else if(result === "break") {
//                 		handleBreakOptions = "MS";
//                 		//console.log("old value not stopped and new value is break");
// //                		this.handleBreak(parentNode._cx, "break");
//                 	} else if(result === "continue") {
//                 		handleBreakOptions = "SS";
//                 		//console.log("old value not stopped and new value is continue");
// //                		this.handleBreak1(parentNode._cx , "continue");
//                 	}
//                 	if(handleBreakOptions) {
//                 		this.handleBreak(parentNode._cx, handleBreakOptions);
//                 	}
            }
        }
        else {
            node.nodeValue = nodeValue === undefined ? '' : nodeValue;
        }
        if(contextSwitchInfo) {
            _LC.removeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo, isYieldContext);
        }
    }

    // handleBreak(contextSwitchInfo, options) {
    // 	if(contextSwitchInfo) {
    // 		let forTemplate = contextSwitchInfo.node;
    // 		let breakIndex = contextSwitchInfo.itemIndex;
    // 		let itemValue = forTemplate.getAttribute("item");
    // 		let forContent = contextSwitchInfo.node._forContent;
    // 		let endIndex = options[0] === "M" ? forContent.length : breakIndex + 1;
    // 		for(let j=breakIndex;j<endIndex;j++) {
    // 			let currentForContent = forContent[j];
    // 			for(let i=0;i<currentForContent.length;i++) {
    // 				currentForContent[i].remove();
    // 				if(currentForContent[i]._forContent || currentForContent[i]._caseContent) {
    // 					this.removeHelpers(currentForContent[i]);
    // 				}
    // 			}	
    // 				forContent[j] = [];
    // 				_LC.removeSelectedBindingDeep(forTemplate._items[j].itemProperty, forTemplate._attributes.items[j]);
    // 				forTemplate._helpers[j] = [];
    // 				forTemplate._items[j] = {"_dynamicProperty" : {}, "itemProperty" : {}, "indexProperty": {}};
    // 		}
    // 		let length = forTemplate._attributes.items.length;
    // 		if(options[1] === "M") {
    // 			this.updateForHelper(forTemplate, {firstIndex : breakIndex, secondIndex : length - breakIndex, "type" : "replace"}, undefined, {});
    // 		} else {
    // 			this.updateForHelper(forTemplate, {firstIndex : breakIndex, secondIndex : 1, "type" : "replace"}, undefined, {});
    // 		}
    // 	}
    // }

    createCustomEvent(eventName, parentNode, actObj){
        const customEvent = new CustomEvent(eventName);
        parentNode._actions[eventName] = customEvent;
        parentNode._actions[eventName].processAction = actObj;
    }

    isEmptyString(str){
        return (!(typeof str === "string") || str === "" );
    }
    setLyteSequence(){
        let registryIns = this.$registry;
        let appAddonIns = this.component.getAppOrAddon();
        if(registryIns.constructor.lyteSequence || appAddonIns.constructor.lyteSequence || this.component.constructor.lyteSequence){
            this.__lq = true;
        }
    }
    processArgs(scope,dynN,dynamicValues,event, node, newCompile,cache,parentSq,processDetails){
        let args = dynN.newHelperInfo && newCompile ? dynN.newHelperInfo.args : dynN.helperInfo.args;
        if(dynN.helperInfo && dynN.helperInfo._t == "sq")   {
            parentSq = true;
        }
        dynamicValues = dynamicValues || [];
        processDetails.lqDyn = processDetails.lqDyn || [];
        let lqDyn = processDetails.lqDyn;
        let previousArg;
        let tempSkipIndex;
        let skipAll = dynN.helperInfo.skipAll;
        args = (Array.isArray(args)) ? Array.from(args) : args;
        for(let i=0; i<args.length; i++){
            if(args[i] && args[i].type){
                let addSkipAll = false
                if(node && node.__lq && (skipAll || tempSkipIndex == i)){
                    args[i].value.skipAll = true;
                    addSkipAll = true;
                }
                if(args[i].type == "sq"){
                    this.internalArray(scope, args, i, dynamicValues, event, node, newCompile,parentSq, processDetails);
                }else{
                    this.internalHelpers(scope, args, i, dynamicValues, event, node, newCompile,cache,parentSq, processDetails);
                }
                if(addSkipAll){
                    dynN.helperInfo.args[i].value.skipAll = false;
                }
            } else {
                if(!this.isEmptyString(args[i])) {
                    if(args[i].startsWith("'") && args[i].endsWith("'")){
                        args[i] = args[i].substr(1,args[i].length-2);   
                        if(this.__lq){
                            if(!node.__lq){
                                processDetails.lqDyn = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(dynamicValues);
                                node.__lq = true;
                            }
                            switch(args[i]){
                                case "||" : {
                                    if(previousArg){
                                        processDetails.skipHelper = true;
                                        tempSkipIndex = i+1;
                                    }
                                }
                                break;
                                case "&&" : {
                                    if(!previousArg){
                                        processDetails.skipHelper = true;
                                        tempSkipIndex = i+1;
                                    }
                                }
                                break;
                                case "?:" : {
                                    if(previousArg){
                                        tempSkipIndex = i+2;
                                    }else{
                                        tempSkipIndex = i+1;
                                    }
                                    processDetails.skipHelper = true;
                                }
                            }
                        }
                    } else {
                        args[i] = args[i].trim();
                        if(args[i] === "event" && event) {
                            args[i] = event;
                        } else if(args[i] === "this" && node) {
                            args[i] = node.nodeType === 2 ? node.ownerElement : node;
                        } else {
                            let dynamicVals = [];
                            args[i] = _LC.get(scope.component.data,args[i],dynamicVals,cache);
                            if(!parentSq || dynamicValues.length == 0){
                                dynamicValues.$push(dynamicVals);
                                if(node && node.__lq && lqDyn){
                                    lqDyn.$push(skipAll || tempSkipIndex == i ? [false] : dynamicVals);
                                }
                            }else{
                                if(dynamicVals.length > 1){
                                    for(let s=0; s<dynamicVals.length; s++){
                                        dynamicValues[dynamicValues.length-1].$push(dynamicVals[s]);
                                        if(node && node.__lq && lqDyn){
                                            lqDyn[lqDyn.length-1].$push(skipAll || tempSkipIndex == i ? false : dynamicVals[s]);
                                        }
                                    }
                                }else{
                                    dynamicValues[dynamicValues.length-1].$push(dynamicVals[0]);
                                    if(node && node.__lq && lqDyn){
                                        lqDyn[lqDyn.length-1].$push(skipAll || tempSkipIndex == i ? false : dynamicVals[0]);
                                    }
                                }
                            }
                        }
                    }
                } else if(newCompile) {
                    if(args[i] instanceof Array) {
                        args[i] = _LC.getDD(scope.component.data, args[i]);
                    }
                }
            }
            previousArg = args[i];
        }
        return args;
    }

    internalHelpers(scope,args,i,dynamicValues, event, node, newCompile,cache,parentSq, processDetails){
        let helperFunc = args[i].value;
        var helperVal =  this.processHelper(scope,{"name" : helperFunc.name, "args" : this.processArgs(scope,{"helperInfo" : helperFunc},dynamicValues, event, node, newCompile,cache,parentSq, processDetails)},undefined, processDetails);
        args[i] = helperVal;
    }
    internalArray(scope, args, i, dynamicValues, event, node, newCompile,parentSq, processDetails) {
        var helperFunc = args[i].value;
        if(!parentSq){
            dynamicValues.$push([]);
            let lqDyn = processDetails.lqDyn
            if(node && node.__lq && lqDyn){
                lqDyn.$push([]);
            }
        }
        var helperVal =  this.processArray(this,{"name" : helperFunc.name, "args" : this.processArgs(scope,{"helperInfo" : helperFunc},dynamicValues, event, node, newCompile,undefined,true, processDetails)},dynamicValues, helperFunc.extra ? Array.from(helperFunc.extra):undefined,event, node, newCompile, processDetails);
        args[i] = helperVal;
    }
    processArray(scope,helperFunc,dynamicValues,extra,event, node, newCompile, processDetails){
        var arrVal;
        dynamicValues = dynamicValues || [];
        var dynVal = [];
        var arr = helperFunc.name;
        var len = helperFunc.args.length;
        var str="";
        let skipAll = helperFunc.skipAll;
        let lqDyn = processDetails.lqDyn;
        for(var i=0; i<len; i++){
            str = str + "['"+ helperFunc.args[i] + "']"
        }
        var fullData = arr+str;
        if(extra && extra.length){
            for(var i=0; i<extra.length; i++){
                if(typeof extra[i] == "string"){
                    fullData += extra[i];
                }else{
                    if (extra[i] && extra[i].type) {
                        if (extra[i].type == "sq") {
                            this.internalArray(scope, extra, i, dynamicValues, event, node, newCompile, true, processDetails);
                        } else {
                            this.internalHelpers(scope, extra, i, dynamicValues, event, node, newCompile, undefined, true, processDetails);
                        }
                        fullData += extra[i];
                    } 
                }
            }
        }
        if(!helperFunc.name.startsWith('.')){
            arrVal = _LC.get(scope.component.data, fullData, dynVal);
            if(dynamicValues.length == 0){
                dynamicValues.$push(dynVal);
                if(node && node.__lq && lqDyn){
                    lqDyn.$push(skipAll ? [false] : dynVal);
                }

            }else{
                dynamicValues[dynamicValues.length-1].$unshift(dynVal[0]);
                if(node && node.__lq && lqDyn){
                    lqDyn[lqDyn.length-1].$unshift(skipAll ? false : dynVal[0]);
                }
            }
            return arrVal;
        }else{
            return fullData;
        }
        
    }
    processHelper(scope,helperFunc, node, processDetails){
        if(processDetails && processDetails.skipHelper){
            return;
        }
        let args = [];
        let helperName = helperFunc.name;
        if(!scope.$component.registeredHelpers[helperName]){
            //@Slicer.developmentStart
            let app = _LC.getNearestParentApp(this.component);
            _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error(app, "LC003" , helperFunc.name);
            //@Slicer.developmentEnd
            return;
	    }
        switch(helperFunc.name){
            case "method" : 
                args.$push(this, node);
                break;
            case "lbind" :
                args.$push(this, node.ownerElement);
                break;
            case "lyteViewPort" :
                if(node && node.ownerElement){
                    args.$push(node.ownerElement);
                    if(!helperFunc.args.length){
                        args.$push(false);
                    }
                }else{
                    return true;
                }
        }
        return scope.$component.registeredHelpers[helperFunc.name].apply(scope.component,args.$concat(helperFunc.args));
        // return _LyteComponent.registeredHelpers[helperFunc.name].apply(this,args.$concat(helperFunc.args));
    }

    // getActionProperty(prop){
    //     let hostProp = this._properties;
    //     let value = (hostProp)?hostProp[prop].value:undefined;
    //     return value;
    // }

    // hasInternalBindings(content){
    //     return content.match(/[(]{1}[^)]+[)]{1}/);
    // }

    // getArgValues(argNames, properties) {
    //     let argValueArray = [];
    //     for(let i=0;i<argNames.length;i++) {
    //         argValueArray.$push(properties[argNames[i]].value);
    //     }
    //     return argValueArray;
    // }

    createEventListeners(node,actionType,actObj){
        let self = this;
        if(!node._callee && node !== this) {
            node._callee = this;
        }
        if(globalDOMEvents.indexOf(actionType) == -1){
            let infoAttr = actionType.substr(2);
            let infoAttrVal = node.getAttribute(infoAttr);
            // var evntListener = function(event) {
        	// 	var toRemove;
            //     if(!window.event) {
            //         window.event = event;
            //         toRemove = true;
            //     }
            //     _LC.throwAction.call(self,self,actionType.substr(2),actObj, undefined, undefined, node, event);
            //     if(toRemove) {
            //         window.event = undefined;
            //     }
            // };
            if ((ComponentRegistry._registeredCommonClass[node.localName] && !node.component) || (node.tagName === "TEMPLATE" && node.getAttribute("is") === "component")) {
            	node._toRegEvnts = node._toRegEvnts || {};
            	node._toRegEvnts[actionType.substr(2)] = {"listener" : globalEventHandler , "attrVal" : this.tagName.toLowerCase()+" => "+actObj.name};
            } else {
            	node.setAttribute(infoAttr, this.tagName.toLowerCase()+" => "+actObj.name);
            	//Event is not in capture phase because, in capture phase, multiple event listeners in hierarchy are called from parent to child (since registration is done in that order)
            	node.addEventListener(actionType.substr(2), globalEventHandler);
            }
            if(node.hasAttribute(actionType)){
            	node[actionType] = undefined;
            }
            node.removeAttribute(actionType);
        }
    }

    registerParentYield(yieldName){
        let locYield,parentYield = this._callee._yields[yieldName];
        if(parentYield){
            // if(Lyte._ie) {
            //     locYield = document.createElement("div");
            //     locYield.innerHTML = parentYield.outerHTML;
            //     locYield = locYield.childNodes[0];
            //     this.constructor.splitTextNodes(locYield);
            // } else {
                locYield = parentYield.cloneNode(true);
            // }
            Object.keys(parentYield).forEach(function(item) {  //eslint-disable-line no-loop-func
                locYield[item] = parentYield[item];
            });
            this._yields[yieldName] = locYield;
        }
    }

    getYieldName(node){
        if(node.getAttribute("yield-name")){
            return node.getAttribute("yield-name");
        }else if(node._attributes && node._attributes["yield-name"]){
            return node._attributes["yield-name"];
        }
    }

    registerYields() {
        this._yields = {};
        let yields = this.querySelectorAll('template[is=registerYield],template[is=yield]');
        let lazyYields = [];
        for(let i=0;i<yields.length;i++) {
            while(yields[i].hasChildNodes()) {
                yields[i].content.appendChild(yields[i].childNodes[0]);
            }
            let yieldName = this.getYieldName(yields[i]);
            if(yields[i].hasAttribute("from-parent") && this._callee) {
                if(this._callee._yields){
                    this.registerParentYield(yieldName);
                }
                else{
                    lazyYields.push(yields[i]);
                }
            } else {
                this._yields[yieldName] = yields[i];
            }
        }
        if(lazyYields.length && this._callee){
            var self = this;
            this.lazyYield = function(){
                if(self._callee){
                    for(let j=0;j<lazyYields.length;j++){
                        let lYield = lazyYields[j];
                        self.registerParentYield(this.getYieldName(lYield));
                    }
                    self._callee.removeEventListener("onReady", self.lazyYield);
                    delete self.lazyYield;
                }
            };
            this._callee.addEventListener("onReady", this.lazyYield);
        }
    }

    connectedCallback() {
        this._connectedCallback();
    }
    _connectedCallback(){
        if(this.hasAttribute("lyte-rendered") || this._ccCalled || !this._registryClass || !this.$registry.registeredComponents[this.localName]) {
            return;
        }
        let fastRenderProp = this._fR;
        if(!fastRenderProp) {
            this._callee = this._callee || this.getCallee(this.parentNode);
        }
        this.__h = {};
        this.__counter = 0;
        this.__dc = {};
        if(fastRenderProp) {
            let methods = fastRenderProp._methods;
            if(methods) {
                this.setMethods(methods);
            }
            _LC.ccDelay.$push(this);
            this._ccCalled = true;
        } else {
            this.actualConnectedCallback();
        }
        let viewObj = this.getViewObj()
        if(viewObj){
            viewObj.connectedCallback(this)
        }
    }
    cmpBind(fastRenderProp){
        let compData = this.component.data;
        if(!_LC.unbound && !fastRenderProp && !compData.lyteFastRender) {
            _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.establishObserverBindings.call(this,this.component.constructor._observers,undefined,undefined,undefined,_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte);
            _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.establishWatchScope.call(this,this.constructor._deepWatchProperties)
            //this.establishObserverBindings();
            makeSet(compData, "_bindings");
            addBindings(compData._bindings,this._properties);
            _LC.establishBindings(this._properties, compData);
        }
    }
    actualConnectedCallback(){
        let compData = this.component.data;
        if(this.component.constructor.dc){
            this.dc = this.component.constructor.dc.p;
        }
        let directiveObj = this.getDirectiveObj();
        directiveObj && directiveObj.instanciatePromises(this)
        let fastRenderProp = this._fR;
        if(fastRenderProp) {
            this._callee = this._callee || this.getCallee(this.parentNode);
        }
        for(let key in this._toRegEvnts) {
        	this.addEventListener(key, this._toRegEvnts[key].listener);
        	if(this.hasAttribute(key)) {
        		this.setAttribute(key, this.getAttribute(key) + " ; "+ this._toRegEvnts[key].attrVal);
        	} else {
        		this.setAttribute(key, this._toRegEvnts[key].attrVal);
        	}
        }
        this._toRegEvnts = {};
        let initialUnbound = _LC.unbound;
        let ssrBind  = this._ssrData || this.getAttribute("ssrbindservernode");
        if(ssrBind && !this.component.data.lyteUnbound){
            this.bindServerData();
            this.removeAttribute("ssrbindservernode");
        }
        this.setLyteSequence();
        let content =  this.afterConnected(fastRenderProp,ssrBind);
        !ssrBind && this.cmpBind(fastRenderProp);

        _LC.unbound = initialUnbound;
        var tagName = this.tagName;
        let dependentPromises = [];
        directiveObj && directiveObj.getDependentPromises(this,dependentPromises,this._dependentPromise);
        if(typeof content === "string") {
            if(content) {
                if(_LC.frSpecial) {
                    let temp = document.createElement("template");
                    temp.innerHTML = content;
                    this.innerHTML = "";
                    this.appendChild(temp.content);
                } else {
                    this.innerHTML = content;
                }
            }
            _LC.processAction(this);
        }
        else{
            let viewObj = this.getViewObj()
            if(viewObj){
                viewObj.actualConnectedCallback(this,content)
            }
            let shadowObj = this.getShadowObj();
            let shadowDeep,shadowMode,shadowParent;
            var shadowSupported = _LC.directive.getTransitionArg(this,"shadow-supported")
            if(shadowObj){
                _LC.directive.setAttrFromRender(this,this._tagDirectives);
                // if(shadowSupported){
                    if(this.$registry._defaultDirectives && this.$registry._defaultDirectives.indexOf("shadow") != -1){
                        var shadowVal = _LC.directive.getTransitionArg(this,"shadow")
                        shadowMode = shadowVal;
                        this.component.data.lyteShadow = shadowVal; //af??
                    }
                    shadowParent = this;
                    if(this.parentNode.shadowRoot){
                        _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.warn(this.tagName +" should not be the direct child of a shadow component "+this.parentNode.tagName)
                    }
                    let rtObj = shadowObj.getShadowParent(this,directiveObj);
                    shadowParent = rtObj.shadowParent;
                    shadowDeep = rtObj.shadowDeep;
                // }
            }
            if(shadowObj && shadowMode == true){
                if(shadowSupported){
                    shadowObj.applyShadow(this,content,shadowParent,dependentPromises);
                }
                //@Slicer.developmentStart
                else{
                    _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error("LC017",this.localName)
                }
                //@Slicer.developmentEnd
            }
            else if(shadowObj && shadowParent){
                if(shadowMode == undefined && shadowDeep == true && this.constructor._observedAttributes.indexOf("lyteShadow")!=-1){
                    shadowObj.applyShadow(this,content,shadowParent,dependentPromises);
                }
                else{
                    this._hasShadowParent=true;
                    this._sw = [];
                    this.component.data.lyteShadow = false;//need to check
                    shadowObj.attachStyleToParentShadow(this, shadowParent, content);
                    if(directiveObj){
                        directiveObj.appendInDom(this,content,true,true,dependentPromises);
                    }else{
                        _LC.appendInDom(this,content);
                    }
                }
            }
            else{
                this.component.data.lyteShadow = false;//need to check
                if(this._compClass._style && _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.$.assetsDiv._duplicateStyle.indexOf(tagName) == -1){
                    var style = _LCSD.stringToStyle(this._compClass._style);
                    style.setAttribute("lyte-id","global-style-"+tagName);
                    if(this._ssrBind){
                        style.setAttribute("from-ssrComponent",tagName);
                    }
                    _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.$.assetsDiv.appendChild(style);
                    _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.$.assetsDiv._duplicateStyle.$push(tagName);
                }
                if(_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.$.shadowDiv._compList.indexOf(tagName) == -1){
                    _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.$.shadowDiv._compList.$push(tagName);
                }
                if(directiveObj){
                    directiveObj.appendInDom(this,content,true,true,dependentPromises);
                }else{
                    _LC.appendInDom(this,content);
                }
            }
        }
        if(directiveObj){
            this._transitionAppend = []
        }
        let dataDef = this.component.__data;
        let attributes = this.attributes;
        this.__lyteIgnore = true;
        for(let i=attributes.length-1;i>-1;i--) {
            let camelCase = _LC.String.toCamelCase(attributes[i].nodeName);
            if(dataDef[camelCase] && dataDef[camelCase].hideAttr) {
            this.removeAttribute(attributes[i].nodeName);
            }
        }
        this.__lyteIgnore = false;
	    if( this._callee && this._callee.serverCall ){
            this.serverCall = true;
        }
        //to bind in ssr
        if( this.serverCall && !this.hasAttribute( "server-rendered") ){
            this.setAttribute( "server-rendered", "");
            var newData = _LC.sendtoclient.call(this,this,true,this.component.__data);
            this.setAttribute("component-data", JSON.stringify( newData ) );
        }
        if( !this.hasAttribute( "server-rendered" ) )
        {        
	        this.setAttribute("lyte-rendered", "");
        }
        
        if(!fastRenderProp && !_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte._ignoreOnReady) {
            this.dispatchEvent(new CustomEvent("onReady"));
        }
        
        let _config_flag;
        if( this.component._ssr && this.component._ssr.config ){
            if( this.component._ssr.config.clientLifeCycleHooks != undefined ){
                _config_flag = this.component._ssr.config.clientLifeCycleHooks == true || ( typeof this.component._ssr.config.clientLifeCycleHooks == 'object' ? this.component._ssr.config.clientLifeCycleHooks.includes('didConnect') : false );
            }
        }
        let _overrides = this.component._ssr ? this.component._ssr.overrides : undefined;
        if( !this.hasAttribute( "server-rendered" ) || this.serverCall ||  _config_flag ){
            if( _overrides && _overrides.didConnect && this.serverCall ){
                _overrides.didConnect.apply( this.component );
            }else{        
                this.callback("didConnect");
            }
            this.onCallBack("didConnect");
        }
    
        if( this.serverCall == undefined ){
            this.callback( "didRender" );
        }            
        if(fastRenderProp) {
            this.removeAttribute("_lyteprop");
        }
    }
    onCallBack(name){
        let callbacks = this.component.constructor._callBacks[name];
        if(callbacks){
            for(let i=0;i<callbacks.length;i++){
                try{
                    callbacks[i].value.call(this.component);    
                } catch(e) {
                    //@Slicer.developmentStart
                    _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error(e);
                    //@Slicer.developmentEnd
                }
                
            }
        }
    }
    callback(name){
        var func = this.component[name];
        var args;
        if(func){
            if(arguments.length > 1) {
                args = Array.from(arguments);
                args.$splice(0,1)
            }
            try{
                func.apply(this.component, args || []);    
            } catch(e) {
                //@Slicer.developmentStart
                _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error(e);
                //@Slicer.developmentEnd
            }
        }
    }
    establishObserverBindings() {
        let observers = this.component.constructor._observers;
        for(let i=0;i<observers.length;i++) {
            let props = observers[i].properties;
            for(let j=0;j<props.length;j++) {
                let actProp;
                let isArrayObserver = false;
                if(props[j].indexOf('.[]') !== -1) {
                    isArrayObserver = true;
                    actProp = this.getProperty(props[j].substring(0, props[j].indexOf('.[]')));
                } else {
                    actProp = this.getProperty(props[j]);
                }
                makeSet(actProp, "_observers");
                actProp._observers.add({callee : this, observer: observers[i], isArrayObserver : isArrayObserver});
            }
        }
    }
    removeBindings(properties, actualData) {
        var del = "delete";
        for(let i in properties) {
            let actData = actualData[i];
            if(actData && actData._bindings) {
                actData._bindings[del](properties[i]);
                //Error while trying to delete _bindings from actData when actData is of type Array
                /*  if(!actData._bindings.size) {
                    delete actData._bindings;
                } */
            }
            if(typeof properties[i] === "object" && actData) {
                this.removeBindings(properties[i], actData);
            }
        }
    }
    actualDisconnected() {
        var self = this;
        if(!self.component) {
            return;
        }
        self._cx = null;
        self._callee = null;
        self.component.$node = null;
        self.component.__data = null;
        self.component.data.__component__ = null;
        self.component.data = null;
        self.component = null;
        self.__dc = self.__dc || {};
        self.__h =  self.__h || {};
        for (key in self.__dc) {
            var helper = self.__dc[key];
            //helper.remove();
            if(helper.hasAttribute("lyte-keep-alive")) {
                var objKeys = Object.keys(helper._renderedComponent);
                for(var j=0;j<objKeys.length;j++) {
                    let key = objKeys[j];
                    if(key !== helper._currentComponent) {
                        // Will remove from hDiv.
                        helper._renderedComponent[key].remove();
                    }
                }
            }
        }
        for (key in self.__h) {
            self.__h[key].remove();
        }
        self.__h = {};
        self.__dc = {};
        let yields = self._yields;
        for(var key in yields) {
            yields[key]._callee = null;
        }
        self = null;
    }
    disconnectedCallback() {
        this._disconnectedCallback();
    }
    _disconnectedCallback(){
        if(_LC.ignoreDisconnect || !this.component || this.__lyteIgnore) {
	       return;
        }
        let shadowObj = this.getShadowObj();
        let directiveObj = this.getDirectiveObj();
        shadowObj && shadowObj.destroyRef(this);
        let viewObj = this.getViewObj()
        if(viewObj){
            viewObj.disconnectedCallback(this)
        }
        this._destroyed = true;
        if(this.__toRemoveLazy){
            for(var __key in this.__toRemoveLazy){
                var __arr = this.__toRemoveLazy[__key];
                __arr.forEach(function(id){
                    _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.$.toRemoveFromRequiredServices(id);
                });
            }
            delete this.__toRemoveLazy;
        }
        this.component._bindings = null;
        var scpObj = this.__scpObj;
        if(scpObj){
            for(var key in scpObj){
                var propData = this.component.data[key], id = scpObj[key], idArr = id.split("_");
                if(propData){
                    (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.removeNestScp)(this.component.data[key], idArr[0], idArr[1], undefined, this);
                }
            }
        }
        if(!this._fR) {
            _LC.removeSelectedBindingDeep(this._properties, this.component.data, true);
        }
        if(directiveObj){
            directiveObj.destroyHelperPromises([this.__dc,this.__h]);
        }
        var h = this.__h;
        for (key in h) {
            if(h[key]._actualBinding){
                this.removeHelpers(h[key]);
            }
        }
        h = {};
        for(key in this._properties) {
            this._properties[key] = {};
        }
        this.callback('didDestroy');
        this.onCallBack('didDestroy');
        this.component.constructor.activeInstances--;
        if(!_LC.dcc) {
            _LC.dcc = [];
            requestAnimationFrame(function() {
                requestAnimationFrame(function() {
                    if(viewObj){
                        viewObj.actualDisconnected(this)
                    }
                    try{
                        for(var i=0,item;item=_LC.dcc[i];i++) {
                            item.actualDisconnected();
                        }
                    }
                    catch(e) {

                    }
                    _LC.dcc = undefined;
                });
            });
        }
        _LC.dcc.$push(this);
        directiveObj && directiveObj.destroyPromises(this);
        if(this.lazyYield){
            this.removeEventListener("onReady", this.registerParentYield);
        }   
        // var self = this;
        // setTimeout(function() {
        //     self.actualDisconnected();
        // },0);
        // this.constructor.activeInstances--;
    }
}
customElementPrototype._V3InsApi = ["getData","cmpBind","component","actualConstructor","_connectedCallback","actualConnectedCallback", "getMethods","hasAction", "setActions", "setMethods", "getCallee", "afterConnected", "renderComponent", "renderFast", "formatValue", "renderNodes", "executeBlockHelpers", "updateBlockHelpers", "_attributeChangedCallback" , "removeHelpersSpecificIndex", "removeHelpers", "updateYield", "updateDynamicComponent","updateForHelper", "updateForInHelper", "updateSwitchHelper", "callObservers","bindNode","debounce", "getProperty", "updateNode", "handleBreak", "createCustomEvent", "isEmptyString", "processArgs", "internalHelpers", "processHelper", "getActionProperty", "hasInternalBindings", "getArgValues", "createEventListeners", "registerParentYield", "registerYields", "onCallBack", "callback", "establishObserverBindings", "removeBindings", "actualDisconnected" ,"_disconnectedCallback","throwAction","get","set","initializeMethod"];
customElementPrototype._V3StaticApi = ["_observers","_callBacks","_properties","activeInstances","_depthTemp","_bindsIds","_ssr","_config","_mixins","_serviceToBeUsed","_actions","_template","_dynamicNodes","_templateAttributes","_observedAttributes","_observedMethodAttributes","_data","_methods","_pendingComponents","splitTextNodes" ,"_registerComponent", "createDocFragment1" , "updateValue"];
customElementPrototype._v4RegClassApi = ["_reg","_compName","componentClass","_observedAttributes"]; //component
customElementPrototype._v4RegProtoApi = ["setData", "getData", "setMethods", "get", "set", "_pendingComponents"];
customElementPrototype.version = {v3 : {component : undefined}};
ltCf._customElementPrototype = customElementPrototype;
ltCf.v3 && !ltCf.instanctiatedBridge && ltCf.instanciateBridge();
// window._customElementPrototype = customElementPrototype;
// var onObj = function(){
//     return {"type": "callBack", "value":(this.type === "observer") ? this.value:this , "properties":arguments, "observes":(this.type === "observer" ? this: undefined)}
// }
// var observesObj = function() {
//     return {"type" : "observer", "value" : this, "properties" : arguments, "on":Function.prototype.on}
// }
// var computedObj = function() {
//     return {"type" : "computed", "value" : this, "properties" : arguments}
// }
// var fnProto = Function.prototype;
// fnProto.on ? fnProto.lyteOn = onObj : fnProto.on = onObj;
// fnProto.observes ? fnProto.lyteObserves = observesObj : fnProto.observes = observesObj;
// fnProto.computed ? fnProto.lyteComputed = computedObj : fnProto.computed = computedObj;


// BaseCompiler(Lyte,_LC);
// if(compConfig.compiler){
//     compConfig.compiler(_LC);
// }

_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.typeCast = _LC.typeCast;
_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.getDataType = _LC.getDataType;
// Lyte.Component._get = _LC.get;
_LC.chromeBugFix = function() {
    var version = userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);;
    version = version ? parseInt(version[2], 10) : 0;
    if(version > 62) {
        this.chI = [];
        document.addEventListener("focus", function(event) {
            var target = event.target;
            if(target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.tagName === "DIV") {
                if(_LC.chI.indexOf(target) == -1) {
                    _LC.chI.$push(target);
                }
            }
        } , true);
        this.chromeBugFix = function() {
            var tags = _LC.chI;
            var tagsL = tags.length;
            var toRemove = ["_callee", "_attributeDetails", "_attributes", "_removedAttributes", "_yields" , "_rA", "_cx"];//no i18n
            var toBeRemoved = [];
            var keepAliveInputs = [];
            document.querySelectorAll("[lyte-keep-alive]").forEach(function(item,index){
                for(var key in item._renderedComponent) {
                    keepAliveInputs.$push.apply(keepAliveInputs, Array.from(item._renderedComponent[key].querySelectorAll("input")));
                }
            });
            for(var i= tagsL-1, item;item=tags[i];i--) {
                if((document.compareDocumentPosition(item) % 2) && (keepAliveInputs.indexOf(item) == -1)) {
                    tags.$splice(i,1);
                    item.remove();
                    toBeRemoved.$push(item);
                    item._rA = item._rA || [];
                    item._rA.forEach(function(remAttr) { //eslint-disable-line no-loop-func
                        remAttr.ownerElement = undefined;
                    });
                    toRemove.forEach(function(key) {//eslint-disable-line no-loop-func
                        item[key] = undefined;
                    });
                    Array.from(item.attributes).forEach(function(itemVal) {//eslint-disable-line no-loop-func
                        item.removeAttribute(itemVal.nodeName);
                    });
                }
            }
        }
        // Lyte.addEventListener("afterRouteTransition", function() {
        //     _LyteComponent.chromeBugFix();
        // });
        if(!_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.Router) {
            setInterval(function() {
                // _LC.chromeBugFix();
                _LC.String.cache_c = {};
                _LC.String.cache_d = {};
            },300000)
        }
    }
}
_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.$.chromeBugFix = _LC.chromeBugFix;

// _LC._directives = {};
if(!customElements.get("lyte-safari-test-component")){
    customElements.define("lyte-safari-test-component", Test, undefined, {v4 : true});
}
var divTest = document.createElement("div");
divTest.innerHTML = "<lyte-safari-test-component t></lyte-safari-test-component>";

let _LCSD = _LC.shadow;
// _LyteComponent.render = _LC.render;
//Change it in v3.0 - Remove from _LC scope. 
// _LyteComponent.insertBefore = _LC.insertBefore;
// _LyteComponent.insertAfter = _LC.insertAfter;
// _LyteComponent.replaceWith = _LC.replaceWith;
// _LyteComponent.appendChild = _LC.appendChild;
_LC.tDiv = createElement("template");
_LC.tDiv.setAttribute("id", "dummy-templates-div");
// _LC.tDiv.setAttribute("style", "display:none");
_LC.hDiv = createElement("template");
_LC.hDiv.setAttribute("id", "keep-alive-div");
// _LC.hDiv.setAttribute("style", "display:none");
_LC.h1Div = createElement("template");
_LC.h1Div.setAttribute("id", "lyte-helper-div");
// _LC.h1Div.setAttribute("style", "display:none");

// ComponentRegistry.Compile.componentsDiv = 
_LC.lyteComponentsDiv = createElement("div");
_LC.lyteComponentsDiv.setAttribute("id", "lyte-components-div");
_LC.setComponentsDiv(_LC.lyteComponentsDiv,ComponentRegistry.name);


_LC.dummyLyteComponentsDiv = document.createElement("div");
_LC.dummyLyteComponentsDiv.setAttribute("id", "dummy-lyte-components-div");
_LC.setComponentsDiv(_LC.dummyLyteComponentsDiv,ComponentRegistry.name);

// if(!Lyte._ie) {
if (document.readyState === "complete" || document.readyState === "interactive") {     
    document.body.appendChild(_LC.dummyLyteComponentsDiv);  
    document.head.appendChild(_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.$.assetsDiv);
    document.head.appendChild(_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.$.shadowDiv);
}else{
    document.addEventListener("DOMContentLoaded", function(){
        document.body.appendChild(_LC.dummyLyteComponentsDiv);  
        document.head.appendChild(_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.$.assetsDiv);
        document.head.appendChild(_slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte.$.shadowDiv);
    },true);
}
// }

Set.prototype.toArrayLyte = function() {
    if(this.constructor.name === "Set"){
        return Array.from(this);
    }
    else{
        return Array.from(this._values);
    }
}
//_LC.registerListener(function() {
//  
//});

if(document.readyState === "complete" || document.readyState === "interactive") {
    onDomContentForLyte();
} else {
    document.addEventListener("DOMContentLoaded", function(e){
        onDomContentForLyte();
    },true);
}
_LC.mappy = {
    t: "type",
    p: "position",
    dN: "dynamicNodes",
    c: "cases",
    d: "default",
    a: "attr",
    f: "for",
    fI: "for-in",
    e: "if",
    s: "switch",
    i: "insertYield",
    r: "registerYield",
    cM: "component",
    cD: "componentDynamic",
    a: "attr",
    tX: "text"
    // dcn - dynamicCaseName
    // cn - caseName
    // hd - hasDynamicCase
    // hc - hasChildTrans
    // in - indNew
    // l-c - lyte-convertion
    // lc-id - lyte-case-id
    // lc_id - lyte_case_id
    // cdp - casesDeepNodes
    // co - casesOrder
    // dc - _dChild
}

function createSvgDepth(actualTemplate,type){
    var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    for(var s=0; s<actualTemplate.childNodes.length; s++){
        svg.appendChild(actualTemplate.childNodes[s].cloneNode(true));
    }
    var depthTemp = document.createElement("template");
    depthTemp.setAttribute("is", type);
    for(var s=0; s<svg.childNodes.length; s++){
        depthTemp.content.appendChild(svg.childNodes[s]);
        s--;
    }
    return depthTemp;
}
function createDepth(actualTemplate,type){
    var depthTemp = document.createElement("template");
    depthTemp.setAttribute("is", type);
    depthTemp.innerHTML = actualTemplate.innerHTML;
    return depthTemp;
}
function appendDepth(depthTemp,constr){
    constr.splitTextNodes(depthTemp);
    constr._depthTemp.content.appendChild(depthTemp);
}
function setHT(dynN,info,dynNewCompile,constr){
    var flag  = true;
    if(dynN.tagName == "TEMPLATE") {
        info._ht = dynN.innerHTML;
        flag = false;
    }
    if(info._ht) {
        if(flag){
            dynN.innerHTML = info._ht;
            constr.splitTextNodes(dynN);
        }
        if(dynNewCompile && dynNewCompile.innerHTML !== info._ht) {
            dynNewCompile.innerHTML = info._ht;
            constr.splitTextNodes(dynNewCompile);
        }
    }
}
function doCompile(dynamicN, dynamicNodes, componentName, constr, newCompile, componentClass, fastRenderClass) {
    for(let j=0;j<dynamicNodes.length;j++) {
        let info = dynamicNodes[j], type = info.t, pos = info.p, helperInfo;
        let dynN = getDynamicNode(dynamicN,pos);
        let dynNewCompile;
        if(newCompile && fastRenderClass) {
            dynNewCompile = fastRenderClass.getDynNewCompile(newCompile,pos);
        }
        switch(type) {
        case "tX" : {
            dynN.nodeValue = dynN.nodeValue.replace('.{}','____lyteinternal____');
            var syn = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default().syntaxCheckWorkerNew(dynN.nodeValue);
            let mustache = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default().getMustache(dynN.nodeValue,syn);
            if(mustache){
                mustache = mustache.replace('____lyteinternal____','.{}');
                actObj = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default().getArray(mustache);  
            }
            if(!actObj && mustache){
                actObj = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default().getHelper(mustache);  
            }
            dynN.nodeValue = dynN.nodeValue.replace('____lyteinternal____','.{}');
            let dynamic = mustache;
            if(actObj){
                info.helperInfo = actObj;
                dynNewCompile && fastRenderClass.caseTx(dynNewCompile,mustache,info,j);
           }
            else if(dynamic){
                //deepNodes.$push({type: "text", position:deepN.slice(), dynamicValue: dynamic});
                info.dynamicValue = dynamic;
                info.newDynamicValue = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default().getDV(dynamic);
                if(dynNewCompile) {
                    fastRenderClass.replaceWithPf(dynNewCompile,j)
                }
//              LN to do
//              deepNodes.$push({type: "text", position:deepN.slice(), dynamicValue: getDV(dynamic)});                    
            }
        }
        break;
        case "i" : {
            dynNewCompile && fastRenderClass.caseI(dynNewCompile,info,j);
        }
        break;
        case "cD" : {
            dynNewCompile && fastRenderClass.caseCD(dynNewCompile,info,j);
        }
        break;
        case "a" : {
            let add = false, toBeRemoved = [],toBeAdded = [];
            let node = dynN;
            let attr = info.a = info.a || {};
            for(let i=0;i<node.attributes.length;i++) {
                if(node.attributes[i].nodeValue.indexOf("{{") !== -1) {
                    node.attributes[i].nodeValue = node.attributes[i].nodeValue.replace('.{}','____lyteinternal____');
                    var val = node.attributes[i].nodeValue;
                    var syn = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default().syntaxCheckWorkerNew(val);
                    var actObj,actValue,multipleAttr=false;
                    var splittedMus = val.split("{{");
                    var splittedMusLen = splittedMus.length;
                    if(syn.mustache >0){
                        splittedMusLen = splittedMusLen - syn.mustache;
                    }
                    if((splittedMusLen > 2 || !/^{{/.test(val) || !/}}$/.test(val)) && /{{.*}}/.test(val) && !/\\{{.*}}/.test(val)){
                        actObj = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default().splitMixedText(val);
                        multipleAttr = true;
                    }
                    else{
                        actValue = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default().getMustache(val,syn);
                        if(actValue){
                            actValue = actValue.replace('____lyteinternal____','.{}');
                            actObj = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default().getArray(actValue);  
                        }
                        if(!actObj && actValue){
                            actObj = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default().getHelper(actValue);  
                        }
                    }
                    node.attributes[i].nodeValue = node.attributes[i].nodeValue.replace('____lyteinternal____','.{}');
                    if( actObj && (actObj.name === "action" || actObj.name === "method") && /^(onfocus|onfocusin|onfocusout|onresize|onscroll|onclick|ondblclick|onmousedown|onmouseup|onmousemove|onmouseover|onmouseout|onchange|onselect|onsubmit|onkeydown|onkeypress|onkeyup|oncontextmenu|__focus|__focusin|__focusout|__resize|__scroll|__click|__dblclick|__mousedown|__mouseup|__mousemove|__mouseover|__mouseout|__change|__select|__submit|__keydown|__keypress|__keyup|__contextmenu)$/.test(node.attributes[i].name)){
                            var newActObj;
                            if(actValue){
                                newActObj = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default().getArray(actValue);  
                            }
                            if(!newActObj && actValue){
                                newActObj = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default().getHelper(actValue,true);  
                            }
                            attr[node.attributes[i].name.substr(2)] = {
                                name:node.attributes[i].name.substr(2),
                                camelCase : _LC.String.toCamelCase(node.attributes[i].name.substr(2)),
                                helperInfo: actObj,
                                newHelperInfo : newActObj,
                                globalEvent: true
                            };
                            let actArgs = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(actObj.args);
                            let actName = actArgs.$splice(0,1)[0];
                            actName = actName.startsWith("'")? actName.replace(/'/g,''):  actName;
                            let actString = getArgString(actName, actArgs);
                            node.setAttribute(node.attributes[i].name.substr(2),componentName+" => "+ actString);
                            if(dynNewCompile) {
                                fastRenderClass.setAttribute(dynNewCompile, node.attributes[i].name.substr(2),componentName+" => "+ actString)
                            }
                            toBeRemoved.$push(node.attributes[i].name);                            
                    }
                    else{
                        if(actObj || actValue) {
                            let attrToPush = {};
                            // if(actObj && actObj.name === "method"){
                            //     let actArgs = deepCopyObject(actObj.args);
                            //     let actName = actArgs.$splice(0,1)[0];
                            //     actName = actName.startsWith("'")? actName.replace(/'/g,''):  actName;
                            //     let actString = getArgString(actName, actArgs);
                            //     node.setAttribute(node.attributes[i].name,componentName+" => "+ actString);
                            // }
                            if(node.attributes[i].name.startsWith("lbind:")) {
                                toBeRemoved.$push(node.attributes[i].name);
                                toBeAdded.$push({"name" : node.attributes[i].name.substring(6), "value": node.attributes[i].nodeValue});
                                attrToPush.isLbind = true;
                                attrToPush.name = node.attributes[i].name.substring(6);
                                attrToPush.camelCase = _LC.String.toCamelCase(attrToPush.name);
                            }
                            else {
                                attrToPush.name = node.attributes[i].name;
                                attrToPush.camelCase = _LC.String.toCamelCase(attrToPush.name);
                            }
                            if(actObj) {
                                if(actObj.name === "lbind") {
                                    attrToPush.dynamicValue = actObj.args[0];
                                    attrToPush.newDynamicValue = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default().getDV(actObj.args[0]);
                                    attrToPush.isLbind = true;
                                }
                                else {
                                    attrToPush.helperInfo = actObj;
                                    var newActObj;
                                    if(multipleAttr){
                                        newActObj = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default().splitMixedText(val);
                                    }
                                    else{
                                        if(actValue){
                                            newActObj = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default().getArray(actValue);  
                                        }
                                        if(!newActObj && actValue){
                                            newActObj = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default().getHelper(actValue,true);  
                                        }
                                    }
                                    attrToPush.newHelperInfo = newActObj;
                                }
                            } 
                            else {
                                attrToPush.dynamicValue = actValue;
//                              LN to do
                                attrToPush.newDynamicValue = _compiler_cli_lyte_base_compile_js__WEBPACK_IMPORTED_MODULE_5___default().getDV(actValue);
                            }
                            add = true;
                            attr[attrToPush.name] = attrToPush;
                        }                  
                    }
                }
                // if(node.attributes[i].name == "$data"){
                //     let attrName = node.attributes[i].name;
                //     attr[attrName].isSpreadData = true;
                // }
                if(node.attributes[i].name.startsWith("@")){
                    let specialAttr;
                    add = true;
                    node._special = true;
                    let attrToPush = {};
                    attrToPush.name = node.attributes[i].name;
                    if(attr[attrToPush.name] && attr[attrToPush.name].dynamicValue){
                        attrToPush.dynamicValue = attr[attrToPush.name].dynamicValue;
                    }else if(attr[attrToPush.name] && attr[attrToPush.name].helperInfo){
                        attrToPush.helperInfo = attr[attrToPush.name].helperInfo;
                    }else{
                        attrToPush.stringValue = node.attributes[i].nodeValue;
                        let ndName = node.attributes[i].nodeName
                        toBeRemoved.push(ndName);
                        toBeAdded.push({name : "lyte-directive-" + ndName.slice(1,ndName.length), value : ""});
                    }
                    attr[attrToPush.name] = attrToPush;
                    attrToPush.hookNode  = true;
                    let hookName = node.attributes[i].name.slice(1,node.attributes[i].name.length);
                    attrToPush.hookName = hookName;
                    specialAttr = true;
                }
            }
            if(toBeRemoved.length){
                for(let i=0; i<toBeRemoved.length;i++){
                    node.removeAttribute(toBeRemoved[i]);
                }
            }
            if(dynNewCompile) {
                fastRenderClass.removeAttributeArr(dynNewCompile, toBeRemoved);
                fastRenderClass.removeAttributeObj(dynNewCompile, attr, j)
            }
            if(toBeAdded.length) {
                for(let i=0;i<toBeAdded.length;i++) {
                    node.setAttribute(toBeAdded[i].name, toBeAdded[i].value);
                }
            }
        } 
        break;
        case "f" : 
        case "fI" : 
        case "r" : 
            setHT(dynN,info,dynNewCompile,constr);
        case "cM" : {
            var actualTemplate = dynN.content;
            if(!dynNewCompile && (type == "r" || dynN.hasAttribute("unbound"))) { //af check
                if(fastRenderClass){
                    dynNewCompile = fastRenderClass.cMBefore(dynN, info);
                }
            }
            let depthTemp;
            let dnNode;
            let actualTemplateNewCompile = dynNewCompile ? fastRenderClass.cMBefore2(dynNewCompile, info, constr) : undefined;
            if(info.actualTemplate) {
                actualTemplate = _LC.getContentForIE(info.actualTemplate, constr, undefined, _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte._ms? info : undefined);
            }
            doCompile(actualTemplate, info.dN, componentName, constr, actualTemplateNewCompile, componentClass, fastRenderClass);
            if(dynNewCompile){
                fastRenderClass.cMAfter(actualTemplateNewCompile, info, type, j, dynNewCompile);
            }
            // if(Lyte._ms) {
            //     if(info.actualTemplate) {
            //         info.templateContent = actualTemplate.outerHTML;
            //         if(info._content) {
            //             info.actualTemplate = info._content.innerHTML;
            //             delete info._content;
            //         }
            //     } else {
            //         info.templateContent = dynN.outerHTML;
            //     }
            //     dynN.innerHTML = "";  
            // }
            if(info.actualTemplate) {
                depthTemp = type;
                // if(!Lyte._ie ) {
                    if(info.svg){
                        depthTemp = createSvgDepth(actualTemplate,type)
                    }else{
                        depthTemp = createDepth(actualTemplate,type)
                    }
                    appendDepth(depthTemp,constr);
                // }
                if(dynamicNodes[j-1] && (dynamicNodes[j-1].p.toString() === dynamicNodes[j].p.toString())) {
                    dnNode = dynamicNodes[j-1];
                } else {
                    dnNode = dynamicNodes[j];
                }
                dnNode._depthTemp = depthTemp;
            }
            if(info._ht) {
                info._ht = dynN.cloneNode(true);
                componentClass._helperTemplate.content.append(info._ht)
                dynN.innerHTML = "";
            }
                //  When a registerYield is present inside another registerYield, in fastRender, we will not be able to get the template using the positions and parentComponent alone, since the insertYield is present inside the insertYield of the parent component. 
                // info.actYield = dynN;
              }
        break;
        case "e" : 
        case "s" : {
            let caseStr;
            setHT(dynN,info,dynNewCompile,constr);
            let depthTemp;
            let actualTemplateNewCompile;
            if(info.actualTemplate) {
                dynN = _LC.getContentForIE(info.actualTemplate, constr, undefined);
            }
            if(dynNewCompile){
                actualTemplateNewCompile = fastRenderClass.caseES(dynNewCompile, info, constr);
            }
            var def = "default";
            // if(Lyte._ms) {
            // 	var cases = {};
            //     var defCase;
            //     var dynNchildNodes = dynN.childNodes;
            //     var lyteCaseName = info.hd ? "lc-id" : "case";
            //     for(var i=0;i<dynNchildNodes.length;i++) {
            //       if(dynNchildNodes[i].tagName === "TEMPLATE"){
            //         if(dynNchildNodes[i].getAttribute(lyteCaseName)) {
            //             cases[dynNchildNodes[i].getAttribute(lyteCaseName)] = dynNchildNodes[i];
            //         } else if(dynNchildNodes[i].hasAttribute("default")) {
            //     		  defCase = dynNchildNodes[i];
            //     	  }
            //       }
            //     }
            //     for (let key in info.c) {
            //         if(info.c[key].dcn){
            //             doCompile(dynN, [info.c[key].cdp], componentName, constr ,undefined ,componentClass, fastRenderClass);
            //         }
            //     }
            //     for (let key in info.c) {
            //         let contentNewCompile;
            //         caseStr = info.c[key].dcn ? "[lc-id='" : "[case='";                    
            //         content = _LC.getContentForIE(cases[key], undefined, true);
            //         if(actualTemplateNewCompile) {
            //             contentNewCompile = _LC.getContentForIE(actualTemplateNewCompile.querySelector(caseStr+_LC.cssEscape(key)+ "']"));
            //         }
            //         setHT(content,info.c[key],contentNewCompile,constr);

            //         doCompile(content, info.c[key].dN, componentName, constr, contentNewCompile ? _LC.getContentForIE(contentNewCompile) : undefined, componentClass, fastRenderClass);

            //         cases[key].remove();
            //         if(actualTemplateNewCompile) {
            //             info.c[key]._sta = _LC.processStatic(contentNewCompile);
            //         }
            //         info.c[key].templateContent = cases[key].outerHTML;
            //     }
            //     if (info.d.dN) {
            //         let contentNewCompile;
            //         content = _LC.getContentForIE(defCase, undefined, true);
            //         if(actualTemplateNewCompile) {
            //             contentNewCompile = actualTemplateNewCompile.querySelector("[default]");
            //         }
            //         setHT(content,info.d,contentNewCompile,constr);
            //         doCompile(content, info.d.dN, componentName, constr, contentNewCompile? _LC.getContentForIE(contentNewCompile) : undefined, componentClass, fastRenderClass);

            //         defCase.remove();
            //         info.d.templateContent = defCase.outerHTML;
            //         if(actualTemplateNewCompile) {
            //             info.d._sta = _LC.processStatic(contentNewCompile);
            //         }
            //     }
            // } else {
                var dynNContent = dynN.content || dynN;
            	for(let key in info.c) {
                    caseStr = info.c[key].dcn ? "[lc-id='" : "[case='";
                    let contentNewCompile;
                    if(actualTemplateNewCompile) {
                        contentNewCompile = _LC.getContentForIE(actualTemplateNewCompile.querySelector(caseStr+_LC.cssEscape(key)+ "']"));
                    }
                    var content = _LC.getContentForIE(dynNContent.querySelector(caseStr+_LC.cssEscape(key)+ "']"), undefined, true);
                    setHT(content,info.c[key],contentNewCompile,constr);
            		if(info.c[key].dcn){
                        doCompile(dynNContent, [info.c[key].cdp], componentName, constr ,undefined ,componentClass);
                    }
                    doCompile(content.tagName === "TEMPLATE" ? content.content : content, info.c[key].dN,componentName, constr, contentNewCompile, componentClass, fastRenderClass);
                    if(actualTemplateNewCompile) {
                      info.c[key]._sta = _LC.processStatic(contentNewCompile);
                    }
                    if(info.c[key]._ht) {
                        info.c[key]._ht = content.cloneNode(true);
                        componentClass._helperTemplate.content.append(info.c[key]._ht)
                        content.innerHTML = "";
                    }
            	}
            	if(info.d.dN) {
                    let contentNewCompile
                    if(actualTemplateNewCompile) {
                        contentNewCompile = _LC.getContentForIE(actualTemplateNewCompile.querySelector("[default]"));
                    }
                    var content = _LC.getContentForIE(dynNContent.querySelector("[default]"), undefined, true);
                    setHT(content,info.d,contentNewCompile,constr);
            		doCompile(content.tagName === "TEMPLATE" ? content.content : content, info.d.dN,componentName, constr, contentNewCompile, componentClass, fastRenderClass);
                    if(actualTemplateNewCompile) {
                      info.d._sta = _LC.processStatic(contentNewCompile);
                    }
                    if(info.d._ht) {
                        info.d._ht = content.cloneNode(true);
                        componentClass._helperTemplate.content.append(info.d._ht)
                        content.innerHTML = "";
                    }
            	}
            	
            // }

            if(info.actualTemplate) {
                depthTemp = type;
                // if(!Lyte._ie ) {
                    if(info.svg){
                        depthTemp = createSvgDepth(dynN.content,type)
                    }else{
                        depthTemp = createDepth(dynN,type)
                    }
                    appendDepth(depthTemp,constr);
                // }
                if(dynamicNodes[j-1] && (dynamicNodes[j-1].p.toString() === dynamicNodes[j].p.toString())) {
            		dynamicNodes[j-1]._depthTemp = depthTemp;
            	} else {
            		dynamicNodes[j]._depthTemp = depthTemp;
            	}
            }

            if(dynNewCompile) {
                fastRenderClass.replaceWithPf(dynNewCompile,j)
            }
            if(info._ht) {
                info._ht = dynN.cloneNode(true);
                componentClass._helperTemplate.content.append(info._ht)
                dynN.innerHTML = "";
            }
        }
        break;    
        }
    }
}

//This is the function where the actual rendering takes place. 
//It takes the template, finds the actual dynamic nodes uwing dynamicNodes argument and then binds each node with the associated
//property by calling bindNode. 

function getDynamicNode(content, positions){
    let dynamicN = content;
    for(var i=0; i<positions.length; i++){
        dynamicN = (dynamicN.tagName != "TEMPLATE") ? dynamicN.childNodes[positions[i]] : dynamicN.content.childNodes[positions[i]];
    }
    return dynamicN;
}

function getArgString(name, array) {
    let retString;
    for(let i=0;i<array.length;i++) {
        if(array[i] && typeof array[i] === "object") {
            array[i] = getArgString(array[i].value.name, array[i].value.args);
        }
    }
    if(name) {
        retString = name +  "(" + array.toString() + ")";
    } else {
        retString = array.toString();
    }
    return retString;
}

var defHelpers = ComponentRegistry._defaultHelpers;
defHelpers["unbound"] = function(value){
     return value;
}
defHelpers["action"] = function(parentNode,attrName,isCustom,actObj){
    if(isCustom){
        parentNode._actions = parentNode._actions? parentNode._actions : {};
        if(!parentNode._actions[attrName]){
            this.$node.createCustomEvent(attrName, parentNode, actObj); 
            parentNode.removeAttribute(attrName);
        }
    }
    else{
        
        this.$node.createEventListeners(parentNode,attrName,actObj);    
    }
};

defHelpers["lbind"] = function(name){
	return this.getData(name);
};

defHelpers["method"] = function(parentComponent, attributeNode, functionName) {
    var parentComponent = arguments[0];
    var attributeNode = arguments[1];
    var functionName = arguments[2];
    var self = arguments[0].component;
    var childComponent = attributeNode? attributeNode.ownerElement : null;
    var attributeName = arguments[1].nodeName;
    attributeNode = null;
    var args = Array.prototype.slice.call(arguments, 2);
    var newFunc = function() {
        let node = this.$node;
        let contextSwitchArray = [];
        _LC.adCx(node, contextSwitchArray);
        let processDetails = {};
        let processedArgs = this.$node.processArgs(this.$node._callee,{"helperInfo" : {"args" : args}}, [], undefined, this.$node, undefined, undefined, undefined, processDetails);
        let functionName1 = processedArgs.$splice(0,1)[0];
        _LC.rmCx(node, contextSwitchArray);
        let customArgs = Array.from(arguments);
        let mainArgs = processedArgs.$concat(customArgs);
        if(self._methods[functionName1]) {
            return self._methods[functionName1].apply(self, mainArgs);
        }
        //@Slicer.developmentStart
        _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error("LC005", functionName, self.$node.tagName);
        //@Slicer.developmentEnd
    }
    if(childComponent) {
        if(!childComponent.set) {
            childComponent.setMethods(_LC.String.toCamelCase(attributeName), newFunc);
        } else {
            childComponent.component._methods[_LC.String.toCamelCase(attributeName)] = newFunc;
        }
    } else {
        return newFunc;
    }
};

// defHelpers["unescape"] = function(value,additionalObject,userInstance){
//     let lyteIns = this.getAppOrAddon();
//     if(_LC.ffr) {
//         return value;
//     }
//     if(lyteIns.Security.ignoreSanitizer){ //af check //take this lyte app instance and proceed
//         let divEle = document.createElement("div");
//         divEle.innerHTML = value;
//         return divEle;
//     }
//     else{
//         if(additionalObject && Object.keys(additionalObject) && Object.keys(additionalObject).length >0){
//             if(Object(additionalObject.GLOBAL_TAGS).length>0){
//                 var index = additionalObject.GLOBAL_TAGS.indexOf("link-to");
//                 if(index != -1){
//                     additionalObject.GLOBAL_TAGS.$splice(index,1);
//                 }
//             }
//             if(additionalObject && additionalObject.GLOBAL_ATTRIBUTES && Object.keys(additionalObject.GLOBAL_ATTRIBUTES).length>0){
//                 var arr = ["yield-name","lt-prop-route", "lt-prop-dp", "lt-prop-fragment", "lt-prop-qp", "lt-prop", "lt-prop-class", "lt-prop-id", "lt-prop-rel", "lt-prop-title", "lt-prop-style", "lt-prop-target","lt-prop-td","lt-prop-custom","lt-prop-target","lt-prop-id","lt-prop-class","lt-prop-style","lt-prop-rel","lt-prop-title"];
//                 for(var i=0;i<arr.length;i++){
//                     var index =additionalObject.GLOBAL_ATTRIBUTES.indexOf(arr[i]);
//                     if(index != -1){
//                         additionalObject.GLOBAL_ATTRIBUTES.$splice(index,1);
//                     }
//                 }
//             }
//         }
//         if(additionalObject && additionalObject.GLOBAL_TAGS){//this if check is inorder to getobserved attributes given in globaltags
//             if(additionalObject.GLOBAL_ATTRIBUTES == undefined){
//                 additionalObject.GLOBAL_ATTRIBUTES = [];
//             }
//             var globalTagArr = Array.from(additionalObject.GLOBAL_TAGS);
//             var attr = [];
//             for(var a=0; a<globalTagArr.length; a++){

//                 let regComps = ComponentRegistry._registeredCommonClass;
//                 if(regComps[globalTagArr[a]]){
//                     attr = regComps[globalTagArr[a]].observedAttributes;
//                 }else if(Lyte.registeredCustomComponent[globalTagArr[a]]){
//                     if(Lyte.registeredCustomComponent[globalTagArr[a]].observedAttributes){
//                         attr = Lyte.registeredCustomComponent[globalTagArr[a]].observedAttributes;
//                     }else{
//                         attr = [];
//                     }
//                 }
//                 for(var i=0; i<attr.length; i++){
//                     if(additionalObject.GLOBAL_ATTRIBUTES.indexOf(attr[i]) == -1){
//                         additionalObject.GLOBAL_ATTRIBUTES.$push(attr[i]);
//                     }
//                 }
//             }
//         }
//         var divEle = document.createElement("div");
//         if(userInstance && Object.keys(userInstance).length){
//             if(additionalObject && Object.keys(additionalObject).length){
//                 lyteIns.Security.addGlobalObject(userInstance,additionalObject);
//                 var clean = userInstance.sanitize(value);
//                 lyteIns.Security.removeGlobalObject(userInstance,additionalObject);
//             }
//             else{
//                 var clean = userInstance.sanitize(value);
//             }
//         }
//         else{
//             if(additionalObject && Object.keys(additionalObject).length){
//                 lyteIns.Security.addGlobalObject(lyteIns.Security._ourSanitizerInstance_,additionalObject);
//                 var clean = lyteIns.Security._ourSanitizerInstance_.sanitize(value);
//                 lyteIns.Security.removeGlobalObject(lyteIns.Security._ourSanitizerInstance_,additionalObject);
//             }else{
//                 var clean = lyteIns.Security._ourSanitizerInstance_.sanitize(value);
//             }
//         }
//         divEle.innerHTML = clean;
//         return divEle;
//     }
// };
defHelpers["unescape"] = function(value, additionalObject, userInstance) {
    let lyteIns = this.getAppOrAddon();
    if(_LC.ffr) {
        return value;
    }
    let divEle = document.createElement("div");
    if(lyteIns.Security.ignoreSanitizer){ //af check //take this lyte app instance and proceed
        divEle.innerHTML = value;
        return divEle;
    }
    else{
        if(additionalObject && Object.keys(additionalObject) && Object.keys(additionalObject).length > 0){
            _LC.Security.initializeConfig(additionalObject);
            _LC.Security.removeConfig(additionalObject);
            _LC.Security.addLyteComponents(additionalObject);
        }
        let clean;
        let ins = userInstance && Object.keys(userInstance).length ? userInstance : lyteIns.Security._ourSanitizerInstance_;
        if(additionalObject && Object.keys(additionalObject).length){
            clean = _LC.Security.sanitizeWithConfig(value ,additionalObject, ins);
        }else{
            clean = ins.sanitize(value);
        }
        divEle.innerHTML = clean;
        return divEle;
    }
};

defHelpers["escape"] = function(value,type){
    if(type == 'url'){
        return ZSEC.Encoder.encodeForHTMLAttribute(value);	
    }
    else if(type == 'js'){
        return ZSEC.Encoder.encodeForJavaScript(value);
    }
    else if(type == 'css'){
        return ZSEC.Encoder.encodeForCSS(value);	
    }
    else{
        return value;
    }
};

defHelpers["debugger"] = function() {
    debugger;
};

defHelpers["log"] = function() {
    console.log.apply(window, Array.from(arguments));
};

defHelpers["ifEquals"] = function(arg1, arg2) {
    if(arg1 === arg2) {
        return true;
    } else {
        return false;
    }
};

defHelpers["if"] = function(value, trueValue, falseValue) {
    if(value) {
        return trueValue;
    } else {
        return falseValue;
    }
};

defHelpers["negate"] = function(arg1) {
    return !arg1;
};


defHelpers["ifNotEquals"] = function(arg1, arg2) {
    if(arg1 === arg2) {
        return false;
    } else {
        return true;
    }
};

function addSlash(value) {
    return ((value[0] != "/") ? "/" : "") + value;
}
defHelpers["slyteImport"] = function(src){
    if(src!=undefined){
        let entry = addSlash(src);
        if (window.LyteFingerPrint && LyteFingerPrint.fingerPrint && LyteFingerPrint.fingerPrint[entry]) {
            return addSlash(LyteFingerPrint.fingerPrint[entry].file.trim());
        }
        return src;
    }
    throw new Error("Missing path argument!!!");
}

defHelpers['concat'] = function(){
	var resp = '';
	var argLength = arguments.length;
	for(var i=0;i<argLength;i++){
		if(arguments[i] != undefined){
			resp += arguments[i];
		}
	}
	return resp;
};


defProp(HTMLElement.prototype, 'setData', {
    configurable : true, 
    writable : true,
    value : function(arg0, arg1) {
        this._initProperties = this._initProperties || {};
        if(typeof arg0 === "string") {
            this._initProperties[arg0] = arg1
        } else if(typeof arg0 === "object") {
            for(let key in arg0) {
                this._initProperties[key] = arg0[key];
            }
        }
    }
});

defProp(HTMLElement.prototype, 'setMethods', {
    configurable : true, 
    writable : true,
    value : function(arg0, arg1) {
        this._initMethods = this._initMethods || {};
        if(typeof arg0 === "string") {
            this._initMethods[arg0] = arg1
        } else if(typeof arg0 === "object") {
            for(let key in arg0) {
                this._initMethods[key] = arg0[key];
            }
        }
    }
});

defHelpers['encAttr'] = function(val) {
    return ZSEC.Encoder.encodeForHTMLAttribute(encodeURIComponent(val));
}

defHelpers['expHandlers'] = function(leftOperand,operator,rightOperand,nextOperand){
    var argLen = arguments.length;
    if(operator == '++' ){
    	if(rightOperand == "postfix"){
    	   return (leftOperand++);
    	} else if(rightOperand == "prefix"){
    		return (++leftOperand);
    	}
    } else if(operator == "--"){
    	if(rightOperand == "postfix"){
    	   return (leftOperand--);
    	} else if(rightOperand == "prefix") {
    		return (--leftOperand);
    	}
    } else if((operator == "==")){
    	return leftOperand == rightOperand;
    }
     else if((operator == "===")){
    	return leftOperand === rightOperand;
    }
    
    else if((operator == "!=")) {
        return leftOperand != rightOperand;
    }
    else if((operator =="!==")) {
        return leftOperand !== rightOperand;
    }
    else if( operator == "&&") {
    	return leftOperand && rightOperand;
    } else if(operator == "||") {
    	return leftOperand || rightOperand;
    } else if(operator == "+"){
        if(argLen > 2){
        	return leftOperand+rightOperand;
        }
        return leftOperand;
    } else if(operator == '-'){
         if(argLen > 2){
        	return leftOperand-rightOperand;
        }
        return (-leftOperand);
    } else if(operator == '*'){
    	return leftOperand * rightOperand;
    } else if(operator == "/"){
    	return leftOperand / rightOperand;
    } else if(operator == "%"){
    	return leftOperand % rightOperand;
    } else if(operator == "<"){
    	return leftOperand < rightOperand;
    } else if(operator == ">") {
    	return leftOperand > rightOperand;
    } else if(operator == "<=") {
    	return leftOperand <= rightOperand;
    } else if(operator == ">=") {
    	return leftOperand >= rightOperand;
    } else if(operator == '|') {
        return leftOperand | rightOperand;
    } else if(operator == '&') {
        return leftOperand & rightOperand;
    }
    else if(operator == "!" ){
        return (!leftOperand);
    } else if(operator == '=') {
        leftOperand = rightOperand;
        return leftOperand;
    } else if(operator == "+=") {
        return leftOperand += rightOperand;
    } else if(operator == '-=') {
        return leftOperand -= rightOperand;
    } else if(operator == "*=") {
        return leftOperand *= rightOperand;
    } else if(operator == '/=') {
        return leftOperand /= rightOperand;
    } else if(operator == '?:') {
        return (leftOperand ? rightOperand : nextOperand);
    }
 };

ComponentRegistry.registerCustomPropHandler("ltProp");

_LC.shouldIgnoreDisconnect = function() {
    return _LC.ignoreDisconnect;
}

_LC.addAction = function(element, eventName, func, context) {
    element._lyteEvents = element._lyteEvents || {};
    element._lyteEvents[eventName] = element._lyteEvents[eventName] || []; 
    var ind = element._lyteEvents[eventName].$push({"func" : func, "fromEventListener" : true, "context" : context});
    return eventName + "-" + ind; 
  }

ComponentRegistry.prototype.removeAction = function(element, listenerId) {
    if(!listenerId) {
        //@Slicer.developmentStart
        _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error("LC014")
        //@Slicer.developmentEnd
        return;
    }
    var split = listenerId.split('-');
    var eventName = split[0];
    var index = parseInt(split[1]);
    if(!element._lyteEvents || !element._lyteEvents[split[0]] || isNaN(index)) {
        //@Slicer.developmentStart
        _utils_lyte_errors_js__WEBPACK_IMPORTED_MODULE_4__.ComponentError.error("LC015")
        //@Slicer.developmentEnd
        return;
    }
    element._lyteEvents[split[0]][split[1] - 1] = {};
}


_LC.hasLyteEvents = function(element, eventName) {
    if(element._lyteEvents && element._lyteEvents[eventName]) {
        return true;
    } else {
        return false;
    }
}

_LC.handleLyteEvents = function(element, event) {
    var funcs = element._lyteEvents[event.type];
    var ret;
    var eventStopped;
    for(var i=0;i<funcs.length;i++) {
        if(funcs[i].func) {
            ret = funcs[i].func.call(funcs[i].context ? funcs[i].context : window, event);
            if(ret === false || event.cancelBubble) {
                eventStopped = true;
                break;
            } 
        }
    }
    if(eventStopped) {
        event.stopPropagation();
    }
    return eventStopped;
}
_LC.executeObservers = function(compClass){
    _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte._preRegister();
    let __observers = compClass.observers();
    _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte._postRegister();
    return __observers;
}
_LC.chromeBugFix();
_LC.booleanAttrList = ["async","autocomplete","autofocus","autoplay","border","challenge","checked1","compact","contenteditable","controls","default","defer","disabled","formNoValidate","frameborder","hidden","indeterminate","ismap","loop","multiple","muted","nohref","noresize","noshade","novalidate","nowrap","open","readonly","required","reversed","scoped","scrolling","seamless","selected","sortable","spellcheck","translate"]

_LC.core = {};
_LC.core._constructor = customElementPrototype;
_LC.core._registerComponent = customElementPrototype._registerComponent;
_LC.core.registerComponent = _LC.registerComponent;
_LC.core.executeBlockHelpers = customElementPrototype.prototype.executeBlockHelpers;
_LC.core.updateForHelper = customElementPrototype.prototype.updateForHelper;
_LC.core.updateForInHelper = customElementPrototype.prototype.updateForInHelper;
_LC.core.updateSwitchHelper = customElementPrototype.prototype.updateSwitchHelper;

ComponentRegistry.prototype.set = _LC.set;
ComponentRegistry.prototype.get = _LC.get;
_LC.aF._name = "arrayUtils";
_LC.oF._name = "objectUtils";
_slyte_core_src_Utils_js__WEBPACK_IMPORTED_MODULE_10__.Utils.addMethods([_LC.set,_LC.get,_LC.arrayUtils,_LC.objectUtils])
let appendChild = _LC.appendChild;
let insertAfter = _LC.insertAfter;
let insertBeforeFn = _LC.insertBefore
let replaceWith = _LC.replaceWith;
let render = _LC.render;
let shouldIgnoreDisconnect = _LC.shouldIgnoreDisconnect;
_LC.globalDOMEvents = globalDOMEvents;
_LC.globalEventHandler = globalEventHandler;
_LC.changeEventhandler = changeEventhandler;
_LC.doCompile = doCompile;
_LC.getDynamicNode = getDynamicNode;
function getNearestApp(node){
    while(node){
      if(node.component){
        return node.component.getApp();
      }
      node = node.parentElement;
    }
    return _slyte_core__WEBPACK_IMPORTED_MODULE_1__.Lyte._getDefaultAppIns();
}



/***/ }),

/***/ 87044171:
/*!****************************************************************!*\
  !*** ./node_modules/@slyte/component/src/utils/lyte-errors.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiError": () => (/* binding */ ApiError),
/* harmony export */   "ComponentError": () => (/* binding */ ComponentError),
/* harmony export */   "RegistryError": () => (/* binding */ RegistryError)
/* harmony export */ });
/* harmony import */ var _slyte_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/core */ 182578);
//ignorei18n_start


class ComponentError extends _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Logger {
    constructor(){
        super(...arguments);
    }
}

ComponentError.errorCodes = {
    LC001: "Error while parsing custom prop handler attribute {0} to the component {1}. Check if the value provided is a valid JSON",
    LC002: "{0} Component is not compiled. Please compile using Lyte CLI",
    LC003: "Helper named {0} is not defined",
    LC004: "Action named {0} doesn't exists",
    LC005: "Method named {0} doesn't exists in {1} component",
    LC006: "Error in data passed to component '{0}' for the properties - {1}",
    LC007: "Directive syntax is used but source not loaded",
    LC008: "{0} component not supporting turbo render. please add @turbo-supported in the component's template tag.",
    LC009: "Error in updateForHelper",
    LC010: "Passing lyteFastRender to unbound option in 'for' helper is depricated. So please make use of '@turbo' directive in the node - {0}",
    LC011: "Fast render source not bundled",
    LC012: "Error with templateAttributes.",
    LC013: "Data passed for property '{0}' of '{1}' cannot be serialized. The component '{2}' might not be registered before its use.",
    LC014: "No listenerId provided",
    LC015: "Invalid listenerId / listener is not available",
    LC016: "Deprecation Warning! pass the component class to component-class attribute, instead of passing '{0}' string component name to component-name attribute.",
    LC017: "{0} component not supporting shadow dom rendering. please add @shadow-supported in the component's template tag.",
    LC018: "Expected to pass object for '$data' on the component {0}.",
    LC019: "A datatype mismatch has occurred for custom DataType '{0}'"
};

ComponentError.register();

class ApiError extends _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Logger {
    constructor(){
        super(...arguments);
    }
}

ApiError.errorCodes = {
    LC001: "Lyte.objectUtils doesn't support {0} function",
    LC002: "Lyte.arrayUtils doesn't support {0} function",
    LC003: "Component not specified in Lyte.Component.render",
    LC004: "Specified outlet {0} doesn't exists - Lyte.Component.render",
    LC005: "Parent Node / reference Node not provided for insertBefore method",
    LC006: "Invalid registry instance passed - Lyte.Component.render",
    LC007: "Uninstantiated registry class passed - Lyte.Component.render",
    LC008: "Unregistered component class passed - Lyte.Component.render",
    LC009: "Sanitizer instance not passed to sanitize api",
    LC010: "Invalid data passed in Lyte.Component.render"

};

ApiError.register();

class RegistryError extends _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Logger {
    constructor(){
        super(...arguments);
    }
}

RegistryError.errorCodes = {
    LC001: "'{0}' registry is not registered with Lyte.",
    LC002: "'{0}' - '{1}' already registered with '{1}' registry.",
    LC003: "'{0}' Component class should extend a ComponentRegistry's Component property directly or extend through base component.",
    LC004: "Registry class extended in the '{0}' '{1}' is not registered with Lyte",
    LC005: "Invalid registry instance '{0}' passed in addRegistries hook of {1}",
    LC006: "Invalid registry instance '{0}'",
    LC007: "'{0}' Registry linked recursively in the app/addon.",
    LC008: "Invalid registry instance '{0}' passed in setDefaultRegisty hook of '{1}'",
    LC009: "Default Registry as well as Current Registry not found.",
    LC010: "{0} : {1} Not found in any registry.",
    LC011: "Invalid registry class '{0}' passed to lyte-registry in the component '{1}'",
    LC012: "Uninstantiated registry class '{0}' passed to lyte-registry in the component '{1}'",
    LC013: "Invalid registry name '{0}' passed to lyte-registry in the component '{1}'",
    LC014: "Uninstantiated registry class '{0}' passed to lyte-registry in the component '{1}'"
};

RegistryError.register();


//ignorei18n_end

/***/ }),

/***/ 33578235:
/*!*******************************************************************!*\
  !*** ./node_modules/@slyte/component/src/utils/lyte-sanitizer.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Sanitizer": () => (/* binding */ Sanitizer)
/* harmony export */ });
/* harmony import */ var _slyte_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/component */ 93270456);

class Sanitizer {
    constructor(config){
        this._sanitzer = _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.Security.createSanitizer(config);
    }
    clean(config){
        config.instance = this._sanitzer;
        return _slyte_component__WEBPACK_IMPORTED_MODULE_0__._LC.Security.sanitizeHTML(config);
    }
}



/***/ }),

/***/ 68393168:
/*!**************************************************!*\
  !*** ./node_modules/@slyte/core/src/DataType.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataType": () => (/* binding */ DataType)
/* harmony export */ });
/* harmony import */ var _lyte_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lyte-error */ 182578);
/* harmony import */ var _lyte_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lyte-utils */ 60768251);



class DataType {
    static register(opts){
        this._name = this.name.replace(/([a-zA-Z0-9])(DataType)$/g, '$1');
        var clsExt = this.extends || this.type;
        this.type = clsExt;
        if(clsExt == undefined || DataType.types.indexOf(clsExt) == -1){
            _lyte_error__WEBPACK_IMPORTED_MODULE_0__.Logger.error("Not a valid field type - "+clsExt);
            return;
        }  
        if(this.prototype.serialize){
            this.serialize = this.prototype.serialize;
        }      
        if(this.prototype.deserialize){
            this.deserialize = this.prototype.deserialize;
        }
        var rHash = opts.refHash;
        var currCls = this, 
        appMap = DataType.lyte = DataType.lyte || new Map(),  
        dtMap,
        currClsName = currCls.name;
        if(!appMap.has(rHash)){
            appMap.set(rHash, new Map());
        }
        dtMap = appMap.get(rHash);
        if(!dtMap.has(currClsName)){
            dtMap.set(currCls.name, currCls);
        }
        DataType.triggerEvent(rHash, currCls);
    }
    static registerInApp(parent){
        var name = this._name = this.name || this.name.replace(/([a-zA-Z0-9])(DataType)$/g, '$1');
        var clsExt = this.extends || this.type;
        this.type = clsExt;
        if(clsExt == undefined || DataType.types.indexOf(clsExt) == -1){
            _lyte_error__WEBPACK_IMPORTED_MODULE_0__.Logger.error("Not a valid field type - "+clsExt);
            return;
        }  
        if(this.prototype.serialize){
            this.serialize = this.prototype.serialize;
        }      
        if(this.prototype.deserialize){
            this.deserialize = this.prototype.deserialize;
        }
        var name = this._name = this._name || this.name.replace(/([a-zA-Z0-9])(DataType)$/g, '$1');
        if(!parent.dataType.hasOwnProperty(name)){
            parent.dataType[name] = this;
            if(parent.dataType.triggerEvent){
                parent.dataType.triggerEvent("add", name, this);
            }
        }
        else{
            _lyte_error__WEBPACK_IMPORTED_MODULE_0__.Logger.warn("DataType with the same name - "+ name+ " already present in the app");
        }
    }
}
(0,_lyte_utils__WEBPACK_IMPORTED_MODULE_1__.defProp)(DataType, "types", {
    value: ["string", "object", "number", "boolean", "array"]
});
(0,_lyte_utils__WEBPACK_IMPORTED_MODULE_1__.extendEventListeners)(DataType);


/***/ }),

/***/ 35352898:
/*!**************************************************!*\
  !*** ./node_modules/@slyte/core/src/JsonPath.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Jwalk": () => (/* binding */ pathFinder)
/* harmony export */ });
/* harmony import */ var _slyte_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/core */ 46823552);


function pathFinder (scope,path){
    if(path){
        var Json = scope;
        if(typeof scope == "object"){
            return parsePath(scope,path)
        }
    }
    else{
        _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Lyte.error("Invalid JsonPath - " + path)
    }
}
function parsePath (scope,path){
    if(path.includes(".")){
        path=path.replace(/ /g,"");
        var pathArr =path.split(".")
        if(pathArr[0] == "$"){
            pathArr.splice(0,1)
        }
    }
    return GetData(scope,pathArr)
}
function GetData (scope,path,DeepTraverse){
    if(DeepTraverse){
        var arr =[];
        if(Array.isArray(scope)){
            path.splice(0,1);
            for(var i_deep=0; i_deep<scope.length ; i_deep++){
            var value = deepBranches(scope[i_deep],path,DeepTraverse)
            if(Array.isArray(value) && value.length ==0){
                value = undefined;
            }
            if(value){
                arr.push(value)
            }
            }
            return arr;
        }
    }
    else{
        return deepBranches(scope,path,DeepTraverse)
    }
}
function deepBranches (obj,path,DeepTraverse){
    for(var pathIndex =0 ; pathIndex<path.length; pathIndex ++){
        var key = path[pathIndex];
        var nextKey = path[pathIndex+1],_nextKey;
        if(nextKey){
            _nextKey = keyParser(nextKey);
        }
        if(key.includes("[") && key.includes("]")){
            var utilScope = key.match(/\[([^\]]+)\]/g)[0]
            var utilKey = key.match(/^(.+?)\[/g)
            if(utilKey){
                utilKey=utilKey[0].replace(/\[/g,"");
            }
            if(!Array.isArray(obj) && utilKey){
                obj = obj[utilKey];
            }
            obj = (!Array.isArray(obj) && utilScope) ? undefined : obj;
            if(Array.isArray(obj)){
                if(utilScope && !utilScope.includes("@")){
                    if(utilScope.includes(":")){
                        utilScope = utilScope.replace(/\[/g,"").replace(/\]/g,"");
                        var slice = utilScope.split(":");
                        var start = slice[0]==""?undefined:parseInt(slice[0]);
                        var end = slice[1]==""?undefined:parseInt(slice[1]);
                        obj = obj.slice(start,end)
                    }
                    else if(utilScope.includes("*")){
                        continue
                    }
                    else if(utilScope){
                        var key = utilScope.match(/\[(.*?)\]/)[1]
                        obj = obj[key]
                    }
                }
            }
        }
        else if(key == ""){
            if(_nextKey == undefined){
                _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Lyte.error("Invalid JsonPath - " + path + "expected : Path string should not end with the  '..' ")
            }
            obj = GetAllKeys(obj,_nextKey)
            if(path.length-1 != pathIndex){
                if(Array.isArray(obj)){
                    DeepTraverse =1;
                    var utilScope = nextKey.match(/\[([^\]]+)\]/g)
                    path.splice(0,pathIndex+1)
                    if(utilScope!=null){
                        utilScope = utilScope[0];
                        utilScope = utilScope.match(/\[(.*?)\]/)[1]
                        obj = separateArray(obj,utilScope);
                    }
                    if(path.length>1){
                        obj = GetData(obj,path,DeepTraverse)
                        break;
                    }
                }
            }
            if(nextKey && !nextKey.includes("[") && !nextKey.includes("]")){
                pathIndex++;
            }
        }
        else if(key == "*"){
            continue;
        }
        else{
            if(path[pathIndex-1] && (path[pathIndex-1] == "*" || path[pathIndex-1].includes("*"))){
                if(Array.isArray(obj)){
                    var newArray=[];
                    var ind=0;
                    for(var arr_index = 0; arr_index<obj.length; arr_index++){
                        if(obj[arr_index][key]){
                            newArray[ind] = obj[arr_index][key];
                            ind++;
                        }
                    }
                    obj=newArray;
                }
                else if (typeof obj == "object"){
                    obj = obj[key]
                }
            }
            else{
                obj = obj[key]?obj[key]:undefined;
            }
        }

    }
    return obj
}
function keyParser (key){
    if(key.includes("[") && key.includes("]")){
        var utilScope = key.match(/\[([^\]]+)\]/g)[0]
        var utilKey = key.match(/^(.+?)\[/g) 
        if(utilKey){
            utilKey=utilKey[0].replace(/\[/g,"");
            return utilKey;
        }
    }
    return key;
}
function GetAllKeys (scope,key){
    var arr= []; 
    getRecurssive(scope,key,arr);
    return arr
}
function getRecurssive (scope,key,arr){
    if(typeof scope == "object"){
        for(var v in scope){
            if(v == key){
                arr.push(scope[key])
            }
            if(typeof scope[v] == "object"){
                getRecurssive(scope[v],key,arr)
            }
        }
    }
    else if(Array.isArray(scope)){
        for( var index = 0 ; index<scope.length ; index++ ){
            var obj = scope[index];
            getRecurssive(obj,key,arr);
        }
    }
}
function separateArray (scope,index){
    var Arr =[];
    for (var i=0; i< scope.length; i++){
        if(scope[i][index]){
            Arr.push(scope[i][index]);
        }
    }
    return Arr;
}



/***/ }),

/***/ 17639124:
/*!***************************************************!*\
  !*** ./node_modules/@slyte/core/src/LyteAddon.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LyteAddon": () => (/* binding */ LyteAddon)
/* harmony export */ });
/* harmony import */ var _lyte__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lyte */ 46823552);
/* harmony import */ var _service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./service */ 76099455);
/* harmony import */ var _lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lyte-utils.js */ 60768251);



// import { resolvePromises } from './rsvp';
// import { Logger } from './lyte-error';
/*convert to custom class*/
class LyteAddon extends _service__WEBPACK_IMPORTED_MODULE_0__.Service {
    constructor(config){
        super();
        this.config = config;
        (0,_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__._lyteInit)(LyteAddon,this);
        (0,_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__._lyteDidConnect)(LyteAddon,this);
    }
    static register(options){
        if(options){
          if(options._migration){
            this._migration = options._migration;
          }
        }
    }
    lookups() {
        return [];
    }

    scopedInstance() {
        return _lyte__WEBPACK_IMPORTED_MODULE_2__.__scopedInstance.apply(this, Array.from(arguments));
    }

    get __isAddon() {
        return true;
    }
    
}
// LyteAddon.prototype.resolvePromises = function(promises) {
//     return new Promise(function(res, rej) {
//       resolvePromises(promises).then(function(data) {
//         res(data);
//       },function(data) {
//         rej(data);
//       })
//     })
// }
LyteAddon._component = {};
// LyteAddon.error = Logger.error.bind(Logger);
// LyteAddon.warn = Logger.warn.bind(Logger);
// LyteAddon.errorCodes = Logger.errorCodes;



/***/ }),

/***/ 8979898:
/*!***********************************************!*\
  !*** ./node_modules/@slyte/core/src/Mixin.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Mixin": () => (/* binding */ Mixin)
/* harmony export */ });
/* harmony import */ var _lyte_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lyte-utils.js */ 60768251);
/* harmony import */ var _lyte_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lyte.js */ 46823552);


let registeredMixin = {};
let Mixin = (0,_lyte_utils_js__WEBPACK_IMPORTED_MODULE_0__.createCustomClass)(function(arg1,overrides){
    class Mixin extends (0,_lyte_utils_js__WEBPACK_IMPORTED_MODULE_0__.getClass)([],arg1) {
        static register(options){
            if(this.__lMod) {
                return super.register.apply(this, Array.from(arguments));
            }
            if(options){
                if(options.hash){
                    this._hash = options.hash;
                }
                if(options.refHash){
                    this._refHash = options.refHash;
                    var mobj = Mixin.registeredMixin[options.refHash] = Mixin.registeredMixin[options.refHash] || {};
                    mobj[this.name] = this;
                    Mixin.getAppClass(options, this);
                }
            }
        }
        static getAppClass(options, mixinCls){
            let registryClass;
            _lyte_js__WEBPACK_IMPORTED_MODULE_1__.Lyte._instances.forEach(function(appIns){
                let appClass = appIns.constructor;
                if(appClass._hash == options.refHash){
                    appIns.registeredMixins[mixinCls.name] = mixinCls;
                }
            });
        }
    }
    Mixin.registeredMixin = registeredMixin;
    return overrides(Mixin)
})



/***/ }),

/***/ 95638012:
/*!***********************************************!*\
  !*** ./node_modules/@slyte/core/src/Utils.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Utils": () => (/* binding */ Utils)
/* harmony export */ });
/* harmony import */ var _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @slyte/core/src/lyte-utils */ 60768251);
/* harmony import */ var _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/core/src/service */ 76099455);


/*convert to custom class */
class Utils extends _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_0__.Service {
    static addMethods(data){
        if(Array.isArray(data)){
            data.forEach(function(fn){
                var name = fn._name ? fn._name : fn.name;
                if(!Utils.prototype[name]){
                    Utils.prototype[name] = fn;
                }
            });
        }
    } 
}
Utils.addMethods([_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_1__.deepCopyObject, _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_1__.extendEventListeners]);



/***/ }),

/***/ 182578:
/*!****************************************************!*\
  !*** ./node_modules/@slyte/core/src/lyte-error.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Logger": () => (/* binding */ Logger)
/* harmony export */ });
/* harmony import */ var _lyte_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lyte-utils */ 60768251);


const level = 0;
class Logger extends Error {
    static get level(){
        return level;
    }
    constructor(){
        super(...arguments);
    }
    static register(){
        var context = this;
        while(context !== Logger){
            if(!context.hasOwnProperty("addEventListener")){
                (0,_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.extendEventListeners)(context);
            }
            context = Object.getPrototypeOf(context);
        }
        if(!Logger.triggerEvent){
            (0,_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.extendEventListeners)(Logger);
        }
    }
    static registerErrorCodes(obj, defineProperty){
        if(obj && typeof obj == "object"){
            for(var key in obj){
                var message = obj[key];
                if(defineProperty){
                    Object.defineProperty(this.errorCodes, key, {
                        value: message
                    });
                }
                else{
                    this.errorCodes[key] = message;
                }
            }
        }
    }
    static getErrorMessage(code, withCode){
      var args = Array.from(arguments).slice(1);
      if(this.errorCodes[code]) {
          var msg = this.errorCodes[code].replace(/{(\d+)}/g, function(t, i) {
              return args[i];
          });
          return code+": "+msg;
      } else {
          return code;
      }
    }
    static setErrorMessage(code, message, defineProperty){
        if(defineProperty){
            Object.defineProperty(this.errorCodes, code, {
                value: message
            });
        }
        else{
            this.errorCodes[code] = message;
        }
    }
    static error(){
        var args = Array.from(arguments), arg0 = arguments[0], ins, errorObj, logLevel = Logger.level;
        if(arg0.__isApp || arg0.__isAddon){
            ins = arg0;
            args.splice(0,1);
            if(ins.hasOwnProperty("logLevel")){
                logLevel = ins.logLevel;
            }
        }
        if(logLevel < 3){
            errorObj = args[0];
            var parse = errorObj.stack, 
            context = this;
            errorObj = parse ? errorObj : new this(this.getErrorMessage.apply(this, args));
            while(context !== Logger){
                if (context.hasOwnProperty("onerror")) {
                    context.onerror.call(context, errorObj, args[1], this, ins);
                }
                if(context.hasOwnProperty("triggerEvent")){
                    context.triggerEvent.call(context, "error", errorObj, args[1], this, ins);
                }
                context = Object.getPrototypeOf(context);
            }
            if (Logger.hasOwnProperty("onerror")) {
                Logger.onerror.call(Logger, errorObj, args[1], this, ins);
            }
            if(Logger.hasOwnProperty("triggerEvent")){
                Logger.triggerEvent.call(Logger, "error", errorObj, args[1], this, ins);
            }
            if(ins){
                if(ins.onerror) {
                    ins.onerror.call(ins, errorObj, args[1], this, ins);
                }
                if(ins.triggerEvent){
                    ins.triggerEvent.call(ins, "error", errorObj, args[1], this, ins);
                }
            }
            var safari = errorObj.stack && errorObj.stack.indexOf(errorObj.message) == -1
            if (parse && !safari) {
                errorObj = JSON.parse(JSON.stringify(errorObj, Object.getOwnPropertyNames(errorObj)));
            }
            if(args[1]) {
                console.error(errorObj.stack ? (safari ? errorObj : errorObj.stack) : errorObj.message, args[1]);
            } else {
                console.error(errorObj.stack ? (safari ? errorObj : errorObj.stack) : errorObj.message);    
            }
        }
    }
    static warn(){
        var args = Array.from(arguments), arg0 = arguments[0], ins, errorObj, logLevel = Logger.level;
        if(arg0.__isApp || arg0.__isAddon){
            ins = arg0;
            args.splice(0,1);
            if(ins.hasOwnProperty("logLevel")){
                logLevel = ins.logLevel;
            }
        }
        if(logLevel < 2){
            var errorObj = args[0];
            errorObj = errorObj.stack ? JSON.parse(JSON.stringify(errorObj, Object.getOwnPropertyNames(errorObj))) : new this(this.getErrorMessage.apply(this, args));
            console.warn(errorObj.stack ? (errorObj.stack.indexOf(errorObj.message) != -1 ? errorObj.stack.replace("Error: ", "Warn: ") : errorObj) : errorObj.message);
        }
    }
    static log(){
        var args = Array.from(arguments), arg0 = arguments[0], ins, errorObj, logLevel = Logger.level;
        if(arg0.__isApp || arg0.__isAddon){
            ins = arg0;
            args.splice(0,1);
            if(ins.hasOwnProperty("logLevel")){
                logLevel = ins.logLevel;
            }
        }
        if(logLevel == 0){
            var errorObj = args[0];
            errorObj = errorObj.stack ? JSON.parse(JSON.stringify(errorObj, Object.getOwnPropertyNames(errorObj))) : new this(this.getErrorMessage.apply(this, args));
            console.log(errorObj.stack ? (errorObj.stack.indexOf(errorObj.message) != -1 ? errorObj.stack.replace("Error: ", "Log: ") : errorObj) : errorObj.message);        
        }
    }
}

Logger.errorCodes = {
    ERR02 : "Mandatory prop cannot be empty", 
    ERR03 : "Type of value does not match the specified data type",
    ERR04 : "Value is greater than the maximum value allowed",
    ERR05 : "Value is less than the minimum value allowed", 
    ERR06 : "Length of string/array is greater than the maximum limit allowed", 
    ERR07 : "Length of string/array is less than the minimum limit allowed",
    ERR08 : "String does not match the specified pattern", 
    ERR09 : "Values in array are not unique", 
    ERR10 : "Value is not equal to the specified constant", 
    ERR29: "Property not defined in the object",
    ERR30: "Property's value is not an instanceof the mentioned class", 
    ERR31: "Type definition for nested properties / items does not match with the value" ,     
    L001: "{0} {1} is already registered"
    // /* move to component */
    // LC001: "Error while parsing custom prop handler attribute {0}. Check if the value provided is a valid JSON",
    // LC002: "{0} Component is not compiled. Please compile using Lyte CLI",
    // LC003: "Helper named {0} is not defined",
    // LC004: "Action named {0} doesn't exists",
    // LC005: "Lyte.objectUtils doesn't support {0} function",
    // LC006: "Lyte.arrayUtils doesn't support {0} function",
    // LC007: "Component name not specified in Lyte.Component.render",
    // LC008: "Specified outlet {0} doesn't exists - Lyte.Component.render",
    // LC009: "Method named {0} doesn't exists in {1} component",
    // LC010: "Parent Node / reference Node not provided for insertBefore method",
};

(0,_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.extendEventListeners)(Logger);



/***/ }),

/***/ 60768251:
/*!****************************************************!*\
  !*** ./node_modules/@slyte/core/src/lyte-utils.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__nestScp__": () => (/* binding */ __nestScp__),
/* harmony export */   "_defineProperty": () => (/* binding */ _defineProperty),
/* harmony export */   "_get": () => (/* binding */ _get),
/* harmony export */   "_lyteDidConnect": () => (/* binding */ _lyteDidConnect),
/* harmony export */   "_lyteInit": () => (/* binding */ _lyteInit),
/* harmony export */   "addEventListener": () => (/* binding */ addEventListener),
/* harmony export */   "addStateToMap": () => (/* binding */ addStateToMap),
/* harmony export */   "arrayUtils": () => (/* binding */ arrayUtils),
/* harmony export */   "bindObj": () => (/* binding */ bindObj),
/* harmony export */   "checkEstablishingSCP": () => (/* binding */ checkEstablishingSCP),
/* harmony export */   "checkNestedProp": () => (/* binding */ checkNestedProp),
/* harmony export */   "checkProperty": () => (/* binding */ checkProperty),
/* harmony export */   "checkWatchPath": () => (/* binding */ checkWatchPath),
/* harmony export */   "cmpData": () => (/* binding */ cmpData),
/* harmony export */   "cmpObjs": () => (/* binding */ cmpObjs),
/* harmony export */   "copyObject": () => (/* binding */ copyObject),
/* harmony export */   "createCustomClass": () => (/* binding */ createCustomClass),
/* harmony export */   "deepCopyObject": () => (/* binding */ deepCopyObject),
/* harmony export */   "defProp": () => (/* binding */ defProp),
/* harmony export */   "defProps": () => (/* binding */ defProps),
/* harmony export */   "defineRelation": () => (/* binding */ defineRelation),
/* harmony export */   "estObjScp": () => (/* binding */ estObjScp),
/* harmony export */   "establishObjectBinding": () => (/* binding */ establishObjectBinding),
/* harmony export */   "establishObserverBindings": () => (/* binding */ establishObserverBindings),
/* harmony export */   "establishWatchScope": () => (/* binding */ establishWatchScope),
/* harmony export */   "extendEventListeners": () => (/* binding */ extendEventListeners),
/* harmony export */   "extendMixin": () => (/* binding */ extendMixin),
/* harmony export */   "extendService": () => (/* binding */ extendService),
/* harmony export */   "getClass": () => (/* binding */ getClass),
/* harmony export */   "getConfig": () => (/* binding */ getConfig),
/* harmony export */   "getCurrentRouterInstance": () => (/* binding */ getCurrentRouterInstance),
/* harmony export */   "getProperty": () => (/* binding */ getProperty),
/* harmony export */   "getSuperClass": () => (/* binding */ getSuperClass),
/* harmony export */   "globalsGet": () => (/* binding */ globalsGet),
/* harmony export */   "globalsSet": () => (/* binding */ globalsSet),
/* harmony export */   "includeMixins": () => (/* binding */ includeMixins),
/* harmony export */   "injectServiceToModules": () => (/* binding */ injectServiceToModules),
/* harmony export */   "isEntity": () => (/* binding */ isEntity),
/* harmony export */   "isInheritedClass": () => (/* binding */ isInheritedClass),
/* harmony export */   "many": () => (/* binding */ many),
/* harmony export */   "nestScp": () => (/* binding */ nestScp),
/* harmony export */   "nestScpId": () => (/* binding */ nestScpId),
/* harmony export */   "nestScpRemove": () => (/* binding */ nestScpRemove),
/* harmony export */   "newGetSuperClass": () => (/* binding */ newGetSuperClass),
/* harmony export */   "objectUtils": () => (/* binding */ objectUtils),
/* harmony export */   "observes": () => (/* binding */ observes),
/* harmony export */   "one": () => (/* binding */ one),
/* harmony export */   "prop": () => (/* binding */ prop),
/* harmony export */   "registerErrorCodes": () => (/* binding */ registerErrorCodes),
/* harmony export */   "removeEventListener": () => (/* binding */ removeEventListener),
/* harmony export */   "removeNestScp": () => (/* binding */ removeNestScp),
/* harmony export */   "removeStateFromMap": () => (/* binding */ removeStateFromMap),
/* harmony export */   "toAddSuper": () => (/* binding */ toAddSuper),
/* harmony export */   "toBeUsedServices": () => (/* binding */ toBeUsedServices),
/* harmony export */   "triggerEvent": () => (/* binding */ triggerEvent),
/* harmony export */   "types": () => (/* binding */ types),
/* harmony export */   "validateData": () => (/* binding */ validateData)
/* harmony export */ });
/* harmony import */ var _slyte_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/core */ 46823552);
/* harmony import */ var _slyte_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @slyte/core */ 76099455);
/* harmony import */ var _lyte_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lyte-error */ 182578);

// import { errorCodes } from "@slyte/core/src/errors.js";


// import { resolvePromises } from './rsvp';
// const _keywords = {
//   "component" : ["init", "didConnect", "didDestroy", "constructor", "onError", "actions", "methods", "data"],
//   "adapter" : ["namespace", "actionNamespace", "host", "withCredentials", "buildURL", "methodForRequest", "headersForRequest", "reloadRecord", "reloadRecord", "reloadAll", "processRequest", "parseResponse", "parseRequest", "super"],
//   "serializer" : ["normalize", "normalizeResponse", "serialize", "serializeKey", "deserializeKey", "extractMeta", "payloadKey", "serializeRecord", "normalizeRecord", "super"],
//   "route" : ["getDependencies", "getResources", "beforeModel", "model", "afterModel", "redirect", "renderTemplate", "afterRender", "beforeExit", "didDestroy", "queryParams", "title", "routeName", "component", "parent", "currentModel", "forceFetch", "setTitle", "setQueryParams", "getQueryParams", "setDynamicParam", "getDynamicParam", "removeFromCache", "refresh", "transitionTo", "replaceWith","actions"]
// };  
// var arrayUtils =  function() {
//     let lc = window.CrmComponentRegistry._instanceList[0]._getLyteComponent();
//     return lc.aF.apply(lc, arguments);
// };
// var objectUtils =  function() {
//     let lc = window.CrmComponentRegistry._instanceList[0]._getLyteComponent();
//     return lc.oF.apply(lc, arguments);
// }
// var set = function(){
//   return LyteComponent.set.apply(LyteComponent,arguments);
// }
// var get = function(){
//   return LyteComponent.get.apply(LyteComponent,arguments);
// }
// var render = function() {
//   return LyteComponent.render.apply(LyteComponent, arguments);
// }
// var modifyTemplate = function(){
//   return LyteComponent.modifyTemplate.apply(LyteComponent,arguments);
// }
// var compileDynamicTemplate = function(){
//   return LyteComponent.compileDynamicTemplate.apply(LyteComponent,arguments);
// }
// var doDomProcessing = function(){
//   return LyteComponent.doDomProcessing.apply(LyteComponent,arguments);
// }
// var getComponentTemplate = function(){
//   return LyteComponent.getComponentTemplate.apply(LyteComponent,arguments);
// }
// var addLyteEventListener = function(){
//   return Lyte.Component.addLyteEventListener.apply(Lyte.Component,arguments);
// }
// var removeLyteEventListener = function(){
//   return Lyte.Component.removeLyteEventListener.apply(Lyte.Component,arguments);
// }
// function getNearestApp(node){
//     while(node){
//       if(node.component){
//         return node.component.getApp();
//       }
//       node = node.parentElement;
//     }
//     return Lyte._getDefaultAppIns();
// }
function defProp() {
	Object.defineProperty.apply(Object, arguments);
}

function defProps() {
	Object.defineProperties.apply(Object, arguments);
}

function observes(){
  var args = Array.from(arguments), 
  func = args.pop(), 
  properties = [];
  args.forEach(function(observerValue) {
      let valueDetails = observerValue.split("::"), 
      observerType = valueDetails[0], 
      observerTo = valueDetails[1];
      switch(observerType){
          // case "event":{
          //     customCrmComponent._callbacks[observerType].push(observerFunction);
          // }
          // break;
          // case "action":
          // case "method":
          // {
          //     customCrmComponent._callbacks[observerType].push({[observerTo] : observerFunction});
          // }
          // break;
          default :{
              properties.push(observerType);
          }
      }
  })
  if(properties.length){
    var observerObj = {
        properties:properties,
        type:"observer",
        value:func
    }
    return observerObj;
  }
}

// function isKeyword(key, scope){
//   var arr = ["component", "adapter", "serializer", "route"];
//   if(scope){
//     arr = [scope];
//   }
//   var len = arr.length;
//   for(var i=0;i<len;i++){
//     var keyArr = _keywords[arr[i]];
//     if(keyArr){
//       var res = keyArr.indexOf(key);
//       if(res != -1){
//         return true;
//       }
//     }
//   }
//   return false;
// }

function injectServiceToModules(scp, services){
  var mdlObj = scp.$.injectServices;
  for(var mKey in mdlObj){
    var mdl = mdlObj[mKey];
    for(var name in services){
      mdl(name, serv[name], mKey);
    }
  }
}

// function addToInstance(ins) {
//   if(ins.is != "app"){
//     if(!__instances[ins.is].hasOwnProperty(ins.name))
//     {
//       __instances[ins.is][ins.name] = ins;
//     }
//     else{
//       Lyte.warn("L001", ins.is, ins.name);
//     } 
//   }
//   else{
//     if(!__instances[ins.is]){
//       __instances[ins.is] = ins;
//     }
//     else{
//       Lyte.warn("L001", ins.is, "");
//     }
//   }
// }

// function createEngineInstance(engineName,config){
//   var ins = new Lyte('engine',engineName,config);
//   ins = Object.assign(ins,__instances.engine[engineName]);
//   return ins;
// }

function registerErrorCodes(obj, lyte) {
    Object.assign(errorCodes, obj);
}


function isEntity(object){
  if(object && object.$ && object.$.hasOwnProperty("isModified")) {
    return true;
  }
  return false;
}
function getVal(key,target){
  return target && target.__config && (target.__config[key]?"true":(target.__config[key] == false?"false":undefined));
}
function getConfig(key,target){
  if(!target){
    target = LyteCls._instances[0].$router.getRouteInstance();
    return getVal(key,target.$component)||
          ((!target._callee)?getVal(key,target.$app): getConfig(key,target._callee));
  }
  else{
    return getVal(key,target.component)||
          getVal(key,target.$component)||
          ((!target._callee)?getVal(key,target.$app): getConfig(key,target._callee));
  }
}
function getCurrentRouterInstance(){
  return LyteCls._instances[0].$router.getRouteInstance();
}
// function getConfig(key,regIns){
//   var configObj = window.__config;
//   if(configObj){
//       return {value:configObj[key],...((regIns)?{regIns:window.__config.getIns}:{})};
//   }
// }

function triggerEvent() {
  var args = Array.prototype.slice.call(arguments, 1)
  var eventName = arguments[0];
  var stopEvent = false;
  var s = this.__lyteRegisteredEvents[eventName];
    if(!s) {
      s = this.__lyteRegisteredEvents[eventName] = {"listeners" : new Map()};
    } else {
      var mp = s.listeners, keys = Array.from(mp.keys()), kLen = keys.length;    
      for(var i=0;i<kLen;i++) { 
        var func = mp.get(keys[i]);
        if(func) {
           var ret = func.apply(this, args);
           if(ret === false) {
             stopEvent = true;
             break;
           }
        }
      }
    }
    var customEvent = new CustomEvent(eventName, {"detail" : args});
    if(!stopEvent) {
     document.dispatchEvent(customEvent); 
    } 
 }

function addEventListener(eventName, func) {
  if(typeof func !== "function") {
      _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Lyte.error("Second parameter to Lyte.Component.addGlobalEventListener() must be a function");
      return;
  }
  var s = this.__lyteRegisteredEvents[eventName];
  if(!s) {
    s = this.__lyteRegisteredEvents[eventName] = {"listeners" : new Map()};
  }
  var id = genMapId(s.listeners);
  var d = s.listeners.set(id, func);
  return eventName + "-" + id;
}

function removeEventListener(id) {
  if(!id) {
    _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Lyte.error("listener unique id not specified");
    return;
  }
   var arr = id.split("-"), evid = arr.pop(), name = arr.join("-");
   var s = this.__lyteRegisteredEvents[name];
   if(!s || !s.listeners.get(evid)) {
     _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Lyte.error("No such listener registered");
     return;
   }
   s.listeners.delete(evid);
}

function genMapId(map){
  var id = Math.floor(Math.random()*10000000000 + 1);
  while(map.get(id)){
      id = Math.floor(Math.random()*10000000000 + 1)
  }
  return id.toString();
}

// function checkNestedProp (id, path, dtype, wobj, object, property, value, check, fromStore) {
//   if (dtype && path.length != 0){
//       var extend;
//       if(Lyte.Transform[dtype.type]){
//           extend = true;
//       }
//       if (dtype.type == 'array' || (extend && Lyte.Transform[dtype.type].extends == "array")) {
//           if (dtype.items && !isNaN(path[0]) && _typeof(dtype.items) == 'object') {
//               path = path.slice(1);
//               checkNestedProp(id, path, dtype.items, wobj, object, property, value, check);
//           }
//       } else if (dtype.type == "object" || (extend && Lyte.Transform[dtype.type].extends == "object")) {
//           if (dtype.properties){
//               var k = path[0];
//               path = path.slice(1);
//               checkNestedProp(id, path, k == "" ? dtype :dtype.properties[k], wobj, object, property, value, check);
//           }
//       }
//   // } else if (dtype.properties && Lyte.isRecord(value) && !check.hasOwnProperty("warn")) {
//   //     check.warn = { warn: true, message: "Nested property will not support for the record" };
//   } 
//   else {
//       var err;
//       if (dtype && (dtype.properties || dtype.items) && !check.hasOwnProperty("warn")) {
//           var component = {};component.__data = {};
//           if (dtype.properties) {
//               component.__data[property] = dtype.properties[property];
//           } else {
//               component.__data[property] = dtype;
//           }
//           var cp = validateData(object, property, value, component);
//           var errKey = wobj.attr ? wobj.attr : wobj.key,_path = wobj.path.split(".");
//           if (cp && (typeof cp === 'undefined' ? 'undefined' : _typeof(cp)) == "object" && cp.code) {
//               cp.value = value;
//               cp.path = wobj.path !=""?wobj.path:property;
//               if(wobj.isRec && fromStore && wobj.key ==  undefined && wobj.path!=""){
//                   errKey = wobj.path.split(".")[0]
//                   _path.shift();
//                   _path = (_path.length == 1 && _path[0] == property) ? [] : _path;
//               }
//               wobj.Error = {};
//               wobj.Error && wobj.Error[errKey] ? wobj.Error[errKey].code && wobj.Error[errKey].nested ? wobj.Error[errKey].nested : wobj.Error[errKey].nested = {} : wobj.Error[errKey] = { nested: {} };
//               wobj.Error[errKey].code = "ERR34"
//               wobj.Error[errKey].message = Logger.errorCodes.ERR34;
//               err = wobj.Error[errKey].nested;
//               wobj._cmpErr[errKey].code = "ERR34";
//               wobj._cmpErr[errKey].message = Logger.errorCodes.ERR34 ;
//               var cmpErrPath = wobj._cmpErr[errKey].path ? wobj._cmpErr[errKey].path : [] ;
//               if(wobj.path !=""){
//                   _path.forEach(function (k) {
//                       if (err && !err[k]) {
//                           err = err[k] = {};
//                       } else {
//                           err = err[k];
//                       }
//                   });
//               }
//               wobj.index != undefined ? err[wobj.index] = cp : err[property] = cp;
//               cmpErrPath.push(wobj.index == undefined && property? wobj.path+"."+property : wobj.index !=undefined ? wobj.path+"."+wobj.index : wobj.path)
//               wobj._cmpErr[errKey].path = cmpErrPath;
//           } else{
//               if(wobj.isRec && fromStore && wobj.key ==  undefined){
//                   errKey = wobj.path.split(".")[0]
//                   _path.shift();
//                   _path = (_path.length == 1 && _path[0] == property) ? [property] : _path;
//               }
//               err = wobj.Error[errKey] && wobj.Error[errKey].nested ? wobj.Error[errKey].nested : undefined;
//               //var p = object.$.error[property];
//               if(err){
//                   var key = wobj.index || property; 
//                   var flag = true,
//                   p = wobj.path !=""?_path:[property];
//                   wobj.index ? p.push(wobj.index) : p;
//                   var prev;
//                   p.forEach(function (r) {
//                       if (err[r] && err[r].code) {
//                           delete err[r];
//                           if(err && Object.keys(err).length == 0){
//                               flag = true;
//                           }
//                           else{
//                               flag = false;
//                           }
//                       }
//                       err = err[r];
//                   });
//                   if (flag == true && wobj.Error[errKey] && wobj._cmpErr[errKey]) {
//                       delete wobj.Error[errKey];
//                       delete wobj._cmpErr[errKey]
//                   }
//               }

//           }
//           if((check.value && check.value.hasOwnProperty("code") && cp.code) || !check.value){
//               check.value = cp;
//           }
//       }
//   }
//   wobj.path && delete wobj.path;
//   wobj.index && delete wobj.index;
//   wobj.attr && delete wobj.attr;
// };

function checkNestedProp(id,path,dtype,wobj,object,property,value,check){
  if (dtype.type instanceof Function){
    dtype = dtype.type;
  }
  if(path.length!=0){
      if(dtype.type == 'array'){
          if(dtype.items && !isNaN(path[0]) && typeof(dtype.items)=='object'){
              path= path.slice(1);
              checkNestedProp(id,path,dtype.items,wobj,object,property,value,check)
          }
      }
      else if( dtype.type == "object"){
          if(dtype.properties && dtype.properties.hasOwnProperty(path[0])){
              var k = path[0];
              path = path.slice(1);
              checkNestedProp(id,path,dtype.properties[k],wobj,object,property,value,check);
          }
      }
  }
  else {
    var err;
    if (dtype && (dtype.properties || dtype.items) && !check.hasOwnProperty("warn")) {
      var component = {};component.__data = {};
      if (dtype.properties) {
          component.__data[property] = dtype.properties[property];
      } else if(dtype.items) {
        component.__data[property] = dtype.items;      
      } else
      {
          component.__data[wobj.index] = dtype;
      }
      var cp = validateData(object, property, value, component);
      var errKey = wobj.attr ? wobj.attr : wobj.key,_path = wobj.path.split(".");
      var PathWay = wobj.index == undefined && property? wobj.path+(wobj.path!="" ?".":"")+property : wobj.index !=undefined ? wobj.path+(wobj.path!="" ?".":"")+wobj.index : wobj.path;
      if (cp && (typeof cp === 'undefined' ? 'undefined' : typeof(cp)) == "object" && cp.code) {
          cp.value = value;
          cp.path = wobj.path !=""?wobj.path:property;
          // if(wobj.isRec && fromStore && wobj.key ==  undefined && wobj.path!=""){
          //     errKey = wobj.path.split(".")[0]
          //     _path.shift();
          //     _path = (_path.length == 1 && _path[0] == property) ? [] : _path;
          // }
          // wobj.Error ? true : wobj.Error = {}
          wobj.Error && wobj.Error[errKey] ? wobj.Error[errKey].code && wobj.Error[errKey].nested ? wobj.Error[errKey].nested : wobj.Error[errKey].nested = {} : wobj.Error[errKey] = { nested: {} };
          wobj.Error[errKey].code = "ERR34"
          wobj.Error[errKey].message = _lyte_error__WEBPACK_IMPORTED_MODULE_1__.Logger.errorCodes.ERR31;
          err = wobj.Error[errKey].nested;
          wobj._cmpErr[errKey] ? true : wobj._cmpErr[errKey]={};
          wobj._cmpErr[errKey].code = "ERR34";
          wobj._cmpErr[errKey].message = _lyte_error__WEBPACK_IMPORTED_MODULE_1__.Logger.errorCodes.ERR31;
          var cmpErrPath = wobj._cmpErr[errKey].path ? wobj._cmpErr[errKey].path : [] ;
          if(wobj.path !=""){
              _path.forEach(function (k) {
                  if (err && !err[k]) {
                      err = err[k] = {};
                  } else {
                      err = err[k];
                  }
              });
          }
          wobj.index != undefined ? err[wobj.index] = cp : err[property] = cp;
          if(!cmpErrPath.includes(PathWay)){
            cmpErrPath.push(PathWay)
          }
          wobj._cmpErr[errKey].path = cmpErrPath;
      } else{
          // if(wobj.isRec && fromStore && wobj.key ==  undefined){
          //     errKey = wobj.path.split(".")[0]
          //     _path.shift();
          //     _path = (_path.length == 1 && _path[0] == property) ? [property] : _path;
          // }
          err = wobj.Error[errKey] && wobj.Error[errKey].nested ? wobj.Error[errKey].nested : undefined;
          var cmpErr = wobj._cmpErr[errKey] || undefined;
          if(cmpErr && cmpErr.path && cmpErr.path.includes(PathWay)){
            var ind = cmpErr.path.indexOf(PathWay)
            cmpErr.path.splice(ind,1)
          }
          //var p = object.$.error[property];
          if(err){
              var key = wobj.index || property; 
              var flag = true,
              p = PathWay.split(".");
              p.forEach(function (r) {
                  if (err[r] && err[r].code) {
                      delete err[r];
                      if(err && Object.keys(err).length == 0){
                          flag = true;
                      }
                      else{
                          flag = false;
                      }
                  }
                  else{
                    err = err[r]
                  }
              });
              if (flag == true && wobj.Error[errKey] && wobj._cmpErr[errKey]) {
                  delete wobj.Error[errKey];
                  delete wobj._cmpErr[errKey]
              }
          }

      }
      if((check.value && check.value.hasOwnProperty("code") && cp.code) || !check.value){
          check.value = cp;
      }
  }
}
  wobj.index && delete wobj.index; 
}

var types = ["string", "object", "number", "boolean", "array", "component"];
function prop(type, opts){
  var obj = {};
  obj.type = type;
  obj._type = "prop";
  if(opts == undefined){
    opts = {};
  }
  Object.assign(obj,opts);
  return obj;
}

function one(name,opts){
  return defineRelation(name,"belongsTo",opts);
}

function many(name,opts){
  return defineRelation(name,"hasMany",opts);
}

function extendEventListeners(scp){
  if(scp && !scp.hasOwnProperty("__lyteRegisteredEvents")){
      Object.defineProperties(scp, {
          __lyteRegisteredEvents : {
              value : {}
          },
          addEventListener : {
              value : addEventListener
          },
          removeEventListener : {
              value : removeEventListener
          },
          triggerEvent : {
              value : triggerEvent
          }
      });
  }
}

function getSuperClass(obj, getName){
	var cons = obj, isInstance = (typeof obj === "object");
	if(isInstance){
		cons = obj.constructor;
	}
	var bClass = Object.getPrototypeOf(cons);
	if((!(bClass instanceof Function)) || bClass === _slyte_core__WEBPACK_IMPORTED_MODULE_2__.Service){
		if(getName){
			return obj.name;
		}
		return obj;
	} 
	return getSuperClass(bClass, getName);
}

function isInheritedClass(baseObj, inheritedClass){
  var cons = baseObj, isInstance = (typeof obj === "object");
  if(isInstance){
    cons = baseObj.constructor;
  }
  var bClass = Object.getPrototypeOf(cons);
  if((bClass.hasOwnProperty("__lyteOrigClass") && bClass.__lyteOrigClass == inheritedClass) || (bClass == inheritedClass)){
    return true;
  }
  else if((!(bClass instanceof Function)) || bClass === _slyte_core__WEBPACK_IMPORTED_MODULE_2__.Service){
    return false;
  }  
  return isInheritedClass(bClass, inheritedClass); 
}

function newGetSuperClass(obj, getName, toBeCompared, getClass) {
  var cons = obj, isInstance = (typeof obj === "object");
  if(isInstance){
    cons = obj.constructor;
  }
  var bClass = Object.getPrototypeOf(cons);
  if(bClass.__lyteOrigClass == toBeCompared){
    return true;
  }
  else if((!(bClass instanceof Function)) || bClass === _slyte_core__WEBPACK_IMPORTED_MODULE_2__.Service){
    // return false;
    if(getName){
      return obj.name;
    } else if(getClass){
      return obj;
    }
    return obj;
  }  
  return newGetSuperClass(bClass, getName, toBeCompared);    
}

function includeMixins(arr,mainClass){
  if(arr.length == 0) {
    return mainClass;
  } 
  var currentClass = mainClass;
  for(var i=0;i<arr.length;i++) {
    var classVar = arr[i];
    var classFunction = classVar._classFunc;
    currentClass = classFunction(currentClass, classFunction.overrides,classFunction._proxy);
  }
  return currentClass;
}
function getClass(arr, mainClass,clsObj) {
  if(arr.length == 0) {
      return mainClass;
  }
  var currentClass = mainClass;
  for(var i=0;i<arr.length;i++) {
    var classVar = arr[i];
    var classFunction = classVar._classFunc;
    currentClass = classFunction(currentClass, classFunction.overrides,classFunction._proxy);
  }

  return currentClass;
}


Function.prototype.tempApply=Function.prototype.apply;
Function.prototype.tempCall=Function.prototype.call;
Function.prototype.tempBind=Function.prototype.bind;
var classObj = {};
function createCustomClass(classDefFunc, fromInside) {

  class LyteModule {
      constructor() {
          if(window.ssss1) {
              this.constructor = window.ssss1;
              window.ssss1 = undefined;
          }
      }
    static actions(arg1) {
      return arg1 ? arg1 : {};
    }
    static methods(arg1) {
      return arg1 ? arg1 : {};
    }
    static observers(arg1) {
      return arg1 ? arg1 : {};
    }
    data(arg1) {
      return arg1 ? arg1 : {};
    }
   
  }
    var dummyObj={};

    var proxy = new Proxy(class {
        static [Symbol.hasInstance](instance) {  // checks if the object's prototype chain contains the [Symbol.hasInstance] method
          console.log("inside  custom instanceof check")
          return instance instanceof dummyObj.arg1._initialCopyClass;
        }
      },{
      "construct" : function(a,b,c) {
        if(c==proxy) {
          window.ssss1 = dummyObj.retClass;
          let constr=Reflect.construct(dummyObj.retClass._initialCopyClass, b);
          if(constr._afterConstructor){
            constr._afterConstructor();
          }
          return constr;
        } else {
          return Reflect.construct(dummyObj.arg1, b,c);
        }
          
      }, 
      "get" : function(target, prop,value) {
        if(prop == "prototype") {
          return Reflect.get(...arguments);
        } else if(prop == "hasOwnProperty" ) {
          return function(prop1) {
              return dummyObj.arg1.hasOwnProperty(prop1);
          }  
        }
        else if(dummyObj.arg1.hasOwnProperty(prop)) {
          return dummyObj.arg1[prop];
        }
        else if(prop.toString()==='Symbol(Symbol.hasInstance)'){
          return Reflect.get(target, prop,value);
        } 
        else {
          return Reflect.get(dummyObj.arg1, prop,value);
        }
      }, 
      "set" : function(target, prop, value, receiver) {
        dummyObj.arg1._updateStaticVal(prop, value, receiver);
          return true;
      }, 
      "getPrototypeOf": function(target){
        return Reflect.getPrototypeOf(dummyObj.arg1); 
      },
      "defineProperty": function(target, key, descriptor) {
        dummyObj.arg1._defineProperty(target,key,descriptor);
          return true;
        },
        
      "getOwnPropertyDescriptor":function(target,prop){
          if( Object.hasOwn(dummyObj.arg1,prop)){
            return {
              value:dummyObj.arg1[prop],
              enumerable : true,
              configurable : true,
              writable : true
          };
          }
          else {
            return Reflect.getOwnPropertyDescriptor(...arguments)  ;
          }
        } ,
        "deleteProperty":function(target,prop,value){
          return dummyObj.arg1._deleteProperty(target,prop);
        }
      });
  var retClass = classDefFunc(LyteModule, function(arg1,cacheObj) {
      if(arg1.name[0]=='_'){
          Object.defineProperty(arg1,"name",{value:arg1.name.slice(1)});
      }
      dummyObj.arg1 = arg1;
      arg1._lyteClasses = [];
    arg1._lyteClasses = [];  //keep track of classes that have been extended from retClass.
  
    arg1._updatePrototypeVal = function(prop, value) {
       arg1.prototype[prop]=value;
       this._lyteClasses.forEach(function(item){
        item.prototype[prop]=value;
       });  
  }
  arg1._deleteProperty=function(target,prop){
    if(arg1[prop]){
      delete arg1[prop];
      this._lyteClasses.forEach(function(item){
        delete item[prop];
      })
    }
    delete arg1.prototype[prop];
    this._lyteClasses.forEach(function(item){
      delete item.prototype[prop];
    });
  }

  arg1._defineProperty = function(target, prop, descriptor) {
  Object.defineProperty(arg1,prop,descriptor);
    this._lyteClasses.forEach(function(item) {
      if(descriptor==undefined){
        item.prototype[prop]=undefined;
      }else{
        Object.defineProperty(item, prop, descriptor);
      }
    });

  }

  arg1._updateStaticVal = function(prop, value, receiver) {
    //updates the static values of arg1 and all the classes in _lyteClasses with the provided prop and value.
    // arg1[prop]=value;
    this[prop] = value;
    if(cacheObj && cacheObj.hasOwnProperty(prop)){
      cacheObj[prop]=value;
    }
    this._lyteClasses.forEach(function(item) {
      item[prop] = value;
    });
  }
  arg1._hasOwnProperty=function(target,prop,receiver){
    return arg1.prototype.hasOwnProperty(prop)
  }

     let tempProxy=new Proxy({} /*proxy.prototype*/, {

      "get" : function(target, prop) {
        //  if(Object.hasOwn(arg1._initialCopyClass.prototype,prop))
        //    return arg1.prototype[prop];
        if(prop === "deleteProp") {
            return function(prop1) {
                 return arg1._deleteProperty(target, prop1, undefined);
                 };
          }
          else if(prop=="hasOwnProperty"){
            return function(prop1){
                return arg1._hasOwnProperty(target,prop1);
            }
        }
        else {
          if(arg1.prototype[prop] && typeof arg1.prototype[prop]=="function" ) {
              arg1.prototype[prop].apply = function() {
                  let tempArgument=arguments[0];
                  while(tempArgument){
                      if(arg1._proxy==tempArgument.constructor){
                          return arg1._initialCopyClass.prototype[prop].tempApply(tempArgument, arguments[1]);
                      }
                      tempArgument=Object.getPrototypeOf(tempArgument);
                  }
                return  arg1.prototype[prop].tempApply(arguments[0],arguments[1]);
              }
              arg1.prototype[prop].call = function() {
                  let tempArgument=arguments[0];
                  while(tempArgument){
                      if(arg1._proxy==tempArgument.constructor){
                          return arg1._initialCopyClass.prototype[prop].tempCall(tempArgument, arguments[1]);
                      }
                      tempArgument=Object.getPrototypeOf(tempArgument);
                  }
                return  arg1.prototype[prop].tempCall(arguments[0],arguments[1]);
              }
              arg1.prototype[prop].bind = function() {
                  let tempArgument=arguments[0];
                  while(tempArgument){
                      if(arg1._proxy==tempArgument.constructor){
                          return arg1._initialCopyClass.prototype[prop].tempBind(tempArgument, arguments[1]);  
                      }
                      tempArgument=Object.getPrototypeOf(tempArgument);
                  }
                return  arg1.prototype[prop].tempBind(arguments[0],arguments[1]);
              }
          }
            return arg1.prototype[prop];
      }
          
      }, 
      "set" : function(target, prop, value) {    
          arg1._updatePrototypeVal(prop, value);
          return true;
      }, 
      "defineProperty" : function(target, prop, value) {
        arg1._defineProperty(target, prop, value);
      },
      "getPrototypeOf": function(target){
        return Reflect.getPrototypeOf(arg1); 
      }, 
  })  ;
   Object.setPrototypeOf(proxy.prototype,tempProxy);                                        
  return proxy;
  },proxy);
  retClass._proxy = proxy;
  dummyObj.retClass = retClass;
  classDefFunc._proxy = proxy;
  
  // var initialCopyClass = classDefFunc(LyteModule, overrides,proxy);
  var initialCopyClass=overrides(dummyObj.arg1);
  function overrides(cls) {
      if(cls.name[0]=='_'){
          Object.defineProperty(cls,"name",{value:cls.name.slice(1)});
      }
      retClass._lyteClasses.push(cls);
      cls.prototype.__origConstructor = cls;
      cls.__lyteOrigClass = retClass;
      if(retClass._lyteClasses.length>1){
          let baseCls=retClass._lyteClasses[0];
          let arr=Object.getOwnPropertyNames(retClass._lyteClasses[0]);
          for(let i=0;i<arr.length;i++){
              if(!cls.hasOwnProperty(arr[i])){
                  cls[arr[i]]=baseCls[arr[i]];
              }
          }
      let arr1=Object.getOwnPropertyNames(retClass._lyteClasses[0].prototype);
          for(let i=0;i<arr1.length;i++){
              if(!cls.prototype.hasOwnProperty(arr1[i])){
                  cls.prototype[arr1[i]]=baseCls.prototype[arr1[i]];
              }
          }
      }
    return cls;
  }


  classDefFunc.overrides = overrides;
  retClass._classFunc = classDefFunc;
  initialCopyClass._classFunc=classDefFunc;   //new changes
  // retClass._initialCopyClass = initialCopyClass; //new changees
  dummyObj.arg1._initialCopyClass = initialCopyClass;
  classDefFunc._mainClass = retClass;
  if(initialCopyClass.name[0]=='_'){
      Object.defineProperty(initialCopyClass,"name",{value:initialCopyClass.name.slice(1)});

  }   
  return retClass;
}

function getCustomData(scp, fieldVal, fromDb){
  if(fromDb){
    if(scp && scp.dataType && scp.dataType.hasOwnProperty(fieldVal)){
      return scp.dataType[fieldVal];
    }
    scp = scp.lyte;
  }
  if(scp && scp.dataType && scp.dataType.hasOwnProperty(fieldVal)){
    return scp.dataType[fieldVal];
  }
}
function checkProperty(property, dataVal, key, fieldVal, record, name, scp, errorCodes ,init, field, fromDb){
  // var errorCodes = scp.errorCodes;
  var exts = "extends";
  switch(property){
    case "type" : errorCodes
      if(typeof fieldVal !== "string"){
        var _fld = getCustomData(scp, fieldVal._name, fromDb);
        if (_fld && dataVal !== undefined && dataVal !== null) {
          var _ret = true;
          if (Array.isArray(dataVal)) {
              if (_fld.type != "array") {
                  return { code: "ERR03", message: errorCodes.ERR03, expected: fieldVal };
              }
              if(_fld.hasOwnProperty("items")){
                  _ret = checkProperty("items", dataVal, key, _fld.items, undefined, undefined, scp, errorCodes);
              }
          }else if(typeof dataVal === "object" && _fld.type == "object" && _fld.hasOwnProperty("properties")){
              _ret = checkProperty("properties", dataVal, key, _fld.properties, undefined, undefined, scp, errorCodes);
          } 
          else if (fieldVal && _fld.type != typeof(dataVal)) {
            return { code: "ERR03", message: errorCodes.ERR03, expected: fieldVal };
          }
          if(_ret !== true){
              return Object.assign(_ret, { code:"ERR31", message:errorCodes.ERR31, value: dataVal});
          }
        }
      }
      else if(dataVal !== undefined && dataVal !== null){
        if(Array.isArray(dataVal)){
          if(fieldVal != "array"){
              return {code : "ERR03", message : errorCodes.ERR03, expected : fieldVal};
          }
        }
        else if(dataVal && dataVal._compName){
          if(fieldVal != "component"){
            return {code : "ERR03", message : errorCodes.ERR03, expected : fieldVal};
          }
        }
        else if(fieldVal != (typeof dataVal)){
          return {code : "ERR03", message : errorCodes.ERR03, expected : fieldVal};
        }
      }
      break;
    case "mandatory":
        let validateFlag = fieldVal;
        if(typeof fieldVal == "object"){
          if(init && fieldVal.skipValidationOnInit == true){
            validateFlag = false;
          }
        }
        if (validateFlag && (dataVal == undefined || dataVal == null || dataVal === "")) {
          return { code: "ERR02", message: errorCodes.ERR02 };
        }
      break;
    case "maximum" :
      if((typeof dataVal == "number") && dataVal > fieldVal){
        return {code : "ERR04", message : errorCodes.ERR04, expected : fieldVal};
      }
      break;
    case "minimum" :
      if((typeof dataVal == "number") && dataVal < fieldVal){
        return {code : "ERR05", message : errorCodes.ERR05, expected : fieldVal};
      }
      break;
    case "maxLength" :
    case "maxItems" :
      if(dataVal && dataVal.length > fieldVal){
        return {code : "ERR06", message : errorCodes.ERR06, expected : fieldVal};
      }
      break;
    case "minLength" :
    case "minItems" :
      if(dataVal && dataVal.length < fieldVal){
        return {code : "ERR07", message : errorCodes.ERR07, expected : fieldVal};
      }
      break;
      case "pattern" :
        if(typeof fieldVal == "string"){
            var _scp = scp;
            if(fromDb){
              _scp = scp.lyte;
            }
            if(_scp){ 
              if(_scp.patterns && _scp.patterns.hasOwnProperty(fieldVal)){
                fieldVal = _scp.patterns[fieldVal];
              }
              else{
                _lyte_error__WEBPACK_IMPORTED_MODULE_1__.Logger.warn("Pattern with name - "+ fieldVal+" is not registered");
                break;
              }
            }
          }
          if( typeof dataVal == "string" && !(new RegExp(fieldVal).test(dataVal))){
            return {code : "ERR08", message : errorCodes.ERR08, expected : fieldVal};
          }
          break;
      case "uniqueItems" :{
      if(Array.isArray(dataVal) && fieldVal){
        var newArr = [];
        for(var i=0; i<dataVal.length; i++){
          var val = dataVal[i];
          if(newArr.indexOf(val) != -1){
            return {code : "ERR09", message : errorCodes.ERR09};
          }
          newArr.push(val);
        }         
      }
      break;        
    }
    case "constant" :
      if(Array.isArray(dataVal)){
        var resp = dataVal.length==fieldVal.length && dataVal.every(function(v,i) { return v === fieldVal[i]});
        if(!resp){
          return {code : "ERR10", message : errorCodes.ERR10, expected : fieldVal};
        }
      }
      else if(typeof dataVal == "object"){
        var resp = db.connector.$.compareObjects(dataVal, fieldVal);
        if(!resp){
          return {code : "ERR10", message : errorCodes.ERR10, expected : fieldVal};
        }
      }
      else if(dataVal && dataVal != fieldVal){
        return {code : "ERR10", message : errorCodes.ERR10, expected : fieldVal};
      }
      break;
    case "items" :{
      if(Array.isArray(dataVal)){
        var _resp = true;
        for(var i=0; i<dataVal.length; i++){
          for(var property in fieldVal){
            var resp = checkProperty(property, dataVal[i], i, fieldVal[property], undefined, undefined, scp, errorCodes, undefined, fieldVal);
            if(resp != true){
              var _path = resp.path || [""], plen = _path.length;
              for(var l=0; l<plen; l++){
                var path = _path[l];
                path = path ? i + "." + path : i.toString();
                if(_resp !== true){
                  _resp.path.indexOf(path) == -1 ? _resp.path.push(path) : undefined; 
                }
                else{
                  _resp = { path: [path]};
                }
              }
              break;
            }
          }
        }
        return _resp;         
      }
      break;        
    }
    case "properties" :
      if(typeof dataVal == "object" && !Array.isArray(dataVal)){
        var _resp = true
        for (var key in dataVal) {
          if(fieldVal.hasOwnProperty(key)){
              var fld = fieldVal[key]; 
              for (var property in fld) {
                  var resp = checkProperty(property, dataVal[key], key, fld[property], undefined, undefined, scp, errorCodes, undefined, fld);
                  if (resp != true) {
                    var _path = resp.path || [""], plen = _path.length;
                    for(var l=0; l<plen; l++){
                      var path = _path[l];
                      path = path ? key + "." + path : key.toString();
                      if(_resp !== true){
                        _resp.path.indexOf(path) == -1 ? _resp.path.push(path) : undefined; 
                      }
                      else{
                        _resp = { path: [path]};
                      }
                    }
                    break;
                  }
              }
          }
          // else if(field.exact){
            //     return { code : "ERR29", message: errorCodes.ERR29, property: key };
            // }
          }
          return _resp;
      }
      break;
    case "validation" :{
      var validator = fieldVal;
      if(validator){
        var resp =  validator.validate.apply(record, [key, dataVal, name]);
        if(resp != true){
          return resp;
        }
      }       
    }
    break;
    case "instanceof": 
    {
        if(typeof dataVal === "object" && !Array.isArray(dataVal) && !(dataVal instanceof fieldVal)){
          return { code: "ERR30", message: errorCodes.ERR30, property: key, instanceof: fieldVal};
        }
    }
  }
  return true;
}

function validateData(object, key, value, component,scp ,init) {
  var definition = component.__data[key];
  var isError = false;
  var type = definition ? definition.type : undefined;
  for(var defKey in definition) {
    let app = component.getApp ? component.getApp() : undefined;
    isError =  checkProperty(defKey, value, key, definition[defKey], object, undefined, app, _lyte_error__WEBPACK_IMPORTED_MODULE_1__.Logger.errorCodes, init, definition);
    if(isError !== true) {
      return isError;
    }
  }
  return false;
}

function deepCopyObject(obj){
  return copyObject(obj, true);
}

function copyObject( obj, internal )  {
  var targetVal = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));
  var current, copies = [{source : obj, target : targetVal}], keys, propertyIndex, descriptor, nextSource, indexOf, sourceReferences = [obj];
  var cloneObject = copies[0].target, targetReferences = [cloneObject];
  while(current = copies.shift()){
      keys = Object.keys(current.source);
      for(propertyIndex = 0; propertyIndex < keys.length; propertyIndex++){
          descriptor = Object.getOwnPropertyDescriptor(current.source, keys[propertyIndex]);
          if(!descriptor){
              continue;
          }
          if(!descriptor.value || typeof descriptor.value != "object"){
              Object.defineProperty(current.target, keys[propertyIndex], descriptor);
              continue;
          }
          nextSource = descriptor.value;
          if(!(descriptor.value instanceof Promise)){
            descriptor.value = Array.isArray(nextSource) ? [] : nextSource instanceof Set ? new Set() : Object.create(Object.getPrototypeOf(nextSource));
          }
          indexOf = sourceReferences.indexOf(nextSource);
          if(indexOf != -1){
              descriptor.value = targetReferences[indexOf];
              Object.defineProperty(current.target, keys[propertyIndex], descriptor);
              continue;
          }
          sourceReferences.push(nextSource);
          targetReferences.push(descriptor.value);
          Object.defineProperty(current.target, keys[propertyIndex], descriptor);
          copies.push({source : nextSource, target : descriptor.value});
      }
      if(internal){
        if(isEntity(current.source)){
          Object.defineProperty(current.target, "$", {
            value: {}
          });
          current.target.$.isNew = current.source.$.isNew;
          current.target.$.isModified = current.source.$.isModified;
          current.target.$.isDeleted = current.source.$.isDeleted;
          current.target.$.pK = current.source.$.pK;
          current.target.$._attributes = current.source.$._attributes;
          current.target.$.isCloned = true;
          if(current.source.$.hasOwnProperty("deepNest")){
            current.target.$.deepNest = current.source.$.deepNest;
          }
          if(current.source.$.hasOwnProperty("partialType")){
            current.target.$.partialType = current.source.$.partialType;
          }
        }
        if(Array.isArray(current.source)){
          if(current.source.partial){
            Object.defineProperty(current.target, "partial", {
              value: current.source.partial
            });
          }
        }
      }
  }
  return cloneObject;
}

function defineRelation(name,type,opts){
  var relation = {type : "relation", relType : type, relatedTo : name};
  if(opts){
    relation.opts = opts;
  }
  return relation;
}

function establishObserverBindings(observers,fromStore,properties,model,lyteScp) {
  var scope = this;
  var watchProps = model && fromStore ? model._fldGrps.JsonPathWatch : scope.constructor._deepWatchProperties;
  if(fromStore){
    scope = fromStore;      
  }
  for(var i=0;i<observers.length;i++) {
    var props = observers[i].properties;
    var obsAttr = {},obsDuplicate=false;
    var Jpath={}
    for(var j=0;j<props.length;j++) {
      var actProp;
      var isArrayObserver = false;
      var isObjectObserver = false;
      if(typeof props[j] == "string"){
        if(props[j].search(/^\$\./g)!=-1){
         
          var JsonPath = props[j];

          var CmpPropertyPath = JsonPath.match(/[^\$.][^\.]*/g)[0]
          if(CmpPropertyPath.search(/\[[0-9*]\]/g)!=-1){
            CmpPropertyPath = CmpPropertyPath.split(/\[[0-9*]\]/g)[0];
          }
          if(watchProps[CmpPropertyPath]==undefined){
            watchProps[CmpPropertyPath]=[];
          }

          if(Jpath[CmpPropertyPath] == undefined){
            Jpath[CmpPropertyPath]=[];
          }
          
          var JSONPATH ;
          var reg = "^\\$\\."+CmpPropertyPath+"\\.?"
          reg = new RegExp(reg);
          JSONPATH = props[j].replace(reg,"$.")
          if(!watchProps[CmpPropertyPath].includes(JSONPATH)){
            watchProps[CmpPropertyPath].push(JSONPATH)
          }
          
          if(!Jpath[CmpPropertyPath].includes(JSONPATH)){
            Jpath[CmpPropertyPath].push(JSONPATH)
          }


          CmpPropertyPath =CmpPropertyPath+".*";
          if(!obsAttr.hasOwnProperty(CmpPropertyPath)){
            actProp= getProperty.call(this,CmpPropertyPath,fromStore,properties)
            obsAttr[CmpPropertyPath]=true;
            obsDuplicate = false;
          }
          else{
            obsDuplicate = true;
          }
        }
        else if(props[j].indexOf('.[]') !== -1) {
          isArrayObserver = true;
          actProp = getProperty.call(this,props[j].substring(0, props[j].indexOf('.[]')),fromStore,properties);
        }
        else if(props[j].indexOf('.{}') !== -1) {
          isObjectObserver = true;
          let objObbName = props[j].substring(0, props[j].indexOf('.{}'))
          actProp = this.getProperty(objObbName);
          Object.defineProperty(actProp, '_objectObservers', {
            value: true,
            enumerable: false,
            writable: true,
            configurable: true
          });
			  }
        else {
          if(props[j].indexOf('.*') !== -1) {
            var prop = props[j].split(".")[0];
            var isDeepObs = (!fromStore && this.component.__data[prop] && this.component.__data[prop].watch) || (fromStore && model && model.fieldList && model.fieldList[prop] && model.fieldList[prop].watch) ? true : false;
            if(!isDeepObs){
              continue;
            }
          } 
          actProp = getProperty.call(this,props[j],fromStore,properties);
        }
      if(!obsDuplicate){
        if(!actProp._observers) {
          Object.defineProperty(actProp, '_observers', {
            value : new Set(),
            enumerable: false, 
            writable: true,
            configurable: true
          });
        }
       actProp._observers.add({callee : scope, observer: observers[i], isArrayObserver : isArrayObserver,isObjectObserver:isObjectObserver });
      }
    }else{
      _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Lyte.warn.call(lyteScp,"ERR27",JSON.stringify(props[j]),observers[i].fnName,this.tagName);
    }
  }
  observers[i].Jpath  = Jpath;
  obsAttr={};
}
}
// getProperty(key) {
//   var arr = key.match(/([^[\].]+|\[\])/g);
// let property = this;
// if(!property._properties[arr[0]]) {
//       property._properties[arr[0]] = {};
//   } 
//   property = property._properties[arr[0]];

// defProp(property, '_path', {enumerable: false, value : arr[0]});
// for(let i=1;i<arr.length;i++) {
//       if (arr[i].startsWith("'") || arr[i].startsWith('"')) {//added check
//           arr[i] = arr[i].substring(1, arr[i].length -1);
//       }
//       if(!property[arr[i]]) {
//           property[arr[i]] = {};
//           defProp(property[arr[i]], '_path', {enumerable: false, value : property._path + "." + arr[i]});
//       }
//     property = property[arr[i]];
//   }
//  return property;
// }
function getProperty(key,fromStore,properties) {
  var arr = key.match(/([^[\].]+|\[\])/g);
  let property = this;
  if(fromStore){
    property = properties;
    if(!properties[arr[0]]){
        properties[arr[0]] = {};
    }
    property = properties[arr[0]];
  }
  else {                      
    if(!property._properties[arr[0]]) {
        property._properties[arr[0]] = {};
    } 
    property = property._properties[arr[0]];
  }

  Object.defineProperty(property, '_path', {enumerable: false, value : arr[0]});
  for(let i=1;i<arr.length;i++) {
    if (arr[i].startsWith("'") || arr[i].startsWith('"')) {//added check
      arr[i] = arr[i].substring(1, arr[i].length -1);
    }
    if(!property[arr[i]]) {
        property[arr[i]] = {};
        Object.defineProperty(property[arr[i]], '_path', {enumerable: false, value : property._path + "." + arr[i]});
    }
    property = property[arr[i]];
  }
  return property;
}

let nestScpId = 1;
const nestScp = {};
const __nestRef__ = {};
const __nestScp__ = new Map();
function establishObjectBinding(data, attr, fromStore, update, storeRecord, watch) {
  var model, fld, nestObj,customDtype;
  var checkAttrs=data.__component__ && data.__component__.component.__data?data.__component__.component.__data[attr]:undefined, db;
  if (fromStore || storeRecord) {
      model = data.$ ? data.$.schema : (( storeRecord && storeRecord.$) ? storeRecord.$.schema : undefined);
      db = model.db;
      fld = model && model.fieldList && model.fieldList.hasOwnProperty(attr)? model.fieldList[attr] : {};
      if (!fld) {
          return;
      }
      checkAttrs=fld;
      watch = fld.watch;
  }
  if(checkAttrs && checkAttrs.type && checkAttrs.type instanceof Function){
    checkAttrs = checkAttrs.type;
    customDtype = true;
  }
  if (update && data._scp && data._scp.size) {
      var keys = Array.from(data._scp.keys());
      keys.forEach(function (id) {
        var _mpObj = data._scp.get(id), 
        mpObj = _mpObj.paths;
          for (var key in mpObj) {
              var path = key ? key.split(".") : [];
              path.push(attr);
              bindObj(data, attr, id, path, new Map(),checkAttrs,watch);
          }
      });
  }
  if ((!fromStore || fld.watch || fld.properties || fld.items || watch || customDtype) && data[attr]) {
      var _scpObj, kmpKey;
      if (data && data.__component__) {
          data.__component__.__scpObj || Object.defineProperty(data.__component__, "__scpObj", {
              value: {}
          });
          kmpKey = data.__component__;
          _scpObj = data.__component__.__scpObj;
      } else if (isEntity(data)) {
          data.$.__scpObj || Object.defineProperty(data.$, "__scpObj", {
              value: {}
          });
          kmpKey = data;
          _scpObj = data.$.__scpObj;
      }
      var obj = _scpObj,
      id;
      if (_scpObj) {
          var __nestScp1Set__ = false, __nestScp2Set__ = false;
          if (fromStore) {
              if(data[attr] && !__nestScp__.has(data[attr])){
                  nestObj = { db: db, model: model._name, attr: attr, pK: data.$.pK , Error : {} };
                  __nestScp1Set__ = true;
              }
              else{
                // var kmp = __nestScp__[kid] = __nestScp__[kid] || new Map();
                // data ? kmp.set(data, true) : undefined;
                var __nId = __nestScp__.get(data[attr])
                var refMp = __nestRef__[__nId] = __nestRef__[__nId] || new Map();
                var refMpId = genMapId(refMp);
                refMp.set(refMpId, true);
                setRecBindMap(nestScp[__nId], {db:db, model:model._name, attr: attr, pK: data.$.pK , Error : {} });
                obj[attr] = __nId+"_"+refMpId;
              }
          } else {
            if(data[attr] && !__nestScp__.has(data[attr])){
              // nestObj = { data: data[attr] };
              var ErrMap = [],cmpDataKeys = {};
              cmpDataKeys.key=attr;
              cmpDataKeys.dtype = data.__component__.component.__data[attr];
              cmpDataKeys._cmpErr = data.errors;
              cmpDataKeys.Error={};
              ErrMap.push(cmpDataKeys);
              nestObj = { data: data[attr], PropsInfo : ErrMap };
                __nestScp2Set__ = true;
            }
            else{
                var __nId = __nestScp__.get(data[attr])
                var scope = nestScp[__nId];
                if(scope){
                  var errMp = scope.PropsInfo;
                  var cmpDataKeys = {};
                  cmpDataKeys.key=attr;
                  cmpDataKeys.Error = {}
                  cmpDataKeys._cmpErr = data.errors;
                  cmpDataKeys.dtype = data.__component__.component.__data[attr];
                  errMp.push(cmpDataKeys);
                }
                var refMp = __nestRef__[__nId] = __nestRef__[__nId] || new Map();
                var refMpId = genMapId(refMp);
                refMp.set(refMpId, true);
                obj[attr] = __nId+"_"+refMpId;
            }
        }
        if(nestObj){
          nestScpId++;
          var refMp = __nestRef__[nestScpId] = __nestRef__[nestScpId] || new Map();
          var refMpId = genMapId(refMp);
          refMp.set(refMpId, true);
          __nestScp__.set(data[attr], nestScpId);
          if(__nestScp1Set__){
              nestScp[nestScpId] = {};
              if(db){
                nestScp[nestScpId].db = db;
              }
              setRecBindMap(nestScp[nestScpId], nestObj);
              nestScp[nestScpId].Error = nestObj.Error
              //     setRecBindMap(model._name, attr, data.$.pK, nestScpId); 
          }
          if(__nestScp2Set__){   
            nestScp[nestScpId] = nestObj;                 
          }
          nestScp[nestScpId]._data = data[attr];
          obj[attr] = obj[attr] || nestScpId+"_"+refMpId;
          var path = [];
          // fromStore ? path.push(attr) : undefined;
          bindObj(data, attr, nestScpId, path, new Map(), checkAttrs, watch);
        }
    }
}
};

function establishWatchScope(watchProps,model){
  var scope = this,object;
  for (var v in watchProps){
    var property = v;
    var watch = watchProps[v]
    if(scope.component && scope.component.__data && scope.component.__data[property]){
      object = scope.getData(property);
      watch = scope.component.__data[property].watch ? true : watch;
      if(typeof object == "object"){
        establishObjectBinding(scope.component.data,v,false,undefined,undefined,watch)
      }
      var dataDef = scope.component.__data;
      if( nestScp[__nestScp__.get(object)]){
        // nestScp[__nestScp__.get(object)].dtype.watch = watch;
        dataDef[v].watch = watch;        
      }
    }
    else{
      if(model){
        var fieldList = model.fieldList;
        if(fieldList[v] && fieldList[v].watch == undefined){
          fieldList[v].watch = watch ;
          model._fldGrps.watch[v] = fieldList[v];
        }
      }
    }
  }
}

function removeNestScp2Bind(mp, mdlObj){
  var mp = mp.model;
  if (mp.has(mdlObj.model)) {
    var mp1 = mp.get(mdlObj.model);
    if (mp1.has(mdlObj.pK)) {
        var mp2 = mp1.get(mdlObj.pK);
        if (mp2.has(mdlObj.attr)) {
            mp2.delete(mdlObj.attr);
        }
        !mp2.size ? mp1.delete(mdlObj.pK) : undefined; 
    }
    !mp1.size ? mp.delete(mdlObj.model) : undefined;
  }
}

function setRecBindMap(obj, nestObj){
  var mp = obj.model = obj.model || new Map(), modelName = nestObj.model, pK = nestObj.pK, attr = nestObj.attr;
  if(modelName && !mp.has(modelName)){
    mp.set(modelName, new Map());
  }
  mp = mp.get(modelName);
  if(pK && !mp.has(pK)){
    mp.set(pK, new Map());
  }
  mp = mp.get(pK);
  if(attr && !mp.has(attr)){
    mp.set(attr, true);
  }
}


function bindObj(data, key, id, path, mp, checkAttrs, watch) {
  mp = mp || new Map();
  var value = key != undefined ? data[key] : data;
  var cyclic = false;
  if(!path.length && __nestScp__.get(data) === id){
    delete nestScp[id].cyclic;
  }
  if (path.length > 1 && value && nestScp[id] && nestScp[id].hasOwnProperty("data") && nestScp[id].data === value) {
    if(mp.get(value)){
      cyclic = true;
    }
    if (checkAndAddBind(value, id, path, cyclic)) {
      estObjScp(value, id, path, cyclic);
    }
    return;
  }
  var attrs,nestedSCP;
  if(checkAttrs){
      if((checkAttrs.hasOwnProperty("items")||checkAttrs.hasOwnProperty("properties"))){
          attrs=checkAttrs.items || checkAttrs.properties;
          nestedSCP = true;
      }
      else if(watch == undefined && checkAttrs.watch == true){
          watch = checkAttrs.watch 
      }
  }
  attrs=watch?undefined:attrs;
  if (Array.isArray(value)) {
    if (!mp.get(value)) {
      mp.set(value, true);
      value.forEach(function (val, idx) {
        path.push(idx);
        if(watch || (checkAttrs && checkAttrs.hasOwnProperty("items") && typeof(checkAttrs.items) == "object" )){
          bindObj(value, idx, id, path, mp,attrs,watch);
        }  
        // bindObj(value, idx, id, path, mp);
        path.pop();
      });
    } else {
      cyclic = true;
    }
    if (checkAndAddBind(value, id, path, cyclic)) {
      var _establish;
      if(Array.isArray(watch)){
        _establish = checkEstablishingSCP(value,path,watch)
      }
      if(_establish || (typeof watch =="boolean" && watch ) || nestedSCP){
          estObjScp(value, id, path, cyclic);
      }
    }
  } else if (value && typeof(value) == "object") {
    var cyclic = false;
    if (!mp.get(value)) {
      mp.set(value, true);
      for (var str in value) {
        path.push(str);
        if(watch || (attrs && attrs.hasOwnProperty(str))){
          bindObj(value, str, id, path, mp,attrs?attrs[str]:undefined,watch);
        }  
        // bindObj(value, str, id, path, mp);
        path.pop();
      }
    } else {
      cyclic = true;
    }
    if (checkAndAddBind(value, id, path, cyclic)) {
      var _establish;
      if(Array.isArray(watch)){
        _establish = checkEstablishingSCP(value,path,watch)
      }
      if(_establish || (typeof watch =="boolean" && watch ) || nestedSCP ){
          estObjScp(value, id, path, cyclic);
      }
    }
  }
};

function checkAndAddBind(value, id, path, cyclic){
    if(!value._scp || !value._scp.size){
        return true;
    }
    if(value._scp.size){
      if(value._scp.has(id)){
          var _obj = value._scp.get(id);
          var obj = _obj.paths;
          if(obj.hasOwnProperty(path.join("."))){
            if(cyclic){
              nestScp[id].cyclic = true;
            }                      
            return false;
          }
      }
    }
    return true;
}   

function estObjScp(value, id, path, cyclic){
  if(!value._scp){
    Object.defineProperty(value, "_scp", {
      value : new Map(),
      enumerable : false,
      configurable : true
    });
  }
  var mp = value._scp;
  if(!mp.has(id)){
    mp.set(id, {});
  }
  var obj = mp.get(id),
  path = path ? path.join(".") : path;
  var pathObj = obj.paths = obj.paths || {};
  pathObj[path] = true;
  var nestObj = nestScp[id];
  nestObj.cyclic = true;
}

function cmpObjs(obj1, obj2){
    if(Object.keys(obj1).length !== Object.keys(obj2).length){
        return false;
    }
    for(var key in obj1){
        if(!obj2.hasOwnProperty(key)){
            return false;
        }
        var ret = cmpData(obj1[key], obj2[key]);
        if(ret == false){
            return false;
        }
    }
    return true;
}	


function cmpData(data1, data2){
  if(Array.isArray(data1)){
    if((!Array.isArray(data2)) || data1.length !== data2.length){
      return false;
    }
    var len = data1.length, ret;
    for(var i=0;i <len; i++){
      ret = cmpData(data1[i], data2[i]);
      if(ret == false){
        return false;
      }
    }
  }
  else if(data1 && data2 && typeof data1 == "object" && typeof data2 == "object"){
    return cmpObjs(data1,data2);
  }
  else if(isEntity(data1) && isEntity(data2)){
    if(data1.$.schema){
      if( (data1.$.schema._name !== data1.$.schema._name) || (str$.getpKVal(data1) !== str$.getpKVal(data2)) ){
        return false;
      }
    }
    else{
      if( (data1.$.model._name !== data1.$.model._name) || (str$.getpKVal(data1) !== str$.getpKVal(data2)) ){
        return false;
      }
    }
  }
  else if(data1 !== data2){
    return false;
  }
  return true;
}

function nestScpRmPath(obj, path){
  if(obj && obj.paths){
      obj = obj.paths;
      for(var key in obj){
          if(key.startsWith(path+".")){
              delete obj[key];
          }
      }
  }
}

function nestScpRemove(data, id, path){
  var mp = data._scp;
  if(mp && mp.size){
      if(path){
        nestScpRmPath(mp.get(id), path);
        var _obj = mp.get(id); 
        var obj = _obj ? _obj.paths : undefined;
        if(obj && !Object.keys(obj).length){
            mp.delete(id);
        }  
      }
      else{
          mp.delete(id);
      }
      if(!mp.size){
        delete data._scp;
      }
  }
}

function rmNestScp(value, id, mp, data, path){
  if (Array.isArray(value)) {
      if (!mp.get(value)) {
          mp.set(value, true);
          value.forEach(function (val, idx) {
              rmNestScp(val, id, mp, undefined, path);
          });
      }
      nestScpRemove(value, id, path);
  } else if (value && typeof(value) == "object") {
      if (!mp.get(value)) {
          mp.set(value, true);
          for (var str in value) {
              rmNestScp(value[str], id, mp, undefined, path);
          }
      }
      nestScpRemove(value, id, path);
  }
}

function removeNestScp(value, id, mpId, path, context, mp, data, recObj) {
  mp = mp || new Map();
  id = Number.parseInt(id);
  var obj = nestScp[id], kmp = __nestRef__[id];
  if(recObj && obj.model){
    removeNestScp2Bind(obj, recObj);
  }
  if(context){
      if(kmp && kmp.has(mpId)){
          kmp.delete(mpId);
      }
      if(!kmp || (kmp && !kmp.size)){
          delete __nestRef__[id];
          if(__nestScp__.has(value)){
              __nestScp__.delete(value);
          }
          rmNestScp(value, id, mp, true, path);
          if(!data){
              delete nestScp[id];
          }
      }
  }
  else{
    rmNestScp(value, id, mp, true, path);
  }
};

//@3055
// function addStateToMap(event, target, XHR, stateName){
//   var mp = window.__nodeXHRMap = window.__nodeXHRMap || new Map();
//   var nodeMap = mp.get(target);
//   if(!nodeMap){
//       mp.set(target, new Map());
//   }
//   nodeMap = mp.get(target);
//   var sr = target.lyteState = target.lyteState || [], type = stateName || XHR;
//   if(sr.indexOf(type) == -1){
//       sr.push(type);
//   }
//   target.setAttribute("lyte-state", "");
//   var evMap = nodeMap.get(event);
//   if(!evMap){
//       nodeMap.set(event, []);
//       evMap = nodeMap.get(event);
//   }
//   if(stateName){
//       evMap.push({state:stateName});
//       return {target: target, event: event};        
//   }
//   else{
//       evMap.push({isXHR:true, xhr:XHR});
//       var callback = function(arg){
//         if(XHR.readyState == 4){
//             removeStateFromMap(XHR, event, target);
//             XHR.removeEventListener("readystatechange", callback);
//         }
//     }
//     XHR.addEventListener("readystatechange", callback);
//   }
// }

// function removeStateFromMap(type, event, target){
//   var mp = window.__nodeXHRMap; 
//   var nodeMap = mp.get(target);
//   if(!nodeMap){
//       return;
//   }
//   var evMap = nodeMap.get(event);
//   if(!evMap){
//       return;
//   }
//   if(evMap){
//       var arr = evMap;
//       var ind = -1;
//       arr.every(function(itm, idx){
//           if((itm && itm.isXHR && itm.xhr == type)|| (typeof type == "string" && itm.state == type)){
//               ind = idx;
//               return false;
//           }
//           return true;
//       });
//       if(ind != -1){
//           arr.splice(ind,1);
//           var sind = target.lyteState.indexOf(type);
//           target.lyteState.splice(sind, 1);
//           if(!arr.length){
//               nodeMap.delete(event);
//               var tyInd = target && Array.isArray(target.lyteState) ? target.lyteState.indexOf(type) : -1; 
//               tyInd != -1 ? target.lyteState.splice(tyInd, 1) : undefined;
//               if(target && target.lyteState && target.lyteState.length == 0){
//                   target.lyteState = null;
//                   target.removeAttribute("lyte-state");
//               } 
//           }
//           if(!nodeMap.size){
//               mp.delete(target);
//           }
//       }
//   }
// }

function toBeUsedServices(obj){
  var serviceToBeUsed = Object.assign({},obj.Lyte.toBeInjectedServices);
  var arr = obj.services;
  if(arr){
    arr.forEach(function(service){
        if(typeof service == "string"){
            serviceToBeUsed[service] = service;
        }
        else if(service && typeof service == "object"){
            for(var key in service){
                serviceToBeUsed[key] = service[key];
            }
        }
    })
  }
  return serviceToBeUsed;
}

function extendService(obj){
  var servObj = obj.serviceToBeUsed || toBeUsedServices(obj), name;
  for(var serv in servObj){
    name = servObj[serv];
    if(obj.Lyte.registeredServices.hasOwnProperty(name)){
      obj.scope[serv] = obj.Lyte.registeredServices[name];
    }else{
      obj.Lyte.$.requiredServices(serv, name, obj.callback);
    }
  }  
}

function extendMixin(obj){
  var scp = obj.Lyte, self = obj.scope;
  obj.mixins.forEach(function(item){
    if(scp.Mixin.exists(item)){
      var mixin = scp.registeredMixins[item];
      for(var key in mixin){
        self[key] = mixin[key];
      }
    }
    else{
      scp.$.requiredMixins(item, obj.callback);
    }
  });
}

function toAddSuper(scp, key, name, self){
  if(scp.__toAddSuper && scp.__toAddSuper.hasOwnProperty(name)){
    var addSuper = scp.__toAddSuper[name];
    for(var i=0; i<addSuper.length; i++){
      var child = scp[addSuper[i]];
      if(child && child.is == key){
        child.$super = self;
        self.__extendedBy.push(addSuper[i]);
        var index;
        if(name != "application")
        {	
          if(scp.__toAddSuper.application)
          {
            index = scp.__toAddSuper.application.indexOf(child.__name);
            if(index > -1)
            {
              scp.__toAddSuper.application.splice(index,1);
            }
          }
          if(scp.application)
          {
            index = scp.application.__extendedBy.indexOf(child.__name);
            if(index > -1)
            {
              scp.application.__extendedBy.splice(index,1);
            }
          }
        }
      }
    }
    delete scp.__toAddSuper[name];
  }
}

function _get(cacheObj, key) {
  return cacheObj[key];
}
function globalsSet(scope,value){
  let set = this.$utils.set;
  if(set){
      return set(this.__gl,scope,value);
  }
  else{
      this.error("Globals set will be supported only if component registry is imported in the app");
  }
};
function globalsGet(scope){
  let get = this.$utils.get;
  if(get){
      return get(this.__gl,scope);
  }
  else{
      elf.error("Globals get will be supported only if component registry is imported in the app");
  }
};
function arrayUtils(){
  let arrayUtils = this.$utils.arrayUtils;
  if(arrayUtils){
      return arrayUtils.apply(arrayUtils, arguments);
  }else{
      this.error("arrayUtils will be supported only if component registry is imported in the app");
  }
}
function objectUtils(){
  let objectUtils = this.$utils.objectUtils;
  if(objectUtils){
      return objectUtils.apply(objectUtils, arguments);
  }else{
      this.error("objectUtils will be supported only if component registry is imported in the app");
  }
}
function _lyteDidConnect(LClass,ins){
  if(LClass._component.didConnect){
    LClass._component.didConnect(ins);
  }
}
function _lyteInit(LClass,ins){
  ins.__gl = {};
  ins.Globals = {};
  // ins.triggerEvent = triggerEvent;
  // ins.addEventListener = addEventListener;
  // ins.removeEventListener = removeEventListener; 
  ins.extendEventListeners = extendEventListeners;
  extendEventListeners(ins);
  extendEventListeners(LClass);
  if(LClass._component.init){
    LClass._component.init(ins);
  }
  // ins.arrayUtils = arrayUtils;
  // ins.objectUtils = objectUtils;
  ins.arrayUtils = function() {
    return arrayUtils.apply(ins ,arguments);
  }
  ins.objectUtils = function(){
      return objectUtils.apply(ins ,arguments);
  }
  ins.Globals.set = function(){
      return globalsSet.apply(ins ,arguments);
  }
  ins.Globals.get = function(){
      return globalsGet.apply(ins ,arguments);
  }
  ins.lyteError = _lyte_error__WEBPACK_IMPORTED_MODULE_1__.Logger;
  ins.error = _lyte_error__WEBPACK_IMPORTED_MODULE_1__.Logger.error.bind(_lyte_error__WEBPACK_IMPORTED_MODULE_1__.Logger);
  ins.warn = _lyte_error__WEBPACK_IMPORTED_MODULE_1__.Logger.warn.bind(_lyte_error__WEBPACK_IMPORTED_MODULE_1__.Logger);
  ins.errorCodes = _lyte_error__WEBPACK_IMPORTED_MODULE_1__.Logger.errorCodes;
  defProp(ins, "patterns", {
    value: {
      email : new RegExp(/^([A-Za-z0-9._%\-'+/]+@[A-Za-z0-9.-]+\.[a-zA-Z]{2,22})$/),
      url : new RegExp(/(^(ht|f)tp(s?):\/\/[0-9a-zA-Z][-.\w]*(:[0-9])*(\/?)([a-zA-Z0-9\-.?,:'/\\+=&amp;%$#_[\]@!()*;~]*)?$)/),
      ampm : new RegExp(/^(AM|PM|am|pm)$/),
      hour : new RegExp(/^(0?[0-9]|1[0-9]|2[0-4])$/),
      minute : new RegExp(/^(0?[0-9]|[1-5][0-9]|60)$/),
      boolean : new RegExp(/^(true|false|TRUE|FALSE)$/),
      alphaNumeric : new RegExp(/([a-zA-Z0-9])+/),
      alphabetsOnly : new RegExp(/([a-zA-Z])+/),
      numeric : new RegExp(/([0-9])+/),
      phoneNo : new RegExp(/^[0-9a-zA-Z+.()\-;\s]+$/)
    }
  });
  ins.deepCopyObject = function(obj){
    return copyObject(obj);
  }
  ins.prop = function(type, opts){
    var obj = {};
    obj.type = type;
    if(opts == undefined){
      opts = {};
    }
    // if(this.types.indexOf(type) == -1 && !this.Transform.hasOwnProperty(type)){
    //   throw new Error("Not a valid field type - "+type);
    // }
    Object.assign(obj, opts);
    return obj;
  }
  _lyte_error__WEBPACK_IMPORTED_MODULE_1__.Logger.addEventListener("error", function(){  
    var arr = Array.from(arguments);
    if (LClass.onerror) {
      LClass.onerror.apply(LClass, arr);
    }
    if(LClass.triggerEvent){
      arr.unshift("error");
      LClass.triggerEvent.apply(LClass, arr);
    }
  });
  ins.types = types;
  ins.log = function (text, src, color) {
    if (this.config && this.config.debug) {
        if(color) {
            console.log("%c" + text,'color:' + color);
        } else {
          console.log(text);      
        }
    }
  };
  ins.isComponent = function(object) {
      if(object && object.$node && object.__data) {
        return true;
      }
      return false;
  }
  ins.Transform = {};
  ins.one = one;
  ins.many = many;

  ins.registerDataType = function(fieldTypeName, properties){
      var exts = "extends";
      if(ins.Transform.hasOwnProperty(fieldTypeName)){
        LClass.error("Custom Field Type - "+fieldTypeName+" -  already exists.");
        return;
      }
      if(properties[exts] == undefined || ins.types.indexOf(properties[exts]) == -1){
        LClass.error("Not a valid field type - "+properties[exts]);
        return;
      }
      ins.Transform[fieldTypeName] = properties;
  }
  ins.registerPattern = function(patternName, pattern){
    ins.patterns[patternName] = pattern;
  }
  // ins.injectResources = function (files, every, completed, options) {
  //   var successFiles = [],
  //   errorFiles = [],
  //   scope = ins;
  //   every = every || function () {};
  //   completed = completed || function () {};
  //   return new Promise(function (resolve,reject) {
  //     processRequirements(files, function () {
  //       if (options && options.defer) {
  //         options.defer({
  //           injectJS: injectJS,
  //           files: files,
  //           errorFiles: errorFiles
  //         });
  //         resolve();
  //       } else {
  //         injectJS(files, function () {
  //           completed(successFiles, errorFiles);
  //           if(errorFiles.length) {
  //               reject(successFiles, errorFiles);
  //             } else {
  //               resolve(successFiles, errorFiles);
  //             }
  //         });
  //       }
  //     }.bind(ins));
  //   });
  
  //   function injectJS(files, resolve, execFiles) {
  //     execFiles = execFiles || []
  //     if (!files) {
  //       resolve(successFiles, errorFiles);
  //     } else {
  //       if (!Array.isArray(files)) {
  //         files = [files];
  //       }
  //       if (!files.length) {
  //         resolve(successFiles, errorFiles);
  //       }
  //       var len = -files.length;
  //       files.forEach(function (file) {
  //         if (typeof file == "string") {
  //            var fileSplit = file.split('.'),
  //           type = fileSplit[fileSplit.length - 1];
  //           if (type && type == "js" && execFiles.indexOf(file) == -1) {
  //             execFiles.push(file);
  //             createScript(file, function () {
  //               loaded();
  //             });
  //           } else {
  //             loaded();
  //           }
  //         } else if (Array.isArray(file)) {
  //           new Promise(function (r) {
  //             injectJS(file, r);
  //           }).then(function () {
  //             loaded();
  //           });
  //         } else {
  //           len--;
  //           new Promise(function (r) {
  //             injectJS(file.parent, r);
  //           }).then(function () {
  //             new Promise(function (r) {
  //               injectJS(file.child, r);
  //             }).then(function () {
  //               loaded();
  //             });
  //             loaded();
  //           });
  //         }
  //       });
  //     }
  
  //     function loaded() {
  //       len++;
  //       if (len == 0) {
  //         resolve(successFiles, errorFiles);
  //       }
  //     }
  //   }
    
  //   function createScript(file, resolve) {
  //     var ev = scope.injectResources.respObj[file];
  //     if (!scope.injectResources.availableTags[file] || scope.injectResources.availableTags[file].tag.tagName == "LINK") {
  //       var tag = document.createElement('script');
  //       tag.setAttribute('type', "text/javascript");
  //       ev.getAttributeNames().forEach(function (attr) {
  //         if (["href", "as", "rel"].indexOf(attr) == -1) {
  //           tag.setAttribute(attr, ev.getAttribute(attr));
  //         }
  //       });
  //       tag.setAttribute('src', file);
  //       tag.onerror = tag.onload = function(event) {
  //         if (event.type == "error") {
  //           errorFiles.push(event)
  //         } else {
  //           successFiles.push(event)
  //         }
  //         scope.injectResources.availableTags[file].tag.remove();
  //         scope.injectResources.availableTags[file] = { tag: tag, event: { type: event.type == "error" ? "error" : "load"} };
  //         resolve();
  //       }
  //       Lyte.$.assetsDiv.appendChild(tag);
  //     } else {
  //       resolve();
  //     }
  //   }
  
  //   function processRequirements(files, resolve) {
  //     if (!files) {
  //       resolve();
  //     } else {
  //       if (!Array.isArray(files)) {
  //         files = [files];
  //       }
  //       if (!files.length) {
  //         resolve();
  //       }
  //       var len = -files.length;
  //       files.forEach(function (file) {
  //         if (typeof file == "string") {
  //           requestFile.call(scope, file, scope.injectResources.availableTags[file], function () {
  //             loaded();
  //           });
  //         } else if (Array.isArray(file)) {
  //           new Promise(function (r) {
  //             processRequirements(file, r);
  //           }).then(function () {
  //             loaded();
  //           });
  //         } else {
  //           len--;
  //           new Promise(function (r) {
  //             processRequirements(file.parent, r);
  //           }).then(function () {
  //             loaded();
  //           });
  //           new Promise(function (r) {
  //             processRequirements(file.child, r);
  //           }).then(function () {
  //             loaded();
  //           });
  //         }
  //       });
  //     }
  
  //     function loaded() {
  //       len++;
  //       if (len == 0) {
  //         resolve();
  //       }
  //     }
  
  //     function requestFile(file, cached, resolve) {
  //       if(ins.$.reqFiles[file]) {
  //         ins.$.reqFiles[file].push(resolve);
  //       } else {
  //         var scope = ins;
  //         ins.$.reqFiles[file] = [resolve];
  //         if (cached && cached.event.type != "error") {
  //           if (ins.removeFromCache.arr.indexOf(file) != -1) {
  //             ins.removeFromCache.arr.splice(scope.removeFromCache.arr.indexOf(file), 1);
  //           }
  //           fileLoaded.call(cached.tag, file, cached.event, true);
  //           resolve();
  //         } else {
  //           makeRequest(file, function (event) {
  //             scope.injectResources.respObj[file] = ins;
  //             scope.$.reqFiles[file].forEach(function (resolve) {
  //               resolve();
  //             });
  //             // filesObj[file] = ins;
  //             fileLoaded.call(ins, file, event);
  //             every.call(ins, event);
  //           });
  //         }
  //       }
  //     }
  
  //     function fileLoaded(file, event, cached) {
  //       delete scope.$.reqFiles[file];
  //       if (!cached) {
  //         if (scope.injectResources.availableTags[file]) {
  //           scope.injectResources.availableTags[file].tag.remove();
  //           delete scope.injectResources.respObj[file];
  //         }
  //         ins.onerror = ins.onload = undefined;
  //         scope.injectResources.availableTags[file] = { tag: ins, event: { type: event.type } };
  //       }
  //     }
  //   }
  
  //   function makeRequest(file, callBack) {
  //     var tag,
  //         ev = every.internal || {},
  //         fileSplit = file.split('.'),
  //         type = fileSplit[fileSplit.length - 1];
  //     ev.file = file;
  //     if (fileSplit.length == 1) {
  //       Lyte.error('Type of file is not specified in injectResources.');
  //       return;
  //     }
  //     tag = document.createElement('link');
  //     tag.setAttribute('href', file);
  //     ev.tag = tag;
  //     if (type == 'css') {
  //       tag.setAttribute('type', "text/css");
  //       tag.setAttribute('rel', "stylesheet");
  //       tag.onerror = tag.onload = function (event) {
  //         // if (event.type == "error") {
  //         //   errorFiles.push(event);
  //         // } else {
  //         //   successFiles.push(event);
  //         // }
  //         callBack.call(ins, event);
  //       };
  //     } else {
  //       tag.setAttribute('as', "script");
  //       tag.setAttribute('rel', "preload");
  //       tag.onerror = tag.onload = function (event) {
  //         // if (event.type != "error") {
  //         //   tag.status = 200;
  //         // }
  //         callBack.call(ins, event);
  //       };
  //     }
  //     Lyte.triggerEvent("onBeforeInject", ev);
  //     Lyte.$.assetsDiv.appendChild(tag);
  //   };
  // };
  // ins.injectResources.availableTags = [];
  // ins.injectResources.respObj = [];

  // ins.removeFromCache = function(arr) {
  //   var scope = ins;
  //   ins.removeFromCache.assign.call(ins,arr);
  //   if(ins.removeFromCache.arr.length) {
  //     ins.removeFromCache.arr.forEach(function(file) {
  //       if(scope.injectResources.availableTags[file]) {
  //         scope.injectResources.availableTags[file].tag.remove();
  //         delete scope.injectResources.availableTags[file];  
  //       }
  //     });
  //     ins.removeFromCache.arr = [];
  //   }
  // }
  // ins.removeFromCache.arr = [];
  // ins.removeFromCache.assign = function(arr) {
  //   arr = arr == "*" ? Object.keys(ins.injectResources.availableTags) : (Array.isArray(arr) ? arr : [arr]); 
  //   ins.removeFromCache.arr = ins.removeFromCache.arr.concat(arr);
  //   return;
  // }
  // ins.resolvePromises = function(promises) {
  //   return new Promise(function(res, rej) {
  //     resolvePromises(promises).then(function(data) {
  //       res(data);
  //     },function(data) {
  //       rej(data);
  //     })
  //   })
  // }
  // ins.setState = function(str){
  //   if(!str){
  //     console.error("Please provide a state name");
  //   }
  //   var evnt = window.event;
  //   if(/^(click|dblclick)$/.test(evnt.type)){
  //       var target = evnt.target;
  //       if(getConfig("stateHandling") == true && target && target.getAttribute && target.getAttribute("lyte-state-handling") != "false"){
  //           var state = target.getAttribute("lyte-state");
  //           if(!state){
  //               var mp = window.__stateMap = window.__stateMap || new Map();
  //               var mpobj = mp.get(str);
  //               if(!mpobj){
  //                   var obj = addStateToMap(evnt.type, target, undefined, str);
  //                   mp.set(str, obj);
  //               }
  //               else{
  //                   console.error("There is already a open state by the name",str);
  //               }
  //           }
  //       }        
  //   }
  // }
  // ins.removeState = function(str){
  //   if(!str){
  //       console.error("Please provide a state name");
  //   }
  //   var mp = window.__stateMap;
  //   if(mp){
  //       var obj = mp.get(str);
  //       if(obj){
  //           mp.delete(str);
  //           removeStateFromMap(str, obj.event, obj.target);
  //       }
  //   }
  // }

  // ins.setConfig = function(key, value){
  //   var configObj = window.__config = window.__config || {};
  //   configObj[key] = value;
  // }
  // ins.getConfig = getConfig;
}


function _defineProperty(exportsObj,specsObj){
  let actualObj = {};
  let defineProperty = function(obj,property){
    Object.defineProperty(exportsObj,property,{
      set : function(newValue){
        actualObj[property] = newValue;
      },
      get : function(){
        if(!actualObj[property]){
          actualObj[property] = obj();
        }
        return actualObj[property];
      }

    })
  }
  for(let key in specsObj){
    defineProperty(specsObj[key],key)
  }
}

function checkEstablishingSCP(value,path,watch){
  if(Array.isArray(watch)){
      var _path ='';
      _path = path.join(".")
      if(checkWatchPath(_path,watch,true) && typeof value != "object"){
          return true
      }
      var _key = Object.keys(value);
      for(var i_scp =0 ; i_scp<_key.length ; i_scp++){
          var spiePath = _key[i_scp];
         var finalaUth =  _path == ""?spiePath : _path+"."+spiePath;
          if(checkWatchPath(finalaUth,watch,true)){
              return true
          }
      }
  }
}
function checkWatchPath(actualPath,watchArr,establishBind){
  if(typeof watchArr == "boolean" && watchArr === true){
      return true
  }
  else if(Array.isArray(watchArr)){
      for(var i_watch=0; i_watch < watchArr.length ; i_watch++){
          var path = watchArr[i_watch];
          path =path.replace(/ /g,"");
          path = path.replace(/\$\.\./g,"..");
          path = path.replace(/\$\./g,"")
          var weirdPath = path.search(/\.\./g) != -1 || path.search(/\[|\\]|\{|\}/g)!=-1 ? true :  false || path.includes("*");
          if(actualPath == path){
              return true;
          }
          else if (weirdPath){
              if(establishBind){
                if(path.search(/\.\./) != -1 ){
                  path = path.replace(/\.\.\S+/g,"..*")
                  if(path == "..*"){
                    return true;
                  }
                } 
              }
              path = path.search(/\[/) == 0? path.replace("[",""):path;
              path = path.search(/\.\.\[/)==0 ? path.replace("..[",".."):path
              path = path.replace(/\.*\[/g,".");
              path = path.replace(/\]/g,"");
              var _watchPath = checkWeirdPath(path,actualPath);
              if(_watchPath){
                  return true
              }
          }
      }
  }
}
function checkWeirdPath(watchPath,actualPath){
  if(actualPath == watchPath){
      return true;
  }
  else if(watchPath.includes("..") || watchPath.includes("*")) {
      var cmpPath = watchPath;
      cmpPath = cmpPath.replace(/\*/g, "$$")
      cmpPath = cmpPath.replace(/\.\./g,"::")
      // cmpPath = cmpPath.replace("[","\\[")
      cmpPath = cmpPath.replace(/\./g, "\\.")
      cmpPath=cmpPath.replace(/\:\:/g,"\\.?.*\\.?");
      cmpPath=cmpPath.replace(/\$/g,".*");
      var _wildCard = watchPath.split(".")
      var _wClenght = _wildCard.length;
      if(_wildCard[_wClenght-2] == "" && _wildCard[_wClenght-1]!="*"){
        cmpPath = cmpPath+"$";
      }
      var regularExp = new RegExp(cmpPath);
      if(regularExp.test(actualPath)){
          return true;
      }
      return false;
  }
}
function removeStateFromMap(type, event, target) {
  var mp = window.__nodeXHRMap;
  var nodeMap = mp.get(target);
  if (!nodeMap) {
      return;
  }
  var evMap = nodeMap.get(event);
  if (!evMap) {
      return;
  }
  if (evMap) {
      var arr = evMap;
      var ind = -1;
      arr.every(function (itm, idx) {
          if ((itm && itm.isXHR && itm.xhr == type) || (typeof type == "string" && itm.state == type)) {
              ind = idx;
              return false;
          }
          return true;
      });
      if (ind != -1) {
          arr.splice(ind, 1);
          var sind = target.lyteState.indexOf(type);
          target.lyteState.splice(sind, 1);
          if (!arr.length) {
              nodeMap.delete(event);
              var tyInd = target && Array.isArray(target.lyteState) ? target.lyteState.indexOf(type) : -1;
              tyInd != -1 ? target.lyteState.splice(tyInd, 1) : undefined;
              if (target && target.lyteState && target.lyteState.length == 0) {
                  target.lyteState = null;
                  target.removeAttribute("lyte-state");
              }
          }
          if (!nodeMap.size) {
              mp.delete(target);
          }
      }
  }
}

function addStateToMap(event, target, XHR, stateName) {
  var mp = window.__nodeXHRMap = window.__nodeXHRMap || new Map();
  var nodeMap = mp.get(target);
  if (!nodeMap) {
      mp.set(target, new Map());
  }
  nodeMap = mp.get(target);
  var sr = target.lyteState = target.lyteState || [],
      type = stateName || XHR;
  if (sr.indexOf(type) == -1) {
      sr.push(type);
  }
  target.setAttribute("lyte-state", "");
  var evMap = nodeMap.get(event);
  if (!evMap) {
      nodeMap.set(event, []);
      evMap = nodeMap.get(event);
  }
  if (stateName) {
      evMap.push({
          state: stateName
      });
      return {
          target: target,
          event: event
      };
  } else {
      evMap.push({
          isXHR: true,
          xhr: XHR
      });
      var callback = function () {
          if (XHR.readyState == 4) {
              removeStateFromMap(XHR, event, target);
              XHR.removeEventListener("readystatechange", callback);
          }
      }
      XHR.addEventListener("readystatechange", callback);
  }
}




/***/ }),

/***/ 46823552:
/*!**********************************************!*\
  !*** ./node_modules/@slyte/core/src/lyte.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Lyte": () => (/* binding */ Lyte),
/* harmony export */   "__getCurrentContext": () => (/* binding */ __getCurrentContext),
/* harmony export */   "__getCurrentFunc": () => (/* binding */ __getCurrentFunc),
/* harmony export */   "__scopedInstance": () => (/* binding */ __scopedInstance),
/* harmony export */   "__setCurrentContext": () => (/* binding */ __setCurrentContext),
/* harmony export */   "toLowerCase": () => (/* binding */ toLowerCase)
/* harmony export */ });
/* harmony import */ var _slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @slyte/core/src/lyte-utils.js */ 60768251);
/* harmony import */ var _service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./service */ 76099455);
/* harmony import */ var _lyte_error__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lyte-error */ 182578);
/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils.js */ 95638012);
/* harmony import */ var _DataType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DataType.js */ 68393168);
/* harmony import */ var _Mixin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Mixin.js */ 8979898);


// import { resolvePromises } from './rsvp';





// var __instances = { engine : {}, addon: {}};
// var __componentsMap = {};
// var __servicesMap = {}; // Map for containing the services needed for every engine
// var __enginesMap = new Map(); //Map for containing the engines associated with every service
var d = document;
// //change to defProp later
// Function.prototype.observes = function(){//af
//   return {
//     type: "observer",
//     value: this,
//     properties: arguments,
//     on: Function.prototype.on
//   }
// }
// Function.prototype.on = function(){
//   return {
//     type: "callBack",
//     value: "observer" === this.type ? this.value : this,
//     properties: arguments,
//     observes: "observer" === this.type ? this : void 0
// }
// }
var currentContext;
var currFunc;

function __setCurrentFunc(func) {
    currFunc = func;
}

function __getCurrentFunc() {
    return currFunc;
}
function __setCurrentContext(self) {
    currentContext = self;
}

function __getCurrentContext() {
    return  currentContext;
}

function toLowerCase(string) {
    return string.charAt(0).toLowerCase() + string.slice(1)
}

function __scopedInstance(cls, args, func, extendArgs) {
  var oldcontext = __getCurrentContext();
  __setCurrentContext(this);
  var self = this;
  __setCurrentFunc(function(ins) {
      __setCurrentFunc();
      if(extendArgs && extendArgs.length){
        extendArgs.forEach(function(itm){
          // let itm__lyte = __getLyte(itm);
          // itm.__lookups
          if(itm.__lookups && itm.__lookups.length){
            (0,_service__WEBPACK_IMPORTED_MODULE_0__.__handleLookups)(itm.__lookups, self, ins);
          }
        });
      }
      func(ins);
  });
  var ins = Reflect.construct(cls, args);
  __setCurrentContext(oldcontext);
  return ins;
}

class Lyte {
  static dataType(type){
    var self = this;
    class dataType extends self.DataType {}
    dataType.type = type;
    return dataType;
  }

  lookups() {
    return [];
  }

  scopedInstance() {
    return __scopedInstance.apply(this, Array.from(arguments));
  }
  static componentMap(map){
    Lyte._componentMap = map;
  }
  static register(options){
    if(options){
      if(options.app == true){
        Lyte._setDefaultApp(this);
      }
      if(options._migration){
        this._migration = options._migration;
      }
      if(options.hash){
        this._hash = options.hash;
      }
      if(options.refHash){
          this._refHash = options.refHash;
      }
    }
    var DT = this.DataType = (function() {
      class DataType extends _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType {
        static register(){
          _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.registerInApp.apply(this, [DT]);
        }
      }
      return DataType;
    })();
    DT.dataType = {};
    (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.extendEventListeners)(DT.dataType);
    // DT.register = function(){
    //     DataTypeClass.register.apply(this, [DT]);
    // }    
    var hash = options ? options.hash : undefined;
    if(hash && _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType && _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.app && _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.app.has(options.hash)){
      var dMap = _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.app.get(hash);
      if(dMap.size){
        dMap.forEach(function(cls, name){
          _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.registerInApp.apply(cls, [DT]);
          dMap.delete(name);
        });
        if(!dMap.size){
          _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.app["delete"](hash);
        }
        if(!_DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.app.size){
          delete _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.app;
        }
      }
    }
    if(hash){
      _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.addEventListener(hash, function(dCls){
        _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.registerInApp.apply(dCls, [DT]);
        if(_DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.lyte.has(hash)){
            var dMap = _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.lyte.get(hash); 
            if(dMap.has(dCls.name)){
              dMap.delete(dCls.name);
            }
            if(!dMap.size){
              _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.lyte["delete"](hash);
            }
            if(!_DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.lyte.size){
              delete _DataType_js__WEBPACK_IMPORTED_MODULE_1__.DataType.lyte;
            }
        }
      });
    }
  }
  constructor(config) {
    var self = this;
    let defApp = Lyte._getDefaultApp();
    if(!Lyte._getDefaultAppIns() &&  defApp && defApp == this.constructor){
      Lyte._setDefaultAppIns(this);
    }
    Lyte._instances.push(this);
    // extendEventListeners(this);
    // this.lyteError = Logger;
    // this.error = Logger.error.bind(Logger);
    // this.warn = Logger.warn.bind(Logger);
    // this.errorCodes = Logger.errorCodes;
    // this.addEventListener = addEventListener;
    // this.removeEventListener = removeEventListener;
    // this.triggerEvent = triggerEvent;
    var consoleTime = [],
    wLyte = Lyte;
    var type = this.is = config.__lp && config.__lp.type ? config.__lp.type :  "app";
    this.config = config;
    this.version = "4.0.0";
    this.$ = {
      isApp : type == "app",
      // isSubApp : type == "subApp",
      isAddon : type == "Addon",
      reqFiles : {},
      injectServices : {},
      modules : {}
    };
    (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.extendEventListeners)(this.$.modules);
    this.$.modules.addEventListener("add", function(name, ins){
      if(!self.$.modules.hasOwnProperty(name)){
        self.$.modules[name] = [];
      }
      self.$.modules[name].push(ins);
    });
    (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.defProps)(this, {
      "__mixins__":{
        value: new Map()
      },
      "registeredServices":{
        value:{}
      },
      "registeredMixins":{
        value:{}
      },
      // "_registeredComponents":{
      //   value: {}
      // },
      "Service":{
        value:{}
      },
      "toBeInjectedServices": {
        value:{}
      },
      "toBeRegistered": {
        value:{}
      },
      "dataType":{
        value:{}
      }
    });
    (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.defProps)(this, { "customValidator":{
      value: new Map()
    } });
    this.constructor.DataType.dataType.addEventListener("add",function(name, def){
      self.dataType[name] = def;
    });
    var dTypeDef = this.constructor.DataType.dataType;
    for(var dKey in dTypeDef){
      this.dataType[dKey] = dTypeDef[dKey];
    }
    // this.registeredCustomComponent = {};
    this.updateMixinsInApp();
    // this.Globals = {}
    // this.__lyteRegisteredEvents = {};
    // this.patterns = {
    //   email : /^([A-Za-z0-9._%\-'+/]+@[A-Za-z0-9.-]+\.[a-zA-Z]{2,22})$/,
    //   url : /(^(ht|f)tp(s?):\/\/[0-9a-zA-Z][-.\w]*(:[0-9])*(\/?)([a-zA-Z0-9\-.?,:'/\\+=&amp;%$#_[\]@!()*;~]*)?$)/,
    //   ampm : /^(AM|PM|am|pm)$/,
    //   hour : /^(0?[0-9]|1[0-9]|2[0-4])$/,
    //   minute : /^(0?[0-9]|[1-5][0-9]|60)$/,
    //   boolean : /^(true|false|TRUE|FALSE)$/,
    //   alphaNumeric : /([a-zA-Z0-9])+/,
    //   alphabetsOnly : /([a-zA-Z])+/,
    //   numeric : /([0-9])+/,
    //   phoneNo : /^[0-9a-zA-Z+.()\-;\s]+$/
    // };
    // this.$.requiredMixins  = {};
    // this.$.requiredServices = {};
    var self = this;
    this.time = function(fn) {
      if(this.config.performance) {
        var index;
        if((index = consoleTime.indexOf(fn)) != -1) {
          consoleTime.splice(index,1);
          console.timeEnd(fn);
        } else {
          consoleTime.push(fn)
          console.time(fn);
        }
      }
    }

    // this.arrayUtils = arrayUtils;
    // this.objectUtils = objectUtils;
    // this.Globals.set = function(){
    //   return globalsSet.apply(self ,arguments);
    // }
    // this.Globals.get = function(){
    //   return globalsGet.apply(self ,arguments);
    // }
    // if(Lyte._component.init){
    //   Lyte._component.init(this);
    // }
    // if(config.compiler){
    //   config.compiler.compiler(this);
    // }
    ;(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__._lyteInit)(Lyte, this);
    this.Globals._name = "Globals";
    _Utils_js__WEBPACK_IMPORTED_MODULE_3__.Utils.addMethods([this.Globals])

    // if(config && config.engines){
    //   for(var engine in config.engines){
    //     var dependencies = config.engines[engine];
    //     if(dependencies.dependencies.services){
    //       __servicesMap[engine] = dependencies.dependencies.services;
    //     }
    //   }
    // }

    // if(type == 'engine' && name){
    //   if(__servicesMap[name]){
    //     __servicesMap[name].forEach(function(itm){
    //       if(config.dependencies && (engServ = config.dependencies.services)){
    //         if(itm && typeof itm == 'object'){
    //           for(var key in itm){
    //             if(engServ.includes(key)){
    //               if(__instances.app.registeredServices.hasOwnProperty(itm[key])){
    //                 self.registeredServices[itm[key]] = __instances.app.registeredServices[itm[key]]
    //               }
    //               // else{
    //               //   self.$.requiredServices(key,itm[key],callback.bind(self));
    //               // }
    //             self.toBeInjectedServices[key] = itm[key];
    //               if(!__enginesMap.has(itm[key])){
    //                 __enginesMap.set(itm[key],[]);
    //               }
    //               __enginesMap.get(itm[key]).push(self.name);
    //             }
    //           }
    //         }else if(itm){
    //           if(engServ.includes(itm)){
    //             if(__instances.app.registeredServices.hasOwnProperty(itm)){
    //               self.registeredServices[itm] = __instances.app.registeredServices[itm]
    //             }
    //             // else{
    //             //   self.$.requiredServices(itm,itm,callback.bind(self));
    //             // }
    //             self.toBeInjectedServices[itm] = itm;
    //             if(!__enginesMap.has(itm)){
    //               __enginesMap.set(itm,[]);
    //             }
    //             __enginesMap.get(itm).push(self.name);
    //             }
    //           }
    //         }
    //     })
    //   }
    // }

    // this.__lyteRegisteredEvents = {};

    this.addEventListener("navigationStart", function(obj){
      var trans = obj.nextTrans;
      if(trans && obj.prevTrans){
          if(window.event && /^(click|dblclick|mouseover|mouseout|mousemove|mousedown|mouseup|contextmenu|keydown|keyup|keypress|submit|reset|focus|blur|input|change|select|load|resize|scroll|unload|beforeunload|DOMContentLoaded|readystatechange|touchstart|touchmove|touchend|touchcancel|play|pause|ended|volumechange|durationchange|ratechange|dragstart|drag|dragenter|dragleave|dragover|drop|dragend)$/g.test(window.event.type)){
              trans.ev = window.event;
              if(obj.prevTrans.ev){
                delete obj.prevTrans.ev;
              }
          }
          else if((obj.prevTrans.state == 409 || obj.prevTrans.state == 308) && obj.prevTrans.ev){
            trans.ev = obj.prevTrans.ev;
            delete obj.prevTrans.ev;
        }
      }
    });

    this.addEventListener("afterRouteNavigation", function(obj){
        if(obj && obj.trans){
            var mp = window.__transXHRMap;
            if(obj.trans.state == 409 || obj.trans.state == 308){
                if(mp){
                    var mpObj = mp.get(obj.trans);
                    if(mpObj){
                        removeStateFromMap(mpObj.XHR, mpObj.currentAction.type, mpObj.currentAction.target);
                        mp.delete(obj.trans);
                    }
                }
            }
            else if(obj.trans.state == 200){
                mp ? mp.delete(obj.trans) : undefined;
                obj.trans.ev ? delete obj.trans.ev : undefined;
            }
        }
    });

    this.addEventListener("afterRouteTransition",function(obj){
      if(false) {}
    })

    this.addEventListener("beforeRouteNavigation", function(obj){
        if(obj && obj.prevTrans && obj.prevTrans.nested){
            obj.trans.ev = obj.prevTrans.ev;
            obj.trans.fromPrevTrans = true; // temp check
        }
    });

    this.includes = function(modules) {
      for(var module in modules) {
        var mod = this[module] = modules[module];
        mod.lyteInit ? mod.lyteInit(this) : undefined;
      }
    }
    // this.Security = {};
    // this.Security.$scp = this;
    // this.Security.createSanitizer = Lyte.Security.createSanitizer;
    // addToInstance(this);
    // window.Lte = Lyte.$scp[type][this.name] = this;
    //window.Lte = Lyte.$scp[type][this.name] = this;
    // if(__instances.app && false) { /* remove this code. Move this to component module */
    //   for(var compName in __globalElements.Component.registeredComponents){
    //     __componentsMap[compName] = {
    //           'is' : __instances.app.is,
    //           'name' : __instances.app.name
    //     };
    //   }
    // }

    // if(false) { /* check code to move to compoennt module*/
    //   this.Component._registeredComponents = Object.assign(this.Component._registeredComponents , __globalElements.Component._registeredComponents);
    //   this.Component.registeredComponents = Object.assign(this.Component.registeredComponents , __globalElements.Component.registeredComponents);
    //   this.Component.registeredHelpers = Object.assign(this.Component.registeredHelpers , __globalElements.Component.registeredHelpers);
    //   this.Component.customPropRegex =  __globalElements.Component.customPropRegex;
    //   this.Component.customPropHandlers = Array.from(__globalElements.Component.customPropHandlers);
    // }
    // this.$.requiredMixins.component = Lyte.Component.requiredMixins.component;
    // this.Security = {};
    // this.Security.$scp = this;
    // this.Security.createSanitizer = Lyte.Security.createSanitizer;

    if(config && config.init){
      config.init.apply(this);
    }
    Object.defineProperty(this, "__lyte", {
      enumerable : false, 
      writable : true, 
      value : {"lookupMap" : new Map()}
    });
    (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.extendEventListeners)(this.__lyte.lookupMap);
    __setCurrentContext(this);
    (0,_service__WEBPACK_IMPORTED_MODULE_0__.__handleLookups)([_Utils_js__WEBPACK_IMPORTED_MODULE_3__.Utils], this, this);
    var lookups = this.lookups();
    // if(Array.isArray(lookups)){
    //   lookups.unshift(Utils);
    // }
    // else{
    //   lookups = [Utils];
    // }
    (0,_service__WEBPACK_IMPORTED_MODULE_0__.__handleLookups)(lookups, this, this);
    __setCurrentContext(undefined)   
    // if(Lyte.instantiateComponent){
    //   Lyte.instantiateSecurity(this);
    // }
    // if(Lyte._component.didConnect){
    //   Lyte._component.didConnect(this);
    // }
    ;(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__._lyteDidConnect)(Lyte, this);
  }
  updateMixinsInApp(){
    var hash = this.constructor._hash;
    if(hash){
      var mObj = _Mixin_js__WEBPACK_IMPORTED_MODULE_4__.Mixin.registeredMixin[hash];
      if(mObj){
        for(var key in mObj){
          let mixinCls = mObj[key];
          if(this.constructor._hash == mixinCls._refHash){
            this.registeredMixins[mixinCls.name] = mixinCls;
          }
        }
      }
    }
  }
  static isEntity(obj){
    (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(obj);
  }
  get __isApp() {
    return true;
  }
}

Lyte._instances = [];

var fnProto = Function.prototype;
if(!fnProto.on){
    fnProto.on = function(){
        Lyte.warn("'.on()' method with the argument '" + arguments[0] + "' cannot be executed outside component scope.");
        return { "type": "callBack", "value": this.type === "observer" ? this.value : this, "properties": arguments, "observes": this.type === "observer" ? this : undefined };
    };
}
if(!fnProto.observes){
    fnProto.observes = function(){
        Lyte.warn("'.observes()' method with the arguments '" + arguments[0] + "' cannot be executed outside component scope.");
        return { "type": "observer", "value": this, "properties": arguments, "on": Lyte._onObj, "lyteOn": Lyte._onObj };
    };
}
if(!fnProto.computed){
    fnProto.computed = function(){
        Lyte.warn("'.computed()' method with the arguments '" + arguments[0] + "' cannot be executed outside component scope.");
        return { "type": "computed", "value": this, "properties": arguments };
    };
}
Lyte._onObj = function(){
  return {"type": "callBack", "value":(this.type === "observer") ? this.value:this , "properties":arguments, "observes":(this.type === "observer" ? this: undefined)}
}
Lyte._observesObj = function() {
    return {"type" : "observer", "value" : this, "properties" : arguments, "on": Lyte._onObj, "lyteOn" : Lyte._onObj}
}
Lyte._computedObj = function() {
    return {"type" : "computed", "value" : this, "properties" : arguments}
}
Lyte._preRegister = function(){
  Lyte._actualFnProtoOn = Function.prototype.on;
  Lyte._actualFnProtoObserves = Function.prototype.observes;
  Lyte._actualFnProtoComputed = Function.prototype.computed;
  let fnProto = Function.prototype;
  fnProto.on = fnProto.lyteOn = Lyte._onObj;
  fnProto.observes = fnProto.lyteObserves = Lyte._observesObj;
  fnProto.computed = fnProto.lyteComputed = Lyte._computedObj;
}
Lyte._postRegister = function(){
  let fnProto = Function.prototype;
  fnProto.on = Lyte._actualFnProtoOn;
  fnProto.observes = Lyte._actualFnProtoObserves;
  fnProto.computed = Lyte._actualFnProtoComputed;
}

Object.defineProperty(Lyte, "_singleTonLookupMap", {
  enumerable : false, 
  writable : true, 
  value : new Map()
});
(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.extendEventListeners)(Lyte._singleTonLookupMap);
// Lyte.prototype.arrayUtils = function(){
//   if(this.$.modules.component && this.$.modules.component.length){
//     let lc = this.$.modules.component[0]._getLyteComponent();
//     return lc.aF.apply(lc, arguments);
//   }else{
//     this.error("arrayUtils will be supported only if component registry is imported in the app");
//   }
// }
// Lyte.prototype.objectUtils = function(){
//   if(this.$.modules.component && this.$.modules.component.length){
//     let lc = this.$.modules.component[0]._getLyteComponent();
//     return lc.oF.apply(lc, arguments);
//   }else{
//     this.error("objectUtils will be supported only if component registry is imported in the app");
//   }
// }
(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.extendEventListeners)(Lyte);
// Logger.addEventListener("error", function(){  
//   var arr = Array.from(arguments);
//   if (Lyte.onerror) {
//     Lyte.onerror.apply(Lyte, arr);
//   }
//   if(Lyte.triggerEvent){
//     arr.unshift("error");
//     Lyte.triggerEvent.apply(Lyte, arr);
//   }
// });

window.addEventListener("getLyteIns", function(ev){
  if(ev && ev.detail && ev.detail.init){
    ev.detail.init(Array.from(Lyte._instances));
  }
});
// Lyte.prototype.Compile = {};
window.LyteCls = Lyte;/* global lyte class */
Lyte.error = _lyte_error__WEBPACK_IMPORTED_MODULE_5__.Logger.error.bind(_lyte_error__WEBPACK_IMPORTED_MODULE_5__.Logger);
Lyte.warn = _lyte_error__WEBPACK_IMPORTED_MODULE_5__.Logger.warn.bind(_lyte_error__WEBPACK_IMPORTED_MODULE_5__.Logger);
Lyte.errorCodes = _lyte_error__WEBPACK_IMPORTED_MODULE_5__.Logger.errorCodes;
Lyte.browser = {};
Lyte._component = {};
Lyte.appList = [];
Lyte._setDefaultApp = function(appClass){
  Lyte._defaultApp = appClass;
}
Lyte._setDefaultAppIns = function(appIns){
  Lyte._defaultAppIns = appIns;
}
Lyte._getDefaultApp = function(){
  return Lyte._defaultAppIns;
}
Lyte._getDefaultAppIns = function(){
  return Lyte._defaultAppIns;
}
var userAgent = navigator.userAgent;
//temporary fix for IE 11
if (userAgent.match(/rv:11/)) {
  Lyte.browser.ie = true;
  window.action = function () {
    return;
  };
}
if (userAgent.match('Edge')) {
  var s = createElement("div");
  s.innerHTML = "<template><div>c</div></template>";
  if (s.querySelector("template").childNodes.length) {
    Lyte.browser.ie = true;
  } else {
    Lyte.browser.edge = true;
  }
  s.remove();
}

Lyte.reg = function(fn,options) {
  let type = options.type;
  let name = options.name;
  if(Lyte.$scp[type][name] && Lyte.$sscp[type][name]){
    fn(Lyte.$scp[type][name],Lyte.$sscp[type][name]);
  }
  else{
    Lyte.$scp[type][name] = new Lyte(type,name);
    Lyte.$sscp[type][name] = new Lyte.Store();
    fn(Lyte.$scp[type][name],Lyte.$sscp[type][name]);
  }
}
Lyte.$scp = {app : {}, addon : {}, subApp : {}};
Lyte.$sscp = {app : {},subApp : {}}
// Lyte.__lyteRegisteredEvents = {};
// Lyte.addEventListener = addEventListener;
// Lyte.removeEventListener = removeEventListener;
// Lyte.triggerEvent = triggerEvent;
Lyte.toBeRegistered = [];
Lyte.nestScp = {};
Lyte.nestScpId = 1;
Lyte.addons = {};
// Lyte.registeredCustomComponent = {};
// Lyte.$ = {
//   assetsDiv : document.createElement("div"),
//   shadowDiv : document.createElement("div")
// }
// Lyte.$.assetsDiv.setAttribute("id", "lyteAssetsDiv");
// Lyte.$.shadowDiv.setAttribute("id", "lyteShadowDiv");

Lyte.domContentLoaded = function(callback) {
  if(d.readyState === "complete" || d.readyState === "interactive") { 
    callback();
  } else {
    window.addEventListener('DOMContentLoaded', function() {
      callback();
    });
  }
}

// Lyte.createApplication = function(name, config){
//   var ins = new Lyte("app", name, config);
//   setTimeout(function() {
//     config.includes.forEach(function(module) {
//       module.init && module.init(ins);
//     });
//   },0)
//   if(Lyte.Store) {
//     var sins = new Lyte.Store();
//     Lyte.$sscp.app[name] = sins;
//   }
//   // window.Lte = Lyte.$scp.app[name] = ins;
//   return ins;
// }

// Lyte.createEngine = function(name, config){
//   var ins = new Lyte("engine", name, config);
//   // var sins = new Lyte.Store();
//   // Lyte.$sscp.engine[name] = sins;
//   Lyte.$scp.engine[name] = ins;
//   return ins;
// }

// Lyte.createAddon = function(name, config){
//   var ins = new Lyte("addon", name, config);
//   Lyte.$scp.addon[name] = ins;
//   return ins;
// }

// Lyte.prototype.types = ["string", "object", "number", "boolean", "array"];

// Lyte.prototype.deepCopyObject = function(obj){
//   return copyObject(obj);
// }

// Object.defineProperty(Lyte, 'debug', {
//   set : function(data) {
//     Lyte._debug = Lyte.prototype.debug = data;
//     return data;
//   },
//   get : function() {
//     return Lyte._debug;
//   }
// });

// Lyte.prototype.log = function (text, src, color) {
//   if (this.config.debug) {
//       if(color) {
//           console.log("%c" + text,'color:' + color);
//       } else {
//         console.log(text);      
//       }
//   }
// };

// Lyte.prototype.isComponent = function(object) {
//   if(object && object.$node && object.__data) {
//     return true;
//   }
//   return false;
// }
// Lyte.prototype.Transform = {};
// Lyte.prototype.prop = function(type, opts){
//   var obj = {};
//   obj.type = type;
//   if(opts == undefined){
//     opts = {};
//   }
//   // if(this.types.indexOf(type) == -1 && !this.Transform.hasOwnProperty(type)){
//   //   throw new Error("Not a valid field type - "+type);
//   // }
//   Object.assign(obj,opts);
//   return obj;
// }

// Lyte.prototype.one = function(name,opts){
//   return defineRelation(name,"belongsTo",opts);
// }

// Lyte.prototype.many = function(name,opts){
//   return defineRelation(name,"hasMany",opts);
// }

// Lyte.prototype.registerDataType = function(fieldTypeName, properties){
//   var exts = "extends";
//   if(this.Transform.hasOwnProperty(fieldTypeName)){
//     this.error("Custom Field Type - "+fieldTypeName+" -  already exists.");
//     return;
//   }
//   if(properties[exts] == undefined || this.types.indexOf(properties[exts]) == -1){
//     this.error("Not a valid field type - "+properties[exts]);
//     return;
//   }
//   this.Transform[fieldTypeName] = properties;
// }

// Lyte.prototype.registerPattern = function(patternName, pattern){
//   this.patterns[patternName] = pattern;
// }

// Lyte.prototype.injectResources = function (files, every, completed, options) {
//   var successFiles = [],
//   errorFiles = [],
//   scope = this;
//   every = every || function () {};
//   completed = completed || function () {};
//   return new Promise(function (resolve,reject) {
//     processRequirements(files, function () {
//       if (options && options.defer) {
//         options.defer({
//           injectJS: injectJS,
//           files: files,
//           errorFiles: errorFiles
//         });
//         resolve();
//       } else {
//         injectJS(files, function () {
//           completed(successFiles, errorFiles);
//           if(errorFiles.length) {
//               reject(successFiles, errorFiles);
//             } else {
//               resolve(successFiles, errorFiles);
//             }
//         });
//       }
//     }.bind(this));
//   });

//   function injectJS(files, resolve, execFiles) {
//     execFiles = execFiles || []
//     if (!files) {
//       resolve(successFiles, errorFiles);
//     } else {
//       if (!Array.isArray(files)) {
//         files = [files];
//       }
//       if (!files.length) {
//         resolve(successFiles, errorFiles);
//       }
//       var len = -files.length;
//       files.forEach(function (file) {
//         if (typeof file == "string") {
//            var fileSplit = file.split('.'),
//           type = fileSplit[fileSplit.length - 1];
//           if (type && type == "js" && execFiles.indexOf(file) == -1) {
//             execFiles.push(file);
//             createScript(file, function () {
//               loaded();
//             });
//           } else {
//             loaded();
//           }
//         } else if (Array.isArray(file)) {
//           new Promise(function (r) {
//             injectJS(file, r);
//           }).then(function () {
//             loaded();
//           });
//         } else {
//           len--;
//           new Promise(function (r) {
//             injectJS(file.parent, r);
//           }).then(function () {
//             new Promise(function (r) {
//               injectJS(file.child, r);
//             }).then(function () {
//               loaded();
//             });
//             loaded();
//           });
//         }
//       });
//     }

//     function loaded() {
//       len++;
//       if (len == 0) {
//         resolve(successFiles, errorFiles);
//       }
//     }
//   }

//   function createScript(file, resolve) {
//     var ev = scope.injectResources.respObj[file];
//     if (!scope.injectResources.availableTags[file] || scope.injectResources.availableTags[file].tag.tagName == "LINK") {
//       var tag = document.createElement('script');
//       tag.setAttribute('type', "text/javascript");
//       ev.getAttributeNames().forEach(function (attr) {
//         if (["href", "as", "rel"].indexOf(attr) == -1) {
//           tag.setAttribute(attr, ev.getAttribute(attr));
//         }
//       });
//       tag.setAttribute('src', file);
//       tag.onerror = tag.onload = function(event) {
//         if (event.type == "error") {
//           errorFiles.push(event)
//         } else {
//           successFiles.push(event)
//         }
//         scope.injectResources.availableTags[file].tag.remove();
//         scope.injectResources.availableTags[file] = { tag: tag, event: { type: event.type == "error" ? "error" : "load"} };
//         resolve();
//       }
//       Lyte.$.assetsDiv.appendChild(tag);
//     } else {
//       resolve();
//     }
//   }

//   function processRequirements(files, resolve) {
//     if (!files) {
//       resolve();
//     } else {
//       if (!Array.isArray(files)) {
//         files = [files];
//       }
//       if (!files.length) {
//         resolve();
//       }
//       var len = -files.length;
//       files.forEach(function (file) {
//         if (typeof file == "string") {
//           requestFile.call(scope, file, scope.injectResources.availableTags[file], function () {
//             loaded();
//           });
//         } else if (Array.isArray(file)) {
//           new Promise(function (r) {
//             processRequirements(file, r);
//           }).then(function () {
//             loaded();
//           });
//         } else {
//           len--;
//           new Promise(function (r) {
//             processRequirements(file.parent, r);
//           }).then(function () {
//             loaded();
//           });
//           new Promise(function (r) {
//             processRequirements(file.child, r);
//           }).then(function () {
//             loaded();
//           });
//         }
//       });
//     }

//     function loaded() {
//       len++;
//       if (len == 0) {
//         resolve();
//       }
//     }

//     function requestFile(file, cached, resolve) {
//       if(this.$.reqFiles[file]) {
//         this.$.reqFiles[file].push(resolve);
//       } else {
//         var scope = this;
//         this.$.reqFiles[file] = [resolve];
//         if (cached && cached.event.type != "error") {
//           if (this.removeFromCache.arr.indexOf(file) != -1) {
//             this.removeFromCache.arr.splice(scope.removeFromCache.arr.indexOf(file), 1);
//           }
//           fileLoaded.call(cached.tag, file, cached.event, true);
//           resolve();
//         } else {
//           makeRequest(file, function (event) {
//             scope.injectResources.respObj[file] = this;
//             scope.$.reqFiles[file].forEach(function (resolve) {
//               resolve();
//             });
//             // filesObj[file] = this;
//             fileLoaded.call(this, file, event);
//             every.call(this, event);
//           });
//         }
//       }
//     }

//     function fileLoaded(file, event, cached) {
//       delete scope.$.reqFiles[file];
//       if (!cached) {
//         if (scope.injectResources.availableTags[file]) {
//           scope.injectResources.availableTags[file].tag.remove();
//           delete scope.injectResources.respObj[file];
//         }
//         this.onerror = this.onload = undefined;
//         scope.injectResources.availableTags[file] = { tag: this, event: { type: event.type } };
//       }
//     }
//   }

//   function makeRequest(file, callBack) {
//     var tag,
//         ev = every.internal || {},
//         fileSplit = file.split('.'),
//         type = fileSplit[fileSplit.length - 1];
//     ev.file = file;
//     if (fileSplit.length == 1) {
//       Lyte.error('Type of file is not specified in injectResources.');
//       return;
//     }
//     tag = document.createElement('link');
//     tag.setAttribute('href', file);
//     ev.tag = tag;
//     if (type == 'css') {
//       tag.setAttribute('type', "text/css");
//       tag.setAttribute('rel', "stylesheet");
//       tag.onerror = tag.onload = function (event) {
//         // if (event.type == "error") {
//         //   errorFiles.push(event);
//         // } else {
//         //   successFiles.push(event);
//         // }
//         callBack.call(this, event);
//       };
//     } else {
//       tag.setAttribute('as', "script");
//       tag.setAttribute('rel', "preload");
//       tag.onerror = tag.onload = function (event) {
//         // if (event.type != "error") {
//         //   tag.status = 200;
//         // }
//         callBack.call(this, event);
//       };
//     }
//     Lyte.triggerEvent("onBeforeInject", ev);
//     Lyte.$.assetsDiv.appendChild(tag);
//   };
// };

// if(Lyte.browser.ie) { //remove no ie support // af
//   Lyte.prototype.injectResources = function (files, every, completed) {
//     var successFiles = [],
//     errorFiles = []; 
//     every = every || function() {};
//     completed = completed || function() {};
//     return new Promise(function(resolve) {
//       processRequirements(files, resolve);   
//     }).then(function() {
//       completed(successFiles,errorFiles);  
//     });

//     function processRequirements(files, resolve) {
//       if(!files) {
//         resolve();
//       } else {
//         if(!Array.isArray(files)) {
//           files = [files];
//         }
//         if(!files.length) {
//           resolve();
//         }
//         var len = -(files.length);
//         files.forEach(function(file) {
//           if(typeof file == "string"){
//             requestFile.call(scope,file, scope.injectResources.availableTags[file], function() {
//               loaded();
//             });  
//           } else if(Array.isArray(file)) {
//             new Promise(function(r){
//               processRequirements(file, r);
//             }).then(function(){
//               loaded();
//             })
//           } else {
//             new Promise(function(r){
//               processRequirements(file.parent, r);
//             }).then(function(){
//               new Promise(function(r1){
//                 processRequirements(file.child, r1)
//               }).then(function(){
//                 loaded();
//               })
//             })
//           }
//         })
//       }

//       function loaded() {
//         len++;
//         if(len == 0) {
//           resolve();
//         }
//       }

//       function requestFile(file,cached,resolve) {
//         if(this.$.reqFiles[file]) {
//           this.$.reqFiles[file].push(resolve)
//         } else {
//           this.$.reqFiles[file] = [resolve];
//           if(cached && cached.event.type != "error") {
//             if(this.removeFromCache.arr.indexOf(file) != -1) {
//               this.removeFromCache.arr.splice(this.removeFromCache.arr.indexOf(file),1);
//             }
//             fileLoaded.call(cached.tag,cached.event,true);
//             resolve();
//           } else {
//             makeRequest(file,
//               function(event) {
//                 this.$.reqFiles[file].forEach(function(resolve) {
//                   resolve();
//                 });
//                 fileLoaded.call(this,event);
//                 every.call(this,event);
//               }
//             );
//           }
//         }
//       }

//       function fileLoaded(event,cached) {
//         var file = this.getAttribute('src') || this.getAttribute('href');
//         delete scope.$.reqFiles[file];
//         if(!cached) {
//           if(scope.injectResources.availableTags[file]) {
//             scope.injectResources.availableTags[file].tag.remove();
//           }
//           this.onerror = this.onload = undefined;
//           scope.injectResources.availableTags[file] = {tag : this, event : {type : event.type}};
//         }
//       }
//     }

//     function makeRequest(file,callBack) {
//       var tags = { ".js": 'script', ".css" : 'link' },
//       type = file.match(/\.[a-zA-Z]+(?=\?|$)/),
//       tag = document.createElement(tags[type]);
//       if (!type) {
//         Lyte.error('Type of file is not specified in injectResources.');
//         return;
//       } else if (type == '.css') {
//         tag.setAttribute('href', file);
//         tag.setAttribute('type', "text/css");
//         tag.setAttribute('rel', "stylesheet");
//       } else {
//         tag.setAttribute('src', file);
//       }
//       tag.onerror = tag.onload = function (event) {
//         if(event.type == "error") {
//           errorFiles.push(event);  
//         } else {
//           successFiles.push(event);
//         }
//         if(callBack) {
//           callBack.call(this,event);
//         }
//       };
//       var ev = every.internal || {};
//       ev.file = file;
//       ev.tag = tag;
//       Lyte.triggerEvent("onBeforeInject", ev);
//       Lyte.$.assetsDiv.appendChild(tag);
//     };
//   };
// }

// Lyte.prototype.injectResources.availableTags = [];
// Lyte.prototype.injectResources.respObj = [];

// Lyte.prototype.removeFromCache = function(arr) {
//   var scope = this;
//   this.removeFromCache.assign.call(this,arr);
//   if(this.removeFromCache.arr.length) {
//     this.removeFromCache.arr.forEach(function(file) {
//       if(scope.injectResources.availableTags[file]) {
//         scope.injectResources.availableTags[file].tag.remove();
//         delete scope.injectResources.availableTags[file];  
//       }
//     });
//     this.removeFromCache.arr = [];
//   }
// }

// Lyte.prototype.removeFromCache.arr = [];

// Lyte.prototype.removeFromCache.assign = function(arr) {
//     arr = arr == "*" ? Object.keys(this.injectResources.availableTags) : (Array.isArray(arr) ? arr : [arr]); 
//     this.removeFromCache.arr = this.removeFromCache.arr.concat(arr);
//     return;
// }

// Lyte.prototype.triggerEvent = triggerEvent;

// Lyte.prototype.addEventListener = addEventListener;

// Lyte.prototype.removeEventListener = removeEventListener; 

// Lyte.prototype.extendEventListeners = extendEventListeners;

// Lyte.prototype.resolvePromises = function(promises) {
//   return new Promise(function(res, rej) {
//     resolvePromises(promises).then(function(data) {
//       res(data);
//     },function(data) {
//       rej(data);
//     })
//   })
// }

// Lyte.createCustomElement = function (customElementName, definition) {
//   var constructor = definition.constructor;
//   delete definition.constructor;
//   var connectedCallback = definition.connectedCallback;
//   delete definition.connectedCallback;
//   var attributeChangedCallback = definition.attributeChangedCallback;
//   delete definition.attributeChangedCallback;
//   var disconnectedCallback = definition.disconnectedCallback;
//   delete definition.disconnectedCallback;

//   this.defProperty = function(obj, key, val) {
//     var obj1 = {};
//     if(val.get) {
//       obj1.get = val.get
//     }
//     if(val.set) {
//       obj1.set = val.set
//     }
//     Object.defineProperty(obj, key, obj1);
//   }
//   class classDef extends HTMLElement {
//     constructor() {
//       super();
//       if(this.isNewComp(customElementName)){
//         this.executeCallbacks(constructor,arguments);
//       }else{
//         this.__lyteIgnore = true;
//       }
//     }

//     connectedCallback(){
//       let _LC = Lyte._instances[0].$.modules.component[0]._getLyteComponent();//temp fix
//       if(!_LC.ignoreDisconnect && !this.__lyteIgnore) {
//         this.executeCallbacks(connectedCallback,arguments);
//         this.setAttribute("lyte-rendered-ce", "");
//       }
//     }
//     attributeChangedCallback(){
//       if(!this.__lyteIgnore) {
//         this.executeCallbacks(attributeChangedCallback,arguments);
//       }
//     }
//     disconnectedCallback(){
//       let _LC = Lyte._instances[0].$.modules.component[0]._getLyteComponent();//temp fix
//       if(!_LC.ignoreDisconnect && !this.__lyteIgnore) {
//         this.executeCallbacks(disconnectedCallback,arguments);
//       }
//     }
//     executeCallbacks(callBack,argArr){
//       if(callBack) {
//         callBack.apply(this, Array.from(argArr));
//       }
//     }
//     isNewComp(customElementName){
//       if(this.hasAttribute("lyte-rendered-ce")) {
//         return false;
//       }
//       return true;
//     }
//   }
//   var staticDef = definition.static;
//   if(staticDef) {
//     for(var key in staticDef) {
//       if(typeof staticDef[key] === "object") {
//         this.defProperty(classDef, key, staticDef[key]);
//       } else {
//         Object.defineProperty(classDef, key, {
//           value : staticDef[key]
//         });
//       }
//     }
//     delete definition.static;
//   }
//   for(var key in definition) {
//     if(typeof definition[key] === "object") {
//       this.defProperty(classDef.prototype, key, definition[key]);
//     } else {
//       Object.defineProperty(classDef.prototype, key, { writable: true, value : definition[key]});
//     }
//   }
//   definition.static = staticDef;
//   definition.constructor = constructor;
//   definition.connectedCallback = connectedCallback;
//   definition.attributeChangedCallback = attributeChangedCallback;
//   definition.disconnectedCallback = disconnectedCallback;
//   if (document.readyState === "complete" || document.readyState === "interactive") {     
//     // document is already ready to go
//     customElements.define(customElementName,classDef);
//   }
//   else{
//     // ***
//     //Change the Lyte to instance
//     Lyte.toBeRegistered.push({name:customElementName, def: classDef});
//   }
//   Lyte.registeredCustomComponent[customElementName] = classDef;
// }

// function domContentLoaded1() {
// document.head.appendChild(Lyte.$.assetsDiv);
// document.head.appendChild(Lyte.$.shadowDiv);
// let comp = Lyte.toBeRegistered;    
// if(comp && comp.length){    
//     for(let j=0; j<comp.length;j++){
//         customElements.define(comp[j].name, comp[j].def);    
//     }    
//     Lyte.toBeRegistered = [];    
// }
// }

// if(document.readyState === "complete" || document.readyState === "interactive") {
//     domContentLoaded1();
// } else {
//     document.addEventListener("DOMContentLoaded", function(e){
//         domContentLoaded1();
//     },true);
// };

//@3055
// var XHRSend = XMLHttpRequest.prototype.send;
// XMLHttpRequest.prototype.send = function(){
//     var event = window.event;  
//     var type, target = event ? event.target : undefined; 
//     let regIns = getConfig("stateHandling",true)
//     if(getConfig("stateHandling")){
//         if(event){
//             type = event.type;
//             /^(click|dblclick)$/.test(type) && target && target.getAttribute && target.getAttribute("lyte-state-handling") != "false" ? addStateToMap(type,target,this) : undefined;
//         }
//         else{
//             var router = Lyte && Lyte.Router ? Lyte.Router.getRouteInstance() : undefined;
//             if(router){
//                 var currentAction = router.transition ? router.transition.ev : undefined;
//                 if(currentAction && currentAction.target && currentAction.target.getAttribute && currentAction.target.getAttribute("lyte-state-handling") != "false"){
//                     var mp = window.__transXHRMap = window.__transXHRMap || new Map();
//                     mp.set(router.transition, {currentAction : currentAction, XHR:this});
//                     addStateToMap(currentAction.type, currentAction.target, this);
//                 }
//             }
//         }
//     }
//     XHRSend.apply(this, arguments);
// }

// Lyte.prototype.setState =   function(str){
//   if(!str){
//     console.error("Please provide a state name");
//   }
//   var evnt = window.event;
//   if(/^(click|dblclick)$/.test(evnt.type)){
//       var target = evnt.target;
//       if(getConfig("stateHandling") == true && target && target.getAttribute && target.getAttribute("lyte-state-handling") != "false"){
//           var state = target.getAttribute("lyte-state");
//           if(!state){
//               var mp = window.__stateMap = window.__stateMap || new Map();
//               var mpobj = mp.get(str);
//               if(!mpobj){
//                   var obj = addStateToMap(evnt.type, target, undefined, str);
//                   mp.set(str, obj);
//               }
//               else{
//                   console.error("There is already a open state by the name",str);
//               }
//           }
//       }        
//   }
// }

// Lyte.prototype.removeState = function(str){
//     if(!str){
//         console.error("Please provide a state name");
//     }
//     var mp = window.__stateMap;
//     if(mp){
//         var obj = mp.get(str);
//         if(obj){
//             mp.delete(str);
//             removeStateFromMap(str, obj.event, obj.target);
//         }
//     }
// }

// Lyte.prototype.setConfig = function(key, value){
//     var configObj = window.__config = window.__config || {};
//     configObj[key] = value;
// }

// Lyte.prototype.getConfig = getConfig;  @3055


// Lyte.errorCodes = errorCodes;
// Lyte.registerErrorCodes = registerErrorCodes;
// Lyte.getErrorMessage = getErrorMessage;
window.addEventListener("onBeforeInject", function(ev) {
  Lyte.triggerEvent("onBeforeInject",ev.detail, ev);
})






/***/ }),

/***/ 74043124:
/*!**********************************************!*\
  !*** ./node_modules/@slyte/core/src/rsvp.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "resolvePromises": () => (/* binding */ resolvePromises)
/* harmony export */ });
function resolvePromises(promises) {
    if(typeof promises == "string" || promises instanceof Promise) {
        return promises;
    } else {
        if(Array.isArray(promises)) {
        return promiseArray(promises);
        } else if(typeof promises == "object") {
        return promiseHash(promises);
        }    
    }

    function promiseHash(promiseObj) {
        var actPromKeys = [],
        promises = [],
        promiseKeys = Object.keys(promiseObj);
        promiseKeys.forEach(function(key) {
            var value = promiseObj[key];
        if(value instanceof Promise) {
            actPromKeys.push(key)
            promises.push(value);
        }
        });
        if(!promises.length) {
            return Promise.resolve(promiseObj);
        } else {
            var obj = {},promise = new Promise(function(resolve,reject) {
            Promise.all(promises).then(function(data) {
                promiseKeys.forEach(function(promiseKey) {
                if(actPromKeys.indexOf(promiseKey) != -1) {
                    obj[promiseKey] = data[actPromKeys.indexOf(promiseKey)]
                } else {
                    obj[promiseKey] = promiseObj[promiseKey];
                }
                });
            resolve(obj);
            },function(err) {
            reject(err);
            });
        });   
        return promise;
        }
    }
    
    function promiseArray(promiseArray) {
        var array = [],
        hasPromise = false;
        promiseArray.every(function(item,i) {
            if(item instanceof Promise) { 
                hasPromise = true;
                return false;
            }
            return true
        });
        if(!hasPromise) {
            return Promise.resolve(promiseArray);
        }
        var promise = new Promise(function(resolve,reject) {
            Promise.all(promiseArray).then(function(data) {
                promiseArray.forEach(function(key,index){
                    array[index] = data[index];
                });
                resolve(array);
            },function(err) {
                reject(err);
                
            });
        });   
        return promise;
    }
};



/***/ }),

/***/ 76099455:
/*!*************************************************!*\
  !*** ./node_modules/@slyte/core/src/service.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Service": () => (/* binding */ Service),
/* harmony export */   "__checkIfService": () => (/* binding */ __checkIfService),
/* harmony export */   "__getLyte": () => (/* binding */ __getLyte),
/* harmony export */   "__handleLookups": () => (/* binding */ __handleLookups)
/* harmony export */ });
/* harmony import */ var _slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/core/src/lyte.js */ 46823552);
/* harmony import */ var _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @slyte/core/src/lyte-utils */ 60768251);


/*convert to custom class*/
class Service { 
    static actions(arg1) {
      if(super.actions){
        return super.actions(arg1 ? arg1 : {});
      }
      return arg1 ? arg1 : {};
    }
    static methods(arg1) {
      if(super.methods){
        return super.methods(arg1 ? arg1 : {});
      }
      return arg1 ? arg1 : {};
    }
    static observers(arg1) {
      if(super.observers){
        return super.observers(arg1 ? arg1 : {});
      }
      return arg1 ? arg1 : {};
    }
    data(arg1) {
      if(super.data){
        return super.data(arg1 ? arg1 : {});
      }
      return arg1 ? arg1 : {};
    }
    constructor() {
        var context = (0,_slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.__getCurrentContext)();
        // if(context){
        if(context.__isAddon) {
            if(this.__isAddon){
                this.$parent = context;
                this.$app = context.$app;
            }else{
                this.$addon = context;
            }
            if((0,_slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.toLowerCase)(this.constructor.name) !== "utils"){
                this.$utils = context.$utils;
            }
        } else {
            this.$app = context;
            if(this.__isAddon){
                this.$parent = context;
            }
            if((0,_slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.toLowerCase)(this.constructor.name) !== "utils"){
                this.$utils = context.$utils;
            }
        }
        var func = (0,_slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.__getCurrentFunc)();
        var lookupMap;
        if(this.__isAddon){
            Object.defineProperty(this, "__lyte", {
                enumerable : false, 
                writable : true, 
                value : {"lookupMap" : new Map()}
            });
            // lookupMap = this.__lyte.lookupMap;
            (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_1__.extendEventListeners)(this.__lyte.lookupMap);
        }
        // else{
            if(this.$addon){
                lookupMap = this.$addon.__lyte.lookupMap;
            }else if(this.$app){
                lookupMap = this.$app.__lyte.lookupMap;
            }
        // }
        if(func) {
            func(this);
        }
        var oldContext = (0,_slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.__getCurrentContext)();
        if(this.__isAddon) {
            (0,_slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.__setCurrentContext)(this);
        }
        
        if(lookupMap.get(this.constructor)){
            lookupMap.set(this.constructor,this);
        }
        else if(this.constructor.singleTon){
            _slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.Lyte._singleTonLookupMap.set(this.constructor,this);
        }

        var lookups = this.lookups();
        // if(this.$addon){ //commented since lookups returned array - we are not using or holding it for anny purpose
        //     this.$addon.__lyte.lookupMap.lookups = lookups;
        // }else{
        //     this.$app.__lyte.lookupMap.lookups = lookups;
        // }
        __handleLookups(lookups, this.__isAddon ? this : context, this);
        this.__lookups = lookups;
        if(this.__isAddon) {
            (0,_slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.__setCurrentContext)(oldContext);
        }
        // }else{
            // debugger
        // }
    }
    
    lookups() {
        return [];
    }

    onLookup() {
        
    }
}
function __getLyte(service){
    return service.$addon ? service.$addon.__lyte : service.__lyte ? service.__lyte : service.$app.__lyte;
}
function __handleLookups(lookups, app, curr) {
    if(lookups && lookups.length){
        var appLookupMap = app.__lyte.lookupMap;
        var currLookupMap = __getLyte(curr).lookupMap;
        lookups.forEach(function(item) {
            if(!item){
                _slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.Lyte.error("Invalid class/instance passed in "+ curr.constructor.name + "'s lookup hook.")
                return
            }
            if(typeof item == "string") {
                if(curr) {
                    if(item.length){
                        if(appLookupMap.get(item)){
                            curr["$" + item] = appLookupMap.get(item);
                            __callOnLookup(curr["$" + item], curr);
                        }
                        else{
                            var id = app.__lyte.lookupMap.addEventListener(item, function(ins){
                                curr["$" + item] = ins;
                                __callOnLookup(ins, curr);
                                app.__lyte.lookupMap.removeEventListener(id);
                            });
                        }
                    }
                    else{
                        _slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.Lyte.error("Lookup cannot be added for empty(undefined) key");
                    }
                }
            } else {
                if(__checkIfService(item)) {
                    instantiateService(item, app, curr);
                } else if(Object.keys(item).length == 1) {
                    for(var onlyKey in item){
                        var val = item[onlyKey];
                        if(onlyKey.length){
                            if(/^(utils|node|lg|app|addon)$/.test(onlyKey)){
                                _slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.Lyte.error("Lookup cannot be added for the predefined key - "+ onlyKey);
                                return;
                            }
                            let name = "$" + onlyKey;
                            if(__checkIfService(val)) {
                                instantiateService(val, app, curr, name);
                            } else {
                                if(val && typeof val == "object"){
                                    curr[name] = val;
                                    __callOnLookup(val, curr);
                                    if(!appLookupMap.get(onlyKey)){
                                        appLookupMap.set(onlyKey, val); //how singleton af ?
                                        appLookupMap.triggerEvent(onlyKey, val);
                                    }
                                }
                                else if(typeof val == "string"){
                                    if(appLookupMap.get(val)){
                                        curr[name] = appLookupMap.get(val);
                                        __callOnLookup(curr[name], curr);
                                    }
                                    else{
                                        var id = appLookupMap.addEventListener(val, function(ins){
                                            curr[name] = ins;
                                            __callOnLookup(ins, curr);
                                            appLookupMap.removeEventListener(id);
                                        });
                                    }
                                }
                                currLookupMap.set(onlyKey, val);
                            }
                        }
                        else{
                            _slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.Lyte.error("Lookup cannot be added for empty(undefined) key");
                        }
                    }
                }
            }
            
        });
    }
}

function instantiateService(cls, app, curr, name) {
    name = name || ("$" + (0,_slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.toLowerCase)(cls.name));
    let appLookupMap = app.__lyte.lookupMap;
    // let currLookupMap = curr.__lyte.lookupMap;
    let lookupValue = appLookupMap.get(cls);
    if(lookupValue) {
        if(lookupValue instanceof Promise) {
            lookupValue.then(function(val) {
                curr[name] = val;
                __callOnLookup(val, curr);
            });
        } else {
            curr[name] = lookupValue;
            __callOnLookup(lookupValue, curr);
        }
    } else {
        if(cls.singleTon){
            let singleTonclass = _slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.Lyte._singleTonLookupMap.get(cls)
            if(singleTonclass){
                curr[name] = singleTonclass;
                return;
            }else{
                _slyte_core_src_lyte_js__WEBPACK_IMPORTED_MODULE_0__.Lyte._singleTonLookupMap.set(cls,cls);
            }
        }else{
            appLookupMap.set(cls, cls);
        }
        let obj = curr[name] = new cls();
        __callOnLookup(obj, curr);
        appLookupMap.triggerEvent(name, obj);
    }
}
function __checkIfService(item) {
    var isService = false;
    while(item != null) {
        if(item == Service || item.__lyteOrigClass) {
            isService = true;
            break;
        } else {
            item = Object.getPrototypeOf(item);
        }
    }
    return isService;
}

function __callOnLookup(service, module) {
    if(service && service.onLookup) {
        service.onLookup(module);
    }
}



/***/ }),

/***/ 87193305:
/*!***************************************************!*\
  !*** ./node_modules/@slyte/data/src/Connector.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Connector": () => (/* binding */ Connector)
/* harmony export */ });
/* harmony import */ var _slyte_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/core */ 76099455);
/* harmony import */ var _slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @slyte/core/src/lyte-utils.js */ 60768251);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ 84646139);
/* harmony import */ var _dberror_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dberror.js */ 82718186);




/*convert to custom class*/
class Connector extends _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Service {
    constructor(){
        super();
        this.constructor._name = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.dbModName)(this.constructor.name, "Connector");
    }
    static processResponse(db, xhr, type, name, argsObj, urlObj, key, customData, opts){
        return new Promise(function(resolve, reject){
            if(xhr){
                var contentType = xhr.getResponseHeader('content-type'),
                resp,
                isSuccess = xhr && (xhr.status.toString()[0] == "2" || xhr.status.toString()[0] == "3") ? true : false,
                def = db.getSchemaObj(name),
                cresp;
                if(Connector.JSON.test(contentType)){
                    resp = xhr.responseText.length ? JSON.parse(xhr.responseText) : JSON.parse("{}");
                }
                else if(Connector.TEXT.test(contentType)){
                    try {
                        resp = JSON.parse(xhr.responseText);
                    }
                    catch(exp){ 
                        resp = new _dberror_js__WEBPACK_IMPORTED_MODULE_2__.ConnectorError("Cannot parse the data", xhr);
                        isSuccess = false;
                    }
                }
                else if(type !== "triggerAction"){
                    resp = xhr.responseText;
                }
                else{
                    resp = new _dberror_js__WEBPACK_IMPORTED_MODULE_2__.ConnectorError("Not an acceptable content-type: "+contentType, xhr);
                }
                argsObj.payLoad = resp;
                // def = getSchemaObj(db, def);
                var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(
                    db,
                    "connector",
                    def ? def.connector : undefined,
                    Connector.PARSERESPONSE,
                    { argsObj: argsObj, args:[type, name, xhr, resp, urlObj ? urlObj.qP : undefined, key, customData, opts]}
                );
                if(res){
                    cresp = res.data;
                    resp = argsObj.payLoad = cresp;
                }
                if(cresp && cresp instanceof Promise)
                {
                    return cresp.then(function(res){
                        argsObj.payLoad = res;
                        return resolve(res)
                    }, function(res){
                        return reject(res);
                    })
                    // return RESTConnector.handleParseResponsePromise(db,cresp,def,type,key,urlObj,xhr,undefined,undefined,undefined,resolve,reject,opts,argsObj);
                }
                else{
                    if(isSuccess){
                        return resolve(resp)
                    }
                    else{
                        return reject(resp);
                    }
                }

            }
        });
    }

    static sendXHR(db,name,type,key,urlObj,customData,argsObj,opts){
        var xhr = new XMLHttpRequest();
        var prm = new Promise(function(res, rej){
            argsObj.xhr = xhr;
            xhr.open(urlObj.method, urlObj.url, true);
            for(var header in urlObj.headers){
                xhr.setRequestHeader(header, urlObj.headers[header]);
            }
            if(urlObj.data !== undefined && !(urlObj.data instanceof FormData) && ( urlObj.headers && !urlObj.headers.hasOwnProperty("Content-Type") && urlObj.method !== "GET")){
                xhr.setRequestHeader("Content-Type", "application/json");
            }
            xhr.withCredentials = (urlObj.withCredentials)?true:false;
            var sch = db.getSchemaObj(name);
            if(sch && sch.connector){
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db, "connector", sch.connector, /*RESTConnector.PARSEREQUEST*/ "parseRequest", { argsObj: argsObj, args:[type, name, xhr ,urlObj ? urlObj.qP : undefined, key, customData]});
            }
            db.emit("beforeRequest", [xhr, name, type, key, urlObj.qP]);
            xhr.send(urlObj.data);
            xhr.onreadystatechange = function(){
                if(xhr.readyState == 4){
                    db.emit("afterRequest",[xhr, name, type, key, urlObj.qP]);
                    argsObj.status = xhr.status;
                    /*RESTConnector.processResponse*/ Connector.processResponse(db, xhr, type, name, argsObj, urlObj, key, customData, opts).then(function(data){
                        return res({data:data, xhr:xhr});
                    }, function(err){
                        return rej({data:err, xhr:xhr});
                    });
                }
            }
        });
        prm.xhr = xhr;
        return prm;
    }
    static getConnector(db, def, argsObj, defless){
        var defObj = def;
        def = def.def ? def.def : def
        if(defless){
            if(db.Connector.hasOwnProperty(def)){

            }
        }
        else if(def && def.Connector && !(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_3__.isInheritedClass)(def.Connector, db.constructor.ConnectorCls) && typeof def.Connector == "function" ){
            var parent = Object.getPrototypeOf(def.Connector), parentName = parent ? parent.name :undefined, context;
            var connec = def.Connector.apply(def, [argsObj]);
            if(connec){
                db.lyte.scopedInstance(connec, [db], function(ins){
                    defObj.connector = ins;
                }, [db]);
                context = defObj.connector.__type;
                db.connector[context] = db.connector[context] || {};
                db.connector[context][defObj.connector.constructor._name] = defObj.connector;
            }
        }
    }
    static getSerializer(db, def, argsObj){
        var defObj = def;
        def = def.def ? def.def : def
        if(def && def.Serializer && !(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_3__.isInheritedClass)(def.Serializer, db.constructor.SerializerCls) && typeof def.Serializer == "function"){
            var parent = Object.getPrototypeOf(def.Serializer), parentName = parent ? parent.name :undefined, context;
            var serz = def.Serializer.apply(def, [argsObj]);
            if(serz){
                db.lyte.scopedInstance(serz, [db], function(ins){
                    defObj.serializer = ins;
                }, [db]);
                context = defObj.serializer.__type;
                db.serializer[context] = db.serializer[context] || {};
                db.serializer[context][defObj.serializer.constructor._name] = defObj.serializer;
            }
        }
    }
    static getSuccess(db,def,type,key,urlObj,respObj,resolve,reject,response,resObj,from,opts,argsObj){
        var resp = respObj ? respObj.data : response, 
        // req = respObj ? respObj.xhr : undefined, 
        req,
        xhr = respObj ? respObj.xhr : undefined,
        batchIndex, 
        batch, 
        customD = opts.customD, 
        name = def && def._name ? def._name : def,
        status = xhr ? xhr.status : undefined;
        if(from != "idb"){
            var baseCons = def && def.connector ? def.connector.constructor : db.constructor.Connector;
            if(resObj){
                batchIndex = resObj.index;
                batch = resObj.batch;
                argsObj.xhr = req = resObj.resp;
                argsObj.payLoad = resObj.content;
                var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"connector", def.connector, baseCons.PARSERESPONSE , { argsObj: argsObj, args:[type, name, req, resp, urlObj ? urlObj.qP : undefined, key, customD, opts]});
                if(res){
                    resp = res.data;
                }
                if(resp instanceof Promise)
                {
                    return baseCons.handleParseResponsePromise(db,resp,def,type,key,urlObj,xhr,undefined,batchIndex,batch,resolve,reject,opts,argsObj);
                }
                else{
                    argsObj.payLoad = resp;
                }
            }
            // if(req){
                argsObj.payLoad = resp;
            // }
            return baseCons.findParseRequestPromise(db, resp,def,type,key,urlObj,xhr,batchIndex,batch,resolve,opts,argsObj);
        }
        var resArr = xhr ? [resp, xhr.statusText, xhr] : (batchIndex != undefined) ? [resp,"batch",{index:batchIndex,batch:batch}] : from ? [resp, "idb"] : [resp];
        resolve(resArr);
    }
    static getFailure(db,def,type,key,urlObj,respObj,resolve,reject,opts,content,code,argsObj,bObj){
        var customD = opts.customD, 
        name = def && def._name ? def._name : def;
        var xhr = respObj? respObj.xhr : undefined,
        response = respObj ? respObj.data : undefined;
        if(xhr){
            var resp;         
            argsObj.payLoad = response;
            var baseCons = def && def.connector ? def.connector.constructor : db.constructor.Connector;
            var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"connector", def ? def.connector : undefined, baseCons.PARSERESPONSE, { argsObj: argsObj, args:[type, name, xhr, response ,urlObj ? urlObj.qP : undefined, key, customD, opts]});
            if(res){
                resp = res.data;
                argsObj.payLoad = resp;
            }
            if(resp instanceof Promise)
            {
                return baseCons.handleParseResponsePromise(db,resp,def,type,key,urlObj,xhr,undefined,undefined,undefined,resolve,reject,opts,argsObj);
            }
            return reject(xhr);
        }
        else if(content){
            var batch, batchIndex;
            if(bObj){
                batchIndex = bObj.index;
                batch = bObj.batch;
            }
            db.$.batchResponse[batch][batchIndex] = {code:code, status:"requestFailure", data:content};
            return reject({code:code,status:"requestFailure", data:content});
        }
        return reject(respObj.data);
    }
    static handleParseResponsePromise(db,response,def,type,key,urlObj,xhr,partialObj,batchIndex,batch,resolve,reject,opts,argsObj)
    {
        response.then(function(payload){
            argsObj.payLoad = payload;
            var baseCons = def && def.connector ? def.connector.constructor : db.constructor.Connector;
            if(type == "get")
            {
                baseCons.findParseRequestPromise(db, payload,def,type,key,urlObj,xhr,batchIndex,batch,resolve,opts,argsObj);
            }
            else
            {
                baseCons.otherParseRequestPromise(db, payload,def,type,key,urlObj,xhr,partialObj,batchIndex,batch,resolve,reject,opts ? opts.customD : undefined,undefined,argsObj,key);
            }
        },function(payload){	
            reject(xhr);
        });
    }
    static findParseRequestPromise(db, payload,def,type,key,urlObj,xhr,batchIndex,batch,resolve,opts,argsObj){
        var options = Object.assign({},opts);
        delete options.customD;
        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer; 
        var resp = baseSerz.getResponse(db,payload,def,type,key,urlObj,xhr, opts ? opts.customD : undefined, options,argsObj);
        var resArr = xhr ? [resp, xhr.statusText, xhr] : (batchIndex != undefined) ? [resp,"batch",{index:batchIndex,batch:batch}] : [resp];
        resolve(resArr);
    }
    static create(db, name, data, isSingleRecord, customData, qP, mutationName){
        var type= isSingleRecord ? "createEntity": "create", 
        def = db.schema[name], 
        argsObj = { type: type, schemaName : name, queryParams: qP, customData: customData};
        Connector.getConnector(db, def, argsObj);
        Connector.getSerializer(db, def, argsObj);
        return def.connector.constructor.create.apply(def.connector.constructor, arguments);
    }
    static put(db, name, data, record, isSingleRecord,customData, qP, mutationName){
        var def = db.schema[name], 
        bK = def.bK , 
        isComp = def.isComp, 
        type = (isSingleRecord) ? "updateEntity" : "update", 
        key = isSingleRecord ? (isComp && bK ? record[bK] : record.$.pK) : undefined, 
        argsObj = { type: type, schemaName : name, queryParams: qP, customData: customData, key: key};
        Connector.getConnector(db, def, argsObj);
        Connector.getSerializer(db, def, argsObj);
        return def.connector.constructor.put.apply(def.connector.constructor, arguments);
    }
    static del(db, name, data, isSingleRecord, destroy, customData, qP, mutationName){
        var def = db.schema[name], 
        bK = def.bK , 
        isComp = def.isComp, 
        type = destroy || "deleteEntity", 
        key = isSingleRecord ? (isComp && bK ? data[bK] : data.$.pK) : undefined, 
        argsObj = { type: type, schemaName : name, queryParams: qP, customData: customData, key: key};
        Connector.getConnector(db, def, argsObj);
        Connector.getSerializer(db, def, argsObj);
        return def.connector.constructor.del.apply(def.connector.constructor, arguments);
    }
    static otherParseRequestPromise(db,resp,def,type,data,urlObj,xhr,partialObj,batchIndex,batch,resolve,reject,customData,partialRef,argsObj,key){
        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer; 
        var response = baseSerz.genericResponse(db,resp,def,type,data,urlObj,xhr,partialObj,customData,partialRef,argsObj);
        if(batchIndex != undefined){
            db.$.batchResponse[batch][batchIndex] = response;
        }
        if(type != "action" && db.idbIns && def){
            db.idbIns.updateIDB(db,def._name,type,data,customData,urlObj);
        }
        var baseCons = def && def.connector ? def.connector.constructor : db.constructor.Connector;
        if(baseCons.constructor.returnData == "new"){
            var obj = {};
            if(xhr && xhr.status){
                obj.status = xhr.status;
            }
            if(obj.status === 204){
                obj.data = null;
            }
            else{
                obj.data = response;
            }
        }
        resolve(response);
    }
    static handleRequest(db,urlObj,name,data,type,changedData,customData,partialObj,key,actionName, partialRef, argsObj){
        if(urlObj.data && (typeof urlObj.data == "object" || (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_3__.isEntity)(urlObj.data) || Array.isArray(urlObj.data)) && !(urlObj.data instanceof FormData)){
            // urlObj.reqData = Lyte.deepCopyObject(urlObj.data);
            urlObj.data = JSON.stringify(urlObj.data);
        }
        var self = this, xhr, key, def = db.schema[name], prmXhr;;
        var prm = new Promise(function(resolve, reject){
            var baseCons = def && def.connector ? def.connector.constructor : db.constructor.Connector;
            var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer;             
            var processRequest = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getFromCB)(db,"connector", def ? def.connector : undefined, baseCons.PROCESSREQUEST),sendXHR = true;
            var makeBatch = db.$.makeBatch;
            var batchPro = false;
            if(processRequest){
                sendXHR = false;
                var returnPromise = self.callGeneric(db,type,def,urlObj.data,data,customData,urlObj?urlObj.qP:undefined,key,urlObj.url,actionName,urlObj.method,urlObj.headers,argsObj),response;
                if(returnPromise instanceof Promise){
                    batchPro = true;						
                    returnPromise.then(function(resp){
                        resp = (resp == "" ? JSON.parse("{}") : JSON.parse(resp));
                        response = baseSerz.genericResponse(db,resp,def,type,data,urlObj,undefined,partialObj,customData,undefined,argsObj);
                        resolve(response);
                    },function(message){
                        reject(message);
                    });
                }
                else{
                    sendXHR = true;
                }
            }
            if(makeBatch && !batchPro){
                baseCons.constructBatch(db,name,type,key,urlObj,customData).then(function(respObj){
                    var resp = respObj.content; 
                    baseCons.handleSuccess(db, name, type, xhr, data, urlObj, resolve, resp, respObj,undefined,reject,key,customData,actionName,partialRef, argsObj);
                    // resolve(resp);
                },function(resObj){
                    baseCons.handleFailure(db, name, type, xhr, data, urlObj, resolve,resObj.content,undefined,reject,key,customData,resObj.code,actionName, argsObj, resObj);
                });
            }
            else if(sendXHR){
                var argsXHR = [db,name,type,key,urlObj,customData,argsObj];
                var xhrPrm = baseCons.sendXHR.apply(baseCons, argsXHR);
                xhrPrm.then(function(xhrResp){
                    baseCons.handleSuccess(db, name, type, xhrResp, data, urlObj, resolve, undefined, undefined, partialObj,reject,key,customData,actionName,partialRef,argsObj);					
                },function(xhrResp){
                    baseCons.handleFailure(db, name, type, xhrResp, data, urlObj, resolve, undefined,partialObj,reject,key,customData,undefined,actionName,argsObj);
                });
                prmXhr = xhrPrm.xhr;
            }
        });	
        if(prmXhr){
            prm.xhr = prmXhr;
        }
        return prm;
    }
    static handleSuccess(db, name, type, xhrResp, data, urlObj, resolve, resp, respObj, partialObj, reject, key, customData, actionName, partialRef, argsObj){
        var resp = resp ? resp : xhrResp ? xhrResp.data : undefined, 
        req, 
        batchIndex, 
        batch, 
        xhr = xhrResp ? xhrResp.xhr : undefined,
        req = xhr ? xhr : undefined,
        def = db.schema[name], 
        opts = { customD : customData };
        var baseCons = def && def.connector ? def.connector.constructor : db.constructor.Connector;
        if(respObj){
            batchIndex = respObj.index;
            batch = respObj.batch;
            req = respObj.resp;
            argsObj.xhr = req;
            var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"connector", def && def.connector ? def.connector : undefined, baseCons.PARSERESPONSE, { argsObj:argsObj, args:[type, name, req, resp, urlObj ? urlObj.qP : undefined, key,customData,undefined,actionName]});
            if(res){
                resp = res.data;
                if(resp instanceof Promise)
                {
                    return baseCons.handleParseResponsePromise(db,resp,def,type,data,urlObj,xhr,partialObj,batchIndex,batch,resolve,reject,opts,argsObj);
                }
                else{
                    argsObj.payLoad = resp;
                }
            }
        }
        return this.otherParseRequestPromise(db, resp,def,type,data,urlObj,xhr,partialObj,batchIndex,batch,resolve,reject,customData,partialRef,argsObj,key);
    }
    static handleFailure(db, name, type, xhrResp, data, urlObj, resolve, respObj, partialObj,reject,key,customData,code,actionName,argsObj,bObj){
        var def = db.schema[name],
        xhr = xhrResp ? xhrResp.xhr : undefined;
        if(xhr){
            var resp, 
            response = xhrResp ? xhrResp.data : undefined;
            argsObj.payLoad = response;
        }
        else if(respObj){
            var batch, batchIndex;
            if(bObj){
                batchIndex = bObj.index;
                batch = bObj.batch;
            }
            db.$.batchResponse[batch][batchIndex] = {code:code, status:"requestFailure", data:respObj};
            reject({code:code, status:"requestFailure", data:respObj});
        }
        reject(response);
    }
}
Connector.__lMod = "Connector";
Connector.returnData = "old";
Connector.PARSEREQUEST = "parseRequest";
Connector.REQUESTURL = "requestURL";
Connector.REQUESTHEADERS = "requestHeaders";
Connector.REQUESTMETHOD = "requestMethod";
Connector.REFETCHALL = "refetchAll";
Connector.REFETCH = "refetchEntity";
Connector.PROCESSREQUEST = "processRequest";
Connector.PARSERESPONSE = "parseResponse";
Connector.JSON = /application\/json/;
Connector.TEXT = /text\/plain/;



/***/ }),

/***/ 45573783:
/*!********************************************!*\
  !*** ./node_modules/@slyte/data/src/Db.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Db": () => (/* binding */ Db),
/* harmony export */   "Dberror": () => (/* reexport safe */ _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror),
/* harmony export */   "ValidationError": () => (/* reexport safe */ _ValidationError__WEBPACK_IMPORTED_MODULE_9__.ValidationError)
/* harmony export */ });
/* harmony import */ var _dberror__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dberror */ 82718186);
/* harmony import */ var _Schema_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Schema.js */ 84879490);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils.js */ 84646139);
/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Entity.js */ 88519247);
/* harmony import */ var _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @slyte/core/src/lyte-utils */ 60768251);
/* harmony import */ var _slyte_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @slyte/core */ 68393168);
/* harmony import */ var _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/core/src/service */ 76099455);
/* harmony import */ var _Connector__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Connector */ 87193305);
/* harmony import */ var _Serializer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Serializer */ 73771730);
/* harmony import */ var _ValidationError__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ValidationError */ 76977460);










/*convert to custom class*/
class Db extends _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_0__.Service {
    // getConnector(name, type){
    //     if(type == "graphql"){
    //         return this.GraphqlConnector.connector[name];
    //     }    
    //     return this.RESTConnector.connector[name];
    // }
    // getSerializer(name, type){
    //     if(type == "graphql"){
    //         return this.GraphqlSerializer.serializer[name];
    //     }  
    //     return this.RESTSerializer.serializer[name];
    // }
    registerPattern(key, pattern){
        this.patterns[key] = pattern;
    }
    static getSchema(name){
        return this.Schema.schema[name];
    }
    static dataType(type){
        var self = this;
        class dataType extends self.DataType {}
        dataType.extends = type;
        return dataType;
    }
    static register(opts){
        var hash = opts ? opts.hash : this.name;
        var DT = this.DataType = (function() {
            class DataType extends _slyte_core__WEBPACK_IMPORTED_MODULE_1__.DataType {}
            return DataType;
        })();
        DT.register = function(){
            _slyte_core__WEBPACK_IMPORTED_MODULE_1__.DataType.registerInApp.apply(this, [DT]);
        }
        this.DataType.dataType = {};
        (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.extendEventListeners)(this.DataType.dataType);    
        Object.defineProperty(this, "Schema", {
            value: (function() {
                class Schema extends _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema {
                }
                return Schema;
            })()
        });
        var SM = this.Schema; 
        this.Schema.schema = {};
        (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.extendEventListeners)(this.Schema.schema);
        if(_Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.db && _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.db.size && _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.db.has(hash)){
            var schMap = _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.db.get(hash);
            if(schMap.size){
                schMap.forEach(function(cls, name){
                    _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.registerInDb.apply(cls, [undefined, SM]);
                    schMap.delete(name);
                });
                if(!schMap.size){
                    _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.db["delete"](hash);
                }
                if(!_Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.db.size){
                    delete _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.db;
                }
            }
        }
        SM.register = function(opts){
            _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.registerInDb.apply(this, [opts, SM]);
        }
        _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.addEventListener(hash, function(schCls){
            _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.registerInDb.apply(schCls, [undefined, SM]);
            if(_Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.db.has(hash)){
                var schMap = _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.db.get(hash); 
                if(schMap.has(schCls.name)){
                    schMap.delete(schCls.name);
                }
                if(!schMap.size){
                    _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.db["delete"](hash);
                }
                if(!_Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.db.size){
                    delete _Schema_js__WEBPACK_IMPORTED_MODULE_3__.Schema.db;
                }
            }
        });
    }
    constructor(opts){
        super();
        var self = this, 
        appIns = this.$app || this.$addon;
        if(!this.constructor.Connector || !this.constructor.Serializer){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(appIns, "Base Connector / Serializer not defined in Db class");
            return;
        }
        if(this.includeDbs){
            var subDbs = this.subDbs = [];
            var dbs = this.includeDbs();
            dbs.forEach(function(itm){
                if((0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.newGetSuperClass)(itm, false, self.constructor)){
                    subDbs.push(itm);
                }
            });
        }
        if(appIns.$ && appIns.$.modules.triggerEvent){
            appIns.$.modules.triggerEvent("add", "db", this);
        }
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__._defProp)(this,"Connector",{});
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__._defProp)(this,"Serializer",{});
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__._defProp)(this,"connector",{});
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__._defProp)(this,"serializer",{});
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__._defProp)(this,"schema",{});
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__._defProp)(this,"_schema",new Map());
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__._defProp)(this,"schemaless",{});
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__._defProp)(this,"dataType", {});
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__._defProp)(this,"_entity",_Entity_js__WEBPACK_IMPORTED_MODULE_6__.Entity);
        var lIns = this.lyte = appIns;
        var parent = this.constructor;
        if(this.constructor.Connector && (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.newGetSuperClass)(this.constructor.Connector, false, _Connector__WEBPACK_IMPORTED_MODULE_7__.Connector)){
            var cparentName = Object.getPrototypeOf(this.constructor.Connector).__lMod, context, defaultConnec;
            switch(cparentName){
                case "RESTConnector":
                    context = "REST";
                    break;
                case "GraphqlConnector":
                    context = "gql";
                    break;
                case "Connector":
                    defaultConnec = this.constructor.Connector;
            }
            if(context){
                this.Connector[context] = this.Connector[context] || {};
                this.Connector[context].application = this.constructor.Connector;
                this.lyte.scopedInstance(this.constructor.Connector, [this], function(ins){
                    self.connector[context] = self.connector[context] || {}; 
                    self.connector[context].application = ins;
                    self.applicationConnector = ins;
                }, [this]);
            }
            else if(defaultConnec){
                var dcparentName = defaultConnec.name, context;
                switch(dcparentName){
                    case "RESTConnector":
                        context = "REST";
                        break;
                    case "GraphqlConnector":
                        context = "gql";
                        break;
                }
                if(context){
                    class applicationConnector extends defaultConnec {
            
                    }
                    applicationConnector.register();
                    this.Connector[context] = this.Connector[context] || {};
                    this.Connector[context].application = applicationConnector;
                    this.lyte.scopedInstance(applicationConnector, [this], function(ins){
                        self.connector[context] = self.connector[context] || {}; 
                        self.connector[context].application = ins;
                        self.applicationConnector = ins;
                    }, [this]);
                }
            }
        }
        if(this.constructor.Serializer && (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.newGetSuperClass)(this.constructor.Serializer, false, _Serializer__WEBPACK_IMPORTED_MODULE_8__.Serializer)){
            var sparentName = Object.getPrototypeOf(this.constructor.Serializer).__lMod, context, defaultSerz;
            switch(sparentName){
                case "RESTSerializer":
                    context = "REST";
                    break;
                case "GraphqlSerializer":
                    context = "gql";
                    break;
                case "Serializer": 
                    defaultSerz = this.constructor.Serializer;
                    break;
            }
            if(context){
                this.Serializer[context] = this.Serializer[context] || {};
                this.Serializer[context].application = this.constructor.Serializer;
                this.lyte.scopedInstance(this.constructor.Serializer, [this], function(ins){
                    self.serializer[context] = self.serializer[context] || {}; 
                    self.serializer[context].application = ins;
                    self.applicationSerializer = ins;
                }, [this]);
            }
            else if(defaultSerz){
                var dsparentName = defaultSerz.name, context;
                switch(dsparentName){
                    case "RESTSerializer":
                        context = "REST";
                        break;
                    case "GraphqlSerializer":
                        context = "gql";
                        break;
                }
                if(context){
                    class applicationSerializer extends defaultSerz {
        
                    }
                    applicationSerializer.register();
                    this.Serializer[context] = this.Serializer[context] || {};
                    this.Serializer[context].application = applicationSerializer;    
                    this.lyte.scopedInstance(applicationSerializer, [this], function(ins){
                        self.serializer[context] = self.serializer[context] || {}; 
                        self.serializer[context].application = ins;
                        self.applicationSerializer = ins;
                    }, [this]);
                }
            }
        }
        var schemaDef = parent.Schema.schema;
        for(var key in schemaDef){
            this.schema[key] = schemaDef[key].create(this, lIns);
            this._schema.set(schemaDef[key], this.schema[key]);
        }
        var dTypeDef = parent.DataType.dataType;
        for(var dKey in dTypeDef){
            this.dataType[dKey] = dTypeDef[dKey];
        }
        this.entityStrictLock = true; //default for external release
        if(opts && opts.hasOwnProperty("entityStrictLock")){
            this.entityStrictLock = opts.entityStrictLock;
        }
        parent.Schema.Lyte = parent.DataType.Lyte = lIns;
        parent.Schema.db = parent.DataType.db = this;
        // var _Logger = lIns.lyteError || Logger; 
		this.$ = {
            toRelate:{},
            idbQ2:{}
        };
        this.cache = {
            getEntity:function getEntity(def,pKey,isDeleted){
                var args = arguments, 
                args0 = args[0], 
                isObj = typeof def == "object" && def != null,
                db = self,
                defless = db.applicationConnector && db.applicationConnector.__type == "REST" ? db.applicationConnector.schemaless : undefined, 
                _defless;
                if(isObj){
                    def = args0.schema, 
                    pKey = args0.pK, 
                    isDeleted = args0.isDeleted;
                }
                var isSchema = defless == true && typeof def == "string" ? false : (def ? ((0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.getSuperClass)(def, true) === "Schema") : def);
                def = isSchema ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(db, def) : def;
                var name = def && def._name ? def._name : def; 
                if( !def  ){
                    _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(appIns,"LD02","Schema ",name);
                    return;
                }
                else if(defless == true && !isSchema && name){
                    def = db.schemaless[name];
                    if(!def){
                        _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(appIns,"LD02","Schema");
                        return;	
                    }
                    _defless = true;
                }    
                if(isDeleted === true){
                    var deleted = def._deleted;
                    var obj = deleted.get(pKey);
                    if(obj && obj.data){
                        return obj.data;
                    }
                }
                else{
                    var isComp = def.isComp; 
                    pKey = (pKey == undefined) ? "" : pKey;
                    if(!isComp && def.data._recMap){
                        return def.data._recMap.get(pKey.toString());
                    }
                    else{
                        var data = def.data, entity;
                        if(_defless != true){
                            entity = data.filter(function(ins){
                                if((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.comparePk)(ins, pKey)){
                                    return ins;
                                }
                            });
                        }
                        else{
                            entity = data.filter(function(ins){
                                if(ins[def._pK] === pKey){
                                    return ins;
                                }
                            });
                        }    
                        if(entity[0]){
                            return entity[0];
                        }
                    }
                }
                return undefined;
            },
            getAll: function getAll(def){
                var args = arguments, 
                args0 = args[0], 
                isObj = typeof def == "object" && def != null, 
                db = self,
                defless = db.applicationConnector && db.applicationConnector.__type == "REST" ? db.applicationConnector.schemaless : undefined;
                if(isObj){
                    def = args0.schema;
                }
                var isSchema = defless == true && typeof def == "string" ? false : (def ? ((0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.getSuperClass)(def, true) === "Schema") : def);
                def = isSchema ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(db, def) : def;
                var name = def && def._name ? def._name : def;
                if( !def  ){
                    _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(appIns,"LD02","Schema");
                    return;
                }
                else if(defless == true && !isSchema && name){
                    def = db.schemaless[name];
                    if(!def){
                        _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(appIns,"LD02","Schema ",name);
                        return;	
                    }
                }    
                return def.data;
            }
        }
        this.lyte = lIns;
        this.constructor.Schema.schema.addEventListener("add", function(name, def){
            self.schema[name] = def.create(self, lIns);
            self._schema.set(def, self.schema[name]);
        });
        this.constructor.DataType.dataType.addEventListener("add", function(name, def){
            self.dataType[name] = def;
        });
    }
    isEntity(obj){
        if(obj && obj.$ && obj.$ instanceof _Entity_js__WEBPACK_IMPORTED_MODULE_6__.$Entity && obj.$.db == this){
            return true;
        }
        return false;
    }
    triggerUpdate(def, pkVal, keys, qP, customData){
        var args = arguments, args0 = args[0], isObj = typeof def == "object" && def != null; 
        if(isObj){
            def = args0.schema, pkVal = args0.pK, keys = args0.keys, qP = args0.qP, customData = args0.customData;
        }
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        if( !def  ){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte,"LD02","Schema");
            return Promise.reject({code : "ERR19", message : _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.errorCodes.ERR19});
        }
        var name = def._name;
        var ArrayOfKeys,sendData=[],recordsArray=[];
        ArrayOfKeys = Array.isArray(pkVal)?pkVal:[pkVal]
        for(var update_Rec = 0; update_Rec<ArrayOfKeys.length ; update_Rec++){
            var ins = this.cache.getEntity(def.def, ArrayOfKeys[update_Rec])
            if(ins){
                var obj = {};
                var def = ins.$.schema,
                pK = def._arrPk,
                fields = keys || Object.keys(def.fieldList);	
                fields.forEach(function(item){
                    obj[item] = ins[item];
                });
                pK.forEach(function(item){
                    obj[item] = ins[item];
                });
                sendData.push(obj)
                recordsArray.push(ins);
            }
            else{
                return Promise.reject("No such record found");
            }
        }
        var isSingleRecord = false;
        if(!Array.isArray(pkVal)){
            sendData=sendData[0];
            recordsArray=recordsArray[0];
            isSingleRecord=true;
        }	
        return def.connector.constructor.put(this, name, sendData, recordsArray, isSingleRecord, customData, qP);
    }
    batch(arg){
		var db = this;
        return new Promise(function(resolve, reject){
            db.$.makeBatch = true;
            db.$.batch = db.$.batch || {};
            db.$.batchPromise = db.$.batchPromise || {};
            var method, 
            customData,
            bLen = (db.$.currentBatch === undefined) ? Object.keys(db.$.batch).length : (db.$.currentBatch + 1), 
            batch = db.$.currentBatch = bLen;
            if(arg && typeof arg == "function"){
                method = arg;
            }
            else if(arg && typeof arg == "object"){
                method = arg.method;
                customData = arg.customData;
            }
            try{
                method();
            }
            catch(e){
                db.$.makeBatch = false;
                throw e;
            }
            db.$.makeBatch = false;
            var payLoad = { batch:db.$.batch[batch] }, 
            argsObj = { type: "batch" }; 
            argsObj.customData = customData;
            argsObj.payLoad = payLoad;
            var urlObj = db.applicationConnector.constructor.buildURL(db, "batch", "POST", undefined, undefined, payLoad, undefined, undefined, customData, undefined, argsObj), 
            batchPl = payLoad.batch;
            if((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.isEmpty)(batchPl)){
                if(db.$.cachedBatch && db.$.cachedBatch[batch] && db.$.cachedBatch[batch].length){
                    var finalRes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.handleCachedResponse)(db, batch, []);
                    return resolve(finalRes);
                }
                return resolve();					
            }
            argsObj.data = payLoad;
            var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.initCB)(db,"serializer", undefined, db.applicationSerializer.constructor.SERIALIZE, {args:["batch",payLoad,undefined,customData], argsObj:argsObj});
            if(res){
                argsObj.data = payLoad = res.data;
            }
            var xhr = new XMLHttpRequest();
            argsObj.xhr = xhr;
            xhr.open("POST", urlObj.url, true);
            for(var header in urlObj.headers){
                xhr.setRequestHeader(header, urlObj.headers[header]);
            }
            xhr.withCredentials = (urlObj.withCredentials)?true:false;
            xhr.send(JSON.stringify(payLoad));
            xhr.onreadystatechange = function(){
                if(xhr.readyState == 4){
                    argsObj.xhr = xhr;
                    if(xhr.status.toString()[0] == "2" || xhr.status.toString()[0] == "3"){
                        var resp = JSON.parse(xhr.responseText);
                        db.$.batchResponse = db.$.batchResponse || {};
                        db.$.batchResponse[batch] = [];
                        db.applicationConnector.constructor.handleBatchPromise({db:db,response:resp,batch:batch,resolve:resolve, argsObj:argsObj});
                        setTimeout(function(){
                            var finalRes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.handleCachedResponse)(db, batch, db.$.batchResponse[batch]);
                            resolve(finalRes);
                            db.$.batchResponse[batch] = [];
                        },0);
                    }
                    else{
                        db.$.batchResponse[batch] = [];
                        db.applicationConnector.constructor.handleBatchPromise({db:db,batch:batch,resolve:resolve,fail:true, argsObj:argsObj});
                        setTimeout(function(){
                            var finalRes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.handleCachedResponse)(db, batch, db.$.batchResponse[batch]);
                            reject(finalRes);
                        },0);
                    }
                }
            }					
        });
    }
    push(def,data,deserialize,index){
        var args = arguments, 
        args0 = args[0], 
        isObj = typeof def == "object" && def != null,
        db = this,
        defless = db.applicationConnector && db.applicationConnector.__type == "REST" ? db.applicationConnector.schemaless : undefined; 
        if(isObj){
            def = args0.schema, 
            data = args0.data, 
            deserialize = args0.deserialize;
            index = args0.index;
        }
        if( !def  ){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte,"LD02","Schema");
            return;
        }
        def = defless && typeof def === "string" ? def : (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        var name = def && def._name ? def._name : def, 
        result = data, 
        len;
        if(deserialize){
            data = def.serializer.constructor.buildJSON(db,def,"pushPayload",data);
            var scope = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.cbScp)(db, def.serializer, def.serializer.constructor.DESERIALIZEKEY, "serializer");
            len = data ? Object.keys(data).length : undefined;
            if(scope){
                _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.warn(this.lyte, "LD08", "deserializeKey", "callback", "Please use payloadKey callback instead");
                if(len > 2){
                    _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte, "LD09");
                }
                var keys = Object.keys(data), ind = 0;
                if(keys.length == 2 && keys[0] == "meta"){
                    ind = 1;
                }
                var argsObj = { type: "pushPayload", schemaName: name};
                var deserializeKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.cB)(scope, [argsObj]), rec = data[keys[ind]];
                delete data[keys[ind]];
                data[deserializeKey] = rec;
                
            }
            result = data[name];
        }
        // if(db.idbIns){
        //     db.idbIns.idbQ2Push(this,name,data,undefined,"pushPayload");
        // }
        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.insertIntoStore)(
            this,
            def.def ? def.def : def,
            result,
            true,
            undefined,
            undefined,
            index,
            true
        );
        var nData = data || [];
        if(!Array.isArray(nData)){
            nData = [nData];
        }
        var idb = def && def.hasOwnProperty("idb");
        nData.forEach(function(itm){
            if((0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.isEntity)(itm)){
                if(idb){
                    db.idbIns.idbQ2Push(db,name,itm,undefined,"pushPayload");
                }
                if(!itm.$.isError){
                    if(itm.$.inIDB && Object.keys(itm.$.inIDB).length){
                        db.dbIns.updateRelationsIDB(itm, itm.$.model.relations);
                    }
                }
            }
        });

        def ? delete def.rel : undefined;
        return data;
    }
    unregisterSchema(data){		
		var self = this;
		if(Array.isArray(data)){
			data.forEach(function(item){
				(0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.unregisterDef)(self, item);
			});
		}
		else{
			(0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.unregisterDef)(self, data);
		}
    }
    unregisterConnector(data){
        if(Array.isArray(data)){
            data.forEach(function(item){
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.unRegCb)(this, "connector", item);
            });
        }	
        else{
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.unRegCb)(this, "connector", data);
        }		
    }
    unregisterSerializer(data){
        if(Array.isArray(data)){
            data.forEach(function(item){
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.unRegCb)(this, "serializer",item);
            });
        }
        else{
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.unRegCb)(this,"serializer",data);
        }
    }
    addField(def, key, type, options, skipValidation, deserialize){
        var args = arguments, args0 = args[0], isObj = typeof def == "object" && def != null; 
        if(isObj){
            def = args0.schema, key = args0.key, type = args0.prop ? args0.prop : args0.type, options = args0.options, skipValidation = args0.skipValidation, deserialize = args0.deserialize;
        }
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        if( !def  ){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte,"LD02","Schema");
            return;
        }
        if(key === "$"){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte, "$ is a reserved key, which cannot be used as the field name");
            return;
        }
        var fieldType, obs = [];
        if(type && typeof type == "object"){
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.registerField)(this,def,key,type,obs);
            if(type.type == "relation"){
                fieldType = "relation"
            }
            else{
                fieldType = "attr"; 
            }
            var deserialize = arguments[4],
            skipValidation = arguments[3];
        }
        else{
            var field = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.prop)(type,options);
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.registerField)(this,def,key,field,obs);
        }
        if(fieldType != "relation"){
            if(!skipValidation || deserialize){
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.updateFieldValidation)(this, def, key, deserialize, skipValidation);
            }
        }
    }
    getSchemaObj(name){
        var schema = this.schema[name];
        if(!schema && this.subDbs){
            var len = this.subDbs.length;
            for(var i=0; i<len; i++){
                var subDb = this.subDbs[i];
                if(subDb.schema[name]){
                    schema = subDb.schema[name];
                    break;
                }
            }
        }
        return schema;
    }
    getSchema(name){
        var schema = this.schema[name];
        if(!schema && this.subDbs){
            var len = this.subDbs.length;
            for(var i=0; i<len; i++){
                var subDb = this.subDbs[i];
                if(subDb.schema[name]){
                    schema = subDb.schema[name];
                    break;
                }
            }
        }
        return schema && schema.def? schema.def : schema;
    }
    hasSchema(name){
        // return this.schema.hasOwnProperty(name);
        var hasSchema = this.schema.hasOwnProperty(name);
        if(!hasSchema && this.subDbs){
            var len = this.subDbs.length;
            for(var i=0; i<len; i++){
                var subDb = this.subDbs[i];
                if(subDb.schema[name]){
                    hasSchema = subDb.schema.hasOwnProperty(name);
                    break;
                }
            }
        }
        return hasSchema;
    }
    getSerializerObj(name, type){
        // return this.serializer[name];
        type = type == "graphql" ? "gql" : type;
        var sObj = type ? this.serializer[type] : this.serializer.REST;
        if(sObj){
            var serializer = sObj[name];
            if(!serializer && this.subDbs){
                var len = this.subDbs.length;
                for(var i=0; i<len; i++){
                    var subDb = this.subDbs[i];
                    if(subDb.serializer[name]){
                        var ssObj = type ? subDb.serializer[type] : subDb.serializer.REST;
                        serializer = ssObj[name];
                        break;
                    }
                }
            }
            return serializer;
        }
    }
    getConnectorObj(name, type){
        // return this.connector[name];
        type = type == "graphql" ? "gql" : type;
        var cObj = type ? this.connector[type] : this.connector.REST;
        if(cObj){
            var connector = cObj[name];
            if(!connector && this.subDbs){
                var len = this.subDbs.length;
                for(var i=0; i<len; i++){
                    var subDb = this.subDbs[i];
                    if(subDb.connector[name]){
                        var scObj = type ? subDb.connector[type] : subDb.connector.REST;
                        connector = scObj[name];
                        break;
                    }
                }
            }
            return connector;
        }
    }
    newEntity(def, opts, skipValidation){
        var args = arguments, args0 = args[0], isObj = typeof def == "object" && def != null; 
        if(isObj){
            def = args0.schema, opts = args0.data, skipValidation = args0.skipValidation;
        }
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        if( !def  ){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte, "LD02","Schema");
            return;
        }
        // skipValidation = skipValidation == undefined ? true : skipValidation;
        var name = def._name;
        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.newRecord)(this, def, opts, skipValidation);
    }
    deleteEntity(def, key){
        var args = arguments, args0 = args[0], isObj = typeof def == "object" && def != null; 
        if(isObj){
            def = args0.schema, key = args0.pK;
        }
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        if( !def  ){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte,"LD02","Schema");
            return;
        }
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.removeFromStore)(def, key, undefined);
    }
    getEntity(def, key, queryParams, cQuery, cacheData, customData, drop, forceFetch, index, methodType, oprName, variables){
        var args = arguments, 
        args0 = args[0], 
        isObj = typeof def == "object" && def != null,
        db = this,
        appIns = this.$app || this.$addon;
        if(isObj){
            def = args0.schema, 
            key = args0.pK, 
            queryParams = args0.qP, 
            cQuery = args0.cacheQuery, 
            cacheData = args0.cacheData, 
            customData = args0.customData;
            drop = args0.drop,
            forceFetch = args0.forceFetch, 
            index = args0.index;
            oprName = args0.gqlQuery;
            variables = args0.gqlVariables;
        }
        var name = def ? def._name : undefined;
        def = typeof def === "string" ? def : (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        var connec = def && def.connector ? def.connector.constructor : db.applicationConnector.constructor; 
        var prm = connec.get(this,methodType ? methodType : "getEntity",def,key,queryParams,cQuery,customData,cacheData,drop,forceFetch,oprName,variables);
        var gPrm = prm.then(function(){
            var data = arguments[0][0], 
            fromCache = arguments[0][1] == "cache" ? true : false,
            xhr = arguments[0][2],
            status = xhr ? xhr.status : arguments[0][3],
            batchObj = (arguments[0][1] == "batch") ? arguments[0][2] : undefined,
            fromIDB = (arguments[0][1] == "idb") ? true : false,
            schema = def, 
            defless = db.applicationConnector && db.applicationConnector.__type == "REST" ? db.applicationConnector.schemaless : undefined, 
            isDefinedSchema = (typeof schema !== "string" ? ((0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.getSuperClass)(schema ? schema.def : undefined, true) === "Schema") : false),
            name = isDefinedSchema ? schema._name : defless ? schema : undefined,
            toCacheParams = (cQuery && cQuery !== true) ? cQuery : (cQuery === true && queryParams && typeof queryParams == "object" && Object.keys(queryParams).length ) ? queryParams : undefined,
            _defless;
            
            if(!isDefinedSchema  && cacheData == undefined){
                cacheData = false;
            }
            else if(defless && !isDefinedSchema && cacheData == true){
                _defless = true;
            }  
            if(cacheData !== undefined && typeof cacheData == "object" && cacheData !== null){
                cacheData = cacheData.hasOwnProperty("cache") ? cacheData.cache : true;
            }
            if(cacheData === false){
                if(!fromCache && toCacheParams){
                    if(key != undefined){
                        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.cacheRecordQuery)(db, name, key, toCacheParams, data, status);
                    }
                    else{
                        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.cacheQuery)(db, name, toCacheParams, data, status);
                    }
                }
                if(batchObj != undefined){
                    db.$.batchResponse[batchObj.batch][batchObj.index] = data;
                }
                return data;
            }
            if(data){
                if(!fromCache){
                    var isEmp;
                    if(!data || !data.hasOwnProperty(name)){
                        _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(db.lyte, "LD13", "get",name, (",key-"+(typeof key == "object"? JSON.stringify(key):key)+(queryParams && typeof queryParams == "object" ? ", queryParams-"+JSON.stringify(queryParams)+"":"")), (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.isEntity)(data) ? data: JSON.stringify(data));
                        return;
                    }						
                    // if(!fromIDB && db.idbIns){
                    //     db.idbIns.idbQ2Push(db,name,data,queryParams,methodType ? methodType : "getEntity", key); 
                    // }
                    if(!(0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.isEntity)(data)){
                        var payLoad = data[name], pload;
                        if(key !== undefined){
                            if((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.isEmpty)(payLoad) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.isEmptyObj)(payLoad)){
                                pload = data[name] = {};
                                isEmp = true;
                            }
                            if(typeof payLoad != "object" || Array.isArray(payLoad)){
                                _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.warn(db.lyte,"LD11");
                            }
                        }
                        else{
                            if(payLoad === undefined || payLoad === null || (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.isEmptyArray)(payLoad)){
                                pload = data[name] = [];
                                isEmp = true;
                            }
                            else if(!Array.isArray(payLoad)){
                                _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.warn(db.lyte,"LD19");
                            } 
                        }
                        if(!isEmp){
                            var defnd = _defless ? "id" : undefined,
                            ind = _defless && index != undefined ? index : defnd;
                            if(key !== undefined){
                                pload = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.insertIntoStore)(db, schema.def ? schema.def : schema, payLoad, true, true, undefined, ind);
                                data[name] = pload;
                            }
                            else{
                                pload = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.toInsertData)(db, schema.def ? schema.def : schema, data,true,ind);
                                data[name] = pload;
                            }
                            var nRec = pload;
                            if(pload && !Array.isArray(pload)){
								nRec =[pload];
							}
                            if(!fromIDB && db.idbIns && ((nRec && !nRec.$) || (pload && pload.$ && !pload.$.isError))){
								if(def && def.hasOwnProperty('idb')){
									db.idbIns.idbQ2Push(db, name, nRec, queryParams, methodType ? methodType : "getEntity", undefined, undefined, customData);
								}
								nRec.forEach(function(itm){
									if(itm && itm.$ && itm.$.inIDB && Object.keys(itm.$.inIDB).length){
										db.idbIns.updateRelationsIDB(itm, itm.$.model.relations);
									}
								});
							}
                            if(fromIDB && Array.isArray(nRec) && nRec.length){
                                nRec.forEach(function(itm){
                                    db.idbIns.constructor.changeIDBState(db, itm);
                                });
                            }
                        }
                        if(data.hasOwnProperty("meta")){
                            if(!(0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.isEntity)(pload) && !data[name].$){
                                data[name].$ || (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__._defProp)(data[name], "$", {});
                            }
                            var p$ = pload.$ ? pload.$ : (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__._defProp)(pload, "$", {});
                            p$.meta = data.meta;
                        }
                    }
                    if(!fromCache && toCacheParams){
                        if(key !== undefined){
                            (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.cacheRecordQuery)(db, name, key, toCacheParams, data);
                        }
                        else{
                            (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.cacheQuery)(db, name, toCacheParams, data);								
                        }
                    }						
                }
                if(batchObj != undefined){
                    db.$.batchResponse[batchObj.batch][batchObj.index] = data[name];
                }
                if(connec.returnData == "new"){
                    var obj = {};
                    obj.data = data[name];
                    if(data.meta){
                        obj.meta = data.meta;
                    }
                    if(status !== undefined){
                        obj.status = status;
                    }
                    return obj;
                }
                return data[name];	
            }
            return arguments;
        }, function(e){
            return Promise.reject(e);
        });
        if(prm.xhr){
            gPrm.xhr = prm.xhr;
        }
        return gPrm;
    }
    getAll(def, queryParams, cQuery, cacheData, customData, drop, forceFetch, index, oprName,variables ){
        return this.getEntity(def, undefined, queryParams, cQuery, cacheData, customData, drop, forceFetch, index, "getAll", oprName,variables)
    }
    ajax(obj){
        var defless = this.applicationConnector ? this.applicationConnector.schemaless : undefined;
        if(defless != true){
            return Promise.reject("Schemaless behaviour is not enabled. Please enable it to make db.ajax call for not defined schemas");
        }
        if(!obj.schema){
            return Promise.reject("Schema name is mandatory for db.ajax");
        }
        if(!obj.type){
            return Promise.reject(obj.type+" is not a valid HTTP method");
        }
        var def = typeof obj.schema === "string" ? this.schema[obj.schema] : undefined;
        if(def || ((0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.getSuperClass)(obj.schema) === Object.getPrototypeOf(this.constructor.Schema))){
            return Promise.reject(obj.schema+" is a defined schema. db.ajax is supported only for a schema which is not defined");
        }
        var nObj = Object.assign({}, obj);
        nObj.db = this;
        return this.applicationConnector.constructor.handleAjax(nObj);
    }
    deleteMany(def, pK){
        var args = arguments, args0 = args[0], isObj = typeof def == "object" && def != null; 
        if(isObj){
            def = args0.schema, pK = args0.pK;
        }
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        if( !def  ){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte,"LD02","Schema");
            return;
        }
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.removeFromStore)(def, pK, undefined);
    }
    dropEntity(def, key , inherit){
        var args = arguments, 
        args0 = args[0], 
        isObj = typeof def == "object" && def != null,
        db = this,
        defless = db.applicationConnector && db.applicationConnector.__type == "REST" ? db.applicationConnector.schemaless : undefined, 
        _defless; 
        if(isObj){
            def = args0.schema, key = args0.pK;
            inherit = args0.inherit;
        }
        def = defless && typeof def === "string" ? def : (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        var parentRel = args[2];
        var schema = def;
        if( !def  ){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(db.lyte,"LD02","Schema");
            return;
        }
        else if(defless == true && typeof def == "string"){
            var name = def;
            schema = db.schemaless[def];
            if(!schema){
                _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(db.lyte,"LD02","Schema ",name);
                return;	
            }
            _defless = true;
        }

        if(key == undefined){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.warn(db.lyte,"LD18","key");
        }
        var cls = def && def.def ? def.def : def; 
        var data = this.cache.getEntity(cls, key),
        pkVal;
        if(_defless == true){
            var ind = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getInd)(schema.data, schema._pK, key);
            if(ind != -1){
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.handleArrOp)(this.lyte, schema.data, "removeAt", undefined, ind, 1);
            }
        }
        else if(data){
            pkVal = data.$.pK;
            var inhFldLen = schema._fldGrps.inherit && Object.keys(schema._fldGrps.inherit).length 
			inherit=(inherit===false)?false:true;
            if(inherit && inhFldLen){
                var recmp = new Map(); 
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.removeChildRecords)(db,schema,data,recmp,true);
            }
            else{
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.removeFromStore)(schema, pkVal, true, true, undefined, undefined, true, parentRel);
            }
    
            def._deleted.delete(key);
            var crq = this.schema.cachedRecordQueries;
            if(crq && crq[name] && crq[name][key]){
                crq[name][key] = [];
            }
            var cqueries = db.schema.cachedQueries;	
            if(cqueries){
                var n=def._name, Nm = cqueries[n];
                if(Nm && Nm.length){
                    for(var i=Nm.length-1; i>=0; i--){
                        var obj = Nm[i];
                        if(obj && obj.data){
                            var ind = obj.data[n].indexOf(data);
                            if(ind != -1){
                                Nm.splice(i, 1);
                            }							
                        }
                    }					
                }
            }
        }
    }
    dropAll(def, arr , inherit){
        var args = arguments, 
        args0 = args[0], 
        isObj = typeof def == "object" && def != null,
        db = this,
        defless = db.applicationConnector && db.applicationConnector.__type == "REST" ? db.applicationConnector.schemaless : undefined, 
        _defless;
        if(isObj){
            def = args0.schema, arr = args0.data;
            inherit = args0.inherit;
        }
        def = defless && typeof def === "string" ? def : (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        var name = def ? def._name: undefined, schema = def;
        if( !def  ){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(db.lyte,"LD02","Schema");
            return;
        }
        else if(defless == true && typeof def == "string"){
            var name = def;
            schema = db.schemaless[def];
            if(!schema){
                _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(db.lyte,"LD02","Schema ",name);
                return;	
            }
            _defless = true;
        }
        var keys = [], 
        cls = def && def.def ? def.def : def,
        data = arr || this.cache.getAll(cls);
        if(_defless == true){
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.handleArrOp)(this.lyte, schema.data, "removeAt", undefined, 0, schema.data.length);
        }
        else{
            if(data){
                for(var i=0; i<data.length; i++){
                    keys.push(data[i].$.pK);
                }				
            }
            var inhFldLen = schema._fldGrps.inherit && Object.keys(schema._fldGrps.inherit).length 
			inherit=(inherit===false)?false:true;
			if(inherit && inhFldLen){
				for(var i = keys.length-1 ;i>=0 ; i--){
					var rec = data[i]
					var recmp = new Map(); 
					(0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.removeChildRecords)(db,schema,rec,recmp,true);
				}
			}
			else{
				(0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.removeFromStore)(schema, keys, true, true, undefined, undefined, true);
			}
            // removeFromStore(schema, keys, true, true, undefined, undefined, true);
            this.schema[name].dirty = [];
            this.schema[name]._deleted = new Map();
            var cq = this.schema.cachedQueries;
            if(cq && cq[name]){
                cq[name] = [];
            }
			var crq = this.schema.cachedRecordQueries; 
			if(crq && crq[name]){
				crq[name] = [];
			}
        }
    }
    triggerAction(def,actionName,customData,qP,method,data){
        var args = arguments, args0 = args[0], isObj = typeof def == "object" && def != null; 
        if(isObj){
            def = args0.schema, actionName = args0.action, qP = args0.qP, customData = args0.customData, method = args0.method, data = args0.data;
        }
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        if(!def){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte,"LD02","Schema");
            return Promise.reject({code : "ERR19", message : _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.errorCodes.ERR19});
        }
        var actions = def.actions, action = (actions)?def.actions[actionName]:undefined;
        if(action){
            return def.connector.constructor.handleAction(this,actionName,def,this.cache.getAll(def.def),customData,qP,method,data).then(function(data){
                return data;
            },function(err){
                return Promise.reject(err);
            });
        }
        else{
            return Promise.reject({code : "ERR18", message : _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.errorCodes.ERR18});
        }
    }
    revert(def){
        var args = arguments, args0 = args[0], isObj = typeof def == "object" && def != null; 
        if(isObj){
            def=args0.schema;
        }
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        if( !def  ){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte,"LD02","Schema");
            return;
        }
        var name = def._name;
        var pK = def._pK, self = this, 
        dirty = Array.from(def.dirty),
        len = dirty.length;
        for(var i=0; i<len; i++){
            var rec = self.cache.getEntity(def.def, dirty[i]);
            if(rec && rec.$.isDeleted){
                continue;
            }
            else if(rec && rec.$.isNew){
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.rollBackNew)(def, rec, pK);
            }                                
            else if(rec && rec.$.isModified){
                rec.$.revertProps(rec.$.getDirtyProps());
            }
        }
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.rollBackDelete)(def, undefined, true);
    }
    create(def, data, customData, qP, toFilterRecords, mutationName){
        var args = arguments, args0 = args[0], isObj = typeof def == "object" && def != null; 
        if(isObj){
            def = args0.schema, data = args0.data, customData = args0.customData, qP = args0.qP, toFilterRecords = args0.toSendData, 
            mutationName = args0.mutationName;
        }
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        if( !def  ){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte,"LD02","Schema ");
            return Promise.reject({code : "ERR19", message : _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.errorCodes.ERR19});
        }
        var name = def._name;
        if(Array.isArray(data)){
            var self = this;
            data.forEach(function(item){
                var resp = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.newRecord)(self, def, item);
                if(resp.$.isError){
                    return Promise.reject(resp);
                }
            });
        }
        else if(data && typeof data == "object"){
            var self = this;
            var resp = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.newRecord)(self, def, data);
            if(resp.$.isError){
                return Promise.reject(resp);
            }				
        }
        var dirty = def.dirty, len = dirty.length, created = [], err;
        for(var i=0; i<len; i++){
            var rec = this.cache.getEntity(def.def, dirty[i]);
            if(rec && rec.$.isNew){
                if(toFilterRecords && toFilterRecords.indexOf(rec) == -1){
                    continue;
                }	
                err = new _ValidationError__WEBPACK_IMPORTED_MODULE_9__.ValidationError(def.lyte);
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.validateRecord)(this, rec, def.fieldList);
                if(rec.$.isError && Object.keys(rec.$.error).length > 0){
                    return Promise.reject(err);
                }
                created.push(rec);
            }
        }
        if(created.length){
            return _Connector__WEBPACK_IMPORTED_MODULE_7__.Connector.create(this, name, created, false, customData, qP, mutationName);
        }
        return Promise.resolve();
    }
    update(def, customData, qP, toFilterRecords, mutationName){
        var args = arguments, args0 = args[0], isObj = typeof def == "object" && def != null; 
        if(isObj){
            def = args0.schema, qP = args0.qP, customData = args0.customData, toFilterRecords = args0.toSendData, 
            mutationName = args0.mutationName;
        }
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        if( !def  ){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte,"LD02","Schema");
            return Promise.reject({code : "ERR19", message : _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.errorCodes.ERR19});
        }
        var changed = [], 
        name = def._name,
        db = def.db,
        recordsChanged = [],
        records = toFilterRecords || db.cache.getAll(def.def),
        rels = def.relations,
		self = this;
        records.forEach(function(item){
            if(item.$.schema === def ){
                var rec = item,
                dirty = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.isDirty)(self, rec, rels);
                if((rec && rec.$.isModified && !rec.$.isNew) || (dirty && dirty.length)){
                    var obj = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.updateJSON)(self, rec, def, dirty);
                    changed.push(obj);
                    recordsChanged.push(rec);
                }
            }
        });
        if(changed.length){
            return _Connector__WEBPACK_IMPORTED_MODULE_7__.Connector.put(this, name, changed, recordsChanged,false, customData, qP, mutationName);
        }
        return Promise.resolve();
    }
    delete(def, key, customData, qP, toFilterRecords, mutationName){
        var args = arguments, args0 = args[0], isObj = typeof def == "object" && def != null; 
        if(isObj){
            def = args0.schema, key = args0.pK, qP = args0.qP, customData = args0.customData, toFilterRecords = args0.toSendData, 
            mutationName = args0.mutationName;
        }
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        if( !def  ){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte,"LD02","Schema");
            return Promise.reject({code : "ERR19", message : _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.errorCodes.ERR19});
        }
        var name = def._name;
        if(key){
            this.deleteEntity(name, key);				
        }
        var deleted = [];
        def._deleted.forEach(function(itm, idx){
            deleted.push(itm.data);
        });
        if(toFilterRecords){
            var newDel = [];
            toFilterRecords.forEach(function(itm){
                var ind = deleted.indexOf(itm);
                if(ind != -1){
                    newDel.push(itm);
                }
            });
            deleted = newDel;
        }
        if(deleted.length){
            var prm = _Connector__WEBPACK_IMPORTED_MODULE_7__.Connector.del(this, name, deleted,undefined,"delete",customData,qP,mutationName);
            return prm.then(function(resp){
                return resp;
            }, function(e){
                return Promise.reject(e);
            });
        }
        return Promise.resolve();
    }
    clearCachedQuery(def, key, cacheQuery){
        var args = arguments, args0 = args[0], isObj = typeof def == "object" && def != null, qP; 
        if(isObj){
            def = args0.schema, key = args0.pK, qP = cacheQuery = args0.cacheQuery;
            // key = (key == undefined && queryParams && typeof queryParams == "object") ? queryParams : key;
        }
        else{
            if( key && typeof key == "object"){
                qP = key;
                key = undefined;
            }
            else if(cacheQuery && typeof cacheQuery == "object"){
                qP = cacheQuery;
            }
        }
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        // var qP = key && typeof key == "object" ? key : queryParams && typeof queryParams == "object" ? queryParams : undefined,
        var cachedQueries = [];
        if(!qP){
            if(def && def._name){
                var cq = this.schema.cachedQueries;
                var crq = this.schema.cachedRecordQueries;
                cq && cq.hasOwnProperty(def._name) ? delete cq[def._name] : undefined;
                crq && crq.hasOwnProperty(def._name) ? ( key ? delete crq[def._name][key] : delete crq[def._name] )  : undefined;
            }
            else{
                this.schema.cachedQueries = [];
                this.schema.cachedRecordQueries = {};
            }
            return;
        }
        if(qP){
            if(key == undefined){
                var cq = this.schema.cachedQueries;
                if(cq && cq[def._name]){
                    cachedQueries = cq[def._name];
                }
            }
            else{
                var crq = this.schema.cachedRecordQueries;
                if(crq && crq[def._name] && crq[def._name][key]){
                    cachedQueries = crq[def._name][key];
                }
            }
            for(var i=0; i<cachedQueries.length; i++){
                if((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.compareData)(cachedQueries[i].cacheQuery, qP, true)){
                    cachedQueries.splice(i, 1);
                    break;
                }
            }
        }
    }
    getErrorMessage(code){
        var args = arguments, args0 = args[0], isObj = typeof code == "object" && code != null; 
        if(isObj){
            code = args0.code;
        }
        return _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.errorCodes[code];
    }
    setErrorMessages(obj){
        Object.assign(_dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.errorCodes, obj);
    }
    addEventListener(type,func){
        var args = arguments, args0 = args[0], isObj = typeof type == "object" && type != null; 
        if(isObj){
            type = args0.type, func = args0.func;
        }
        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.evAdd)(this,type,func);
    }
    removeEventListener(id){
        var args = arguments, args0 = args[0], isObj = typeof id == "object" && id != null; 
        if(isObj){
            id = args0.id;
        }
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.evRemove)(this,id);
    }
    emit(type,args){
        var _args = arguments, args0 = _args[0], isObj = typeof type == "object" && type != null; 
        if(isObj){
            type = args0.type, args = args0.args;
        }
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.evEmit)(this,type,args);
    }
    getPrimaryKey(def){
        var args = arguments, args0 = args[0], isObj = typeof def == "object" && def != null;
        if(isObj){
            def = args0.schema;
        }
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        if(!def){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.error(this.lyte,"LD02","Schema");
            return;
        }
        return def._pK;
    }
    getDirtyEntities(def , filters , deepNest){
        var isObj = typeof def == "object" ? true : false; 
        if(isObj){
            var args = arguments[0];
            def = args.schema;
            filters = args.filters;
            deepNest = args.deepNest;
        }
        var model = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSchemaObj)(this, def);
        if(!model){
            _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.warn("LD02","schema ",def._name);
            return;
        }
        var DirtyKeys = model.dirty,dirtyRecords=[],dirty={isNew :[],isModified :[],isDeleted :[]};
        for(var i_dirty = 0 ; i_dirty<DirtyKeys.length; i_dirty++){
            var record = this.cache.getEntity(def,DirtyKeys[i_dirty]);
            if(record){
                record.$.isNew?dirty.isNew.push(record):dirty.isModified.push(record);
            }
        }
        if(model._deleted.size){
            var deletedRecord = model._deleted
            deletedRecord.forEach(function(value){
                dirty.isDeleted.push(value.data);
            })
        }
        if(model.dirty || model._deleted.size){
            if(filters == undefined || filters == true){
                dirtyRecords=dirtyRecords.concat(dirty.isNew,dirty.isModified,dirty.isDeleted);
            }
            if(Array.isArray(filters)){
                filters.forEach(function(value){
                    dirtyRecords=dirtyRecords.concat(dirty[value]);
                })
            }
            if(typeof filters == "string"){
                dirtyRecords = dirty[filters];
            }
        }
        if(deepNest){
            var records =this.cache.getAll(def);
            records.forEach(function(rec){
                if(rec.$.isDirty() && !dirtyRecords.includes(rec)){
                    dirtyRecords.push(rec);
                }
            });
        }
        return dirtyRecords;
    }
    __dVC(){
        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.deepValueChange)(...arguments);
    }

    __sD(){
        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setData)(...arguments);
    }
}

Db.__lMod = "Db";
Db.ConnectorCls = _Connector__WEBPACK_IMPORTED_MODULE_7__.Connector;
Db.SerializerCls = _Serializer__WEBPACK_IMPORTED_MODULE_8__.Serializer;




/***/ }),

/***/ 88519247:
/*!************************************************!*\
  !*** ./node_modules/@slyte/data/src/Entity.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$Entity": () => (/* binding */ $Entity),
/* harmony export */   "Entity": () => (/* binding */ Entity)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ 84646139);
/* harmony import */ var _dberror__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dberror */ 82718186);
/* harmony import */ var _slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @slyte/core/src/lyte-utils.js */ 60768251);
/* harmony import */ var _Connector_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Connector.js */ 87193305);
/* harmony import */ var _commonUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./commonUtils.js */ 5950311);
/* harmony import */ var _ValidationError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ValidationError.js */ 76977460);








class Entity {
    constructor(name,data,opts){
        var def = db.getSchema(name), delayPers = opts ? opts.delayPersistence : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getFromCB)(db, "connector", def.connector, "delayPersistence");
        Object.assign(this, data);
        Object.defineProperties(this, {
            $ : {
                writable : true,
                value : new $Entity(this, def, delayPers)
            }
        });
        var parent = db.$.saveParent;
        if(parent && this !== parent){
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._defProp)(this.$, "parent", parent);
        }
        var defF = def._fldGrps.default;
        var watchF = def._fldGrps.watch;
        var hasManyF = def._fldGrps.hasMany;
        var nested_prop = def._fldGrps.nested_prop;
        for(var dKey in defF){
            var dFld = defF[dKey];
            var fldVal = data[dKey];
            if(fldVal === undefined || fldVal === ""){
                this[dKey] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getDefaultVal)(this, dFld.default);
            }
        }

        for( var k in model.fieldList){
            var field= model.fieldList[k];
            var customDtype = false;
            if(field && field.type instanceof Function  && (field.type.hasOwnProperty("properties") || field.type.hasOwnProperty("items") )){
                customDtype=true;
            }
            if((/^(array|object)$/.test(field.type) && (field.properties || field.items) )  ||  nested_prop.hasOwnProperty(k)){
                (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.establishObjectBinding)(this,k,true,undefined,undefined,(field && field.watch)?field.watch:undefined);
            }
        }
    
        // for(var wKey in watchF){
        //     establishObjectBinding(this, wKey, true);
        // }
        for(var hKey in hasManyF){
            var hFld = hasManyF[hKey];
            if(this.hasOwnProperty(hKey)){
                this[hKey] = Array.isArray(this[hKey]) ? Array.from(this[hKey]) : this[hKey];
            }
            else if(hFld.relatedTo){
                var toInit = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getFromCB)(db,"serializer", (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getSchemaObj)(db,hFld.relatedTo).serializer, "initHasManyRelation");
                if(toInit){
                    this[hKey] = [];
                }
            }
        }
        var props = def._properties;
        if(Object.keys(props).length){
            if(!this._bindings){
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._defProp)(this, '_bindings', new Set(), false, true, true);
            }
            this._bindings.add(props);
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.establishObsBindings)(this,props);
        }
    }
}
Entity.__lMod = "Entity";
class $Entity {
    constructor(ins, def, delayPers, db){
        // def = getSchemaObj(db, def);
        this.isModified = false;
        this.isNew = false;
        this.isDeleted = false;
        this.isError = false;
        this.error = {};
        this.db = db;
        this.isUnloaded = false;
        var pkVal = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getpKVal)(ins, def);
        Object.defineProperties(this, {
            events:{ 
                value : [],
                writable : true
            }, 
            validatedOnCreate:{ 
                value : true,
                writable: true
            },
            pK:{
                value: pkVal,
                writable: true
            },
            schema : {
                value : def
            },
            _attributes : {
                value : {} ,
                writable : true
            },
            _relationships : {
                value : {},
                writable : true
            },
            isDirty: {
                value: function value(){
                    var result = [];
                    var ins = this.entity;
                    if(ins.$.isModified){
                        return true;
                    }
                    result = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isDirty)(db, ins, this.schema.relations);
                    if(result.length){
                        return result;
                    }
                    return false;
                }
            },
            undoStack : {
                value : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.genUnRedoStack)(),
                writable : true
            },
            redoStack : {
                value : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.genUnRedoStack)(),
                writable : true
            },
            delayPersistence : {
                value : delayPers
            },
            entity: {
                value: ins
            }
        });
        this.inIDB = false;
        this.isPersisted = true;
        this.strictLock = def.db && def.db.entityStrictLock ? def.db.entityStrictLock : false; 
    }
    get(attr){
        if(this.db.lyte && this.db.lyte.$utils && this.db.lyte.get){
            return this.db.lyte.$utils._get(this.entity,attr)
        }
        else{
            if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
                return this.entity[attr];
            }
        }
    }
    set(attr, value, opts){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            if(this.isUnloaded){
                _ValidationError_js__WEBPACK_IMPORTED_MODULE_2__.ValidationError.setRecErr(this, this.schema._pK, "ERR17");
            }
            else{
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.setData)(this, attr, value, opts);
            }
            return this.entity;
        }
    }
    getDirtyProps(){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var ret = [];
            var attributes = this._attributes;
            if(Object.keys(attributes).length){
                for(var key in attributes){
                    ret.push(key);
                }
            }
            return ret;
        }
    }
    revertProps(attr){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            if(!Array.isArray(attr)){
                attr = [attr];
            }
            var ins = this.entity, changed = [], def = this.schema, _attrs = this._attributes;
            for(var i=0; i<attr.length; i++){
                var key = attr[i];
                if(_attrs.hasOwnProperty(key)){
                    var field = def.fieldList[key], oldVal = _attrs[key];
                    if(field.type == "relation"){
                        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rllBckRecArr)(def.db, oldVal && oldVal._changes ? oldVal._changes : oldVal, ins, def, field);
                        var obj = ins.$.dN && ins.$.dN.hasOwnProperty(key) ? ins.$.dN[key] : new Map();
                        for(var dnArr of obj){
                            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.deleteDeepNest)(ins, key, dnArr[0]);
                        }
                    }
                    else{
                        (0,_commonUtils_js__WEBPACK_IMPORTED_MODULE_3__.cmpSet)( def.db.lyte, ins, key, oldVal, undefined, true );
                    }
                    changed.push(key);
                    delete _attrs[key];
                }
                _ValidationError_js__WEBPACK_IMPORTED_MODULE_2__.ValidationError.clrRecErr(this, key);
            }
            if(!Object.keys(this._attributes).length){
                if((!this.hasOwnProperty("dN") || ( this.dN && !Object.keys(this.dN).length )) && !ins.$.isNew){
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.removeParentNesting)(ins, undefined, "modified");
                }
                (0,_commonUtils_js__WEBPACK_IMPORTED_MODULE_3__.cmpSet)(def.db.lyte, this, "isModified", false);
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.changePersist)(this.entity, true);
                if(!this.isNew){
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.deleteFromArray)(def.dirty, this.get(def._pK));
                }
            }
            if(changed.length > 0){
                var arr = [ins,changed];
                this.emit("change", arr);
                def.emit("change", arr);
                this.undoStack = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.genUnRedoStack)();
                this.redoStack = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.genUnRedoStack)();
            }
        }
    }
    revert(state,inherit){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var def = this.schema, pK = def._pK , recmp = new Map();
            inherit=(inherit===false)?false:def._fldGrps.inherit && Object.keys(def._fldGrps.inherit).length;
            if(state){
                this.revertToState(state);
            }
            else {
                if(inherit){
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rBinherit)(this,recmp);
                }
                if(this.isModified){
                    this.revertProps(this.getDirtyProps());
                    delete this._savedState;
                }
                if(this.isDeleted){
                    // var index = getInd(model._deleted, pK, this.get(pK));
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rollBackDelete)(def, this.get(pK));
                }
                else if(this.isNew){
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rollBackNew)(def, this.entity, pK);
                }			
                else if(this.isError){
                    _ValidationError_js__WEBPACK_IMPORTED_MODULE_2__.ValidationError.clrRecErr(this);
                }
            }
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.removeOnSave)(def.db, this.schema._name, this.entity.$.pK);
        }
    }
    delete(delayPers){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var def = this.schema, ins = this.entity, 
            delayPers = ( delayPers !== undefined ) ? delayPers : (ins.$.delayPersistence ? ins.$.delayPersistence.delete : false); 
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.removeFromStore)(def, ins.$.pK, undefined, undefined, delayPers);
        }
    }
    destroy(customData,qP,delayPers){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            this.delete(delayPers);
            return this.save(customData,qP,"destroyRecord");
        }
    }
    addEventListener(type, func){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.evAdd)(this, type, func);
        }
    }
    removeEventListener(id){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.evRemove)(this,id);
        }
    }
    emit(type, args){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.evEmit)(this,type,args);
        }
    }
    triggerAction(actionName,customData,qP,method,data){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var def = this.schema, 
			db = def.db,
			actions = def.actions, 
			action = (actions) ? actions[actionName] : undefined;
            if(action){
                return def.connector.constructor.handleAction(db,actionName,def,this.entity,customData,qP,method,data);
            }
            return Promise.reject({code : "ERR18", message : _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.errorCodes.ERR18, data : actionName});
        }
    }
    save(customData,qP,options,destroy,mutationName){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var def = this.schema, 
			db = def.db,
			ins = this.entity, 
			dirty = this.isDirty(), 
			validateOnSave = options && options.validateOnSave, 
			skipValidation = options && options.skipValidation, 
			fields = def.fieldList, 
			ret;
            if(this.isUnloaded !== true){
                if(this.isDeleted){
                    if(!this.isNew){
                        return _Connector_js__WEBPACK_IMPORTED_MODULE_5__.Connector.del(db, def._name, ins, true, destroy, customData, qP, mutationName);
                    }
                }
                else if(this.isNew){
                    var err = this;
                    if(!skipValidation && (!ins.$.validatedOnCreate || validateOnSave)){
                        ret = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateRecord)(db, this.entity, fields);
                    }
                    if(!skipValidation && (ret == false || (err && err.error && Object.keys(err.error).length > 0))){
                        return Promise.reject(err.error);
                    }
                    return _Connector_js__WEBPACK_IMPORTED_MODULE_5__.Connector.create(db, def._name, ins, true , customData, qP, mutationName);
                }
                else if(this.isModified || (dirty && dirty.length) ){
                    var data = {};
                    if(!skipValidation && (options && validateOnSave)){
                        ret = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateRecord)(db, this.entity, fields);
                    }
                    if(!skipValidation){
                        if(ret == false || (ins && ins.$ && ins.$.isError)){
                            return Promise.reject(ins.$.error);
                        }
                    }
                    var data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateJSON)(db, this.entity, def, dirty);
                    return _Connector_js__WEBPACK_IMPORTED_MODULE_5__.Connector.put(db, def._name, data, ins, true, customData, qP, mutationName);
                }
            }
            else{
                _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.warn(db.lyte,"LD29", typeof ins.$.pK == "object" ? JSON.stringify(ins.$.pK) : ins.$.pK, def._name)
				var rejectUnloadRecordSave = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getFromCB)(db, "connector", def.connector, "rejectUnloadRecordSave");
				if(rejectUnloadRecordSave){
					return Promise.reject({code: "ERR28", message: _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.errorCodes.ERR28, data: ins});
				}
			}
            return Promise.resolve();
        }
    }
    getInitialValues(attr){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var isAttrPassed = false;
            if(attr){
                if(!Array.isArray(attr)){
                    attr = [attr];
                }
                isAttrPassed = true;
            }
            else{
                attr = this.getDirtyProps();
            }
            var ret = {}, rec = this.entity, _attrs = this._attributes;
            for(var i=0; i<attr.length; i++){
                if(rec[attr] == undefined || !rec[attr[i]].add){
                    ret[attr[i]] = _attrs[attr[i]];					
                }
                else{
                    ret[attr[i]] = rec[attr[i]].slice(0);
                    var arr = _attrs[attr[i]] && _attrs[attr[i]]._changes ? _attrs[attr[i]]._changes : [], 
                    isPoly = rec[attr[i]].polymorphic,
                    pK = !isPoly ? rec[attr[i]].schema._pK : undefined;
                    for(var j=arr.length-1; j>=0; j--){
                        if(arr[j]._type == "added"){
                            for(var k=0; k<arr[j].records.length; k++){
                                var index = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getInd)(ret[attr[i]], !isPoly ? pK : arr[j].records[k].$.schema._pK, arr[j].records[k].$.pK);
                                if(index == -1){
                                    continue;
                                }
                                ret[attr[i]].splice(index, 1);
                            }
                        }
                        else if(arr[j]._type == "removed"){
                            for(var k=arr[j].records.length-1; k>=0; k--){
                                ret[attr[i]].splice(arr[j]._indices[k], 0, arr[j].records[k]);
                            }
                        }
                        else if(arr[j]._type == "changed"){
                            ret[attr[i]] = Array.isArray(arr[j].records) ? Array.from(arr[j].records) : arr[j].records;
                        }
                    }
                }
            }
            if(isAttrPassed){
                return ret[attr[0]];
            }
            return ret;
        }
    }
    toJSON(type){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var db = this.schema.db,addNotDefinedFields , inherit = true,
            parentRel = arguments[1];
            if(typeof type == "object"){
                addNotDefinedFields = type.addNotDefinedFields?true:false
                inherit = type.inherit == false ? false : Object.keys(this.schema._fldGrps.inherit).length ? true : false;
                type = undefined;
            }
            return Object.assign({}, (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toJSON)(db, this.schema._name, this.entity, !type ? true : type, undefined, undefined, parentRel,addNotDefinedFields,inherit));
        }
    }
    undo(attr, state){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var currentState = this.undoStack._order_.length;
            state = state || (currentState ? currentState - 1 : currentState);
            // state = state || 0;
            while(currentState-- > state){
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.unredoOp)(1, this, attr);
            }
        }
    }
    getCurrentState(){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            return this.undoStack._order_.length;
        }
    }
    redo(attr){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.unredoOp)(2,this,attr);
        }
    }
    validate(arr){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var fields = {};
            var def = this.schema;
            var fieldList = def.fieldList;
            if(Array.isArray(arr)){
                arr.forEach(function(item, index){
                    if(fieldList[item]){
                        fields[item] = fieldList[item];
                    }
                });
            }
            if(Object.keys(fields).length == 0){
                fields = fieldList;
            }
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateRecord)(def.db, this.entity, fields);				
        }
    }
    saveState(state){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var fromRel = arguments[1];
            var parentRel = arguments[2];
            if(!fromRel){
                if(!this.isNew && !this.isModified){
                    _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.warn(this.db.lyte,"LD20");
                    return;
                }
                var savedState = this._savedState = this._savedState || {};
                var currentState = state, randomState;
                while(!currentState){
                    randomState = Math.floor(Math.random()*100000 + 1);
                    currentState = !savedState.hasOwnProperty(randomState) ? randomState : currentState;
                }
            }
            var obj = this.toJSON("state", parentRel);
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._defProp)(obj, "$", {}, false, true);
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._defProp)(obj.$, "isSavedState", true, false, true);
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._defProp)(obj.$, "pK", this.entity.$.pK, false, true);
            var pK = this.schema._arrPk;
            pK.forEach(function(val){
                delete obj[val];
            });
            var undoStack = this.undoStack;
            var redoStack = this.redoStack;
            var _attributes = this._attributes;
            // var dN = this.entity.$.dN;
            if(undoStack && Object.keys(undoStack).length){
                var _order = undoStack._order_;
                undoStack = obj.$.undoStack = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.deepCopyStack)(undoStack);
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._defProp)(undoStack, "_order_", (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.deepCopyObject)(_order), false, true);
            }
            if(redoStack && Object.keys(redoStack).length){
                var _order = redoStack._order_;
                redoStack = obj.$.redoStack = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.deepCopyStack)(redoStack);
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._defProp)(redoStack, "_order_", (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_1__.deepCopyObject)(_order), false, true);
            }			
            if(_attributes && Object.keys(_attributes).length){
                obj.$._attributes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.deepCopyAttrs)(this.schema, _attributes);
            }
            if(!fromRel){
                this._savedState[currentState] = obj; 
                return currentState;
            }else{
                return obj;	
            }
        }
    }
    clearState(state){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            if(!state){
                this._savedState = {};
                return;
            }
            delete this._savedState[state];
        }
    }
    revertToState(state){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var savedSt = this._savedState
            var obj = savedSt ? savedSt[state] : undefined;
            if(!obj){
                _dberror__WEBPACK_IMPORTED_MODULE_4__.Dberror.warn(this.db.lyte, "LD21", state);
                return;
            }
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.setState)(this, obj);
            delete this._savedState[state];
        }
    }
    hasSavedState(state){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            return this._savedState && this._savedState.hasOwnProperty(state) ? true : false;
        }
    }
    clone(){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var parentRel = arguments[0];
            var obj = this.toJSON("clone", parentRel);
            return this.schema.db.newEntity(this.schema.def, obj);
        }
    }
    persist(obj){
        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.recChk)(this.db.lyte, this.entity)){
            var schema = this.schema, 
			name = schema._name,
			db = schema.db, 
			ins = this.entity, 
			partialObj = {obj:new Map()}, 
            type, 
            dirty;
            if(this.isNew){
                type = "create";
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toJSON)(db, name, ins, undefined, "create", partialObj);
            }
            else if(dirty = this.isDirty()){
                var data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateJSON)(db, ins, this.schema, dirty);
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toJSON)(db, name, data, undefined, undefined, partialObj);
            }
            var pObj = partialObj.obj.get(this.pK);
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mergeResponse)(db, ins, this.schema, undefined, this.pK, pObj, true);
            if(db.idbIns){
                db.idbIns.updateIDB(db, name, type ? type : ins.$.isDeleted ? "deleteEntity" : ins.$.isModified || dirty ? "updateEntity" : undefined, ins);
            }
        }
    }
}
$Entity.__lMod = "$Entity";
(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._defProp)(Entity, "strictValueSet", true);
(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._defProp)(Entity, "strictRelSet", true);


/***/ }),

/***/ 34309705:
/*!*******************************************************!*\
  !*** ./node_modules/@slyte/data/src/RESTConnector.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RESTConnector": () => (/* binding */ RESTConnector)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ 84646139);
/* harmony import */ var _RESTSerializer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RESTSerializer.js */ 64160506);
/* harmony import */ var _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @slyte/core/src/lyte-utils */ 60768251);
/* harmony import */ var _Connector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Connector.js */ 87193305);




/*convert to custom class*/
class RESTConnector extends _Connector_js__WEBPACK_IMPORTED_MODULE_0__.Connector {
    static register(parent){
    }
    constructor(db){
        super();
        this.host = window.location.origin ? window.location.origin : window.location.protocol+"//"+window.location.host;
        this.namespace = "";
        this.actionNamespace = "action";
        this.batchNamespace = "batch";
        this.__type = "REST";
        var lIns = db.lyte, 
        name = this.constructor._name;
        Object.defineProperty(this,'$lg', {
            value : lIns.__gl
        });   
        if(!db.getConnectorObj(name)){
            db.connector.REST = db.connector.REST || {}; 
            db.connector.REST[this.constructor._name] = this; 
        }
    }

    // static sendXHR(db,name,type,key,urlObj,customData,argsObj,opts){
    //     var xhr = new XMLHttpRequest();
    //     var prm = new Promise(function(res, rej){
    //         argsObj.xhr = xhr;
    //         xhr.open(urlObj.method, urlObj.url, true);
    //         for(var header in urlObj.headers){
    //             xhr.setRequestHeader(header, urlObj.headers[header]);
    //         }
    //         if(urlObj.data !== undefined && ( urlObj.headers && !urlObj.headers.hasOwnProperty("Content-Type") && urlObj.method !== "GET")){
    //             xhr.setRequestHeader("Content-Type", "application/json");
    //         }
    //         xhr.withCredentials = (urlObj.withCredentials)?true:false;
    //         initCB(db,"connector", name, RESTConnector.PARSEREQUEST, { argsObj: argsObj, args:[type, name, xhr ,urlObj ? urlObj.qP : undefined, key, customData]});
    //         db.emit("beforeRequest", [xhr, name, type, key, urlObj.qP]);
    //         xhr.send(urlObj.data);
    //         xhr.onreadystatechange = function(){
    //             if(xhr.readyState == 4){
    //                 db.emit("afterRequest",[xhr, name, type, key, urlObj.qP]);
    //                 argsObj.status = xhr.status;
    //                 RESTConnector.processResponse(db, xhr, type, name, argsObj, urlObj, key, customData, opts).then(function(data){
    //                     return res({data:data, xhr:xhr});
    //                 }, function(err){
    //                     return rej({data:err, xhr:xhr});
    //                 });
    //             }
    //         }
    //     });
    //     prm.xhr = xhr;
    //     return prm;
    // }
    static getHost(db, connector){
        
    }
    static buildURL(db,type,method,def,key,snapshot,queryParams,actionName,customData,url,argsObj){
        var adapter, name;
        if(def !== undefined){
            adapter = def.connector, name = def._name;
        }
        var schemaless = db.applicationConnector && db.applicationConnector.__type == "REST" ? db.applicationConnector.schemaless : undefined;
        if(typeof def == "string" && schemaless){
            name = def;
        }
        var host = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getFromCB)(db,"connector",adapter,"host"), 
        url = url || "", 
        makeBatch = db.$.makeBatch;
        argsObj.host = host;
        if(!url){
            if(!makeBatch){
                if(host !== undefined){
                    url += host;
                    if(host[host.length-1] != "/"){
                        url+="/";					
                    }
                }
            }
            var namespace = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getFromCB)(db,"connector",adapter,"namespace");
            if(namespace !== "" && namespace[namespace.length-1] != "/"){
                url+=namespace+"/";
                argsObj.namespace = namespace;
            }
            else{
                url+=namespace;
            }
            if(type != "batch"){
                if(def.endPoint){
                    url +=def.endPoint
                }
                else{
                    url+=name;
                }
                if(key && typeof key != "object"){
                    url+="/"+key;
                }	
            }
            if(type == "action" && def){
                var actionNamespace = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getFromCB)(db,"connector",adapter,"actionNamespace");
                if(actionNamespace !== "" && actionNamespace[actionNamespace.length-1] != "/"){
                    url+="/"+actionNamespace;
                }
                else{
                    url+=actionNamespace;
                }
                // url+="/"+getFromCB(db,"connector",adapter,"actionNamespace");
                var actions = def.actions, action = actions[actionName].endPoint ? actions[actionName].endPoint : actionName;
                url+="/"+action;
                argsObj.actionName = action;
            } else if(type == "batch"){
                url+=(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getFromCB)(db,"connector",undefined,"batchNamespace");
            }
        }
        if(!queryParams){
            queryParams = {};
        }
        var ret = {method : (method)? method : ""}, res;
        argsObj.url = url;
        argsObj.method = ret.method;
        argsObj.queryParams = queryParams;
        res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"connector", adapter, RESTConnector.REQUESTHEADERS, { argsObj: argsObj, args:[type, queryParams, customData, actionName, key]});
        if(res){
            ret.headers = res.data;
        }
        argsObj.headers = ret.headers;
        argsObj.cachedData = snapshot;
        res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"connector", adapter, RESTConnector.REQUESTURL, { argsObj: argsObj, args:[name, type, queryParams, snapshot, url,actionName,customData, key]});
        if(res){
            url = res.data;
        }
        argsObj.url = url;
        res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"connector", adapter, RESTConnector.REQUESTMETHOD, { argsObj: argsObj, args:[method, type, queryParams, customData, actionName, key]});
        if(res){
            ret.method = res.data;
        }
        argsObj.method = method;
        if(!makeBatch && Object.keys(queryParams).length){
            url+="?";
            var index = 0;
            for(var qKey in queryParams){
                if(index !== 0){
                    url+="&";
                }
                var res = queryParams[qKey];
                if(res && typeof res == "object"){
                    res = JSON.stringify(res);
                }
                url+=qKey+"="+encodeURIComponent(res);
                index++;
            }
        }
        if(adapter && adapter.withCredentials == true){
            ret.withCredentials = true;
        }
        ret.url = url;
        ret.qP = queryParams;
        return ret;
    }
    static get(db, type, def, key, queryParams, cacheQuery, customData, cacheData, unload, forceFetch){
        var name = def && def._name ? def._name : def, 
        argsObj = { type: type, schemaName : name, queryParams: queryParams, opts:{cacheData:cacheData !== undefined ? cacheData : true, cacheQuery:cacheQuery!== undefined ? cacheQuery : false, unload: unload!==undefined?unload:false, forceFetch: forceFetch!==undefined?forceFetch:false }, customData: customData, key: key}, 
        mdl = def,
        makeBatch = db.$.makeBatch, 
        defless = db.applicationConnector && db.applicationConnector.__type == "REST" ? db.applicationConnector.schemaless : undefined;
        if(defless && typeof def == "string"){
            var defobj = db.schemaless, _name = def; 
			def = defobj[_name] = defobj[_name] || {};
            def._name = _name;
        }
        if(mdl || ( typeof mdl == "string"  && defless === true)){
            RESTConnector.getConnector(db, def, argsObj, defless);
            RESTConnector.getSerializer(db, def, argsObj, defless);
            if(unload){
                if(key !== undefined){
                    db.dropEntity(def.def, key);
                }
                else{
                    db.dropAll(def.def);
                }
            }
            customData = customData == undefined ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getFromCB)(db,"connector", mdl.connector, "customData") : customData;
            var urlObj = this.buildURL(db, type, "GET", def, key, undefined, queryParams,undefined,customData,undefined,argsObj), 
            self = this,
            queryParams = urlObj.qP, 
            toCheckParams = (cacheQuery && typeof cacheQuery !== "boolean") ? cacheQuery : (queryParams && typeof queryParams == "object") ? queryParams : undefined;
            if(key == undefined && toCheckParams && db.schema.cachedQueries && db.schema.cachedQueries[name] && !forceFetch){
                var cachedQueries = db.schema.cachedQueries[name], 
                sendData;
                for(var i=0; i<cachedQueries.length; i++){
                    var qry = cachedQueries[i];
                    if(!qry.hasDeletedRecords){
                        var params = qry.cacheQuery;
                        if((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.compareData)(params, toCheckParams, true)){
                            sendData = [qry.data, "cache", undefined, qry.status];
                            break;
                        }
                    }
                }
                if(sendData){
                    return new Promise(function(resolve){
                        if(makeBatch){
                            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.addToCachedBatch)(db,Array.isArray(sendData) ? sendData[0][name] : sendData);
                        }
                        resolve(sendData);
                    });
                }
            }
            else if(key !== undefined && toCheckParams && db.schema.cachedRecordQueries && db.schema.cachedRecordQueries[name] && db.schema.cachedRecordQueries[name][key] && !forceFetch){
                var cachedQueries = db.schema.cachedRecordQueries[name][key], 
                sendData;
                for(var i=0; i<cachedQueries.length; i++){
                    var params = cachedQueries[i].cacheQuery;
                    if((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.compareData)(params, toCheckParams, true)){
                        sendData = [cachedQueries[i].data, "cache", undefined, cachedQueries[i].status];
                        break;
                    }
                }
                if(sendData){
                    return new Promise(function(resolve){
                        if(makeBatch){
                            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.addToCachedBatch)(db,Array.isArray(sendData) ? sendData[0][name] : sendData);
                        }
                        resolve(sendData);
                    });
                }
            }
            else if(!forceFetch){
                var scope = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cbScp)(db, def.connector, type == "getAll" ? RESTConnector.REFETCHALL : RESTConnector.REFETCH, "connector");
                if(scope){
                    var data, callRefetch = false;
                    if(key !== undefined){
                        data = db.cache.getEntity(mdl.def,key);		
                        callRefetch = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.isEntity)(data) ? true : false; 					
                    }
                    else{
                        data = db.cache.getAll(mdl.def);
                        callRefetch = data && data.length ? true : false;
                    }
                    argsObj.cachedData = data;
                    if(callRefetch && !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cB)(scope, [argsObj])){
                        var toRet = {};
                        toRet[name] = data;
                        return new Promise(function(resolve){
                            if(makeBatch){
                                (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.addToCachedBatch)(db,toRet[name]);
                            }
                            resolve([toRet, "cache"], "success", undefined, true);
                        });
                    }
                }
            }
            if(urlObj.method == "POST"){
                var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"serializer", mdl.serializer, _RESTSerializer_js__WEBPACK_IMPORTED_MODULE_3__.RESTSerializer.SERIALIZE, { argsObj: argsObj, args:[type,undefined,undefined,customData,name,queryParams]});
                if(res){
                    urlObj.data = res.data;
                    if(urlObj.data && (typeof urlObj.data == "object" || (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.isEntity)(urlObj.data) || Array.isArray(urlObj.data)) && !(urlObj.data instanceof FormData)){
                        // urlObj.reqData = Lyte.deepCopyObject(urlObj.data);
                        urlObj.data = JSON.stringify(urlObj.data);
                    }
                    argsObj.data = urlObj.data;
                }
            }
            var prmXhr;
            var prm = new Promise(function(resolve, reject){
                var idbObj = db.idbIns ? db.idbIns.getIDBObj(def, queryParams, type, key, customData) : undefined, 
                processRequest = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getFromCB)(db,"connector", def ? def.connector : undefined, RESTConnector.PROCESSREQUEST),payLoad, sendXHR = true, 
                batchPro = false, 
                opts = { cacheQuery : cacheQuery, cacheData : cacheData, customD : customData},
                argsXHR = [db,name,type,key,urlObj,customData,argsObj,opts];
                if(processRequest){
                    sendXHR = false;
                    var returnPromise = self.callGeneric(db,type,def,undefined,undefined,customData, queryParams,key,urlObj.url,undefined,urlObj.method,urlObj.headers,argsObj);
                    if(returnPromise instanceof Promise){
                        batchPro = true;
                        returnPromise.then(function(resp){
                            resp = (resp == "" ? JSON.parse("{}") : JSON.parse(resp));
                            payLoad = _RESTSerializer_js__WEBPACK_IMPORTED_MODULE_3__.RESTSerializer.getResponse(db,resp,def,type,key,urlObj,undefined,customData,opts,argsObj);
                            resolve([payLoad]);
                        },function(message){
                            reject(message);
                        });
                    }
                    else{
                        sendXHR = true;
                    }
                }
                if(makeBatch && !batchPro){
                    RESTConnector.constructBatch.apply(RESTConnector, argsXHR).then(function(resObj){
                        var payLoad = resObj.content;
                        RESTConnector.getSuccess(db,def,type,key,urlObj,undefined,resolve,reject,payLoad,resObj,undefined,opts,argsObj);
                    },function(resObj){
                        RESTConnector.getFailure(db,def,type,key,urlObj,undefined,resolve,reject,opts,resObj.content,resObj.code,argsObj,resObj);
                    });
                }
                else if(idbObj && db.idbIns){
                    db.idbIns.getFromIDB(idbObj, name, type, queryParams, key, urlObj, customData).then(function(payLoad){
                        argsObj.payLoad = payLoad;
                        var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"serializer", def.serializer, _RESTSerializer_js__WEBPACK_IMPORTED_MODULE_3__.RESTSerializer.IDBRESPONSE, { argsObj: argsObj, args:[name, type, queryParams, key, payLoad]});
                        if(res){
                            payLoad = res.data;
                            argsObj.payLoad = payLoad;
                        }
                        if(payLoad == false){
                            var xhrPrm = RESTConnector.sendXHR.apply(RESTConnector, argsXHR);
                            xhrPrm.then(function(resp){
                                RESTConnector.getSuccess(db,def,type,key,urlObj,resp,resolve,reject,undefined,undefined,undefined,opts,argsObj);
                            }, function(resp){
                                RESTConnector.getFailure(db,def,type,key,urlObj,resp,resolve,reject,opts,undefined,undefined,argsObj);
                            });	
                            prmXhr = xhrPrm.xhr;						
                        }
                        else{
                            RESTConnector.getSuccess(db, def,type,key,urlObj,undefined,resolve,reject,payLoad,undefined,"idb",opts,argsObj);
                        }
                    },function(message){
                        var xhrPrm = RESTConnector.sendXHR.apply(RESTConnector, argsXHR);
                        xhrPrm.then(function(resp){
                            RESTConnector.getSuccess(db, def,type,key,urlObj,resp,resolve,reject,undefined,undefined,undefined,opts,argsObj);
                        }, function(resp){
                            RESTConnector.getFailure(db,def,type,key,urlObj,resp,resolve,reject,opts,undefined,undefined,argsObj);
                        });		
                        prmXhr = xhrPrm.xhr;					
                    });
                }
                else if(sendXHR){
                    var xhrPrm = RESTConnector.sendXHR.apply(RESTConnector, argsXHR);
                    xhrPrm.then(function(resp){
                        RESTConnector.getSuccess(db, def,type,key,urlObj,resp,resolve,reject,undefined,undefined,undefined,opts,argsObj);
                    },function(resp){
                        RESTConnector.getFailure(db,def,type,key,urlObj,resp,resolve,reject,opts,undefined,undefined,argsObj);
                    });
                    prmXhr = xhrPrm.xhr;
                }
            });
            if(prmXhr){
                prm.xhr = prmXhr;
            }
            return prm;
        }
        else {
            Dberror.error(db.lyte,"LD02","Schema",name);
            return Promise.reject({code : "ERR19", message : Dberror.errorCodes.ERR19, data:name});
        }
    }
    static create(db, name, data, isSingleRecord, customData, qP){
        var type= isSingleRecord ? "createEntity": "create", 
        def = db.schema[name], 
        argsObj = { type: type, schemaName : name, queryParams: qP, customData: customData};
        customData = customData == undefined ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getFromCB)(db,"connector", def.connector, "customData") : customData;
        var urlObj = this.buildURL(db, type, "POST", def, undefined, data,qP,undefined,customData,undefined,argsObj);
        qP = urlObj.qP;
        var partial = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initPartialObj)(db, name, type, qP, undefined, urlObj.url, customData, argsObj);
        var changedData = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toJSON)(db, name, data, undefined, "create", partial);
        _RESTSerializer_js__WEBPACK_IMPORTED_MODULE_3__.RESTSerializer.sendingData(db, name, changedData, urlObj, type, customData, data, argsObj,partial.obj);
        return this.handleRequest(db, urlObj, name, data, type, changedData, customData, partial.obj, undefined, undefined, partial.ref, argsObj);
    }
    static put(db, name, data, record, isSingleRecord,customData, qP){
        var def = db.schema[name], 
        bK = def.bK , 
        isComp = def.isComp, 
        type = (isSingleRecord) ? "updateEntity" : "update", 
        partialObj = new Map(), 
        key = isSingleRecord ? (isComp && bK ? record[bK] : record.$.pK) : undefined, 
        argsObj = { type: type, schemaName : name, queryParams: qP, customData: customData, key: key};
        customData = customData == undefined ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getFromCB)(db,"connector", def.connector, "customData") : customData;
        var urlObj = this.buildURL(db, type, "PATCH", def, key, data, qP, undefined, customData, undefined, argsObj);
        qP = urlObj.qP;
        var partial = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initPartialObj)(db, name, type, qP, key, urlObj.url, customData, argsObj);
        var updatedData = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toJSON)(db, name, data, undefined, undefined, partial);
        _RESTSerializer_js__WEBPACK_IMPORTED_MODULE_3__.RESTSerializer.sendingData(db, name, updatedData, urlObj, type, customData, record, argsObj,partial.obj);
        return this.handleRequest(db, urlObj, name, record, type, updatedData, customData, partial.obj,key, undefined, partial.ref, argsObj);
    }
    static del(db, name, data, isSingleRecord, destroy, customData, qP){
        var def = db.schema[name], 
        bK = def.bK , 
        isComp = def.isComp, 
        type = destroy || "deleteEntity", 
        key = isSingleRecord ? (isComp && bK ? data[bK] : data.$.pK) : undefined, 
        argsObj = { type: type, schemaName : name, queryParams: qP, customData: customData, key: key};
        customData = customData == undefined ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getFromCB)(db,"connector", def.connector, "customData") : customData;
        var urlObj = this.buildURL(db, type, "DELETE", def, key, data,qP,undefined,customData,undefined,argsObj);
        qP = urlObj.qP;
        var partial = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initPartialObj)(db, name, type, qP, key, urlObj.url, customData, argsObj);
        var ids = [];
        if(!isSingleRecord){
            ids = data.map(function(val){
                return val.$.pK;
            });				
        }
        var pkVal = (isSingleRecord) ?  (data ? data.$.pK : undefined) : ids;
        _RESTSerializer_js__WEBPACK_IMPORTED_MODULE_3__.RESTSerializer.sendingData(db, name, pkVal, urlObj, type, customData, data, argsObj,partial.obj);
        return this.handleRequest(db, urlObj, name, data, type, pkVal, customData, undefined, key, undefined, undefined, argsObj);
    }
    static handleAjax(obj){
        if(obj.url){
            if(!obj.schema){
                Dberror.error(obj.db.lyte,"Please pass schema param to db.ajax call");
                return Promise.reject("Please pass schema param to db.ajax call");
            }
        }
        var argsObj = { type: "ajax", schemaName : obj.schema, queryParams: obj.queryParams, customData: obj.customData}
        var urlObj = RESTConnector.buildURL(obj.db, "ajax", obj.type, obj.schema, obj.index, undefined, obj.queryParams, undefined, obj.customData, obj.url, argsObj);
        urlObj.data = obj.data;
        var qP = urlObj.qP, res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(obj.db,"serializer", obj.schema, _RESTSerializer_js__WEBPACK_IMPORTED_MODULE_3__.RESTSerializer.SERIALIZE, { argsObj: argsObj, args:["ajax",urlObj.data,undefined,obj.customData,obj.schema,qP,undefined]});
        if(res){
            argsObj.data = urlObj.data = res.data;
        }
        return RESTConnector.handleRequest(obj.db, urlObj, obj.schema, undefined, "ajax",undefined,obj.schema,undefined,undefined,undefined,undefined,argsObj);
    }
    static handleAction(db,actionName,def,record,customData,qP,method,data){
        var pkVal;
        if(record && (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.isEntity)(record)){
            pkVal = record.$.get(def._pK);				
        }
        var name = def._name, 
        type = "action", 
        argsObj = { type: type, schemaName : name, queryParams: qP, customData: customData, actionName:actionName}
        RESTConnector.getConnector(db, def, argsObj);
        RESTConnector.getSerializer(db, def, argsObj);
        customData = customData == undefined ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getFromCB)(db,"connector", def ? def.connector : undefined, "customData") : customData;
        var urlObj = this.buildURL(db,type, method ? method : "POST", def, pkVal, record, qP, actionName, customData, undefined, argsObj);
        argsObj.data = urlObj.data = data, qP = urlObj.qP;
        var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"serializer", def.serializer, _RESTSerializer_js__WEBPACK_IMPORTED_MODULE_3__.RESTSerializer.SERIALIZE, { argsObj: argsObj, args:["action",data,record,customData,name,qP,actionName]});
        if(res){
            argsObj.data = urlObj.data = res.data;
        }
        return this.handleRequest(db, urlObj, def._name, undefined, type,undefined,customData,undefined,undefined,actionName,undefined,argsObj);
    }
    static callGeneric(db, type, def, data, record, customData, queryParams, key, url, actionName, method, headers, argsObj){
        var name = def && def._name ? def._name : def;
        argsObj.cachedData = record;
        var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"connector", def.connector, RESTConnector.PROCESSREQUEST, {argsObj:argsObj, args:[type,name,data,record,customData,queryParams,key,url,actionName,method,headers]});
        return res ? res.data : undefined;
    }
    static handleBatchPromise(obj){
        var response = obj.response,
        db = obj.db, 
        batch = obj.batch, 
        fail = obj.fail;
        //callback
        obj.argsObj.payLoad = response;
        if(!fail){
            var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"serializer", undefined, _RESTSerializer_js__WEBPACK_IMPORTED_MODULE_3__.RESTSerializer.NORMALIZE, {argsObj:obj.argsObj, args:[undefined,"batch",obj.response]});
            if(res){
                response = res.data;
            }
    
            var resp = response.batch_requests;
            resp.forEach(function(item, index){
                var pro = db.$.batchPromise[batch][index];
                var status = item.status.toString();
                var code = status[0];
                if(code == "2"){
                    pro.resolve({content:item.content,index:index,batch:batch,resp:item});
                }
                else if(code == "4" || code == "5"){
                    db.$.batchResponse[batch][index] = undefined;
                    pro.reject({content:item.content,index:index,batch:batch,resp:item,code:status});
                }
            });
        }
        else{
            var prmArr = db.$.batchPromise[batch];
            prmArr.forEach(function(itm, idx){
                itm.reject({content:{}, index: idx, batch:batch, code:"400",resp:{}})
            });
        }
        // obj.resolve(response);
        delete db.$.batch[batch];
        delete db.$.batchPromise[batch];
    }
    static constructBatch(db,name,type,key,urlObj,customData){
        return new Promise(function(resolve, reject){
            var batch = db.$.currentBatch;
            var q = db.$.batch[batch] = db.$.batch[batch] || [];
            var pro = db.$.batchPromise[batch] = db.$.batchPromise[batch] || []; 
            var batchObj = {};
            batchObj.method = urlObj.method;
            batchObj.uri = "/" + urlObj.url;
            batchObj.parameters = urlObj.qP;
            batchObj.content = typeof urlObj.data == "string" ? JSON.parse(urlObj.data) : undefined;
            q.push(batchObj);
            pro.push({resolve:resolve,reject:reject});	
        });
    }
}
RESTConnector.__lMod = "RESTConnector";
RESTConnector.returnData = "old";
RESTConnector.PARSEREQUEST = "parseRequest";
RESTConnector.REQUESTURL = "requestURL";
RESTConnector.REQUESTHEADERS = "requestHeaders";
RESTConnector.REQUESTMETHOD = "requestMethod";
RESTConnector.REFETCHALL = "refetchAll";
RESTConnector.REFETCH = "refetchEntity"
RESTConnector.PROCESSREQUEST = "processRequest";
RESTConnector.PARSERESPONSE = "parseResponse";

RESTConnector.JSON = /application\/json/;
RESTConnector.TEXT = /text\/plain/;
RESTConnector.__extendedBy = [];


/***/ }),

/***/ 64160506:
/*!********************************************************!*\
  !*** ./node_modules/@slyte/data/src/RESTSerializer.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RESTSerializer": () => (/* binding */ RESTSerializer)
/* harmony export */ });
/* harmony import */ var _Serializer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Serializer */ 73771730);


/*convert to custom class*/
class RESTSerializer extends _Serializer__WEBPACK_IMPORTED_MODULE_0__.Serializer {
    static register(parent){
        // this.__class = RESTSerializer;
        // var name = this._name = dbModName(this.name, "Serializer");
    }
    constructor(db){
        super();
        this.__type = "REST";
        var lIns = db.lyte,
        name = this.constructor._name;
        Object.defineProperty(this,'$lg', {
            value : lIns.__gl
        });
        this.deserializeEmptyData = true;
        if(!db.getSerializerObj(name)){
            db.serializer.REST = db.serializer.REST || {}; 
            db.serializer.REST[name] = this; 
        }
    }
}

RESTSerializer.__lMod = "RESTSerializer";
RESTSerializer.PROCESSENTITY = "processEntity";
RESTSerializer.NORMALIZE = "normalizePayload";
RESTSerializer.SERIALIZE = "serializePayload";
RESTSerializer.SERIALIZEKEY = "serializeKey";
RESTSerializer.NORMALIZEKEY = "normalizeKey";
RESTSerializer.SERIALIZEENTITY = "serializeEntity";
RESTSerializer.NORMALIZEENTITY = "normalizeEntity";
RESTSerializer.DESERIALIZEKEY = "deserializeKey";
RESTSerializer.GETMETA = "getMeta";
RESTSerializer.IDBRESPONSE = "idbResponse";
RESTSerializer.REFERENCEKEY = "referenceKey";
RESTSerializer.__extendedBy = [];



/***/ }),

/***/ 84879490:
/*!************************************************!*\
  !*** ./node_modules/@slyte/data/src/Schema.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Schema": () => (/* binding */ Schema)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ 84646139);
/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Entity.js */ 88519247);
/* harmony import */ var _slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @slyte/core/src/lyte-utils.js */ 60768251);
/* harmony import */ var _dberror_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dberror.js */ 82718186);






class Schema {
    static observers(arg){
        return arg;
    }
    static actions(arg){
        return arg;
    }
    static prop(type, opts){
        if(opts && typeof opts !== "object"){
            console.error("second param should be a object");
        }
        opts = opts || {};
        var obj = Object.assign({},opts);
        obj.type = type;
        return obj;
    }
    static register(opts){
        var rHash = opts.refHash;
        var schCls = this, 
        dbMap = Schema.db = Schema.db || new Map(),  
        schMap,
        schClsName = schCls.name;
        if(!dbMap.has(rHash)){
            dbMap.set(rHash, new Map());
        }
        schMap = dbMap.get(rHash);
        if(!schMap.has(schClsName)){
            schMap.set(schCls.name, schCls);
        }
        Schema.triggerEvent(rHash, schCls);
    }
    static registerInDb(opts, parent){
        this.__class = Schema;
        var name;
        if(this.schemaName){
            name = this._name = this.schemaName;
        }   
        else{
            name = opts && opts.name? opts.name : this.name;
            name = this._name = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.dbModName)(name, "Schema", opts && opts.name ? false : true);
        }
        parent = parent || Object.getPrototypeOf(this);
        if(!parent.schema.hasOwnProperty(name)){
            parent.schema[name] = this;
            this.opts = opts;
            if(parent.schema.triggerEvent){
                parent.schema.triggerEvent("add", name, this);
            }
        }
        else{
            _dberror_js__WEBPACK_IMPORTED_MODULE_1__.Dberror.warn("Schema with the same name - "+ name+ " already present in the db");
        }        
    }
    static create(db, lIns){
        var _this = {}, 
        parent = Object.getPrototypeOf(this);
        parent = parent !== db.constructor.Schema && parent !== Schema ? parent : undefined;
        (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.extendEventListeners)(_this);
        Object.defineProperty(_this, "emit", {
            value: function(name, args){
                var arr = Array.isArray(args) ?  Array.from(args) : [];
                arr.splice(0, 0, name);
                _this.triggerEvent.apply(this, arr);
            }
        });
        var name = _this._name = this._name;
        var delay = this.opts && this.opts.delay ? this.opts.delay : undefined;
        _this.db = db;
        _this.Lyte = lIns;
        _this.__class = Schema;
        _this.fieldList = {id : {type : "string", primaryKey : true, defined : false}};
        _this.relations = new Map();
        _this._properties = {};
        _this._fldGrps = { default : {}, hasMany: {}, watch: {}, inherit:{} ,nested_prop: {}, reverseKey: new Map() , JsonPathWatch : {} };
        _this.data = [];
        _this.dirty = [];
        _this._deleted = new Map();
        _this.events = {};
        _this.def = this;
        _this.endPoint = this.endPoint;
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._defProp)(_this.data, "_recMap", new Map());
		// _defProp(_this, "db", db);
        
        var obs = [], self = _this, _self = this;
        function _props(){
            delete self._pK;
            delete self._arrPk;
            var parentProps = {};
            if(parent && parent.props){
                parentProps = parent.props(lIns);
                for(var key in parentProps){
                    if(parentProps[key].type == "relation"){
                        delete parentProps[key];
                    }
                }
            }
            var fields = Object.assign(parentProps, _self.prototype.props(lIns));            
            for(var key in fields){
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.registerField)(db,self,key,fields[key],obs);
            }
            if(!self._pK){
                self._pK = 'id';
            }    
            self.isComp = false;
            var splt = self._pK.split(',');
            if(splt.length > 1){
                self.isComp = true;
            }
            self._arrPk = splt;    
            // delete _self.prototype.props;    
        }
        var self = _this;
        db.schema[_this._name] = _this;
        if(this.prototype.props){
            if(delay){
                setTimeout(_props,1)
            }
            else{
                _props();
            }
        }
        if(this.prototype.actions){
            var parentAct = {};
            if(parent && parent.actions){
                parentAct = parent.actions() || {};
            }
            Object.defineProperty(_this, "actions", {
                value: Object.assign(parentAct, this.prototype.actions() || {})
            });
            // _this.actions = Object.assign(parentAct, this.prototype.actions());
        }
        if(this.observers){
            var parentObs = {};
            if(parent && parent.observers){
                parentObs = parent.observers() || {};
            }
            var obj = Object.assign(parentObs, this.observers() || {});
            for(var key in obj){
                obs.push(obj[key]);
            }
        }
        _this.didLoad = _this.didLoad || [];
        if(this.prototype.didLoad){
            _this.didLoad.push(this.prototype.didLoad);
        }
        if(this.prototype.idb){
            _this.idb = this.prototype.idb;
        }
        if(!_this._pK){
            _this._pK = 'id';
        }
        _this.isComp = false;
        var splt = _this._pK.split(',');
        if(splt.length > 1){
            _this.isComp = true;
        }
        _this._arrPk = splt;
        (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.establishObserverBindings)(obs,true,_this._properties, _this);
        (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.establishWatchScope)(_this._fldGrps.JsonPathWatch,_this)
        ;(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.defArrUtls)(_this.data);
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.defUtls)(_this.data, _this);
        if(parent){
            _utils_js__WEBPACK_IMPORTED_MODULE_0__.extendDef.apply(self, [db.getSchemaObj(parent._name), undefined, db]);
        }
        else if(this.prototype.polymorphic){
            var pArr = this.prototype.polymorphic();
            pArr.forEach(function(itm, idx){
                _utils_js__WEBPACK_IMPORTED_MODULE_0__.extendDef.apply(db.getSchemaObj(itm._name), [self, undefined, db]);
            });
        }
        delete _this.connector;
        delete _this.serializer;
        var self = _this;
        if(this.Connector){
            if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isInheritedClass)(this.Connector, db.constructor.ConnectorCls)){
                _this.Connector = this.Connector;
                var cname = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.dbModName)(this.Connector.name, "Connector");
                if(cname === "application"){
                    var aIns;
                    lIns.scopedInstance(this.Connector, [db], function(ins){
                        self.connector = ins;
                        aIns = ins;
                    }, [db]);
                    var context = aIns.__type
                    db.Connector[context] = db.Connector[context] || {};
                    db.Connector[context][cname] = _self.Connector;
        
                    db.connector[context] = db.connector[context] || {}; 
                    db.connector[context].application = aIns;
                }
                else{
                    lIns.scopedInstance(this.Connector, [db], function(ins){
                        self.connector = ins;
                    }, [db]);
                    var context = self.connector.__type;
                    db.Connector[context] = db.Connector[context] || {};
                    db.Connector[context][cname] = _self.Connector;
                }
    
                // _this.connector = new this.Connector(lIns); 
            }
        }
        else if(db.applicationConnector){
            self.connector = db.applicationConnector;
        }
        if(this.Serializer){
            if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isInheritedClass)(this.Serializer, db.constructor.SerializerCls)){
                _this.Serializer = this.Serializer;
                var sname = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.dbModName)(this.Serializer.name, "Serializer");
                if(sname === "application"){
                    var asIns;
                    lIns.scopedInstance(this.Serializer, [db], function(ins){
                        self.serializer = ins;
                        asIns = ins;
                    }, [db]);
                    var context = asIns.__type
    
                    db.Serializer[context] = db.Serializer[context] || {};
                    db.Serializer[context][sname] = _self.Serializer;
        
                    db.serializer[context] = db.serializer[context] || {}; 
                    db.serializer[context].application = asIns;
                }
                else{
                    lIns.scopedInstance(this.Serializer, [db], function(ins){
                        self.serializer = ins;
                    }, [db]);
                    var context = self.serializer.__type
                    db.Serializer[context] = db.Serializer[context] || {};
                    db.Serializer[context][sname] = _self.Serializer;
                }
            }
        }
        else if(db.applicationSerializer){
            self.serializer = db.applicationSerializer;
        }
        _this.cache = {
            get : function(){
                var args = _utils_js__WEBPACK_IMPORTED_MODULE_0__.schArgs.apply(self, arguments);
                return self.db.cache.get.apply(self.db.cache, args);
            },
            getAll: function(){
                var args = _utils_js__WEBPACK_IMPORTED_MODULE_0__.schArgs.apply(self, arguments);
                return self.db.cache.getAll.apply(self.db.cache, args);
            },
            drop : function(){
                var args = _utils_js__WEBPACK_IMPORTED_MODULE_0__.schArgs.apply(self, arguments);
                return self.db.drop.apply(self.db.cache, args);
            },
            dropAll : function(){
                var args = _utils_js__WEBPACK_IMPORTED_MODULE_0__.schArgs.apply(self, arguments);
                return self.db.dropAll.apply(self.db.cache, args);
            }
        }
        delete this.prototype.actions;
        delete this.prototype.didLoad;
        delete this.prototype.includes;
        delete this.prototype.idb;
        return _this;
    }
    constructor(data, opts, db){
        // super();
        var def = this.constructor;
        def = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getSchemaObj)(db, def);
        var delayPers = opts && opts.hasOwnProperty("delayPersistence") ? opts.delayPersistence : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getFromCB)(db,"connector", def.connector, "delayPersistence");
        Object.assign(this, data);
        Object.defineProperties(this, {
            $ :{
                writable : true,
                value : new _Entity_js__WEBPACK_IMPORTED_MODULE_3__.$Entity(this, def, delayPers, db)
            }
        });
        var parent = db.$.saveParent;
        if(parent && this !== parent){
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._defProp)(this.$, "parent", parent);
        }
        var defF = def._fldGrps.default;
        var watchF = def._fldGrps.watch;
        var hasManyF = def._fldGrps.hasMany;
        var nested_prop = def._fldGrps.nested_prop;
        for(var dKey in defF){
            var dFld = defF[dKey];
            var fldVal = data[dKey];
            if(fldVal === undefined || fldVal === ""){
                this[dKey] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getDefaultVal)(this, dFld.default);
            }
        }
        for(var wKey in watchF){
            (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.establishObjectBinding)(this, wKey, true, undefined, undefined, true);
        }
        for(var nest in nested_prop){
            (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.establishObjectBinding)(this,nest,true , undefined , undefined ,  true);
        }
        for(var hKey in hasManyF){
            var hFld = hasManyF[hKey];
            if(this.hasOwnProperty(hKey)){
                this[hKey] = Array.isArray(this[hKey]) ? Array.from(this[hKey]) : this[hKey];
            }
            else if(hFld.relatedTo){
                var toInit = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getFromCB)(db,"serializer", (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getSchemaObj)(db, hFld.relatedTo).serializer, "initHasManyRelation");
                if(toInit){
                    this[hKey] = [];
                }
            }
        }
        var props = def._properties;
        if(Object.keys(props).length){
            if(!this._bindings){
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._defProp)(this, '_bindings', new Set(), false, true, true);
            }
            this._bindings.add(props);
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.establishObsBindings)(this,props);
        }
    }
    static addEventListener(type, func){
        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.evAdd)(this,type,func);
    }
    static removeEventListener(id){
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.evRemove)(this,id);
    }
    static emit(type, args){
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.evEmit)(this,type,args);
    }
    static on(type,func){
        return this.addEventListener(type,func);
    }
    /**
     * To get a data from the server.
     * @param {Object} obj - arguments object.
     * @param {string} obj.schema - schema.
     * @param {string} obj.pK - pK.
     * @return A promise which will be resolved on success and rejected on failure
    */
}

Schema.__lMod = "Schema";

(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.extendEventListeners)(Schema);




/***/ }),

/***/ 73771730:
/*!****************************************************!*\
  !*** ./node_modules/@slyte/data/src/Serializer.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Serializer": () => (/* binding */ Serializer)
/* harmony export */ });
/* harmony import */ var _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/core/src/service */ 76099455);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ 84646139);
/* harmony import */ var _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @slyte/core/src/lyte-utils */ 60768251);




/*convert to custom class*/
class Serializer extends _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_0__.Service {
    constructor(){
        super();
        this.constructor._name = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.dbModName)(this.constructor.name, "Serializer");
    }
    static genericResponse(db,resp,def,type,data,urlObj,xhr,partialObj,customData,partialRef,argsObj){
        var response = resp, 
        name = def && def._name ? def._name : def,
        status = xhr ? xhr.status : undefined, 
        scope, 
        args, 
        qP = urlObj ? urlObj.qP : undefined, extractMetaCall;
        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer;
        scope = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cbScp)(db, def ? def.serializer : undefined, baseSerz.GETMETA, "serializer");
        if(scope){
            if(response){
                var metaRes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cB)(scope, [argsObj]);
                if(!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(metaRes)){
                    argsObj.meta = response.meta = metaRes;    
                }
                extractMetaCall = true;
            }
            else{
                extractMetaCall = false;
            }
        }
        if(response && type != "action" && type != "ajax"){
            response = baseSerz.buildJSON(db, def, type, response, (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.isEntity)(data) ? data[db.getSchemaObj(name)._pK] :undefined ,xhr ? xhr.status : undefined, urlObj, customData, qP, argsObj);
            if( extractMetaCall == false && scope && response ){
                var metaRes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cB)(scope, [argsObj]);
                if(!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(metaRes)){
                    response.meta = metaRes;
                }
            }
            var keys = Object.keys(response);
            var len = keys.length;
            /* Internal release
            scope = cbScp(db, def ? def.serializer : undefined, RESTSerializer.DESERIALIZEKEY, "serializer");
            if(scope){
                db.lyte.warn("LD08", "deserializeKey", "callback", "Please use normalizeKey callback instead");
                if(len > 2){
                    db.lyte.error("LD09");
                }
                    var index = 0;
                    if(keys[0] == "meta"){
                        index = 1;
                    }
                    var deserializeKey = cB(scope, [argsObj]), rec = response[keys[index]];
                    delete response[keys[index]];
                    response[deserializeKey] = rec;	
            } 
            */	
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.handleResponse)(db, data, response, def, type, partialObj, undefined, partialRef);
        }
        return response;
    }
    static getResponse(db,resp,def,type,key,urlObj,xhr,customData,opts,argsObj){
        var name = def && def._name ? def._name : def,
        scope, 
        payLoad, 
        args, 
        qP = urlObj ? urlObj.qP : undefined;
        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer;
        var doNormalize = opts.cacheData !== undefined && opts.cacheData !== null && typeof opts.cacheData == "object" && opts.cacheData.hasOwnProperty("normalize")  ? opts.cacheData.normalize : true;
        if(doNormalize){
            resp = baseSerz.normalizeResponse(db, def, type, resp, key, xhr ? xhr.status : xhr, urlObj,customData,opts,argsObj)
            payLoad = resp;
            if(payLoad && typeof payLoad != "object"){
                payLoad = JSON.parse(payLoad);
                argsObj.payLoad = payLoad;
            }
            var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"serializer", def.serializer, baseSerz.GETMETA, { argsObj: argsObj, args:[payLoad,name,type,qP,customData,opts]}), metaRes;
            if(res){
                metaRes = res.data;
                if(!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(metaRes)){
                    payLoad.meta = metaRes;
                    argsObj.meta = payLoad.meta;
                }	
            }
            var keys = Object.keys(payLoad);
            var len = keys.length; 
            if(len){			
                res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"serializer", def.serializer, baseSerz.NORMALIZEKEY, { argsObj: argsObj, args:[name,type,key,qP,customData,opts]});
                var plKey;
                if(res){
                    plKey = res.data;
                    if(plKey && plKey != name){
                        var temp = payLoad[plKey];
                        payLoad[name] = temp;
                        delete payLoad[plKey];
                    }
                }
                /* Internal release
                scope = cbScp(db,def.serializer, RESTSerializer.DESERIALIZEKEY, "serializer");
                if(scope){
                    db.lyte.warn("LD08", "deserializeKey", "callback", "Please use payloadKey callback instead");
                    if(len > 2){
                        db.lyte.error("LD09");
                    }
                    var index = 0;
                    if(len == 2 && keys[0] == "meta"){
                        index = 1;
                    }
                    args = [name,type];
                    var deserializeKey = cB(scope, [argsObj]), rec = payLoad[keys[index]];
                    delete payLoad[keys[index]];
                    payLoad[deserializeKey] = rec;
                }
                */
                baseSerz.normalize(
                    db,
                    def,
                    type,
                    payLoad,
                    key,
                    xhr ? xhr.status : xhr,
                    urlObj.headers,
                    customData,
                    opts,
                    urlObj,
                    argsObj
                );
            }
            return payLoad;
        }
        else{
            payLoad = resp
            if(payLoad && typeof payLoad != "object"){
                payLoad = JSON.parse(payLoad);
                argsObj.payLoad = payLoad;
            }
            var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"serializer", def.serializer, baseSerz.GETMETA, { argsObj: argsObj, args:[payLoad,name,type,qP,customData,opts]}), metaRes;
            if(res){
                metaRes = res.data;
                if(!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(metaRes)){
                    payLoad.meta = metaRes;
                    argsObj.meta = payLoad.meta;
                }	
            }
            return payLoad;
        }
    }
    static sendingData(db,name,data,urlObj,type,customData,snapshot,argsObj,partial){
        var serializeKey = name, 
        payload = {}, 
        qP = urlObj ? urlObj.qP : undefined, 
        tempObj = {},
        def = db.schema[name];
        for (var key in urlObj){
            tempObj[key] = urlObj[key];
        }
        tempObj.type = type;
        tempObj.schema = name;
        argsObj.data = data;
        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer;
        var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"serializer", def.serializer, baseSerz.SERIALIZEKEY, { argsObj: argsObj, args:[name,type,customData,qP]});
        if(res){
            serializeKey = res.data;
        }
        data = baseSerz.serializeRecords(db,def,data,snapshot,tempObj,"serializeEntity",customData,argsObj,partial);
        if(!serializeKey){
            payload = data;
        }
        else if(Array.isArray(data) || typeof data == "object" || (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.isEntity)(data)){
            payload[serializeKey] = data;
        }
        argsObj.data = payload;
        var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"serializer", def.serializer, baseSerz.SERIALIZE, { argsObj: argsObj, args:[type,payload,snapshot,customData,name,qP]});
        if(res){
            argsObj.data = payload = res.data;
        }   
        urlObj.data = payload;
    }
    static serializeRecords(db,schema,data,records,urlObj,type,customData,argsObj,partial){
        var defless = db.applicationConnector && db.applicationConnector.__type == "REST" ? db.applicationConnector.schemaless : undefined;
        if(!schema && defless){
            return data;
        }
        var rels = schema.relations;
        if(!records && type != "normalizeEntity"){
            records = db.cache.getEntity(schema.def, data.$.pK);
        }
        var result, 
        baseSerz = schema && schema.serializer ? schema.serializer.constructor : db.constructor.Serializer;
        if(Array.isArray(data)){
            result = [];
            for(var index1=0;index1<data.length;index1++){
                var record = data[index1];
                if(record && typeof record === "object")
                {
                    result.push(baseSerz.serializeSingleRecord(db,schema,record,records ? records[index1]:undefined,urlObj,rels,type,customData,argsObj,partial));
                }
                else{
                    result.push(record);
                }
            }
        }
        else if(data){
            result = data;
            if(data && typeof data === "object"){
                result = baseSerz.serializeSingleRecord(db,schema,data,records,urlObj,rels,type,customData,argsObj,partial)
            }
        }
        return result;
    }
    static serializeSingleRecord(db,def,data,record,urlObj,rels,type,customData,argsObj,partial){
        var partObj;
        type == "serializeEntity" && typeof data == "object" && data.$ == undefined ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._defProp)(data, "$", {}): data;
        if(typeof partial == "object" && record && record.$ && record.$.pK){
            partObj = partial.get ? partial.get(record.$.pK):partial;
            if(data.$ && data.$._partialObj){
                var data$; 
                data$ = Object.assign({}, data.$);
                data = Object.assign({}, data);
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._defProp)(data, "$", data$);
            }
            var relDirty =  (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isDirty)(db,record,record.$.schema.relations);
            if(record.$.isModified || (Array.isArray(relDirty) && relDirty.length != 0)){
                var dirtAttr = record.$.getDirtyProps();
                Array.isArray(relDirty) && dirtAttr.concat(relDirty);
                var keys = Object.keys(data);
                !partObj.hasOwnProperty("_removedAttr")?Object.defineProperties(partObj,{_removedAttr : {value : {} }}):undefined; 
                dirtAttr.forEach(function(val){
                    if(!keys.includes(val) && !record.$.schema._arrPk.includes(val)){
                        partObj._removedAttr[val] = true;
                    }
                })
            }
            var name = def && def._name ? def._name : def;
            Object.defineProperties(data.$,{
                _partialObj:{
                    value:partObj
                },
                _pkVal:{
                    value:record.$.pK
                },
                _schema:{
                    value:name
                },
                _payloadObj:{
                    value:data
                }
            })
        }
        type == "serializeEntity" ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.defpayObjUtls)(db,data.$) : undefined;
        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer, 
        scope = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cbScp)(db,def.serializer,type == "serializeEntity" ? baseSerz.SERIALIZEENTITY : baseSerz.NORMALIZEENTITY,"serializer");
        if(scope){
            var args;
            var oPLoad = argsObj.payLoad
            if(type == "serializeEntity"){
                argsObj.entityData = data;
                argsObj.cachedData = record;
                args = [argsObj];
            }
            else{
                argsObj.entityData = data;
                argsObj.entityPayload = data;
                args = [argsObj];
            }
            data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cB)(scope,args);
            argsObj.payLoad = oPLoad;
        }
        if(rels){
            rels.forEach(function(rel, key){
                var relLen = rel.length;
                for(var i=0; i<relLen; i++){
                    var field = rel[i];
                    var val = data[field.relKey], recs, res, relTo, srz, isPoly;
                    if(field.type == "relation" && val && ( type == "normalizeEntity" || ( type == "serializeEntity" && field.opts && field.opts.serialize && field.opts.serialize != "id"))){
                        recs = record ? record[field.relKey] : undefined, relTo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getSchemaObj)(db, field.relatedTo), srz = field.opts ? field.opts.serialize : undefined;
                        isPoly = field.opts ? field.opts.polymorphic : undefined
                        if(field.relType === "hasMany"){
                            if(!Array.isArray(val)){
                                val = [val];
                            }
                            var valLen = val.length, res = [];
                            if(type == "serializeEntity"){
								(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._defProp)(res, "$", {});
								(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.defPayArrUtls)(db,res.$);
								if(partObj && partObj[field.relKey]){
									Object.defineProperties(res.$,{
										_key:{
											value:field.relKey
										},
										_partialObj:{
											value:partObj[field.relKey]
										},
										_schema:{
											value:relTo._name
										},
										_payloadObj:{
											value:res
										},
										replace:{
											value:_utils_js__WEBPACK_IMPORTED_MODULE_1__.replaceCheck,
											writable:true
										},
										partRecMap:{
											value : new Map()
										}
									});
									if(field.opts && field.opts.serialize){
										Object.defineProperty(res.$,"_serialize",{
											value:field.opts.serialize
										});
									}
								}
							}
                            for(var index1=0;index1<valLen;index1++){
                                var _relTo = relTo;
                                if(isPoly){
                                    if(type == "normalizeEntity"){
                                        _relTo = val[index1] && val[index1]._type ? val[index1]._type : relTo; 
                                    }
                                    else if(type == "serializeEntity"){
                                        if(srz == "record"){
                                            _relTo = recs && (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.isEntity)(recs[index1]) ? recs[index1].$.schema._name : relTo;
                                        }
                                        else if(srz == "partial"){
                                            _relTo =  val[index1] && val[index1].$ ?  val[index1].$.polymorphicType : relTo;
                                        }
                                    }
                                }	
                                if(type == "serializeEntity"){
									var relPk = relTo._pK
									res.$.partRecMap.set(val[index1][relPk],true);
								}
                                res.push(baseSerz.serializeRecords(db,relTo,val[index1],undefined,urlObj,type,customData,argsObj,partObj?partObj[field.relKey][index1]:undefined));
                            }
                            data[field.relKey] = res;
                        }
                        else {
                            var _relTo = relTo;
                            if(isPoly){
                                if(type == "normalizeEntity"){
                                    _relTo = data[field.relKey] && data[field.relKey]._type ? data[field.relKey]._type : relTo; 
                                }
                                else if(type == "serializeEntity"){
                                    _relTo = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_2__.isEntity)(record[field.relKey]) ? record[field.relKey].$.schema._name : relTo;									
                                }
                            }	
                            data[field.relKey] = baseSerz.serializeRecords(db,_relTo,data[field.relKey],record ? record[field.relKey] : undefined,urlObj,type,customData,argsObj,partObj?partObj[field.relKey]:undefined);
                        }
                    }
                    else if	( type == "serializeEntity" && field.opts && field.opts.serialize && field.opts.serialize == "id" && field.type == "relation"){
						if(field.relType == "hsaMany"){
							(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._defProp)(data[field.relKey], "$", {});
							(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.defPayArrUtls)(db,data[field.relKey].$);
							if(partObj && partObj[field.relKey]){
								Object.defineProperties(data[field.relKey].$,{
									_key:{
										value:field.relKey
									},
									_partialObj:{
										value:partObj[field.relKey]
									},
									_schema:{
										value:relTo
									},
									_payloadObj:{
										value:data[field.relKey]
									},
									replace:{
										value:_utils_js__WEBPACK_IMPORTED_MODULE_1__.replaceCheck,
										writable:true
									}
								});
								if(field.opts && field.opts.serialize){
									Object.defineProperty(res.$,"_serialize",{
										value:field.opts.serialize
									});
								}
							}
						}
					}	
                }
            });
        }
        return data;
    }
    static buildJSON(db, def, type, payLoad, id, status, urlObj, customData, qP, argsObj){
        var headers = urlObj ?  urlObj.headers : undefined, 
        realData = payLoad,
        name = def && def._name ? def._name : def;
        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer;
        var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db, "serializer", def.serializer, baseSerz.NORMALIZE, { argsObj: argsObj, args:[name, type, realData, id, status, headers, urlObj ? urlObj.qP : undefined,customData]});
        if(res){
            argsObj.payLoad = realData = res.data;
            
        }
        var changed = false, recs, isGet = type == "get";
        if(!isGet && realData && typeof realData == "object"){
            res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"serializer", def.serializer, baseSerz.NORMALIZEKEY, { argsObj: argsObj, args:[name,type,undefined,qP,customData]});
            if(res){
                var plKey = res.data;
                if(plKey && plKey != name){
                    var temp = realData[plKey];
                    realData[name] = temp;		
                    delete realData[plKey];
                }	
            }
        }    
        if(isGet || (realData && realData[name])){
            recs = realData[name], changed = true;
            // Internal release
            var scope = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cbScp)(db, def.serializer, baseSerz.PROCESSENTITY, "serializer");
            if(scope){
                if(Array.isArray(recs)){
                    for(var i=0; i<recs.length; i++){
                        argsObj.entityData = recs[i];
                        recs[i] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cB)(scope, [argsObj]);
                    }
                }					
                else{
                    argsObj.entityData = recs;
                    recs = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cB)(scope, [argsObj]);
                }
            }
            var flUrlObj = type != "pushPayload" ? {url:urlObj.url, method:urlObj.method, headers:urlObj.headers, type: type, qP : urlObj.qP, withCredentials: urlObj.withCredentials, schema :name} : undefined;
            recs = baseSerz.serializeRecords(db, def, recs, undefined, flUrlObj, baseSerz.NORMALIZEENTITY, customData, argsObj);
            realData[name] = recs;
            argsObj.payLoad = realData;
        }
        return realData;
    }
    static normalizeResponse(db, def, type, payLoad, id, status, urlObj, customData, opts, argsObj){
        var headers = urlObj ? urlObj.headers : undefined,
        name = def && def._name ? def._name : def, realData;
        argsObj.payLoad = realData = payLoad;
        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer;
        var res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.initCB)(db,"serializer", def.serializer, baseSerz.NORMALIZE, { argsObj: argsObj, args:[name, type, realData, id, status, headers, urlObj ? urlObj.qP : undefined, customData, opts]});
        if(res){
            argsObj.payLoad = realData = res.data;
        }
        return realData;
    }
    static normalize(db,def,type,payLoad,id,status,headers,customData,opts,urlObj,argsObj){
        var realData = payLoad, 
        changed = false,
        name = def && def._name ? def._name : def;
        if(type == "get" || realData[name]){
            realData = realData[name];
            changed = true;
        }
        // Internal release
        var baseSerz = def && def.serializer ? def.serializer.constructor : db.constructor.Serializer;
        var scope = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cbScp)(db,def.serializer, baseSerz.PROCESSENTITY, "serializer");
        if(scope){
            if(Array.isArray(realData)){
                for(var i=0; i<realData.length; i++){
                    argsObj.entityData = realData[i];
                    realData[i] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cB)(scope, [argsObj]);
                }
            }					
            else{
                argsObj.entityData = realData;
                realData = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cB)(scope, [argsObj]);
            }
        }
        
        argsObj.payLoad = realData;
        if(changed){
            payLoad = {};
            realData = baseSerz.serializeRecords(db, def, realData, undefined, {url:urlObj.url, method:urlObj.method, headers:urlObj.headers, type: type, qP : urlObj.qP, withCredentials: urlObj.withCredentials, schema :name}, "normalizeEntity", customData, argsObj)
            payLoad[name] = realData;
        }
        argsObj.payLoad = payLoad;
    }
}

Serializer.__lMod = "Serializer";



/***/ }),

/***/ 76977460:
/*!*********************************************************!*\
  !*** ./node_modules/@slyte/data/src/ValidationError.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ValidationError": () => (/* binding */ ValidationError)
/* harmony export */ });
/* harmony import */ var _commonUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commonUtils */ 5950311);



class ValidationError {
    constructor(lyte, attr, obj, message){
        Object.defineProperties(this, {
            $ : {
                value : {isError : true , error:message?message:{}}
            }
        });
        if(attr){
            ValidationError.setError(lyte,this,attr,obj);
        }    
    }

    static setError(lyte,err,attr,codeObj){
        if(err.$.hasOwnProperty("error")){
            if(Array.isArray(attr)){
                attr.forEach(function(itm){
                    (0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(lyte, err.$.error, itm, codeObj);
                });
            }
            else{
                (0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(lyte, err.$.error,attr,codeObj);
            }
        }
        else{
            ValidationError.error(lyte,"LD03",err,attr);
        }
    }

    static setRecErr(ent$, field, code, value){
        var lyte = ent$.schema.Lyte;
        (0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(lyte, ent$, "isError", true);
        var errObj = code;
        if(typeof errObj == "object"){
            (0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(lyte, ent$.error,field,errObj);
        }
        else{
            if(typeof code == "string"){
                var errMes = ValidationError.errorCodes[code];
                if(errMes){
                    errObj = {code : code, message : ValidationError.errorCodes[code]};
                }
                else{
                    errObj = code;
                }
            }
            (0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(lyte, ent$.error, field, errObj);
            if(value){
                (0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(lyte, ent$.error[field],"value",value);
            }				
        }
		var db = ent$.schema.db;
        (0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.emit)(db,"error",ent$.entity,field,errObj);
    }

    static clrRecErr(ent$, field, code){
        var lyte = ent$.schema.Lyte;
        var objUtl = lyte.objectUtils;
        var $err = ent$.error;
        if(code){
            if(ent$.error.code == code){
                if(typeof objUtl != "undefined"){
                    objUtl($err,"delete",field);
                }
                else{
                    delete $err[field];                        
                }
            }
        }
        else if(field){
            if(typeof objUtl != "undefined"){
                objUtl($err,"delete",field);
            }
            else{
                delete $err[field];                       
            }
        }
        else{
            if(typeof objUtl != "undefined"){
                for(var err in $err){
                    objUtl($err,"delete",err);
                }
            }	
            else{
                ent$.error = {};
            }   
        }
        if(Object.keys(ent$.error).length == 0){
            (0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(lyte, ent$, "isError", false);
        }
    }
}

ValidationError.errorCodes = {
    ERR01 : "Primary key cannot be modified", 
    ERR02 : "Mandatory prop cannot be empty", 
    ERR03 : "Type of value does not match the specified data type",
    ERR04 : "Value is greater than the maximum value allowed",
    ERR05 : "Value is less than the minimum value allowed", 
    ERR06 : "Length of string/array is greater than the maximum limit allowed", 
    ERR07 : "Length of string/array is less than the minimum limit allowed",
    ERR08 : "String does not match the specified pattern", 
    ERR09 : "Values in array are not unique", 
    ERR10 : "Value is not equal to the specified constant", 
    ERR11 : "Schema of related field is not defined",
    ERR12 : "Schema of backward relation is not defined", 
    ERR13 : "Entity not found", 
    ERR14 : "Schema does not match the schema defined in the related field", 
    ERR15 : "Error in creating a entity as a relation",
    ERR16 : "Entity with primary key already exists", 
    ERR17 : "Value cannot be changed because entity has been deleted", 
    ERR18 : "Action not defined", 
    ERR19 : "Schema not defined",
    ERR20 : "Key not specified", 
    ERR21 : "'one' relationship expects a single object/id", 
    ERR22 : "Type not specified for polymorphic relation", 
    ERR23: "Primary Key value not present", 
    ERR24: "Error while relating entities", 
    ERR25: "Backward relation not present",
    ERR26: "Primary key value cannot be undefined or null",
    ERR27: "Observer can observe only string data type value, '{0}' value cannot be observed in the function named '{1}' in the component '{2}'",
    ERR29: "Property not defined in the object",
    ERR30: "Property's value is not an instanceof the mentioned class"      
};



/***/ }),

/***/ 5950311:
/*!*****************************************************!*\
  !*** ./node_modules/@slyte/data/src/commonUtils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cmpSet": () => (/* binding */ cmpSet),
/* harmony export */   "emit": () => (/* binding */ emit)
/* harmony export */ });
function cmpSet(lyte, obj, key, value, opts, fromStore){
    if(lyte && lyte.$utils && lyte.$utils.set){
        lyte.$utils.set(obj, key, value, opts, fromStore);
    }
    else{
        obj[key] = value;
    }
}

function emit(db, type, record, attr, err){
	record.$.emit(type, [record,attr,err]);
	record.$.schema.emit(type, [record, attr, err]);
	db.emit(type, [record.$.schema._name, record, attr, err]);
}

 

/***/ }),

/***/ 82718186:
/*!*************************************************!*\
  !*** ./node_modules/@slyte/data/src/dberror.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dberror": () => (/* binding */ Dberror)
/* harmony export */ });
/* harmony import */ var _slyte_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/core */ 182578);


class Dberror extends _slyte_core__WEBPACK_IMPORTED_MODULE_0__.Logger {
    constructor(){
        super(...arguments);
    }
}

Dberror.errorCodes = {
    LD01: "Primary key value might be missing in the response data that is received, {0}",
    LD02: "Not a valid {0}",
    LD03: "Cannot set the error {0} for {1}",
    LD04: "No such record to merge, {0}",
    LD05: "Model( {0} ) of related property - {1} not found in model - {2}",
    LD06: "Backward relation not present in model( {0} ), for the property {1} of model( {2} )",
    LD07: "{0} type not handled in handleArrayOperations",
    LD08: "{0} {1} will be deprecated from next version {2}",
    LD09: "deserializeKey cannot be processed for payload with more than two keys. Please use payloadKey callback instead or try modifying the same in normalizeResponse callback",
    LD10: "Response data not in a format lyte data store expects",
    LD11: "Deprecation Warning! findRecord response payload will not accept an array. It will be deprecated from the next version",
    LD12: "Response ( {0} ) is not in a format, lyte data store expects",
    LD13: "Response processing failed in {0} for model-{1} {2}, since invalid data is received in {1}(modelName) key of response data. Data - {3}",
    LD14: "Cannot register {0} - {1}, as it already exists.",
    LD15: "Primary key value might be missing in the response data that is received, {0}",
    LD16: "Record merge failed for the record in model - {0} with primaryKey value - {1}, since either the persisted(saved) primary key value for a newly created record is not received from server or not in the proper structure to merge",
    LD17: "Record with the primary key value already exists",
    LD18: "No { 0 } present",
    LD19: "Deprecation Warning! findAll will not accept response payload values other than an array or any empty value. Current implementation which allows this will be deprecated from the next version",
    LD20: "Record cannot be saved as a state, when it is not either a new or a modified record or in a error state.",
    LD21: "No such state ( {0} ) saved for the record.",
    LD22: "For create / createRecord, response with a primary key value should be received",
    LD23: "PrimaryKey field {1} in {0} cannot have default value",
    LD24: "Response couldn't be parsed, {0}",
    LD25: "Cannot create record for the data - {0}",
    LD26: "Only one baseKey is allowed for a model",
    LD27: "Record merge failed, since the data passed is invalid - {0}",
    LD28: "Record merge failed for the model - {0}, since a valid primary key value is not found in the data to be merged - {1}"   
};

Dberror.register();



/***/ }),

/***/ 84646139:
/*!***********************************************!*\
  !*** ./node_modules/@slyte/data/src/utils.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_attrsForRel": () => (/* binding */ _attrsForRel),
/* harmony export */   "_defProp": () => (/* binding */ _defProp),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "addDeepNest": () => (/* binding */ addDeepNest),
/* harmony export */   "addOnSave": () => (/* binding */ addOnSave),
/* harmony export */   "addToCachedBatch": () => (/* binding */ addToCachedBatch),
/* harmony export */   "addToRelate": () => (/* binding */ addToRelate),
/* harmony export */   "addTo_Del": () => (/* binding */ addTo_Del),
/* harmony export */   "cB": () => (/* binding */ cB),
/* harmony export */   "cacheQuery": () => (/* binding */ cacheQuery),
/* harmony export */   "cacheRecordQuery": () => (/* binding */ cacheRecordQuery),
/* harmony export */   "cbScp": () => (/* binding */ cbScp),
/* harmony export */   "changeCallbck": () => (/* binding */ changeCallbck),
/* harmony export */   "changePersist": () => (/* binding */ changePersist),
/* harmony export */   "changeRelPkMaps": () => (/* binding */ changeRelPkMaps),
/* harmony export */   "checkAndAddToArray": () => (/* binding */ checkAndAddToArray),
/* harmony export */   "checkAttrs": () => (/* binding */ checkAttrs),
/* harmony export */   "checkForCorrectRelation": () => (/* binding */ checkForCorrectRelation),
/* harmony export */   "checkObjAndAddToArr": () => (/* binding */ checkObjAndAddToArr),
/* harmony export */   "checkPresenceInArray": () => (/* binding */ checkPresenceInArray),
/* harmony export */   "cmpRelInitVal": () => (/* binding */ cmpRelInitVal),
/* harmony export */   "compareData": () => (/* binding */ compareData),
/* harmony export */   "compareObjects": () => (/* binding */ compareObjects),
/* harmony export */   "comparePk": () => (/* binding */ comparePk),
/* harmony export */   "compareRecordWithObj": () => (/* binding */ compareRecordWithObj),
/* harmony export */   "compareRecords": () => (/* binding */ compareRecords),
/* harmony export */   "compareRelations": () => (/* binding */ compareRelations),
/* harmony export */   "createAndRelate": () => (/* binding */ createAndRelate),
/* harmony export */   "createCopy": () => (/* binding */ createCopy),
/* harmony export */   "dbModName": () => (/* binding */ dbModName),
/* harmony export */   "deepCopyAttrs": () => (/* binding */ deepCopyAttrs),
/* harmony export */   "deepCopyStack": () => (/* binding */ deepCopyStack),
/* harmony export */   "deepRelIter": () => (/* binding */ deepRelIter),
/* harmony export */   "deepRelOptions": () => (/* binding */ deepRelOptions),
/* harmony export */   "deepValueChange": () => (/* binding */ deepValueChange),
/* harmony export */   "defArrUtls": () => (/* binding */ defArrUtls),
/* harmony export */   "defPar": () => (/* binding */ defPar),
/* harmony export */   "defPayArrUtls": () => (/* binding */ defPayArrUtls),
/* harmony export */   "defPolyUtls": () => (/* binding */ defPolyUtls),
/* harmony export */   "defUtls": () => (/* binding */ defUtls),
/* harmony export */   "defpayObjUtls": () => (/* binding */ defpayObjUtls),
/* harmony export */   "deleteDeepNest": () => (/* binding */ deleteDeepNest),
/* harmony export */   "deleteFromArray": () => (/* binding */ deleteFromArray),
/* harmony export */   "demoLishObserverBindings": () => (/* binding */ demoLishObserverBindings),
/* harmony export */   "demolishLink": () => (/* binding */ demolishLink),
/* harmony export */   "demolishSingleRelation": () => (/* binding */ demolishSingleRelation),
/* harmony export */   "emit": () => (/* reexport safe */ _commonUtils__WEBPACK_IMPORTED_MODULE_0__.emit),
/* harmony export */   "estAttrs": () => (/* binding */ estAttrs),
/* harmony export */   "establishLink": () => (/* binding */ establishLink),
/* harmony export */   "establishObsBindings": () => (/* binding */ establishObsBindings),
/* harmony export */   "establishToRelated": () => (/* binding */ establishToRelated),
/* harmony export */   "evAdd": () => (/* binding */ evAdd),
/* harmony export */   "evEmit": () => (/* binding */ evEmit),
/* harmony export */   "evRemove": () => (/* binding */ evRemove),
/* harmony export */   "extendDef": () => (/* binding */ extendDef),
/* harmony export */   "filter": () => (/* binding */ filter),
/* harmony export */   "filterBy": () => (/* binding */ filterBy),
/* harmony export */   "genPk": () => (/* binding */ genPk),
/* harmony export */   "genUnRedoStack": () => (/* binding */ genUnRedoStack),
/* harmony export */   "generateRandomPk": () => (/* binding */ generateRandomPk),
/* harmony export */   "getBackwardRel": () => (/* binding */ getBackwardRel),
/* harmony export */   "getCompInd": () => (/* binding */ getCompInd),
/* harmony export */   "getDefaultVal": () => (/* binding */ getDefaultVal),
/* harmony export */   "getFromCB": () => (/* binding */ getFromCB),
/* harmony export */   "getInd": () => (/* binding */ getInd),
/* harmony export */   "getIndex": () => (/* binding */ getIndex),
/* harmony export */   "getRelatedRecord": () => (/* binding */ getRelatedRecord),
/* harmony export */   "getRelations": () => (/* binding */ getRelations),
/* harmony export */   "getSchemaObj": () => (/* binding */ getSchemaObj),
/* harmony export */   "getpKVal": () => (/* binding */ getpKVal),
/* harmony export */   "handleArrOp": () => (/* binding */ handleArrOp),
/* harmony export */   "handleCachedResponse": () => (/* binding */ handleCachedResponse),
/* harmony export */   "handleRelation": () => (/* binding */ handleRelation),
/* harmony export */   "handleResponse": () => (/* binding */ handleResponse),
/* harmony export */   "handleResults": () => (/* binding */ handleResults),
/* harmony export */   "hasDuplicateRelation": () => (/* binding */ hasDuplicateRelation),
/* harmony export */   "hasRecordInArray": () => (/* binding */ hasRecordInArray),
/* harmony export */   "hasRecordsArrayChanged": () => (/* binding */ hasRecordsArrayChanged),
/* harmony export */   "idSerialize": () => (/* binding */ idSerialize),
/* harmony export */   "idbSerialize": () => (/* binding */ idbSerialize),
/* harmony export */   "initCB": () => (/* binding */ initCB),
/* harmony export */   "initPartialObj": () => (/* binding */ initPartialObj),
/* harmony export */   "insertIntoStore": () => (/* binding */ insertIntoStore),
/* harmony export */   "isDefData": () => (/* binding */ isDefData),
/* harmony export */   "isDirty": () => (/* binding */ isDirty),
/* harmony export */   "isDuplicateEntity": () => (/* binding */ isDuplicateEntity),
/* harmony export */   "isDuplicateRecord": () => (/* binding */ isDuplicateRecord),
/* harmony export */   "isEmpty": () => (/* binding */ isEmpty),
/* harmony export */   "isEmptyArray": () => (/* binding */ isEmptyArray),
/* harmony export */   "isEmptyObj": () => (/* binding */ isEmptyObj),
/* harmony export */   "isRelDirty": () => (/* binding */ isRelDirty),
/* harmony export */   "makeDirty": () => (/* binding */ makeDirty),
/* harmony export */   "mapBy": () => (/* binding */ mapBy),
/* harmony export */   "mergeData": () => (/* binding */ mergeData),
/* harmony export */   "mergeDeletedRec": () => (/* binding */ mergeDeletedRec),
/* harmony export */   "mergeError": () => (/* binding */ mergeError),
/* harmony export */   "mergeModifiedRec": () => (/* binding */ mergeModifiedRec),
/* harmony export */   "mergeNewDataKeys": () => (/* binding */ mergeNewDataKeys),
/* harmony export */   "mergeNewRecord": () => (/* binding */ mergeNewRecord),
/* harmony export */   "mergePartialObj": () => (/* binding */ mergePartialObj),
/* harmony export */   "mergeRecords": () => (/* binding */ mergeRecords),
/* harmony export */   "mergeResponse": () => (/* binding */ mergeResponse),
/* harmony export */   "newRecord": () => (/* binding */ newRecord),
/* harmony export */   "partialData": () => (/* binding */ partialData),
/* harmony export */   "partialSerialize": () => (/* binding */ partialSerialize),
/* harmony export */   "pkPresence": () => (/* binding */ pkPresence),
/* harmony export */   "polyToJSON": () => (/* binding */ polyToJSON),
/* harmony export */   "polymorphicToJSON": () => (/* binding */ polymorphicToJSON),
/* harmony export */   "rBinherit": () => (/* binding */ rBinherit),
/* harmony export */   "rSerialize": () => (/* binding */ rSerialize),
/* harmony export */   "recChk": () => (/* binding */ recChk),
/* harmony export */   "recordSerialize": () => (/* binding */ recordSerialize),
/* harmony export */   "registerField": () => (/* binding */ registerField),
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "removeBackwardRel": () => (/* binding */ removeBackwardRel),
/* harmony export */   "removeChildRecords": () => (/* binding */ removeChildRecords),
/* harmony export */   "removeDeepNest": () => (/* binding */ removeDeepNest),
/* harmony export */   "removeDirtyStack": () => (/* binding */ removeDirtyStack),
/* harmony export */   "removeFromStore": () => (/* binding */ removeFromStore),
/* harmony export */   "removeOnSave": () => (/* binding */ removeOnSave),
/* harmony export */   "removeParentNesting": () => (/* binding */ removeParentNesting),
/* harmony export */   "removePartial": () => (/* binding */ removePartial),
/* harmony export */   "removePartialKeys": () => (/* binding */ removePartialKeys),
/* harmony export */   "removeSelfCircularReference": () => (/* binding */ removeSelfCircularReference),
/* harmony export */   "replaceCheck": () => (/* binding */ replaceCheck),
/* harmony export */   "revertToOldVal": () => (/* binding */ revertToOldVal),
/* harmony export */   "rllBckRecArr": () => (/* binding */ rllBckRecArr),
/* harmony export */   "rollBackDelete": () => (/* binding */ rollBackDelete),
/* harmony export */   "rollBackNew": () => (/* binding */ rollBackNew),
/* harmony export */   "schArgs": () => (/* binding */ schArgs),
/* harmony export */   "setData": () => (/* binding */ setData),
/* harmony export */   "setDeepNest": () => (/* binding */ setDeepNest),
/* harmony export */   "setState": () => (/* binding */ setState),
/* harmony export */   "setValue": () => (/* binding */ setValue),
/* harmony export */   "singleEstablishLink": () => (/* binding */ singleEstablishLink),
/* harmony export */   "solveRelation": () => (/* binding */ solveRelation),
/* harmony export */   "sortBy": () => (/* binding */ sortBy),
/* harmony export */   "toChildJSON": () => (/* binding */ toChildJSON),
/* harmony export */   "toDemolishLink": () => (/* binding */ toDemolishLink),
/* harmony export */   "toDemolishRelation": () => (/* binding */ toDemolishRelation),
/* harmony export */   "toInsertData": () => (/* binding */ toInsertData),
/* harmony export */   "toJSON": () => (/* binding */ toJSON),
/* harmony export */   "toJSONObj": () => (/* binding */ toJSONObj),
/* harmony export */   "unRegCb": () => (/* binding */ unRegCb),
/* harmony export */   "unredoOp": () => (/* binding */ unredoOp),
/* harmony export */   "unregisterDef": () => (/* binding */ unregisterDef),
/* harmony export */   "updateDn": () => (/* binding */ updateDn),
/* harmony export */   "updateFieldValidation": () => (/* binding */ updateFieldValidation),
/* harmony export */   "updateJSON": () => (/* binding */ updateJSON),
/* harmony export */   "updateNestScp": () => (/* binding */ updateNestScp),
/* harmony export */   "validateAndMerge": () => (/* binding */ validateAndMerge),
/* harmony export */   "validateAndPush": () => (/* binding */ validateAndPush),
/* harmony export */   "validateField": () => (/* binding */ validateField),
/* harmony export */   "validateJSON": () => (/* binding */ validateJSON),
/* harmony export */   "validateRecord": () => (/* binding */ validateRecord),
/* harmony export */   "validateRelatedRecord": () => (/* binding */ validateRelatedRecord)
/* harmony export */ });
/* harmony import */ var _dberror__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dberror */ 82718186);
/* harmony import */ var _Schema_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Schema.js */ 84879490);
/* harmony import */ var _slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @slyte/core/src/lyte-utils.js */ 60768251);
/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Entity.js */ 88519247);
/* harmony import */ var _Serializer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Serializer */ 73771730);
/* harmony import */ var _commonUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commonUtils */ 5950311);
/* harmony import */ var _ValidationError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ValidationError */ 76977460);







// import { isMixin } from "../../core/src/lyte-utils";

// function getOrigParent(cls){
// 	var prt = Object.getPrototypeOf(cls);
// 	while(isMixin(prt)){
// 		prt = Object.getPrototypeOf(prt);
// 	}
// 	return prt;
// }

function changePersist(record, value){
	if(!record.$.isUnloaded || record.$.isPeristed !== value){
		switch(value){
			case true: {
				if(!record.$.isNew && !record.$.isModified && !record.$.isDeleted){
					(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(undefined, record.$, "isPersisted", true);
				}
				break;
			}
			case false: {
				if(record.$.isNew || record.$.isModified || record.$.isDeleted || (record.$.dN && Object.keys(record.$.dN) && Object.keys(record.$.dN).length)){
					(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(undefined, record.$, "isPersisted", false);
				}
				break;
			}
		}
	}
}

function getSchemaObj(db, schema){
	var schemaObj = db._schema.get(schema);
	if(!schemaObj && db.subDbs){
		var len = db.subDbs.length;
		for(var i=0;i<len;i++){
			var subDb = db.subDbs[i];
			if(subDb._schema.get(schema)){
				schemaObj = subDb._schema.get(schema);
				break;
			}
		}
	}
	return schemaObj;
}

function dbModName(name, type, pascalToCamel){
	var mp = { Schema : /([a-zA-Z0-9])(Schema)$/g, Connector: /([a-zA-Z0-9])(Connector)$/g, Serializer : /([a-zA-Z0-9])(Serializer)$/g };
	name = name.replace(mp[type], '$1');
	return pascalToCamel !== false ? name.slice(0, 1).toLowerCase() + name.slice(1) : name;
}

function schArgs(){
	var arg1 = arguments[0], args;
	if(typeof arg1 == "object"){
		arg1.schema = this;
		args = [arg1]
	}
	else{
		args = Array.from(arguments);
		args.splice(0,0,this);
	}
	return args;
}

function evAdd(scope,type,func){
	scope.events = scope.events || {};
	scope.events[type] = scope.events[type] || [];
	scope.events[type].push({f : func});
	return type+"-"+(scope.events[type].length-1);              
}

function evRemove(scope,id){
	var type;
	if(id){
		if(/^(add|remove|change)$/.test(id)){
			type = id;
			(scope.events && scope.events[type]) ? delete scope.events[type] : undefined;   
		}
		else{
			var arr = id ? id.split("-") : undefined;
			if(arr){
				var listeners = scope.events[arr[0]];
				if(listeners && arr[1]){
					listeners[arr[1]] = null;
				}   
			}            
		}
	}else{
		var ev = scope.events;
		for(var evType in ev){
			(ev && ev[evType]) ? delete ev[evType] : undefined;
		}
	}
}

function evEmit(scope,type,args){
	var listeners = (scope.events && scope.events[type]) ? scope.events[type] : [];
	for(var i=0; i<listeners.length; i++){
		(listeners[i]) ? listeners[i].f.apply(null, args) : undefined;
	}            
}

function addTo_Del(def, data, ind){
	var deleted = def._deleted = def._deleted || new Map(), 
	obj = { index : ind , data : data };
	deleted.set(data.$.pK, obj);
}

function genUnRedoStack(){
	var obj = {};
	_defProp(obj, "_order_", [], false);
	return obj;
}

function deepCopyStack(stack){
	if(stack && typeof(stack) == "object"){
		stack = Object.assign({},stack);
		for(var attr in stack){
			if(Array.isArray(stack[attr])){
				var arr = stack[attr] = Array.from(stack[attr]);
				arr.forEach(function(itm,idx){
					arr[idx] = Object.assign(itm);
				});
			}
		}
	}
	return stack;
}

function deepCopyAttrs(def,obj){
	var fields = def.fieldList, 
	obj = Object.assign({},obj);
	for(var attr in obj){
		var _attr = obj[attr];
		if(fields[attr] && fields[attr].type == "relation" && Array.isArray(_attr)){
			_attr = obj[attr] = Array.from(_attr);
			_attr.forEach(function(itm, idx){
				_attr[idx] = Object.assign({}, itm);
				itm.hasOwnProperty("records") && itm.records ? (itm.records = Array.from(itm.records)) : undefined;
				itm.hasOwnProperty("_indices") && itm._indices ? (itm._indices = Array.from(itm._indices)) : undefined;
			});
		}
	}
	return obj;
}

function unredoOp(type,rec,attr){
	var stack, revStack;
	var lyte = rec.schema.db.lyte;
	if(type == 1){
		stack = rec.undoStack;
		revStack = rec.redoStack;
	}
	else{
		stack = rec.redoStack;
		revStack = rec.undoStack;
	}
	var attrs=[], obj, revObj = {};
	if(attr){
		if(!Array.isArray(attr)){
			attrs=[attr];
		}
		else{
			attrs = attr;
		}
		attrs.forEach(function(item){
			if(stack[item].length){
			var len = stack._order_.length;
			for (var index=len-1;index>=0;index--){
				var order = stack._order_[index];
				var attrIndex = order.indexOf(item);
				if(attrIndex > -1){
					order.splice(attrIndex,1);
						if(!order.length){
							stack._order_.splice(index,1);
						}
						break;
					}
				}
			}
		});
	}
	else{
		attrs = stack._order_ && stack._order_.length ? stack._order_.pop() : attrs;
	}
	if(attrs.length){
		for(var index=0;index<attrs.length;index++){
			var key=attrs[index], obj = stack[key].pop();
			if(obj._type == "update"){
				if(obj.hasOwnProperty("val")){
					setData(rec,key,obj.val,undefined, revObj);
					// redoObj[key] = undo;
				}
				else if(obj.hasOwnProperty("records")){
					setData(rec,key,obj.records,undefined, revObj)	
				}
			}
			else if(type == 1 && obj._type == "propAdd"){
				if(typeof lyte != "undefined"){
					revObj[key] = {_type:"propDelete", val:rec.entity[key]};
					if(obj.hasOwnProperty("val")){
						setData(rec,key,obj.val,undefined, {});
						// redoObj[key] = undo;
					}
					if(lyte.objectUtils){
						lyte.objectUtils(rec.entity, "delete", key);
					}
					else{
						delete rec.entity[key];
					}
				}
				else{
					delete rec.entity[key];
				}
			}
			else if(type == 2 && obj._type == "propDelete"){
				revObj[key] = {_type:"propAdd"}
				setData(rec,key,obj.val,undefined, revObj);
			}
			else if(obj._type == "added"){
				rec.entity.$.get(key).remove(obj.records,undefined,revObj);
			}
			else if(obj._type == "removed"){
				rllBckRecArr(rec.schema.db, [obj], rec.entity, rec.schema, rec.schema.fieldList[key])
				obj._type = "added";
				revObj[key] = obj;
			}
		}
		var keys = Object.keys(revObj);
		for(var index=0;index<keys.length;index++){
			var key = keys[index];
			revStack[key] = revStack[key] || [];
			revStack[key].push(revObj[key]);
		}
		if(keys.length){
			// rec.redoStack._order_ = rec.redoStack._order_ || [];
			revStack._order_.push(keys);
		}
	}
}

function unregisterDef(db, schema){
	schema = getSchemaObj(db, schema);
	if(schema){
		var name = schema._name;
		if(schema.data.length){
			db.dropAll(schema.def);
		}
		var extendedBy = schema.extendedBy;
		if(extendedBy && Object.keys(extendedBy).length){
			for(var ext in extendedBy){
				unregisterDef(db, db.schema[ext].def);
			}
		}
		if(schema.extend){
			var extend = db.getSchemaObj(schema.extend);
			if(extend){
				delete extend.extendedBy[name];
			}
		}
		delete db.schema[name];  
		delete db.constructor.Schema.schema[name];
		db._schema.delete(schema.def);
	}
}

function updateFieldValidation(db, schema, key, deserialize, ignoreValidation){
	var records = schema.data, 
	fields = schema.fieldList;
	records.forEach(function(item){
		var field = fields[key], 
		isOldVal = item.$.error && item.$.error.hasOwnProperty(key) && item.$.error[key].hasOwnProperty("value") ? true : false, 
		oldVal = isOldVal ? item.$.error[key].value : undefined;
		_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.clrRecErr(item.$, key);
		if(deserialize){
			var fldTypeName = field.type._name, 
			empD = getDsrzEmpData(schema, field, schema._name), 
			boolChk = !empD && item[key];
			if((item.hasOwnProperty(key) && (boolChk || empD) && db.dataType[fldTypeName].hasOwnProperty("deserialize"))){
				item[key] = db.dataType[fldTypeName].deserialize(item[key],key,schema._name,getpKVal(item,schema));
			}
		}
		isOldVal ? validateField(db, item, key, fields[key], undefined, {old:true, value:oldVal}) : validateField(db, item, key, fields[key], undefined)
		if(!ignoreValidation){
			var isOldVal = item.$.error && item.$.error.hasOwnProperty(key) && item.$.error[key].hasOwnProperty("value") ? true : false;
			var oldVal = isOldVal ? item.$.error[key].value : undefined;
			_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.clrRecErr(item.$, key);
			isOldVal ? validateField(db, item, key, field, undefined, {old:true, value:oldVal}) : validateField(db, item, key, fields[key], undefined)
		}
		if(isOldVal && item.$.error && Object.keys(item.$.error) === 0){
			item.$.set(key, oldVal);
		}
	});
}

function handleCachedResponse(db,batch,resp){
	var cached = db.$.cachedBatch = db.$.cachedBatch || {}, 
	arr = cached[batch] || [], 
	count = 0;
	arr.forEach(function(item,index){
		resp.splice((item.ind+count++),0,item.data);
	});
	delete cached[batch];
	return resp;
}

function addToCachedBatch(db, data){
	var curr = db.$.currentBatch, 
	cached = db.$.cachedBatch = db.$.cachedBatch || {}, 
	cachedB = cached[curr] = cached[curr] || [], 
	arr = db.$.batch[curr] || [], 
	ind = arr.length;
	cachedB.push({ind:ind, data:data});
}

function checkObjAndAddToArr(arr, obj, keys){
	var len = Object.keys(keys).length, res = -1, arrLen = arr.length;
	for(var k=0; k<arrLen; k++){
		var item = arr[k];
		var i=0;
		for(var key in keys){
			if(item[key] == obj[key]){
				i++;
			}	
		}
		if(i == len){
			res = k;
			arr.splice(k,1,obj);
			return;
		}
	}
	if(res == -1){
		arr.push(obj);
	}
	return res;
}

function addToRelate(db, name, data, rel, key){
	var relMod = getSchemaObj(db, rel.forward.relatedTo), 
	toRelMod = db.$.toRelate[relMod._name] = db.$.toRelate[relMod._name] || new Map();
	if(!toRelMod.has(key)){
		toRelMod.set(key, []);
	}
	var toRel = toRelMod.get(key), 
	pkVal = data.$.pK, 
	obj = {schema : name, pkVal : pkVal, key : rel.forward.relKey};
	toRel.push(obj);
	// checkObjAndAddToArr(toRel, obj, ["record","key"]);
}

function getDefaultVal(rec, defVal){
	if(typeof defVal != "function"){
		return defVal;
	}
	else{
		return defVal.call(rec);
	}
}

function deepValueChange(rec, attr, value, changeObj){
	var toEmit = {emit : false, attr : [], oldRec : {}};
	estAttrs(rec, attr, value, toEmit, changeObj);
	checkAttrs(rec);
	changeCallbck(rec, toEmit);
}

function updateDn(record){
	var schema = record.$.schema, 
	relations = schema.relations;
	relations.forEach(function(rels, key){
		rels.forEach(function(itm){
			var options = itm.opts, 
			attr = itm.relKey, 
			relType = itm.relType ;
			if(options && options.deepNest == true){
				deepRelIter("updateDN", schema, record);
				if(record.hasOwnProperty(attr)){
					var relRec = record[attr];
					if(relType == "belongsTo" && (relRec.$.isModified || (relRec.$.dN && Object.keys(relRec.$.dN).length ))){
						setDeepNest(record, attr, relRec.$.pK, "updated", undefined, relRec)
					}
					else if(relType == "hasMany" && Array.isArray(relRec)){
						relRec.forEach(function(rec){
							if(rec.$.isModified || (rec.$.dN && Object.keys(rec.$.dN).length)){
								setDeepNest(record, attr, rec.$.pK, "updated", undefined, rec)
							}
						});
					}
				}
			}
		});
	});
}

function deepRelIter(type, def, record, parentRel){
	var relations = def.relations, db = def.db;
	relations.forEach(function(arr, key){
		arr.forEach(function(rel){
			var relKey = rel.relKey, isParent;
			var relType = rel.relType;
			var dN = rel.opts && rel.opts[type];
			if(parentRel){
				var relDef = getSchemaObj(db, rel.relatedTo);
				var child = getBackwardRel(def,rel, relDef);
				if(parentRel == child && def != relDef){
					isParent = true;
				}
			}
			if(!isParent && record.hasOwnProperty(relKey) && record[relKey] && dN){
				var relData = record[relKey];
				if(relType == "hasMany" && Array.isArray(relData)){
					relData.forEach(function(relRec){
						deepRelOptions(db, relRec, type, rel);
					});
				}
				else if(relType == "belongsTo" && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(relData)){
					deepRelOptions(db, relData, type, rel);
				}
			}
		});		
	});
}

function deepRelOptions(db, relRec, type, rel){
	switch(type){
		case "rollback":
		{
			relRec.$.rollBack(undefined,rel);
			break;
		}	
		case "unload":
		{
			db.dropEntity(rel.relatedTo, relRec.$.pK, rel);
		}								
	}
}

function handleResults(db, results, partialRef){
	if(Array.isArray(results)){
		results.forEach(function(itm, idx){
			var refKey = partialRef.refKey;
			var refId = itm[refKey], refObj = partialRef.get(refId);
			if(refObj){
				mergePartialObj(db, refObj, undefined, itm, true);
			} 
		});
	}
	else{
		_dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.warn(db.lyte, "results expected be a flat structure of type array, instead it was "+typeof(results));
	}
}

function handleResponse(db, data, response, schema, type, partialObj, status, partialRef){
	var pK = schema._pK, 
	partial, 
	obj, 
	pkVal;
	if(response.results && schema._name != "results"){
		handleResults(db,response.results, partialRef);
	}
	response = response[schema._name];
	if(Array.isArray(data)){
		for(var i=0; i<data.length; i++){
			obj = data[i], pkVal = obj.$.pK;
			partial = partialObj && obj && pkVal ?  partialObj.get(pkVal) : undefined;
			mergeResponse(db, data[i], schema, Array.isArray(response) ? response[i] : response, pK, partial);	
		}
	}
	else{
		pkVal = data.$.pK;
		partial = partialObj && data && pkVal ?  partialObj.get(pkVal) : undefined;
		mergeResponse(db, data, schema, response, pK, partial);	
	}
}

function setState(self, obj){
	self.dN ? self.dN = {} : undefined;
	setData(self, obj, undefined, undefined, {}, true);
	updateDn(self.entity);
	self.undoStack = obj.$.undoStack || genUnRedoStack();
	self.redoStack = obj.$.redoStack || genUnRedoStack();
	self._attributes = obj.$._attributes || {};
	checkAttrs(self.entity);
}

function validateRelatedRecord(db, record, key, field){
	var fields = getSchemaObj(db, field.relatedTo).fieldList;
	if(field && field.opts && record && record.hasOwnProperty(key)){
		if(field.opts && field.opts.serialize == "record"){
			if(field.relType == "belongsTo" && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(record[key])){
				return validateRecord(db, record[key], fields);
			}
			else if(field.relType == "hasMany"){
				if(Array.isArray(record[key])){
					var ret = true, 
					result, 
					self = this;
					record[key].forEach(function(item, index){
						if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(item)){
							result = validateRecord(db, item, fields);
							if(result === false){
								ret = false;
							}
						}
					});
					return ret;
				}
			}
		}
	}
}

function validateRecord(db, record, fields){
	var result, ret = true, returnVal;
	for(var field in fields){
		returnVal = validateField(db, record, field, fields[field], result);
		if(ret === true && returnVal === false){
			ret = false;
		}
	}
	if(ret === false || (record.$.isError === true && record.$.error && Object.keys(record.$.error).length)){
		return false;
	}
	return true;
}

function validateField(db, record, key, field, result, obj){
	var val = obj && obj.old ? obj.value : record[key], 
	ret, 
	err = record.$, 
	clear,
	db = record.$.schema.db,
	lyte = record.$.schema.db.lyte,
	validateOptions = true;
	if(field.type == "relation"){
		ret = validateRelatedRecord(db, record, key, field);
		if(ret === false){
			result = false;
			return result;
		}
		validateOptions = false;
	}
	else if(field.mandatory && !record.$.error.hasOwnProperty(key) && (val === undefined || val === "" || (Array.isArray(val) && val.length === 0) )){
		_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.setRecErr(err, key, {code : "ERR02", message : _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes.ERR02, value : val});
	}
	if(validateOptions){
		clear = true;
		if( obj || (record.hasOwnProperty(key) && !record.$.error.hasOwnProperty(key))){
			for(var property in field){
				var resp = (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.checkProperty)(property, val, key, field[property], record, (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(record) ? record.$.schema._name : undefined, db, _ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.errorCodes, undefined, field, true);
				if(resp !== true){
					if(typeof resp == "object"){
						resp.value = val; 
					}
					_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.setRecErr(err,key,resp);
					clear = false;
					//err[field] = resp;
					break;
				}
			}
			if(_Entity_js__WEBPACK_IMPORTED_MODULE_4__.Entity.strictValueSet === false && obj && clear){
				(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)( lyte, record, key, val, undefined, true );
			}
			if(clear){
				_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.clrRecErr(err, key);
			}		
		}
	}
}

function addOnSave(db,name,record,attr,field,pK,relPk){
	db.$.onSave = db.$.onSave || {};
	var saveMod = db.$.onSave[name] = db.$.onSave[name] || {};
	var saveQ = saveMod[record[pK]] = saveMod[record[pK]] || {} 
	var recs = record[attr] || [];
	if(field.relType == "belongsTo"){
		recs = !Array.isArray(record[attr]) ? [record[attr]] : record[attr]; 
	}
	recs.forEach(function(item){
		var q = saveQ[field.relKey] = saveQ[field.relKey] || [];
		checkAndAddToArray(q, item[relPk]);
	});
}

function removeOnSave(db, name, pkVal){
	var saveMod = db.$.onSave ? db.$.onSave[name] : undefined;
	if(saveMod && saveMod[pkVal]){
		delete saveMod[pkVal];
	}
}

function registerField(db,def,key,field,obs){
	var oldField = def.fieldList[key] ? Object.assign({},def.fieldList[key]) : undefined;
	if(key == "didLoad"){
		if(!def.didLoad){
			def.didLoad = [];
		}
		def.didLoad.push(field);
	}
	else if(typeof field.type == "string"){
		if(field.primaryKey){
			if(def.fieldList.id && def.fieldList.id.defined == false){
				delete def.fieldList.id;
			}
			if(field.hasOwnProperty("default")){
				_dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.warn(db.lyte, "LD23",def._name,key);
				delete field.default;
			}
			if(def._pK != undefined){
				def._pK = def._pK + "," + key;
				def.isComposite = true; 
			}
			else{
				def._pK = key;
			}
			if(field.baseKey){
				if(def.bK){
					_dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.warn(db.lyte, "LD02",type,def._name);
					return;
				}
				def.bK = key
			}	
		}
		def.fieldList[key] = field;
		if(oldField && def._fldGrps){
			if(oldField.hasOwnProperty("default")){
				delete def._fldGrps.default[key];
			}
			if(oldField.hasOwnProperty("watch")){
				delete def._fldGrps.watch[key];
			}
			if(oldField.hasOwnProperty("inherit")){
				delete def._fldGrps.inherit[key];
			}
		}
		if(field.hasOwnProperty("default")){
			def._fldGrps.default[key] = field;
		}
		if(field.hasOwnProperty("watch") && (field.watch == true || Array.isArray(field.watch)) && /^(array|object)$/.test(field.type)){
			def._fldGrps.watch[key] = field;
		}
		if(field.opts &&  field.opts.hasOwnProperty("inherit")){
			def._fldGrps.inherit[key] = field;
		}		
	}
	else if(field._type == "prop"){
		if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.newGetSuperClass)(field.type,  undefined, def.db.constructor.DataType)){
			field.is = "transform";
			def.fieldList[key] = field;
		}
		else{
			_dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.warn(db.lyte, key+" in Schema-"+def._name+" is not a valid prop");
		}
		if(field.type && (field.type.hasOwnProperty("properties") || field.type.hasOwnProperty("items"))){
			def._fldGrps.nested_prop[key]=field
		}
	}
	if(field.type === "relation"){
		field.relKey = key;
		var relTo;
		if(typeof field.relatedTo == "string"){
			var fRelToName = dbModName(field.relatedTo, "Schema"); 
			_relTo = db.constructor.getSchema(field.relatedTo);
			if(_relTo){
				relTo = _relTo;
			}
			else{
				var _id = db.constructor.Schema.schema.addEventListener("add", function(name, newRelTo){
					if(name == fRelToName){
						relDef(def, key, newRelTo, field);
						db.constructor.Schema.schema.removeEventListener(_id);
					}
				});
			}
		}
		else{
			relTo = field.relatedTo;
		}
		if(relTo){
			relDef(def, key, relTo, field);
		}
	}	
}

function relDef(def, key, relTo, field){
	if(typeof field.relatedTo == "string" && relTo && typeof relTo !== "string"){
		field.relatedTo = relTo;
	}
	var relObj = def.fieldList[key];
	if(!def.relations.get(relTo)){
		def.relations.set(relTo, []);
	}
	var rArr = def.relations.get(relTo);
	var chkObj = {};
	chkObj.relKey = relObj.relKey; 
	checkObjAndAddToArr(rArr, relObj, chkObj);
	if(field.relType == "hasMany"){
		def._fldGrps.hasMany[key] = field;
	}
	if(field.hasOwnProperty("opts") && field.opts.hasOwnProperty("reverseKey")){
		def._fldGrps.reverseKey.set(relTo, field);
	}
}
function unRegCb(db,type,name){
	var callback = db[type][name];
	if(!callback){
		_dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.error(db.lyte,"LD02",type,name);
		return;
	}
	var extendedBy = callback.__extendedBy;
	if(extendedBy.length)
	{
		db[type].__toAddSuper = db[type].__toAddSuper || {};
		if(!db[type].__toAddSuper[name])
		{
			db[type].__toAddSuper[name] = extendedBy.slice();
		}
		else
		{
			extendedBy.forEach(function(item){
				db[type].__toAddSuper[name].push(item);
			});
		}
		extendedBy.forEach(function(item){
			db[type][item].$super = undefined;
		});
		if(db[type].application && name != "application")
		{	
			var application = db[type].application;
			extendedBy.forEach(function(item){
				db[type][item].$super = application;
				db[type].application.__extendedBy.push(item);
			});
		}
		if(!db[type].application)
		{
			if(!db[type].__toAddSuper.application)
			{
				db[type].__toAddSuper.application = extendedBy.slice();
			}
			else
			{
				extendedBy.forEach(function(item){
					db[type].__toAddSuper.application.push(item);
				});
			}
		}
	}
	if(callback.$super){
		callback.$super.__extendedBy.splice(callback.$super.__extendedBy.indexOf(name),1);
	}
	delete db[type][name];
}

function extendDef(extend, mdl, db){
	var scp = mdl || this,
	// scp = getSchemaObj(db, scp),
	db = db || scp.db;
	if(!extend){
		return;
	}
	var parentFields = Object.assign({},extend.fieldList);
	for(var key in parentFields){
		if(parentFields[key].type == "relation"){
			delete parentFields[key];
		}
	}
	var pkObj = {}, 
	extendParentPks = scp._pK == "id" && scp.fieldList.id.defined == false ? true : false;
	for(var key in parentFields){
		var fld = parentFields[key], 
		custPk = extendParentPks && fld.primaryKey && fld.defined != false;
		if(scp.fieldList.hasOwnProperty(key) && scp._fldGrps){
			var oldField = scp.fieldList[key];
			if(oldField.hasOwnProperty("default")){
				delete scp._fldGrps.default[key];
			}
			if(oldField.hasOwnProperty("watch")){
				delete scp._fldGrps.watch[key];
			}
		}
		if(fld.hasOwnProperty("default")){
			scp._fldGrps.default[key] = fld;
		}
		if(fld.hasOwnProperty("watch") && fld.watch == true && /^(array|object)$/.test(fld.type)){
			scp._fldGrps.watch[key] = fld;
		}
		if(!fld.primaryKey){
			scp.fieldList[key] = fld;
		}
		else {
			pkObj[key] = fld;
		}
	}
	var pkObjKeys = Object.keys(pkObj), pkObjLen = pkObjKeys.length;
	if(extendParentPks && pkObjLen){
		delete scp.fieldList.id;
		for(var key in pkObj){
			scp.fieldList[key] = pkObj[key];
		}
		if(pkObjLen == 1){
			scp._pK = pkObjKeys[0];
			scp._arrPk = Array.from(pkObjKeys);
		}
		else{
			scp.isComp = true;
			scp._arrPk = Array.from(pkObjKeys);
			scp._pK = scp._arrPk.toString();
		}
	}
	var name = scp._name;
	db.schema[name].extend = extend._name;
	extend.extendedBy = extend.extendedBy || {};
	extend.extendedBy[name] = true;
	// if(!db.connector[name] && db.connector[extend]){
	// 	db.connector[name] = db.connector[extend];
	// }
	// if(!db.serializer[name] && db.serializer[extend]){
	// 	db.serializer[name] = db.serializer[extend];
	// }
	if(extend.actions){
		var actions = scp.actions = scp.actions || {};
		for(var key in extend.actions){
			if(!actions.hasOwnProperty(key)){
				actions[key] = extend.actions[key]; 							
			}
		}					
	}
}

function demoLishObserverBindings(obj,prop,record){
	if(!record){
		record = obj;
	}
	for(var key in prop){
		if(obj[key] instanceof Object){
			if(record && obj[key]._setterScope){
				var ind = obj[key]._setterScope.indexOf(record);
				ind != -1 ? obj[key]._setterScope.splice(ind, 1) : undefined;
			}
			if(Object.keys(prop[key]).length){
				demoLishObserverBindings(obj[key],prop[key],obj);
			}
		}
		if(obj._setterScope && obj != record){
			var inx = obj._setterScope.indexOf(record);
			inx != -1 ? obj._setterScope.splice(inx, 1) : undefined;
		}
	}
}

function establishObsBindings(obj,prop,record){
	if(!record){
		record = obj;
	}
	for(var key in prop){
		if(obj[key] instanceof Object){
			if(!obj[key]._bindings){
				_defProp(obj[key], '_bindings', new Set(), false, true, true);
			}
			if(record && !obj[key]._setterScope){
				_defProp(obj[key],'_setterScope',[]);
			}
			var ind = obj[key]._setterScope.indexOf(record);
			ind == -1 ? obj[key]._setterScope.push(record) : undefined;
			obj[key]._bindings.add(prop[key]);
			if(Object.keys(prop[key]).length){
				establishObsBindings(obj[key],prop[key],obj);
			}
		}
		if(!obj._setterScope){
			_defProp(obj, '_setterScope', []);
			obj._setterScope.push(obj);
		}
	}
}

function isEmpty(val){
	if(val != undefined && val !== "" && val != null){
		return false;
	}
	return true;
}

function isEmptyObj(obj){
	if(obj !== null && typeof obj == "object" && Object.keys(obj).length == 0){
		return true;
	}
	return false;
} 

function isEmptyArray(arr){
	if(Array.isArray(arr) && arr.length == 0){
		return true;
	}
	return false;
}

function compareData(data1, data2, isQp){
	if(!isEmpty(data1) && !isEmpty(data2)){
		var data1Type = typeof data1, data2Type = typeof data2;
		if(data1Type !== data2Type){
			return false;
		}
		switch(data1Type){
			case "string":
			case "number":
			case "boolean":
			if(data1 === data2){
				return true;
			}
			break;
			case "object":
				return compareObjects(data1, data2, isQp);
		}
	}
	return false;
}

function compareObjects(obj1, obj2, qP){
	if(!(obj1 instanceof Object) || !(obj2 instanceof Object)){
		return false;
	}
	if(Object.keys(obj1).length != Object.keys(obj2).length){
		return false;
	}
	for(var key in obj1){
		var val1 = obj1[key], val2 = obj2[key];
		if(qP && Array.isArray(val1) && Array.isArray(val2)){
			if(val1.length != val2.length){
				return false;
			}
			var len = val1.length;
			for(var i=0; i<len; i++){
				var ret = compareData(val1[i], val2[i], qP);
				if(!ret){
					return false;
				}
			}
		}
		else if(val2 == undefined || !compareData(val1,val2,qP)){
			return false;
		}
	}
	return true;
}

function setData(self, attr, value, opts, redoObj, ignoreChange){
	var toEmit = {emit : false, attr : [], oldRec : {}}, 
	schema = self.schema, 
	db = schema.db,
	_estObsBind = false, 
	record = self.entity, 
	attrData;
	if(record && record.$.isStrict && record.$.isDeleted){
		_dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.warn(db.lyte, "LD29");
		return;
	}
	if(attr && typeof attr === "object"){
		attrData = [];
		opts = value;
		for(var key in attr){
			attrData.push(key);
			setValue(self, key, attr[key], opts, toEmit, ignoreChange);
			schema && schema._properties && schema._properties.hasOwnProperty(key) ? _estObsBind = true : undefined;
		}
	}
	else{
		attrData = attr;
		setValue(self, attr, value, opts, toEmit, ignoreChange);
		schema && schema._properties && schema._properties.hasOwnProperty(attr) ? _estObsBind = true : undefined;
	}
	self.emit("set", [self.entity, attrData]);
	self.schema.emit("set", [schema._name, self.entity, attrData]);
	db.emit("set", [schema._name, self.entity, attrData]);
	if(_estObsBind){
		establishObsBindings(record, schema._properties);
	}
	if( !ignoreChange && toEmit.emit){
		changeCallbck(record, toEmit, redoObj)
	}
	return record;
} 

function changeCallbck(record, toEmit, redoObj){
	var db = record.$.schema.db;
	var arr = [record, toEmit.attr], 
	self = record.$;
	self.emit("change", arr);
	self.schema.emit("change", arr);
	db.emit("change", [self.schema._name,self.entity, toEmit.attr]);
	if(redoObj){
		for(var key in toEmit.oldRec){
			redoObj[key] = toEmit.oldRec[key];
		}
	}
	else{
		for(var index=0;index<toEmit.attr.length;index++){
			var key = toEmit.attr[index];
			self.undoStack[key] = self.undoStack[key] || [];
			self.undoStack[key].push(toEmit.oldRec[key]);
		}
		// self.undoStack._order_ = self.undoStack._order_ || _defProp(self.undoStack, "_order_", [], false, true);
		self.undoStack._order_.push(toEmit.attr); 
	}
}

function setValue(self,attr,value,opts,toEmit,ignoreChange,deepChange){
	var schema = self.schema, 
	db = schema.db,
	lyte = db.lyte,
	pK = schema._pK, 
	record = self.entity, 
	_attrs = record.$._attributes;
	if(attr === "$"){
		return;
	}
	if(attr != schema._pK){
		var field = schema.fieldList[attr], watch = field && field.opts ? field.opts.watch == true : undefined;
		var serz = field && field.opts ? field.opts.hasOwnProperty("serialize") : undefined;
		if(!field){
			(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)( lyte, record, attr, value, undefined, true );
			return;
		}
		else if(field.mandatory && (value == undefined || value == null || value === "")){
			_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.setRecErr(self, attr, {code : "ERR02", message : _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes.ERR02, value : value});
		}
		else if(field.relType){
			var relType = field.relType;
			var rel ={},relRec, oldVal, relMod = getSchemaObj(db, field.relatedTo), bDef = relMod, bPk = bDef._pK, relPk = relMod._pK, isComp = relMod.isComp, bPkType = isComp ? "object" : relMod.fieldList[bPk].type, relRec;
			var isComp = relMod.isComp, bPk = relMod._pK, bPkType = isComp ? "object" : relMod.fieldList[bPk].type, isPoly = field && field.opts ? field.opts.polymorphic : undefined;;
			getRelations(db, schema, field.relKey, relMod, rel);
			// var oldRecVal = record[attr], oldRecId, newRecId;
			// if(oldRecVal && isEntity(oldRecVal)){
			// 	oldRecId = oldRecVal.$.pK;
			// }
			// if(value && isEntity(value)){
			// 	newRecId = value.$.id;
			// }

			if(record[attr] && relType == "hasMany"){
				oldVal = [];
				record[attr].forEach(function(item){
					oldVal.push(item);
				});
				if(record[attr] === value){
					return;
				}
				if(Array.isArray(value) && value.length === record[attr].length){
					var valLen = value.length,j=0, val;
					for(var i=0;i<valLen;i++){
						val = value[i];
						if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(val)){
							relRec = val;
						}
						else {
							if(val && typeof val == bPkType){
								relRec = db.cache.getEntity((val._type) ? val._type : field.relatedTo, val);
							}
						}
						if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(relRec) && relRec === record[attr][i]){
							j++;
						}
						else{
							break;
						}
					}
					if(j && j == valLen){
						return;
					}
				}
				// oldVal = record[attr].slice(0);
				// oldVal1 = record[attr].mapBy(relMod._pK);
				addOnSave(db, schema._name, record, attr, field, pK, relPk);
				// toDemolishLink(schema, record, rel.forward);
				var relData = Array.from(record[attr]);
				relData.forEach(function(rec){
					demolishLink(db, rec, relPk, record, rel.forward.relKey, undefined, undefined, undefined, true);
					if(rel.backward !== null){
						demolishLink(db, record, schema._pK, rec, rel.backward.relKey, rel.forward);
					}
					_attrsForRel(record, attr, "removed", rec);
				});
				// // record[attr].splice(0, record[attr].length);
				// if(record[attr].length){
				// 	handleArrOp(lyte, record[attr], "removeAt", undefined, 0, record[attr].length);
				// }
				// _attrsForRel(record, attr, "removed", oldVal, 0);
				// if(!_attr.size){
				// 	delete record.$._attributes[attr];
				// }
			}
			else if(record[attr] && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(record[attr]) && relType == "belongsTo"){
				oldVal = record[attr];
				if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(value)){
					relRec = value;
				}
				else {
					if(value && typeof value == bPkType){
						relRec = db.cache.getEntity((value._type) ? value._type : field.relatedTo, value);
					}
				}
				if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(relRec) && relRec === record[attr]){
					return;
				}
				// oldVal = this.createCopy(record[attr]);
				addOnSave(db, schema._name, record, attr, field, pK, relPk);
				// oldVal1 = record[attr][relMod._pK];
				// toDemolishLink(schema, record, rel.forward);
				var relRef = record[attr];
				demolishLink(db, relRef, relPk, record, rel.forward.relKey, undefined, undefined, undefined, true);
				if(rel.backward !== null){
					demolishLink(db, record, schema._pK, relRef, rel.backward.relKey, rel.forward);
				}
				_attrsForRel(record, attr, "removed", relRef);
				// record[attr] = undefined;
				(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(lyte, record, attr, {}, opts, true);
				// _attrsForRel(record, attr, "removed", oldVal);
			}
			if(relType == "hasMany" && isEmpty(value)){
				var partial = record[attr] && record[attr].partial ? record[attr].partial : undefined;  
				(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(lyte, record, attr, [], opts, true);
				partial ? (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.defProp)(record[attr], "partial", { value : partial }) : undefined;
				establishObsBindings(record, record.$.schema._properties);
				defArrUtls(record[attr]);
				defPolyUtls(record[attr]);
				defUtls(record[attr], relMod, record, attr);	
			}

			if(!Array.isArray(value)){
				value = [value];
			}
			else if(relType == "belongsTo"){
				revertToOldVal(record, attr, oldVal, rel);
				_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.setRecErr(self, attr, "ERR21", value);
				return;
			}

			var err = [];
			for(var i=0; i<value.length; i++){
				if(isEmpty(value[i]) || (relType == "belongsTo" && isEmptyObj(value[i])) || (relType == "hasMany" && isEmptyArray(value[i]))){
					continue;
				}
				var relRecord = value[i], relMod1 = (value[i] && value[i]._type) ? value[i]._type : field.relatedTo;
				relMod1 = getSchemaObj(db, relMod1);
				if(!isComp && value[i] && typeof value[i] === bPkType){
					relRecord = db.cache.getEntity((value[i]._type) ? value[i]._type : field.relatedTo, value[i]);
					if(relRecord == undefined){
						addToRelate(db, schema._name, record, rel, value[i]);
					}
					else if(!_Entity_js__WEBPACK_IMPORTED_MODULE_4__.Entity.strictRelSet && relRecord && relRecord.$ && relRecord.$.isError){
						err.push({code : "ERR15", message : _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes.ERR15, error : Object.assign({}, relRecord)});
						continue;
					}
				}
				else if(value[i] && typeof value[i] == "object"){
					if(!_Entity_js__WEBPACK_IMPORTED_MODULE_4__.Entity.strictRelSet && relRecord.$ && relRecord.$.isError){
						err.push({code : "ERR15", message : _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes.ERR15, error : Object.assign({}, relRecord)});
						continue;
					}
					else if(!(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(relRecord)){
						if(isPoly && value[i] && value[i]._type){
							relRecord = db.cache.getEntity(db.getSchema(value[i]._type), getpKVal(value[i], db.getSchema(value[i]._type)));
						}
						else if(isComp){
							relRecord = db.cache.getEntity((value[i]._type) ? value[i]._type : field.relatedTo, value[i]);
							if(!relRecord){
								relRecord = newRecord(db, relMod1, value[i], opts ? opts.skipValidation : undefined);
							}
						}
						else if(value[i].$ && value[i].$.isSavedState){
							relRecord = db.cache.getEntity((value[i]._type) ? value[i]._type : field.relatedTo, value[i].$.pK);
							// if(!relRecord){
							// 	//to check 	
							// }
							setState(relRecord.$, value[i]);
						}
						else{
							relRecord = newRecord(db, relMod1, value[i],opts?opts.skipValidation:undefined);
						}
						if(!_Entity_js__WEBPACK_IMPORTED_MODULE_4__.Entity.strictRelSet && relRecord.$.isError){
							err.push({code : "ERR15", data : value[i], message : _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes.ERR15, error : Object.assign({}, relRecord)});
							continue;
						}
					}
				}
				var changed = establishLink(db, rel.forward, rel.backward, record, relRecord , undefined, undefined);
				if(changed != true){
					err.push({code : changed, data : value[i], message : _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes[changed]});
				}
				else{
					_attrsForRel(record, attr, "added", relRecord);
					// if(!_attr.size){
					// 	delete record.$._attributes[attr];
					// }
					addOnSave(db, schema._name, record, attr, field, pK, relPk);
				}
			}
			if(err.length && (err.length == value.length)){
				revertToOldVal(record, attr, oldVal, rel);
				if(field.relType == "belongsTo"){
					_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.setRecErr(self, attr, err[0]);
				}
				else{
					_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.setRecErr(self, attr, err);
				}
				return;
			}
			else{
				if(err.length > 1){
					_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.setRecErr(self, attr, err);
				}
				else{
					_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.clrRecErr(self, attr);
				}
				if(!ignoreChange || serz){
					toEmit.emit = true;
					toEmit.attr.push(attr);
					var obj = {}; obj.records = oldVal; obj._type = "update";
					toEmit.oldRec[attr] = obj;
					var _attr = _attrs[attr] = _attrs[attr] || new Map();
					var _changes = _attr._changes = _attr._changes || []; 
					_changes.push({_type:"changed", records:oldVal});
					cmpRelInitVal(record, attr, bDef);
				}
			}
		}
		else{
			if(value !== record[attr]){
				// if(field && field.type !== Lyte.getDataType(value) && (value !== undefined  || field.type === "boolean")) {
				// 	value = Lyte.typeCast(value, field.type);
				// }
				var clear = true;
				if(!opts || (opts && opts.skipValidation !== true)){		
					for(var property in field){
						var resp = (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.checkProperty)(property, value, attr, field[property], record, schema._name, db, _ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.errorCodes, undefined, field, true);
						if(resp != true){
							if(typeof resp == "object"){
								resp.value = value;
							} 
							_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.setRecErr(self, attr, resp);
							clear = false;
							if(_Entity_js__WEBPACK_IMPORTED_MODULE_4__.Entity.strictValueSet === false){
								break;
							}
							return;
						}
					}
				}
				if(!ignoreChange){
					estAttrs(record, attr, value, toEmit, deepChange, opts, clear);
				}
				else{
					if(watch && /^(array|object)$/.test(field.type)){
						(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.establishObjectBinding)(record, attr, true, undefined, undefined,watch);
					}
					(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(lyte,record,attr,value,opts,true);
				}
			}
			else if(value === record[attr] && record.$.isError && record.$.error[attr]){
				var valid = true;
				for(var property in field){
					var resp = (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.checkProperty)(property, value, attr, field[property], record, schema._name, db, _ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.errorCodes, undefined, field, true);
					if(resp != true){
						valid = false;
					}
				}
				if(valid){
					_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.clrRecErr(self,attr);
				}
			}
		}
		checkAttrs(record);
	}
	else{
		if(record[attr] !== value){
			_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.setRecErr(self, attr, "ERR01", value);
		}
	}
}

function estAttrs(record, attr, value, toEmit, deepChange, opts, clear){
	var _attrs = record.$._attributes, 
	schema = record.$.schema, 
	attribute = _attrs[attr], 
	isAttrPres = _attrs.hasOwnProperty(attr);
	if( !isAttrPres){
		_attrs[attr] = deepChange ? deepChange.data : createCopy(record[attr]);
	}
	else if((( deepChange && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.cmpData)(isAttrPres ? attribute : deepChange.data, record[attr])) || (value && typeof value == "object" && ( !deepChange && compareObjects(attribute, value))) || (attribute == value))){
		delete _attrs[attr];
	}
	var hasAttr = record.hasOwnProperty(attr), 
	oldAttrVal = deepChange ? deepChange.data : record[attr];
	if(!deepChange){
		var isPropPresent = schema._properties && schema._properties.hasOwnProperty(attr), propObj = {};
		if(isPropPresent){
			propObj[attr] = schema._properties[attr];
			demoLishObserverBindings(record, propObj);
		}
		(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(schema.db.lyte,record,attr,value,opts,true);
	}
	if(clear){
		_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.clrRecErr(record.$, attr);
	}
	if(record.$.srtObs){
		changeRelPkMaps(record, undefined, undefined, "sort", attr);
	}
	var obj = {};
	obj._type = "update";
	obj.val = oldAttrVal;
	if(!hasAttr){
		obj._type = "propAdd";
	}
	toEmit.emit = true;
	toEmit.attr.push(attr);
	toEmit.oldRec[attr] = obj;
}

function checkAttrs(record){
	var schema = record.$.schema;
	if( Object.keys(record.$._attributes).length ){
		// changeModified(schema.db.lyte, record, true, record.$.pK, true);
		if(!record.$.isNew){
			(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(schema.db.lyte, record.$, "isModified", true);
			changePersist(record, false);
		}
		addDeepNest(record);
		checkAndAddToArray(schema.dirty, record[schema._pK]);
	}
	else{
		// changeModified(schema.db.lyte, record, false);
		(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(schema.db.lyte, record.$, "isModified", false);
		changePersist(record, true);
		if(!record.$.isNew && (!record.$.hasOwnProperty("dN") || (record.$.dN && !Object.keys(record.$.dN).length))){
			var ignorePartial = record.$.isNew ? true : false;
			removeParentNesting(record, ignorePartial);                  
		}
		if(!record.$.isNew){
			deleteFromArray(schema.dirty, record.$.pK);
		}
	}
}

function checkForCorrectRelation(db,rel,record){
	var relatedTo = rel.relatedTo;
	if(!(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(record)){
		return false;
	}
	if(rel.opts && rel.opts.polymorphic){
		return (record.$.schema.extend ? rel.relatedTo === db.getSchema(record.$.schema.extend) : false);
	}
	return (rel && record ? relatedTo === record.$.schema.def : false);
}

function partialData(rec, prop, relRec, type, polymorphicType,partRemoveOnly){
	var arr = rec[prop];
	if(!arr || !Array.isArray(arr)){
		return true;
	}
	if(!arr.partial){
		defPar(arr);
	}
	var partial = arr.partial; 
	// = arr.partial || new Map();
	if(!partial.get(relRec)){
		partial.set(relRec, {});
	}
	var revert = false, 
	obj = partial.get(relRec), 
	objType = obj.type;
	if(type == "delete"){
		partial.delete(relRec);
		revert = true;
	}
	else{
		switch(objType){
			case "added":{
				if(type == "removed"){
					partial.delete(relRec);
					revert = true;
				}
				break;
			}
			case "removed":{
				if(type == "added"){
					if(rec[prop]._recMap){
						var relRec = rec[prop]._recMap.get(relRec.$.pK);
					} 
					if(!relRec || ((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(relRec) && !relRec.$.isDirty())){
						partial.delete(relRec);
						revert = true;
					}
					else{
						var obj = partial.get(relRec);
						obj.type = "modified";
					}
				}
				break;
			}
			case "modified":
			case "updated":{
				if(type == "added"){
					//this case mostly won't come. if at all it comes, break
					break;
				}
			}
			default:{
				if(!partRemoveOnly){
					var pObj = { type : type };
					polymorphicType ? pObj.polymorphicType = polymorphicType : undefined;
					partial.set(relRec, pObj);
				}
			}
		}
	}
	if(revert && !partial.size){
		deleteDeepNest(rec, prop, relRec);
		return true;
	}
}

function removeDeepNest(record){
	if(!(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(record)){
		return;
	}
	var bool1 = record.$.dN && Object.keys(record.$.dN).length;
	if(bool1){
		record.$.dN = {};
		var schema = record.$.schema, 
		relations = schema.relations;
		relations.forEach(function(rels, key){
			rels.forEach(function(item){
				var opts = item.opts;
				if(opts && (opts.deepNest == true || opts.serialize == "partial")){
					var data = record[item.relKey];
					if(Array.isArray(data)){
						data.forEach(function(itm){
							if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(itm)){
								removeDeepNest(itm);
								if(!itm.$.isNew && !itm.$.isModified && (!itm.$.dN || ( itm.$.dN && Object.keys(itm.$.dN).length == 0 ))){
									removeParentNesting(itm);
								}
							}
						});
					}
					else if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(data)){	
						removeDeepNest(data);
						if(!data.$.isNew && !data.$.isModified && (!data.$.dN || ( data.$.dN && Object.keys(data.$.dN).length == 0))){
							removeParentNesting(data);
						}																			
					}
				}
			});					
		});
	}
}

function addDeepNest(record, extended,type,parentRel,ignoreRel, mp , processOnlySrzPart){
	var relatedRecord, 
	mp = mp || new Map(),
	db = record.$.schema.db,
	schema = extended ? db.schema[record.$.schema.extend] : record.$.schema, 
	pK = record.$.pK,
	type = type || "updated",
	relations = schema.relations;
	relations.forEach(function(rels, key){
		rels.forEach(function(item){
			var inv , deep, part, serz, bMod = getSchemaObj(db , item.relatedTo);
			inv = getBackwardRel(schema,item,bMod);
			if(bMod){
				if(!item.relKey || (inv === item)){
					relatedRecord = getRelatedRecord(record,getSchemaObj(db, item.relatedTo),item.dummy ? item.dummy: item.relKey);
				}
				else{
					relatedRecord = record[item.relKey];
				}
				if(relatedRecord){
					var mppass = false, nmp , ignoreDn;
					if(inv !== parentRel){		
						if(!mp.get(inv)){
							nmp = mp.set(inv, new Map());
							mppass = true;
						}
						nmp = mp.get(inv);			
						if(mppass || !nmp.get(relatedRecord)){
							nmp.set(relatedRecord, true);
							if(inv && inv.opts){
								deep = inv.opts.deepNest;
								part = inv.opts.serialize == "partial" ? true : false; 
								serz = inv.opts.serialize ? true : false;
							}
							if((type == "updated" && serz == "id")){
								ignoreDn = true;
							}
							if((!processOnlySrzPart || ( processOnlySrzPart && part)) && !ignoreDn){
								if(deep == true){
				//					if(deep || part){
									makeDirty(relatedRecord, type, inv, pK, item, record, mp);
								}
								if(serz && record && relatedRecord && (!ignoreRel || !(ignoreRel && ignoreRel.schema === item.relatedTo && inv.relKey === ignoreRel.relKey))){
									var data = relatedRecord;
									if(inv.relType == "hasMany"){
										if(Array.isArray(data)){
											data.forEach(function(item){
												partialData(item, inv.relKey, record , /^(added|removed)$/.test(type) ? type : "modified");								
											});
										}
										else if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(data)){
											partialData(data, inv.relKey, record, /^(added|removed)$/.test(type) ? type : "modified");	
										}
									}
									else{
										if(Array.isArray(data)){
											data.forEach(function(item){
												if(type == "added" && item && item.$ && item.$.partial && item.$.partial[inv.relKey] && item.$.partial[inv.relKey].has(pK)){
													delete item.$.partial;
												}
											});
										}
										else if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(data)){
											if(type == "added" && data && data.$ && data.$.partial && data.$.partial[inv.relKey] && data.$.partial[inv.relKey].has(pK)){
												delete data.$.partial;
											}
										}
									}
									//partialData(record[item.relKey], inv.relKey, pK , "modified");
								}
							} 
						}
					}
				}
			}
		});		
	});
	if(schema.extend){
		addDeepNest(record, true);
	}
}

function makeDirty(records, type, rel, pK, parentRel, relRec, mp){
	if(!(rel.opts.serialize =='id' && type =="updated")){
		var relKey = rel.relKey;
		if(Array.isArray(records)){
			records.forEach(function(item){
				setDeepNest(item, relKey, pK, type, parentRel, relRec, mp);
			});
		}
		else if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(records)){
			setDeepNest(records, relKey, pK, type, parentRel, relRec, mp);
		}
	}
}

function setDeepNest(item, relKey, pK, type, parentRel, relRec, mp){
	var deepN = item.$.dN = item.$.dN || {}, 
	deepRel = deepN[relKey] = deepN[relKey] || new Map();
	if(!deepRel.has(relRec)){
		deepRel.set(relRec, {});
	}
	var obj = deepRel.get(relRec);
	switch(obj.type){
		case "added": {
			if(type == "removed"){
				deleteDeepNest(item, relKey, relRec);
			}
			break;
		}
		case "removed": {
			if(type == "added"){
				deleteDeepNest(item, relKey, relRec);
			}
			break;
		}
		default : {
			obj.type = type;
			changePersist(item, false);
			addDeepNest(item, undefined, undefined, parentRel, undefined, mp);		
		}
	}
}

function deleteDeepNest(rec, key, relRec){
	var deepNest = rec.$.dN;
	if(deepNest){
		if(deepNest[key] && relRec === undefined){
			delete deepNest[key];
		}
		else if(deepNest[key] && deepNest[key].get(relRec)){
			deepNest[key].delete(relRec);
			if(!deepNest[key].size){
				delete deepNest[key];
			}
		}
		if(!Object.keys(deepNest).length){
			delete rec.$.dN;
			if(!rec.$.isModified && !rec.$.isNew){
				removeParentNesting(rec);
			}
			changePersist(rec, true);
		}
	}
}

function getRelatedRecord(ins,def,key){
	if(ins){
		var relationship = ins.$._relationships;
		if(relationship[def._name] && relationship[def._name][key]){
			return relationship[def._name][key];
		}
	}
}

function removeParentNesting(rec, ignorePartial, type){
	var schema = rec.$.schema, 
	db = schema.db,
	pkVal = rec.$.pK, 
	rels = schema.relations;
	rels.forEach(function(relations, key){
		relations.forEach(function(item){
			var inv, deep, part, invRecs;
			//getRelations(schema, item.relKey, db.schema[item.relatedTo], rel);
			var bMod = item.relatedTo, _bDef = getSchemaObj(db, bMod);
			if(bMod){
				inv = getBackwardRel(schema, item, _bDef);
				//inv = rel.backward;
				if(inv && inv.opts){
					deep = inv.opts.deepNest;
					part = inv.opts.hasOwnProperty("serialize");
					if(!item.relKey || (item == inv)){
						invRecs = getRelatedRecord(rec,_bDef,item.dummy?item.dummy:item.relKey);
					}
					else{
						invRecs = rec[item.relKey];
					}
				}
				// if(deep == true){
				// 	if(Array.isArray(invRecs)){
				// 		invRecs.forEach(function(item){
				// 			if(isEntity(item)){
				// 				deleteDeepNest(item, inv.relKey, rec);
				// 			}
				// 		});
				// 	}
				// 	else if(isEntity(invRecs)){
				// 		deleteDeepNest(invRecs, inv.relKey, rec);
				// 	}
				// }
				if(part && !ignorePartial){
					if(invRecs && !Array.isArray(invRecs)){
						invRecs=[invRecs];
					}
					if(Array.isArray(invRecs)){
						invRecs.forEach(function(invItm){
							if(invItm instanceof bMod){
								if(inv.relKey){	
									if(inv.relType == "belongsTo" && invItm && invItm.$){
										if(invItm.$.partial && invItm.$.partial[inv.relKey] && invItm.$.partial[inv.relKey].has(rec)){
											invItm.$.partial[inv.relKey].delete(rec);
											if(!invItm.$.partial[inv.relKey].size){
												delete invItm.$.partial[inv.relKey]; 
											}
										}
										deep ? deleteDeepNest(invItm, inv.relKey, rec ) : undefined;
									}
									else if(inv.relType == "hasMany"){
										var invArr = invItm[inv.relKey];
										if(Array.isArray(invArr)){
											if(invArr.partial && invArr.partial.has(rec)){
												var _ptype = invArr.partial.get(rec).type;
												if(type == "modified"){
													if(/^(modified|updated)$/.test(_ptype)){
														invArr.partial.delete(rec);
													}   
												}
												else{
													invArr.partial.delete(rec);
												}
											}
											deep ? deleteDeepNest(invItm, inv.relKey, rec) : undefined;
										}
									}
								}
							}
						});
					}
				}
			}
		});		
	});
}

function cmpRelInitVal(record, attr, bDef ){
	var arr = record.$.getInitialValues(attr), 
	changed = true, 
	_attrs = record.$._attributes, 
	bPk = bDef._pK, 
	field = record.$.schema.fieldList[attr], 
	srz = field && field.opts ? field.opts.serialize : undefined, 
	cmpInd = (srz == "id" || srz == "record"); 
	if(arr && Array.isArray(record[attr]) && arr.length == record[attr].length && cmpInd){
		changed = false;
		for(var i=0; i<arr.length; i++){
			if(!comparePk(record[attr][i], arr[i])){
				changed = true;
				break;
			}
		}
	}
	var size = _attrs[attr].size;
	if((!changed && size == 0 && cmpInd) || (srz == "partial" && size == 0)){
		delete _attrs[attr];
	}
}

function _attrsForRel(record, attr, type, arr, index){
	var _attrs = record.$._attributes, 
	_attr,
	db = record.$.schema.db; 
	_attr = _attrs[attr] = _attrs[attr] || new Map();
	if(arr && !Array.isArray(arr)){
		arr = [arr];
	}
	arr.forEach(function(itm){
		var _attrObj = _attr.get(itm), currType = _attrObj ? _attrObj._type : undefined;
		switch(currType){
			case "added": {
				if(type == "removed"){
					_attr.delete(itm);
					break;
				}
			}
			case "removed":{
				if(type == "added"){
					_attr.delete(itm);
					break;
				}
			}
			default: {
				var obj = { _type : type };
				if(index){
					obj.index = index;
				}
				_attr.set(itm, obj);
			}
		}
	});
}

function establishToRelated(record, relArr){
	var bSchema = record.$.schema, 
	rel = {},
	db = bSchema.db;
	relArr.forEach(function(item){
		var rec = db.cache.getEntity(db.getSchemaObj(item.schema).def, item.pkVal);
		if(rec){
			var fSchema = rec.$.schema;
			getRelations(db, fSchema, item.key, bSchema, rel);
			establishLink(db, rel.forward, rel.backward, rec, record, undefined, true);
		}
	});
}

function add(value,type,opts,redoObj){
	var record = this.entity, 
	schema = record.$.schema,
	db = schema.db,
	attr = this.key, 
	field = schema.fieldList[attr], 
	rel = {}, 
	oldArr, 
	serz = field.opts ? field.opts.hasOwnProperty("serialize") : undefined;
	getRelations(db, schema, field.relKey, getSchemaObj(db, field.relatedTo), rel);
	if(!Array.isArray(value)){
		value = [value];
	}
	var relMod = getSchemaObj(db, rel.forward.relatedTo);
	var pK = relMod._pK, err = [], arr = [], isComp = relMod.isComp;
	if(record.$._attributes.hasOwnProperty(attr) && record.$._attributes[attr].length){
		oldArr = record.$.getInitialValues(attr);
	}
	for(var i=0; i<value.length; i++){
		var rec = value[i];
		if(isComp){
			if(typeof rec == "object" && Object.keys(rec).length === relMod._arrPk.length){
				if(this.polymorphic && !type){
					err.push({code : "ERR22", data : value[i], message : _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes.ERR22});
					continue;
				}
				
				rec = db.cache.getEntity(this.polymorphic && type ? (typeof type == "string" ? db.getSchema(type) : type) : rel.forward.relatedTo, rec);	
			}
		}
		if((!isComp && relMod.fieldList[pK].type.toLowerCase() == typeof rec) || (isComp && typeof rec == "object" && Object.keys(rec).length === relMod._arrPk.length) ){
			if(this.polymorphic && !type){
				err.push({code : "ERR22", data : value[i], message : _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes.ERR22});
				continue;
			}
			rec = db.cache.getEntity(this.polymorphic && type ? (typeof type == "string" ? db.getSchema(type) : type) : rel.forward.relatedTo, rec);
		}
		else if(typeof rec == "object" && !(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(rec)){
			if(this.polymorphic){
				var pType;
				if(rec._type){
					pType = typeof rec._type == "string" ?  db.getSchemaObj(rec._type) : rec._type
				}
				else if(type){
					pType = typeof type == "string" ?  db.getSchemaObj(type) : type
				}
				if(!pType){
					err.push({code : "ERR22", data : value[i], message : _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes.ERR22});
					continue;
				}
				rec = newRecord(db, pType, rec, opts?opts.skipValidation:undefined);
			}
			else{
				rec = newRecord(db,getSchemaObj(db,field.relatedTo), rec, opts?opts.skipValidation:undefined);
			}
		}
		var polyType = this.polymorphic && type ? type : ((rec && rec._type) ?rec._type: undefined);
		if(rec == undefined){
			err.push({code : "ERR13", data : value[i], message : _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes.ERR13});
		}
		else if(!_Entity_js__WEBPACK_IMPORTED_MODULE_4__.Entity.strictRelSet && rec.$ && rec.$.isError){
			err.push({code : "ERR15", data : value[i], message : _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes.ERR15, error : rec});
		}
		else if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(rec) && !hasDuplicateRelation(rec, record[attr], pK, polyType, relMod)){
			var resp = establishLink(db, rel.forward, rel.backward, record, rec);
			if(resp != true){
				err.push({code : resp, data : value[i], message : _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes[resp]});
			}
			else{
				arr.push(rec);
			}
		}
	}
	if(arr.length){
		if(serz){
			var obj = {_type:"added", records: arr};
			_attrsForRel(record, attr, "added", arr);
			if(redoObj){
				redoObj[attr] = obj; 
			}
			else{
				var stackObj = {};
				stackObj[attr] = obj;
				record.$.undoStack[attr] = record.$.undoStack[attr] || [];
				record.$.undoStack[attr].push(obj);
				// record.$.undoStack._order_ = record.$.undoStack._order_ || [];
				record.$.undoStack._order_.push([attr]);
			}
			var _attrs = record.$._attributes, _attr = _attrs[attr];
			if(_attr){
				var _changes = _attr._changes = _attr._changes || [];
				_changes.push(obj);
			}
			cmpRelInitVal(record, attr, relMod);
			if(Object.keys(_attrs).length > 0){
				// changeModified(db.lyte, record, true)
				if(!record.$.isNew){
					(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(db.lyte, record.$, "isModified", true);
					changePersist(record, false);
				}
				checkAndAddToArray(schema.dirty, record[schema._pK]);
			}
			else{
				delete record.$._attributes[attr];
				if(!Object.keys(record.$._attributes).length){
					// changeModified(db.lyte, record, false, record.$.pK)
					(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(db.lyte, record.$, "isModified", false);
					changePersist(record, true);
					// record.$.isModified = false;
					// delete _attrs[attr];
					if(!record.$.isNew){
						deleteFromArray(schema.dirty, record.$.pK);
						if(!record.$.dN || (record.$.dN && !Object.keys(record.$.dN).length)){
							removeParentNesting(record);
						}			
					}
				}
			}
			(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.emit)(db, "change", record, [attr]);
		}
	}
	if(err.length > 0){
		_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.setRecErr(record.$, attr, err);
	}
	else{
		_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.clrRecErr(record.$, attr);
	}
	return record;
}

function remove(key,type,redoObj){
	var record = this.entity, 
	schema = record.$.schema, 
	db = schema.db,
	lyte = db.lyte,
	attr =  this.key, 
	field = schema.fieldList[attr], 
	rel = {},
	oldArr, 
	serz = field.opts ? field.opts.hasOwnProperty("serialize") : undefined;
	getRelations(db, schema, field.relKey, getSchemaObj(db, field.relatedTo), rel);
	if(!Array.isArray(key)){
		key = [key];
	}
	var relMod = getSchemaObj(db, rel.forward.relatedTo), 
	pK = relMod._pK, 
	isComp = relMod.isComp, 
	err = [], 
	relatedRecord, 
	arr = [], 
	indices = [];
	if(record.$._attributes.hasOwnProperty(attr) && record.$._attributes[attr].length){
		oldArr = record.$.getInitialValues(attr);
	}
	for(var i=0; i<key.length; i++){
		var rec = key[i], polyType;
		if((!isComp && relMod.fieldList[pK].type.toLowerCase() == typeof key[i]) || (isComp && typeof rec == "object" && Object.keys(rec).length === relMod._arrPk.length)){
			if(this.polymorphic == true && !type){
				err.push({code : "ERR22", data : key[i], message : _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes.ERR22});
				continue;
			}
			relatedRecord = db.cache.getEntity((type)?(typeof type == "string" ? db.getSchema(type) : type):rel.forward.relatedTo,key[i]);
			polyType = type;
		}
		else if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(key[i])){
			relatedRecord = key[i];
			polyType = type ? type : ((relatedRecord && relatedRecord._type) ? relatedRecord._type : undefined);
		}
		if(relatedRecord){
			var index = getIndex(record[attr], pK, relatedRecord.$.get(pK),polyType);
			demolishLink(db, relatedRecord, pK, db.cache.getEntity(schema.def, record.$.pK), rel.forward.relKey, undefined, undefined, undefined, true);
			if(rel.backward != null){
				demolishLink(db, record, schema._pK, db.cache.getEntity((polyType)?(typeof polyType == "string" ? db.getSchema(polyType) : polyType):rel.forward.relatedTo, relatedRecord.$.pK), rel.backward.relKey, rel.forward);
			}
			arr.push(relatedRecord);
			indices.push(index);
		}
	}
	if(arr.length){
		if(serz){
			var obj = {_type:"removed", records: arr, _indices : indices};
			_attrsForRel(record, attr, "added", arr);
			if(redoObj){
				redoObj[attr] = obj; 
			}
			else{
				var stackObj = {};
				stackObj[attr] = obj;
				// record.$.undoStack.push(stackObj);
				record.$.undoStack[attr] = record.$.undoStack[attr] || [];
				record.$.undoStack[attr].push(obj);
				// record.$.undoStack._order_ = record.$.undoStack._order_ || [];
				record.$.undoStack._order_.push([attr]); 
			}
			var _attrs = record.$._attributes, _attr = _attrs[attr];
			if(_attr){
				var _changes = _attr._changes = _attr._changes || [];
				_changes.push(obj);
			}
			// if(!_attr.size){
			// 	delete record.$._attributes[attr];
			// }
			cmpRelInitVal(record, attr, relMod);
			if(Object.keys(_attrs).length > 0){
				// changeModified(lyte, record, true);
				if(!record.$.isNew){
					(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(lyte, record.$, "isModified", true);
					changePersist(record, false);
				}
				checkAndAddToArray(schema.dirty, record[schema._pK]);
			}
			else{
				delete record.$._attributes[attr];
				if(!Object.keys(record.$._attributes).length){
					// changeModified(lyte, record, false, record.$.pK)
					(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(lyte, record.$, "isModified", false);
					changePersist(record, true);
					// record.$.isModified = false;
					// delete _attrs[attr];
					if(!record.$.isNew){
						deleteFromArray(schema.dirty, record.$.pK);								
						if(!record.$.dN || (record.$.dN && !Object.keys(record.$.dN).length)){
							removeParentNesting(record);
						}			
					}
				}
			}
		}
		(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.emit)(db, "change", record, [attr]);
	}
	if(err.length > 0){
		_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.setRecErr(record.$, attr, err);
	}
	else{
		_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.clrRecErr(record.$, attr);
	}
}

function filter(record,filObj,len){
	var j=0;
	for(var key in filObj){
		if(record[key] === filObj[key]){
			j++;
		}
	}
	if(j === len){
		return true;
	}
}

function filterBy(obj){
	var len = Object.keys(obj).length, j = 0, arr = [];
	for(var i=0; i<this.length; i++){
		if(filter(this[i],obj,len)){
			arr.push(this[i]);
		}
	}
	if(!arr.filterBy){
		defArrUtls(arr);
		defUtls(arr,this.schema);
	}
	return arr;
}

function checkAndAddToArray(arr,value){
	if(!checkPresenceInArray(arr,value)){
		arr.push(value);
	}else{
		return -1;
	}
}

function deleteFromArray(arr,value){
	var ind = arr.indexOf(value);
	if(ind != -1){
		arr.splice(ind,1);
	}
}

function genPk(pK, opts, fields){
	var pkType;
	pK.forEach(function(item){
		pkType = fields[item].type;
		var random = opts[item] = Math.floor(Math.random()*100000 + 1);
		if(pkType == "string"){
			opts[item] = random.toString();                    
		}
	});
}

function generateRandomPk(def, opts, pK, fields){
	genPk(pK, opts, fields);
	while(isDuplicateRecord(def, opts, pK.toString())){
		genPk(pK, opts, fields);
	}            
}

function isDuplicateRecord(def,obj){
	var data = def.data, pK = def._pK, isComp = def.isComposite;
	if(data.length){
		if(!isComp && def.data._recMap){
			var pkVal = obj[pK];
			if(pkVal!=undefined){
				return def.data._recMap.get(pkVal ? pkVal.toString() : pkVal) !== undefined;
			}
			else{
				return false
			}
		}
		else{
			return data.some(function(record){
				if(compareObjects( getpKVal(obj, def), getpKVal(record) )){
					return true;
				}
			});
		}
	}
	return false;
}

function pkPresence(opts, pK){
	var result = true;
	pK.forEach(function(item){
		if(!opts.hasOwnProperty(item) || !opts[item] ){
			result = false;
			return;
		}
	});
	return result;
}

function updateJSON(db, record, def, dirty){
	var data = {},
	arrPk = def._arrPk,
	dirtyAttr = record.$._attributes;
	for(var field in dirtyAttr){
		data[field] = record[field];
	}
	var attrs = dirty;
	if(dirty == true){
		attrs = isDirty(db, record, def.relations) || [];
	}
	for(var i=0;i<attrs.length;i++){
		data[attrs[i]] = record[attrs[i]];
	}
	arrPk.forEach(function(item){
		data[item] = record[item];
	});
	return data;
}

function isDirty(db, record, relations, parent, fMod){
	var result = [];
	relations.forEach(function(red_def, rel){
		for(var j=0;j<red_def.length;j++){
			var rel = red_def[j];
			if(rel.opts && rel.opts.serialize){
				var key = rel.relKey, 
				type = rel.relType, 
				records = record[key],
				bMod = rel.relatedTo;
				if(parent && bMod){
					var child = getBackwardRel(fMod,rel,getSchemaObj(db, rel.relatedTo));
					if(parent == child && fMod != rel.relatedTo){
						continue;
					}
				}
				if(rel.opts.serialize == "record"){
					var res = isRelDirty(db, rel, records, rel);
					if(res){
						result.push(key);
						continue;
					}							
				}
				else if(rel.opts.serialize == "partial"){
					if(type == "hasMany"){
						if(records && records.partial && records.partial.size){
							result.push(key);
							continue;
						}
					}
					else{
						if(((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(records) && records.$.isModified) || (record && record.$ && record.$.partial && record.$.partial.hasOwnProperty(key))){
							result.push(key);
							continue;
						}
					}
				}
				if(rel.opts.deepNest == true){	
					if(record.$.dN && record.$.dN[key]){
						result.push(key);
					}
				}
			} 
		}
	});
	return result;
}

function isRelDirty(db, rel, records, parent){
	var type = rel.relType;
	var fMod = rel.relatedTo;
	var fDef = getSchemaObj(db, fMod);
	var relations = fDef.relations; 
	if(!isEmpty(records)){
		if(type == "hasMany" && Array.isArray(records) && records.length){
			var len = records.length;
			for(var i=0; i<len; i++){
				if(records[i].$.isModified == true){
					return true;
				}
			}
			for(var j=0; j<len; j++){
				var rec = records[j];
				var arr = isDirty(db, rec, relations, parent, fDef);
				if(arr.length){
					return true;
				}
			}
		}
		else if(type == "belongsTo" && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(records)){
			if(records.$.isModified == true){
				return true;
			}
			var arr = isDirty(db, records, relations, parent, fDef);
			if(arr.length){
				return true;
			}
		}
	}
	return false;
}

function polymorphicToJSON(db,rel,data){
	var opts = rel.opts;
	if(opts && opts.polymorphic){
		if(Array.isArray(data)){
			var res = [];
			data.forEach(function(item){
				res.push(polyToJSON(db,item));
			});
			return res;
		}
		else{
			return polyToJSON(db,data);
		}
	}
}

function polyToJSON(db, data){
	// var type = data ? data._type : undefined;
	var polyMod = data.$.schema;
	if(!polyMod.hasOwnProperty("fieldList") && polyMod._name){
		polyMod = db.getSchema(polyMod._name);
	} 
	var pK = polyMod ? polyMod._pK : undefined, 
	poly = {}, 
	pkVal = data.$.pK;

	if(typeof pkVal == "object"){
		poly = Object.assign({}, pkVal);
	}
	else{
		poly[pK] = pkVal;
	}
	// poly._type = data._type;
	poly._type = data._type ? data._type : data.$.model._name;
	return poly;
}

function removeBackwardRel(val,rel,pK,pkVal,wholeRelKey){
	if(wholeRelKey){
		delete val[rel.backward.relKey];
		return; 
	}
	if(rel.backward != null){
		var rec = val[rel.backward.relKey];
		if(Array.isArray(rec)){
			for(var i=0; i<rec.length; i++){
				if(comparePk(rec[i],pkVal)){
					rec.splice(i,1);
					if(rec.length == 0){
						delete val[rel.backward.relKey];
					}
					return;
				}								
			}
		}
		else if(rec && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(rec) && comparePk(rec, pkVal)){
			delete val[rel.backward.relKey];
		}
	}
}

function checkPresenceInArray(arr,value){
	return arr && arr.some(function(val){
		return val === value;
	});
}

function idbSerialize(db, data, rel, def, bDef, pkVal, expose){
	var relTo = rel.forward.relatedTo, 
	pK = def._pK, 
	bPk = bDef._pK;
	if(Array.isArray(data)){
		data.forEach(function(item, index){
			if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(item) && item.$.inIDB){
				data[index] = item[bPk];										
			}
			else if(!checkPresenceInArray(db.$.recStack[relTo._name],item[bPk])){
				removeBackwardRel(item, rel, pK, pkVal, true);
				removeSelfCircularReference(db, bDef._name, item, expose);
			}
			else{
				data[index] = item[bPk];										
			}
		});
	}
	else if(data && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(data)){
		if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(data) && data.$.inIDB){
			obj[relKey] = data[bPk];
		}
		else if(!checkPresenceInArray(db.$.recStack[relTo._name],data[bPk])){
			removeBackwardRel(data, rel, pK, pkVal, true);
			removeSelfCircularReference(db, bDef._name, data,expose);
		}else{
			obj[relKey] = data[bPk];
		}
	}
}

function idSerialize(db, obj, rel, expose, partialObj, partialRef){
	var opts = rel.forward.opts, 
	polymorphic = opts ? opts.polymorphic : undefined, 
	relKey = rel.forward.relKey,
	relKey = rel.forward.relKey, 
	toJSON,
	clone, 
	saveState;
	if(opts){
		toJSON = opts.toJSON, clone = opts.clone, saveState = opts.saveState;
	}
	var data = obj[relKey], 
	schema = rel.backward.relatedTo, 
	bDef = rel.forward.relatedTo, 
	pkVal = getpKVal(obj,getSchemaObj(db, schema)), 
	modName;
	if(Array.isArray(data)){
		if(polymorphic){
			obj[relKey] = polymorphicToJSON(db,rel.forward,data);
		}
		else{
			var arr = [];
			if(partialObj){
				var partial = partialObj[relKey] = partialObj[relKey] || [], anyNew = false;
			}
			data.forEach(function(item){
				if(item.$.isNew && expose != true && expose != "state"){
					anyNew = true;
					rSerialize(db, item, rel, bDef, schema._pK, pkVal, expose, partial, partialRef);
					arr.push(item);													
				}
				else{
					if(partial){
						var pObj = {}, pType = "related";
						if(item.$.isDeleted){
							pType = "removed";
						}
						_defProp(pObj, "$", {});
						var nPartial = 	pObj.$, nDef = getSchemaObj(db, rel.forward.relatedTo);
						Object.defineProperties(nPartial, {
							pkVal : {
								value : item.$.pK
							},
							type : {
								value : pType
							},
							schema : {
								value : nDef
							},
							record : {
								value : db.cache.getEntity(nDef.def, item.$.pK)
							}
						});		
						if(item.$.isDeleted){
							pObj.$.onlyDetach = true;
						}
						partial.push(pObj);
					}
					if(!item.$.isDeleted){
						if(expose == true && toJSON){
							arr.push(item.$.toJSON(undefined, rel.backward));
						}
						else if(expose == "state" && saveState){
							arr.push(item.$.saveState(undefined, true, rel.backward));
						}
						else if(expose == "clone" && clone){
							arr.push(item.$.clone(rel.backward));
						}
						else{
							arr.push(item.$.pK && typeof item.$.pK == "object" ? Object.assign({}, item.$.pK) : item.$.pK);
						}	
					}
				}
			});
			obj[relKey] = arr;
		}
	}
	else if(data && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(data)){
		if(data.$.isNew && expose != true && expose != "state"){
			var partial;
			if(partialObj){
				partial = partialObj[relKey] = partialObj[relKey] || {};
			}
			partial = rSerialize(db, data, rel, bDef, schema._pK, pkVal, expose, partial, partialRef);
			partialObj[relKey] = partial;
		}
		else{
			if(polymorphic){
				obj[relKey] = polymorphicToJSON(db,rel.forward,data);								
			}
			else if(!data.$.isDeleted){
				if(expose == true && toJSON){
					obj[relKey] = data.$.toJSON(undefined, rel.backward);
				}
				else if(expose == "state" && saveState){
					obj[relKey] = data.$.saveState(undefined, true, rel.backward);
				}
				else if(expose == "clone" && clone){
					obj[relKey] = data.$.clone(rel.backward);
				}
				else{
					obj[relKey] = (data.$.pK && typeof data.$.pK == "object" ? Object.assign({}, data.$.pK) : data.$.pK);
				}
			}
		}
	}
}

function recordSerialize(db, obj, key, val, rel, def, bDef, pkVal, expose, partialObj, partialRef){
	var pK = def._pK;
	if(Array.isArray(val)){
		if(val.length == 0){
			delete obj[key];
			return 0;
		}
		val = Array.from(val);
		var partial = partialObj[key] = partialObj[key] || [];
		for(var j=0; j<val.length; j++){
			if(val[j] && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(val[j])){
				rSerialize(db, val[j], rel, bDef, pK, pkVal, expose, partial, partialRef);
				if(val[j].$.isDeleted){
					partial[j] && partial[j].$ ? partial[j].$.onlyDetach = true : undefined; 
					val.splice(j,1);
					j--;
				}
			}
		}
	}
	else if(val && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(val)){
		var partial = partialObj[key] = partialObj[key] || {};
		partial = rSerialize(db, val, rel, bDef, pK, pkVal, expose, partial, partialRef);
		// if(val.$.isDeleted){
		// 	debugger
		// }
		partialObj[key] = partial;
	}
}

function rSerialize(db, data, rel, bDef, pK, pkVal, expose, partialObj, partialRef){
	var relTo = rel.forward.relatedTo, 
	partial, 
	def = rel.backward.relatedTo, 
	polymorphic = rel.forward.opts ? rel.forward.opts.polymorphic : undefined; 
	removeBackwardRel(data, rel, pK, pkVal);
	if(partialObj){
		var partial = {}, 
		pType = data.$.isNew ? "added" : data.$.isModified ? "modified" : data.$.isDeleted ? "removed" : "related", modName;
		if(polymorphic){
			modName = data.$.schema._name;
			data.$.polymorphicType = modName;
			bDef = db.schema[modName];
		}
		_defProp(partial, "$", {});
		var nPartial = 	partial.$, 
		nDef = polymorphic ? db.schema[modName] : getSchemaObj(db, relTo);
		Object.defineProperties(nPartial, {
			pkVal : {
				value : data.$.pK
			},
			type : {
				value : pType
			},
			schema : {
				value : nDef
			},
			record : {
				value : db.cache.getEntity(nDef.def, data.$.pK)
			}
		});
		if(Array.isArray(partialObj)){
			partialObj.push(partial);
		}
	}
	removeSelfCircularReference(db, bDef._name, data, expose, undefined, partial, partialRef);
	return partial;
}

function partialSerialize(db, obj, key, val, rel, def, bDef, pkVal, expose, partialObj, partialRef){
	var field = rel.forward, 
	pK = def._pK, 
	relTo = rel.forward.relatedTo,
	polymorphic = rel.forward.opts ? rel.forward.opts.polymorphic : undefined;
	if(field.relType == "hasMany"){
		if(val && val.partial){
			var part = val.partial,
			bpK = bDef._pK;
			if(partialObj){
				partial = partialObj[key] = partialObj[key] || [];
				_defProp(partial, "partial", true);
			}
			if(part){
				var pObj, 
				pKey, 
				newPartial,
				result = [], 
				self = this, 
				relRec;
				part.forEach(function(value , partKey){
					pObj = value, relRec = partKey, pKey = partKey.$.pK , newPartial;
					if(/^(added|modified)$/.test(pObj.type)){
						var pType = "related",
						ind = getIndex(val, bpK, pKey, undefined, getSchemaObj(db, relTo));
						if(ind != -1){
							var rec = val[ind], updVal, rec$;
							var polyType;
							if(rec && rec.$){
								rec$ = Object.assign({}, rec.$);
								rec = Object.assign({}, rec);
								_defProp(rec, '$', rec$);
							}
							updVal = rec;
							if(polymorphic && rec){
								polyType =  rec._type ? rec._type : rec.$.schema._name;
								bDef = db.schema[polyType];
							}
							var record = db.cache.getEntity(bDef.def, pKey);
							removeBackwardRel(rec, rel, pK, pkVal);
							if(rec.$.isNew){
								pType = "added";
							}
							else if(rec.$.isModified){
								pType = "modified";												
								var valDir = isDirty(db, record, bDef.relations);
								updVal = updateJSON(db, rec, bDef, valDir);				
							}
							else{
								var valDir = isDirty(db, record, bDef.relations);
								updVal = updateJSON(db, rec, bDef, valDir);											
							}
							if(partial){
								var newPart = {};
								_defProp(newPart, "$", {});
								var newPart$ = newPart.$,
								newPartDef = polymorphic ? polyType : relTo;
								Object.defineProperties(newPart$, {
									pkVal : {
										value : pKey
									},
									type : {
										value : pType
									},
									schema : {
										value : polymorphic ? db.schema[polyType] : getSchemaObj(db, relTo)
									},
									record : {
										value :  db.cache.getEntity(newPartDef, pKey)
									}																										
								});
								// if(partialRef){
								// 	var refId = "rec"+(++partialRef.size), refKey = partialRef.refKey;
								// 	updVal[refKey] = refId;
								// 	partialRef.set(refId, newPart);
								// }
								partial.push(newPart);
							}
							removeSelfCircularReference(db, bDef._name, updVal, expose, undefined, newPart, partialRef);			
							// var resObj = {type: pObj.type, data: updVal};
							if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(updVal)){
								updVal.$.partialType = pObj.type;
							}
							else{
								_defProp(updVal, "$", {});
								_defProp(updVal.$, "partialType", pObj.type);
								if(!updVal.$.hasOwnProperty("pK")){
									_defProp(updVal.$, "pK", pKey);
								}
							}
							if(polymorphic){
								updVal.$.polymorphicType = polyType;
							}
							result.push(updVal);
						}
					}
					else if(pObj.type == "removed"){
						var dObj = {};
						if(pKey && typeof pKey == "object"){
							Object.assign(dObj, Object.assign({},pKey));
						}
						else{
							dObj[bpK] = pKey;
						}
						var record = db.cache.getEntity(bDef.def, pKey) || db.cache.getEntity(bDef.def, pKey, true);
						if(partial){
							var newPart = {}; 
							_defProp(newPart, "$", {});
							var newPart$ = newPart.$;
							Object.defineProperties(newPart$, {
								pkVal : {
									value : pKey
								},
								type : {
									value : "removed"
								},
								schema : {
									value : polymorphic && pObj.polymorphicType ? db.schema[pObj.polymorphicType] : getSchemaObj(db, relTo) 
								},
								record: {
									value : record
								}																										
							});
							if(partialRef){
								var sz = partialRef.size,
								refId = "rec"+(++sz), refKey = partialRef.refKey;
								dObj[refKey] = refId;
								partialRef.set(refId, newPart);
							}
							partial.push(newPart);
						}
						_defProp(dObj, "$", {});
						dObj.$.partialType = "removed";
						if(polymorphic && pObj.polymorphicType){
							dObj.$.polymorphicType = pObj.polymorphicType;
						} 
						if(!dObj.$.hasOwnProperty('pK')){
							dObj.$.pK = pKey;
						}
						// result.push({type:"removed", data: dObj})

						result.push(dObj);
					}
				});
				if(result.length){
					val = obj[key] = result;
				}
				else{
					delete obj[key];
				}
			}
		}
		else{
			delete obj[key];
		}
	}
	else if(field.relType == "belongsTo" && val && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(val)){
		var polyType;
		if(polymorphic && val){
			polyType =  val._type ? val._type : val.$.schema._name;
			bDef = db.schema[polyType];
		}
		removeBackwardRel(val, rel, pK, pkVal);
		var updVal = val, valDir;
		if(val.$.isNew){
			removeBackwardRel(val, rel, pK, pkVal);
		}
		else{
			valDir = isDirty(db, val, bDef.relations);
			updVal = updateJSON(db, val, bDef, valDir);
		}
		if(partialObj){
			var partial = partialObj[key] = partialObj[key] || {};
			var pType = val.$.isNew ? "added" : val.$.isModified ? "modified" : "related";
			_defProp(partial, "$", {});
			var partial$ = partial.$;
			var partMod = polymorphic ? db.schema[polyType] : getSchemaObj(db, relTo);
			Object.defineProperties(partial$, {
				pkVal : {
					value : val.$.pK
				},
				type : {
					value : pType
				},
				schema : {
					value : partMod
				},
				record : {
					value : db.cache.getEntity(partMod.def, val.$.pK)
				}
			});
			// if(partialRef){
			// 	var refId = "rec"+(++partialRef.size), refKey = partialRef.refKey;
			// 	updVal[refKey] = refId;
			// 	partialRef.set(refId, partial);
			// }
		}
		if(polymorphic){
			updVal.$ || _defProp(updVal, "$", {});
			updVal.$.polymorphicType = polyType;
		}
		removeSelfCircularReference(db, bDef._name, updVal, expose, undefined, partial, partialRef);
		val = obj[key] = updVal;
	}
}

function removeSelfCircularReference(db, name, obj, expose, type, partialObj, partialRef, parentRel,addNotDefinedFields,inherit){
	var def = db.schema[name], 
	fieldList = def.fieldList,
	pkVal = getpKVal(obj,def),  
	record = db.cache.getEntity(def.def, pkVal), 
	partObj = (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(record) ? record.$.partial : undefined, 
	polymorphicType = obj && obj.$ ? obj.$.polymorphicType : undefined, 
	refId,
	recmp = new Map();
	recmp.set(obj,pkVal)
	db.$.recStack[name] = db.$.recStack[name] || []; 
	var ret = checkAndAddToArray(db.$.recStack[name], pkVal)
	if(partialRef){
		var sz = partialRef.size,
		refObj = {};
		refId = "rec"+(++sz);
		_defProp(refObj, "$", {pkVal: record.$.pK, schema :record.$.schema});
		partialRef.set(refId, refObj);
	}
	var unlinkedKeys = getFromCB(db,"serializer",def.serializer,"serializeEmptyRelation");
	for(var key in obj){
		var field = fieldList[key], 
		extMod, 
		swap = false, 
		relTo, 
		bDef, 
		relType;
		var removePk = ((expose == "clone" || type == "create" || ((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(obj) && obj.$.isNew)) && def._pK == key) ? true: false;
		if(field && (field == parentRel || (removePk && expose != true && expose != "state"))){
			delete obj[key];
			continue;
		}
		if(!field){
			if(polymorphicType){
				extMod = db.getSchemaObj(polymorphicType);
				field = extMod.fieldList[key];
				swap = true;
			}
			if(!addNotDefinedFields){
				delete obj[key];
			}
			continue;
		}
		if(field && field.type != "relation" && !expose  && db.dataType[field.type] && db.dataType[field.type].serialize && obj.hasOwnProperty(key)){			
			obj[key] = db.dataType[field.type].serialize(obj[key],key,record);
			continue;
		}
		if(partObj && partObj.hasOwnProperty(key)){
			var partPload = {},
			_bDef = getSchemaObj(db, field.relatedTo),
			bPk = _bDef._pK,
			doCont = false;
			partObj[key].forEach(function(item, partPk){
				partPload[bPk] = partPk.$.pK;
				_defProp(partPload, "$", {});
				_defProp(partPload.$, "partialType", "removed");
				_defProp(partPload.$, "pK", partPk.$.pK);
				if(partialObj){
					var partial = partialObj[key] = partialObj[key] || {};
					_defProp(partial, "$", {});
					var partial$ = partial.$;
					Object.defineProperties(partial$, {
						pkVal : {
							value : partPk.$.pK
						},
						type : {
							value : "removed"
						},
						schema : {
							value : _bDef
						},
						parent : {
							value : record
						},
						record: {
							value: db.cache.getEntity(field.relatedTo, partPk.$.pK)
						}
					});
				}
				if((unlinkedKeys === true || (Array.isArray(unlinkedKeys) && unlinkedKeys.indexOf(field.relKey))) && field.opts && /^(id|record)$/.test(field.opts.serialize)){
					obj[key] = null;
					doCont = true;
				}
				else if(field.opts.serialize == "partial"){
					obj[key] = partPload;
					doCont = true;
				}
				if(field && field.opts && /^(id|record)$/.test(field.opts.serialize)){
					Object.defineProperties(partial$, {
						onlyDetach:{
							value: true
						},
						relKey: {
							value: key
						}
					});
				}
			});		
			if(doCont){
				continue;
			}
		}
		if((expose == true || expose == "clone" || expose == "state") && obj[key] && typeof obj[key] == "object" && field && field.type != "relation"){
			obj[key] = (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.deepCopyObject)(obj[key]);
			continue;
		}
		if(obj[key] && field && field.type == "relation"){
			relTo = field.relatedTo;
			relType = field.relType;
			Slave = field.opts && field.opts.inherit ? true : false;
			bDef = getSchemaObj(db, relTo);
			if(bDef == undefined){
				continue;
			}
			var relKey = field.relKey, rel = {};
			if(swap){
				getRelations(db, extMod, field.relKey, bDef, rel);						
			}
			else{
				getRelations(db, def, relKey, bDef, rel);
			}
			var opts = field.opts;
			var serialize = opts ? opts.serialize : undefined, val = obj[relKey];
			if(expose == "idb"){
				idbSerialize(db, val, rel, def, bDef, pkVal, expose);
			}
			else if(inherit && Slave){
				toChildJSON(db,relTo,relType,obj[key],key,def._name,recmp,addNotDefinedFields)
				if(relType == "belongsTo"){
					var _PK = getSchemaObj(db,relTo)._pK
					if(obj[key][_PK] == pkVal && relTo == def.def){
						delete obj[key];
					}
					obj[key] = Object.assign({} , obj[key])
				}
			}
			else if((expose && !inherit)|| (inherit && !Slave) || serialize == "id"){
				idSerialize(db, obj, rel, expose, partialObj, partialRef);
			}
			else if(serialize === "record"){
				var ret = recordSerialize(db, obj, key, val, rel, def, bDef, pkVal, expose, partialObj, partialRef);
				if(ret == 0){
					if(relType === "hasMany" && (unlinkedKeys === true || (Array.isArray(unlinkedKeys) && unlinkedKeys.indexOf(field.relKey))) && Array.isArray(record[key]) && record[key].partial && record[key].partial.size){
						var emptyArr = true;
						record[key].partial.forEach(function(pobj){
							if(pobj.type !== "removed"){
								emptyArr = false;
							}
						});
						if(emptyArr){
							obj[key] = [];
							continue;
						}
					}
				}
			}
			else if(serialize === "partial"){
				partialSerialize(db, obj, key, val, rel, def, bDef, pkVal, expose, partialObj, partialRef)
			}
			else{
				delete obj[relKey];
				continue;
			}
			val = obj ? obj[relKey] : undefined;
			if( val && (relType == "hasMany" && Array.isArray(val) && val.length == 0) || (relType == "belongsTo" && typeof val == "object" && Object.keys(val).length == 0)) {
				if((unlinkedKeys === true || (Array.isArray(unlinkedKeys) && unlinkedKeys.indexOf(field.relKey))) && relType == "hasMany" && field.opts && /^(id|record)$/.test(field.opts.serialize)){
					obj[relKey] = [];
				}
				else{
					delete obj[relKey];
				}
			}
		}
		
	}
	if(partialRef){
		var refKey = partialRef.refKey;
		obj[refKey] = refId;
	}
}

function getpKVal(ins, schema){
	var schema = schema ? schema : ins.$.schema, 
	arr = schema._arrPk;
	if(arr.length == 1){
		return ins[arr[0]];
	}
	else{
		var obj = {};
		arr.forEach(function(item){
			obj[item] = ins[item];
		});
	}
	return obj;
}

function toJSONObj(db, schema, data, expose, type, partial, parentRel, addNotDefinedFields,inherit){
	var copyObj, 
	pkVal, 
	name = schema._name, 
	pK = schema._pK;
	var inhFldLen = schema._fldGrps.inherit && Object.keys(schema._fldGrps.inherit).length 
	if((expose == true || expose == "state" || expose == "clone" ) && ( !inherit || (inherit && !inhFldLen))){
		copyObj = Object.assign({},data);
	}
	else{
		copyObj = (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.deepCopyObject)(data)
	}
	if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(copyObj)){
		pkVal = copyObj.$.pK;
	}
	else{
		pkVal = db.cache.getEntity(schema.def, getpKVal(copyObj, schema)).$.pK;
	}
	var partialObj = partial ? partial.obj : undefined, partialMp;
	if(partialObj && !partialObj.has(pkVal)){
		partialObj.set(pkVal,{});
		partialMp = partialObj.get(pkVal); 
	}
	removeSelfCircularReference(db, name, copyObj,expose,type, partialMp, partial && partial.ref ? partial.ref : undefined, parentRel,addNotDefinedFields,inherit);
	if(expose == "idb"){
		db.idbIns.removeNotNeededKeys(db, name, copyObj, schema.idbObj);
	}
	return copyObj;
}

function toJSON(db,name,obj,expose,type,partialObj,parentRel,addNotDefinedFields,inherit){
	var copyObj, 
	def = db.schema[name];
	db.$.recStack = {};
	if(Array.isArray(obj)){
		var arr = [];
		for(var i=0; i<obj.length; i++){
			copyObj = toJSONObj(db, def, obj[i], expose, type, partialObj, parentRel,addNotDefinedFields,inherit);
			arr.push(copyObj);
		}
		return arr;
	}
	else if(obj && (typeof obj === "object" || (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(obj))){
		copyObj = toJSONObj(db, def, obj, expose, type, partialObj, parentRel,addNotDefinedFields,inherit);
	}
	db.$.recStack = {};
	return copyObj;
}

function createCopy(data){
	if(Array.isArray(data)){
		if(data.save){
			var arr = [];
			for(var i=0; i<data.length; i++){
				var rec = (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.deepCopyObject)(data[i]);
				arr.push(rec);
			}
			return arr;
		}
	}
	else if(data && ( (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(data) || typeof data == "object")){
		return (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.deepCopyObject)(data);
	}
	return data;
}

function initPartialObj(db, name, type, qP, key, url, customData, argsObj){
	var partial = { obj : new Map() };
	// rKey = "recId", 
	// refKey, 
	// res,
	// def = db.schema[name];
	// partial.ref = new Map();
	// res = initCB(db,"serializer", def.serializer, def.serializer.constructor.REFERENCEKEY, { argsObj: argsObj, args:[name,type,qP,key,url,customData]});
	// refKey = res ? res.data : undefined;
	// if(!isEmpty(refKey)){
	// 	rKey = refKey;
	// }
	// partial.ref.refKey = rKey;
	return partial;
}

function recChk(lyte, rec){
	if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(rec)){
		if(rec.$.isUnloaded !== true){
			return true;
		}
		else{
			_dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.error(lyte, rec+ "has been dropped. So no operations can be performed over this entity");
		}
	}
	return false;
}

function initCB(db, type, ins, key, obj){
	var args = obj.args, ret = {}, _appC, _appS;
	obj.argsObj ? obj.argsObj.callback = key : undefined;
	if(ins){
		if(ins[key]){
			ret.data = ins[key].apply(ins, obj.argsObj ? [obj.argsObj] : obj.args);
			// if(db.debug){
			// 	Dberror.log(key+" of "+ type+"-"+ins.constructor.name+ " called", "#008000")
			// }
			return ret;
		}
	}
	else{
		var appC = db.applicationConnector, appS = db.applicationSerializer;
		if(type == "connector" && appC){
			if(appC[key]){
				ret.data = appC[key].apply(appC, obj.argsObj ? [obj.argsObj] : obj.args);
				return ret;
			}
		}
		else if(type == "serializer" && appS){
			if(appS[key]){
				ret.data = appS[key].apply(appS, obj.argsObj ? [obj.argsObj] : obj.args);
				return ret;
			}
		}
	}
}

function cB(callback,args){
	return callback.func.apply(callback.context, args.concat(callback.name));
}

function cbScp(db, ins, key, type){
	if(ins){
		if(ins[key]){
			return { func : ins[key], context: ins, name:key};
		}
	}
	else{
		var appC = db.applicationConnector, appS = db.applicationSerializer;
		if(type == "connector" && appC && appC[key]){
			return { func : appC[key], context: appC, name:key };
		}
		else if(type == "serializer" && appS && appS[key]){
			return { func : appS[key], context: appS, name:key};
		}
	}
}

function getFromCB(db, type, ins, key){
	var _appC, _appS, appC = db.applicationConnector, appS = db.applicationSerializer;
	if(ins){
		return ins[key];
	}
	else{
		// var appC = db.applicationConnector, appS = db.applicationSerializer;
		if(type == "connector"){
			if(appC){
				return appC[key];
			}
		}
		else if(type == "serializer" && appS){
			if(appS){
				return appS[key];
			}
		}
	}
}

function comparePk(ins, pkVal){
	var pK = ins.$.pK, 
	pkType = typeof pK;
	if(pkType == "string" || pkType == "number"){
		return pK === pkVal;
	}
	else if(typeof pK == "object"){
		var len = Object.keys(pK).length, i=0;
		for(var key in pK){
			if(pK[key] === pkVal[key]){
				i++;
			}
		}
		return len === i;
	}
}

function newRecord(db, def, opts, skipValidation){
	var lyte = db.lyte;
	if(opts == undefined){
		opts = {};
	}
	if(opts && typeof opts !== "object"){
		_dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.warn(db.lyte, "LD25", opts);
		var err = new _ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError(db.lyte, undefined, undefined, db.lyte.getErrorMessage("LD25", opts));
		return err;
	}
	var fields = def.fieldList, 
	record = {}, 
	errorObj = new _ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError(db.lyte), 
	pK = def._arrPk;
	if(!pkPresence(opts, pK)){
		generateRandomPk(def, opts, pK, fields)
	}
	else if(isDuplicateRecord(def, opts, pK)){
		_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.setError(lyte, errorObj, pK, {code : "ERR16", message : _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes.ERR16})
	}
	for(var field in fields){
		var fieldKeys = fields[field];
		if(fieldKeys.relType == "hasMany"){
			record[field] = [];
		}
		var val = opts[field];     
		var fldType = fieldKeys.type;
		if(fldType != "relation"){
			if(val === undefined || val === ""){
				if(fieldKeys.hasOwnProperty("default")){
					val = record[field] = getDefaultVal(record, fieldKeys.default);
				}
			}
			// if(fldType !== Lyte.getDataType(val) && (val !== undefined  || fldType === "boolean")) {
			// 	val = Lyte.typeCast(val, fldType);
			// }		
			if(!skipValidation){
				for(var property in fieldKeys){
					var resp = (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.checkProperty)(property, val, field, fieldKeys[property], record, def._name, db, _ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.errorCodes, undefined, fieldKeys, true);
					if(resp != true){
						if(typeof resp == "object"){
							resp.value = val;
						}
						_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.setError(lyte, errorObj,field,resp);
						break;
					}
				}
			}	
		}    
	}
	for(var opt_key in opts){
		record[opt_key] = opts[opt_key];
	}
	record = new def.def(record, {}, db);
	(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(lyte, record.$, "isNew", true);
	changePersist(record, false);
	// record.$.isNew = true;
	var relations = def.relations;
	relations.forEach(function(relation, key){
		for(var i=0; i<relation.length; i++){
			var relObj = relation[i];
			var relKey = relObj.relKey;
			var polymorphic = relObj.opts ? relObj.opts.polymorphic : undefined; 
			if(record && record[relKey]){
				var optsRelVal = opts[relKey];
				record[relKey] = undefined;
				var fieldKeys = relation[i], rel = {}, resp = getRelations(db, def, fieldKeys.relKey, getSchemaObj(db, fieldKeys.relatedTo), rel),ingore=false;
				if(resp != true){
					_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.setError(lyte, errorObj,fieldKeys.relKey,{code : resp, data : relation, message : _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes[resp]});
					continue;
				}
				var bDef = getSchemaObj(db, fieldKeys.relatedTo), bPk = bDef._pK , isComp = bDef.isComp, bPkType = !isComp ? bDef.fieldList[bDef._pK].type : undefined;
				if(!Array.isArray(optsRelVal)){
					optsRelVal = [optsRelVal];
				}
				else if(relation[i].relType == "belongsTo"){
					_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.setError(lyte, errorObj,fieldKeys.relKey,{code : "ERR21", data : optsRelVal, message : _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes.ERR21});
					continue;
				}
				errorObj[fieldKeys.relKey] = [];
				for(var j=0; j<optsRelVal.length; j++){
					var relRecord = undefined, relMod = getSchemaObj(db, fieldKeys.relatedTo), ind;
					if(optsRelVal[j] && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(optsRelVal[j])){
						relRecord = optsRelVal[j];
					}
					else if(isComp && typeof optsRelVal[j] == "object"){
						var ind = getIndex(bDef.data, bPk, getpKVal(optsRelVal[j], bDef));
						if(ind != -1){
							relRecord = bDef.data[ind];
						}
						else{
							if(polymorphic){
								if(optsRelVal[j] && optsRelVal[j].hasOwnProperty("_type")){
									relMod =  optsRelVal[j]._type;
								}
								else{
									_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.setError(lyte, errorObj, fieldKeys.relKey, {code : "ERR22", data : optsRelVal[j], message : _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes.ERR22});
									continue;		
								}
							}
							relRecord = newRecord(db, relMod, optsRelVal[j]);									
						}
					}
					else if(optsRelVal[j] && typeof optsRelVal[j] == bPkType.toLowerCase()){
						relRecord = db.cache.getEntity(relMod.def, optsRelVal[j]);
					}
					else if(optsRelVal[j] && typeof optsRelVal[j] == "object"){
						if(polymorphic){
							if(optsRelVal[j] && optsRelVal[j].hasOwnProperty("_type")){
								relMod =  optsRelVal[j]._type;
							}
							else{
								_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.setError(lyte, errorObj, fieldKeys.relKey, {code : "ERR22", data : optsRelVal[j], message : _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes.ERR22});
								continue;		
							}
						}
						relRecord = newRecord(db, relMod, optsRelVal[j]);
						// ingore = true;
					}
					if(relRecord && relRecord.$ && relRecord.$.isError){
						_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.setError(lyte, errorObj, fieldKeys.relKey,{code : "ERR15", data : optsRelVal[j], message : _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes.ERR15, error : Object.assign({}, relRecord)});
						continue;
					}
					if(relRecord && relRecord.$ && !relRecord.$.isError){
						resp = establishLink(db, rel.forward, rel.backward, record, relRecord, undefined, ingore);
						if(resp != true){
							_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.setError(lyte, errorObj,fieldKeys.relKey,{code : resp, data : optsRelVal[j], message : _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes[resp]});
						}							
					}
				}
				if(errorObj[fieldKeys.relKey].length == 0){
					delete errorObj[fieldKeys.relKey];
				}
				if(relation[i].relType == "hasMany"){
					var fieldkey = relKey;
					if(record[fieldkey] == undefined){
						record[fieldkey] = [];
					}
					if(!record[fieldkey].add){
						if(polymorphic){
							_defProp(record[fieldkey], "polymorphic", true);
						}
						defArrUtls(record[fieldkey]);
						defUtls(record[fieldkey], relation[i].relatedTo,record,fieldkey);
						defPolyUtls(record[fieldkey]);
					}
				}
			}
		}	
	});
	if(errorObj && errorObj.$ && Object.keys(errorObj.$.error).length > 0){
		return errorObj;
	}
	var toRel = db.$.toRelate[def._name], pkVal = record.$.pK;
	if(toRel && toRel.has(pkVal)){
		establishToRelated(record, toRel.get(pkVal));
		toRel.delete(pkVal);
	}
	if(def.didLoad){
		var callBack = def.didLoad;
		for(var i=0;i<callBack.length;i++){
			callBack[i].apply(record);				
		}
	}
	handleArrOp(lyte, def.data,"push",record);
	checkAndAddToArray(def.dirty, record.$.pK);
	def.emit("add",[record]);
	db.emit("add",[def._name,record]);
	if(skipValidation){
		record.$.validatedOnCreate = false;
	}
	return record;
}

function getIndex(data,pKey,pkVal,type,def){
	var isComp = def ? def.isComp : (pKey.split(',').length > 1 ? true : false); 
	if(!isComp){
		return getInd(data, pKey, pkVal, type)
	}
	else{
		return getCompInd(data, pkVal, type, def)
	}
}

function getCompInd(data,pkVal,type,def){
	for(var i=0;data && i<data.length;i++){
		var rec = data[i];
		if(type && data[i]._type !== type){
			continue;
		}
		if(compareObjects(getpKVal(rec,def), pkVal)) {
			return i;
		}
	}
	return -1;
}

function getInd(data,pKey,pkVal,type){
	for(var i=0;data && i<data.length;i++){
		var rec = data[i];
		if(type && rec._type !== type){
			continue;
		}
		if(rec[pKey] == pkVal){
			return i;
		}
	}
	return -1;
}

function isDuplicateEntity(def,obj){
	var data = def.data, pK = def._pK, isComp = def.isComposite;
	if(data.length){
		if(!isComp && def.data._recMap){
			var pkVal = obj[pK];
			return def.data._recMap.get(pkVal ? pkVal.toString() : pkVal) !== undefined;
		}
		else{
			return data.some(function(record){
				if(compareObjects( getpKVal(obj, def), getpKVal(record) )){
					return true;
				}
			});
		}
	}
	return false;
}

function compareRecords(a,b,pK,type,def){
	var pK = def._arrPk;
	if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(a) && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(b) && pK.length){
		if(type && a._type && type !== a._type){
			return false;
		}
		var pkLen = pK.length;
		for(var i=0;i<pkLen;i++){
			var itm = pK[i];
			if(a[itm] && b[itm] && a[itm] !== b[itm]){
				return false;
			}
		}
		return true;
	}
	return false;
}

function hasRecordInArray(array,record,pK,type,isComp){
	if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(record) && pK){
		var len = array.length;
		for(var i=0; i<len; i++){
			var itm = array[i];
			if(type && itm._type !== type){
				continue;
			}
			if(isComp){
				if(compareRecords(itm, record, pK, undefined, record.$.schema)){
					return true;
				}
			}
			else{
				if((type && itm._type && type === record._type && itm[pK] === record[pK]) || (itm[pK] === record[pK])){
					return true;
				}
			}
		}
	}
	return false;
}

function hasDuplicateRelation(toRelate,relation,pK,type,def){
	var isComp = def.isComp;
	if(Array.isArray(relation)){
		if(!isComp && !relation.isPolymorphic && relation._recMap){
			return relation._recMap.get(toRelate[pK]);
		}
		else{
			return hasRecordInArray(relation, toRelate, pK, type, isComp);
		}
	}
	else if(relation && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(relation)){
		return compareRecords(toRelate, relation, pK, type, def);
	}
	return false;
}

function toInsertData(db, def, payLoad, saveParent, index){
	// var def = db.schema[name];
	var name = def._name ? def._name : def;
	var data = insertIntoStore(db, def, payLoad[name],saveParent,true, undefined, index);
	def ? delete def.rel : undefined;
	return data;
}

function insertIntoStore(db,schemaCls,data,saveParent,stack,partialObj,index, checkRelData){
	var ret;
	if(Array.isArray(data)){
		ret = [];
		for(var i=0; i<data.length; i++){
			ret[i] = insertIntoStore(db, schemaCls, data[i], saveParent, stack, partialObj, index);
			if(ret[i] && ret[i].$ && ret[i].$.isError){
				if(!ret.$){
					_defProp(ret, "$", {}, true, true ,true); 
				} 
				// ret.$.isError = true;y
				(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(db.lyte, ret.$, "isError", true);
			}
		}
	}
	else if(data && typeof data == "object" && Object.keys(data).length){
		// var cDef = db.getSchemaObj(name);
		var cDef = getSchemaObj(db, schemaCls);
		if(cDef){
			if(data._type && cDef.extendedBy){
				cDef = (cDef.extendedBy[data._type]) ? db.getSchemaObj(data._type) : undefined;
				// cDef = getSchemaObj(db, cDef);
			}
			if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(data))
			{
				return undefined;
			}
			if(checkRelData && data && cDef){
				var rels = cDef.relations;
				if(rels){
					rels.forEach(function(relArr, key){
						relArr.forEach(function(rel){
							var key = rel.relKey,
							type = rel.relType;
							if(type == "hasMany" && data.hasOwnProperty(key) && Array.isArray(data[key]) && data[key].length){
								var arr = data[key], newArr = [];
								arr.forEach(function(itm){
									if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(itm)){
										newArr.push(itm.$.pK);
									}
									else{
										newArr.push(itm);
									}
								});
								data[key] = newArr;
							}
							else if(type == "belongsTo" && data.hasOwnProperty(key) && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(data[key])){
								data[key] = data[key].$.pK;
							}
						});
					});
				}
			}
			if(!isDuplicateEntity(cDef, data, cDef._pK)){
				var rec = new cDef.def(data, {}, db);
				cDef.data.push(rec);
				var toRel = db.$.toRelate[cDef._name], pkVal = rec.$.pK;
				if(saveParent){
					db.$.saveParent = rec;
				}
				ret = validateAndPush(db,cDef,rec,partialObj);
				if(toRel && toRel.has(pkVal)){
					establishToRelated(rec, toRel.get(pkVal));
					toRel.delete(pkVal);
				}
			}
			else{
				ret = validateAndMerge(cDef,data,partialObj);
				if(ret && ret.data){
					ret = ret.data;
				}
				else if(ret && ret.type){
					Array.isArray(result.args) ? result.args.splice(0,0,db.lyte) : [db.lyte]
					_dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror[result.type].apply(_dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror, result.args || [db.lyte]);
					return;
				}
			}
			if(saveParent){
				db.$.saveParent = undefined;
			}
			if(stack){
				db.$.recStack = {};
			}
		}
		else if(typeof schemaCls == "string"){
			var defobj = db.schemaless, 
			def = defobj[schemaCls] = defobj[schemaCls] || {};
			if(index){
				if(!typeof index == "string"){
					_dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.error(db.lyte,"Index should be a string");
				}
				if(def._pK){
					if(def._pK !== index){
						_dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.error(db.lyte,"");
						return;
					}
				}
				def._pK = index;
				def._arrPk = [index];
			}
			else{
				def._pK = index = "id";
				def._arrPk = [index];
			}
			def.data = def.data || [];
			(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.defProp)(def.data,"schemaless", {value:true});
			(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.defProp)(def.data, "pK", {value:def._pK});
			var ind = getInd(def.data, index, data[index]);
			if(ind == -1){
				handleArrOp(db.lyte, def.data, "push", data);
			}
			else{
				handleArrOp(db.lyte, def.data, "replaceAt", data, ind);
			}
			return data;
		}
	}
	return ret;
}

function validateAndPush(db,def,data,partialObj){
	if(!def.rel){
		def.rel = {};
	}
	var pkVals = def._arrPk, pkValsLen = pkVals.length, index;
	for(var i=0; i<pkValsLen; i++){
		var item = pkVals[i];
		if(!data.hasOwnProperty(item)){
			index = def.data.indexOf(data);
			def.data.splice(index,1);	
			return new _ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError(db.lyte, item, {code : "ERR23", data : data, message : _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes.ERR23});
		}
		else if(data[item] == undefined || data[item] == null){
			index = def.data.indexOf(data);
			def.data.splice(index,1);	
			return new _ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError(db.lyte, item, {code : "ERR26", data : data, message : _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes.ERR26});
		}
	}
	var mapPk = (( data.$.pK == undefined || typeof data.$.pK == "object") ? data.$.pK : data.$.pK.toString());
	def.data._recMap.set(mapPk, data);
	data = validateJSON(db, def, data, undefined, undefined, partialObj);
	var index = def.data.indexOf(data); //have to check if the removal of these lines, doesn't affect any
	def.data.splice(index, 1);
	handleArrOp(db.lyte,def.data,"push",data);
	if(def.didLoad){
		var callBack = def.didLoad;
		for(var i=0;i<callBack.length;i++){
			callBack[i].apply(data);	
		}
	}
	def.emit("add",[data]);
	db.emit("add",[def._name,data]);
	return data;
}

function validateJSON(db,def,data,keys,toValidate,partialObj){
	var validate = (toValidate) ? toValidate.toValidate : undefined;
	var fields = (validate && Object.keys(validate).length) ? validate : def.fieldList;
	var extended = def.extend ? true : false;
	for(var key in data){
		if(keys && keys.indexOf(key) == -1){
			continue;
		}
		var fld = fields[key];
		if(fld){
			if(fld.type == "relation" && data[key]){
				var partialAdd = (toValidate && toValidate.toPartialAdd) ? toValidate.toPartialAdd[key] : undefined;
				var resp = handleRelation(db, key, def, fld, data, partialAdd, partialObj);
				if(resp != true){
					return new _ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError(db.lyte, key, {code : resp, data : data, message : _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes[resp]});
				}
				if(fld.relType == "hasMany" && !data[key].add){
					defArrUtls(data[key]);
					defPolyUtls(data[key]);
					defUtls(data[key],fld.relatedTo,data,key);
				}
			}
			else if(fld.type){
				var fieldKeys = fld;
				if(data[key] === undefined && fieldKeys.default){
					data[key] = getDefaultVal(data, fieldKeys.default);
				}
				var empD = getDsrzEmpData(def, fld, def._name);
				var boolChk = !empD && data[key]
				if(data.hasOwnProperty(key) && (boolChk || empD) && db.dataType.hasOwnProperty(fieldKeys.type) && db.dataType[fieldKeys.type].hasOwnProperty("deserialize")){
					data[key] = db.dataType[fieldKeys.type].deserialize(data[key],key,def._name,getpKVal(data,def));
				}
			}
		}
		else{
			if(extended){
				var extMod = db.getSchemaObj(def.extend);
				var extKey = extMod.fieldList[key];
				if(extKey && extKey.type == "relation"){
					var partialAdd = (toValidate && toValidate.toPartialAdd) ? toValidate.toPartialAdd[key] : undefined;
					var resp = handleRelation(db, key, extMod, extKey, data, partialAdd);
					if(resp != true){
						return new _ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError(db.lyte, key, {code : resp, data : data, message : _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes[resp]});
					}
					if(extKey.relType == "hasMany" && !data[key].add){
						defArrUtls(data[key]);
						defPolyUtls(data[key]);
						defUtls(data[key],extMod,data,key);
					}
				}
			}
		}
	}
	return data;
}

function handleRelation(db,key,def,field,data,partialAdd, partialObj){
	var rel = {},
	mRel = def.rel = def.rel || {};
	if (!mRel.hasOwnProperty(key)){
		var relResp = getRelations(db, def,key,getSchemaObj(db, field.relatedTo),rel);	
		if(relResp !== true){
			return relResp;
		}
		mRel[key] = rel;
	}
	else{
		rel = mRel[key];
	}
	return solveRelation(db, rel, def, getSchemaObj(db, field.relatedTo), key, data, partialAdd, partialObj);
}

function getRelations(db,fDef,key,bDef,rel){
	if(bDef == undefined){
		_dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.error("LD05",fDef.fieldList[key].relatedTo,key,fDef._name)
		return "ERR11";
	}
	rel.forward = fDef.fieldList[key];
	rel.backward = getBackwardRel(fDef,rel.forward,bDef);
	if(rel.backward === undefined){
		var temp_backward = {type: "relation",relatedTo:fDef.def, dummy:rel.forward.relKey, relKey:undefined};
		if(!bDef.relations.get(fDef.def)){
			bDef.relations.set(fDef.def, []);
		}
		var bArr = bDef.relations.get(fDef.def);
		bArr.push(temp_backward);
		rel.backward = temp_backward;
	}
	return true;
}

function getBackwardRel(fDef,rel,bDef){
	var inverse, 
	polymorphic, 
	db = fDef.db;
	if(rel.opts){
		inverse = rel.opts.reverseKey;
		polymorphic = rel.opts.polymorphic;
		if(inverse === null){
			return undefined;
		}
		if(polymorphic){
			var extDefs = bDef.extendedBy;
			if(extDefs){
				for(var key in extDefs){
					var extDef = db.getSchemaObj(key);
					// extDef = getSchemaObj(db, extDef);
					if(extDef.relations.get(fDef.def)){
						bDef = extDef;
						break;
					}
				}
			}
		}
	}
	var relatedTo;
	if(inverse && inverse != ""){
		relatedTo = inverse;
	}
	else{
		var bRel = bDef.relations.get(fDef.def);
		var extFDef = db.getSchemaObj(fDef.extend), checkPoly;
		if(!bRel && extFDef && bDef.relations.get(extFDef.def)){
			bRel = bDef.relations.get(extFDef.def);
			checkPoly = true;
		}
		relatedTo = (bRel && bRel.length == 1 && (bRel[0].opts && bRel[0].opts.reverseKey && bRel[0].opts.reverseKey !== rel.relKey ? false : true ) && (!checkPoly || (checkPoly && bRel[0].opts && bRel[0].opts.polymorphic))) ? bRel[0].relKey : undefined;
	}
	if(!relatedTo){
		var bRels = bDef.relations.get(fDef.def);
		var extFDef_1 = db.getSchemaObj(fDef.extend);
		if(!bRels && extFDef_1 && bDef.relations.get(extFDef_1.def) && bDef.relations.get(extFDef_1.def).opts && bDef.relations.get(extFDef_1.def).opts.polymorphic){
			bRels = bDef.relations.get(extFDef_1.def);
		}
		if(rel.dummy && bRels){
			for(var i=0;i<bRels.length;i++){
				if(bRels[i] && bRels[i].relKey && bRels[i].relKey == rel.dummy)
				{
					 relatedTo = bRels[i].relKey;
					 break;
				}
			}
		}
		else if(bRels){
			for(var i=0;i<bRels.length;i++){
				if(bRels[i] && bRels[i].opts && bRels[i].opts.reverseKey && bRels[i].opts.reverseKey === rel.relKey){
					relatedTo = bRels[i].relKey;
					break;
				}
				else if(bRels[i] && bRels[i].dummy && bRels[i].dummy == rel.relKey)
				{
					 relatedTo = bRels[i];
					 break;
				}
			}
		}
	}
	if(relatedTo && relatedTo.dummy){
		return relatedTo;
	}
	if(relatedTo && fDef._fldGrps.reverseKey.has(rel.relatedTo) && !rel.dummy){
		if(relatedTo && fDef.relations.get(rel.relatedTo) && fDef.relations.get(rel.relatedTo).length>1 && !inverse){
			if((!bDef.fieldList[relatedTo].opts) || bDef.fieldList[relatedTo].opts && !bDef.fieldList[relatedTo].opts.reverseKey){
				return undefined;
			}
		}
	}
	return relatedTo?bDef.fieldList[relatedTo]:undefined;			
}

function solveRelation(db,rel,fDef,bDef,key,data,partialAdd,partialObj){
	var forward = rel.forward, 
	partial = partialObj ? partialObj[key] : undefined, 
	partialRel = partial && partial.partial, 
	val = [];
	if(partialAdd){
		val = partialAdd;
	}
	else if(!partialRel){
		if(data[key] && (data[key].add || (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(data[key]) ) ){
			return true;
		}
		if(!Array.isArray(data[key])){
			data[key] = [data[key]];
		}
		else if(forward.relType == "belongsTo"){
			return "ERR21";
		} 
		val = data[key].splice(0, data[key].length);
		if(forward.relType == "belongsTo"){
			data[key] = undefined;				
		}                
	}
	else if(Array.isArray(data[key])){
		var val = data[key].splice(0, data[key].length);
	}
	for(var i=0; i<val.length; i++){
		var ret;
		ret = createAndRelate(db, fDef, bDef, data, key, val[i], rel, partial);
		if(ret != true){
			return ret;
		}
	}
	return true;
}

function createAndRelate(db, fDef, bDef, data, key, val, rel, partial){
	if(!rel.backward){
		if(rel.forward.relatedTo === fDef){
			rel.backward = rel.forward;
		}
		if(rel.backward === undefined){
			return "ERR12";
		}
	}
	var pK = fDef._pK, 
	isComp = bDef.isComp, 
	isPoly = rel.forward && rel.forward.opts ? rel.forward.opts.polymorphic : undefined,
	relatedRecord, 
	newPartial = partial && partial.hasOwnProperty(val[pK]) ? partial[val[pK]] : partial;
	if(!isComp && typeof val == bDef.fieldList[bDef._pK].type){
		relatedRecord = db.cache.getEntity(bDef.def, val);
	}
	else if(typeof val == "object" && !(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(val)){
		relatedRecord = insertIntoStore(db, bDef.def, val, undefined, undefined, newPartial);					
	}
	if(relatedRecord && relatedRecord.$ && relatedRecord.$.isError){
		(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(db.lyte, data.$, "isError", true);
		var errObj = {code:"ERR24", message: _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.errorCodes.ERR24, data: data, error: relatedRecord.$.error};
		(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(db.lyte, data.$.error, key, errObj );
	}
	else if(relatedRecord){
		if(!hasDuplicateRelation(relatedRecord, data[key], bDef._pK, isPoly ? val._type : undefined, bDef)){
			establishLink(db, rel.forward, rel.backward, data, relatedRecord, undefined, true, false);							
		}
	}
	else{
		addToRelate(db, fDef._name, data, rel, val);
	}
	return true;
}

function singleEstablishLink(forward,data,relatedRecord){
	var relation = relatedRecord.$._relationships , fName = data.$.schema._name , fRelKey = forward.relKey ;
	relation[fName] = relation[fName] || {};
	relation[fName][fRelKey] = relation[fName][fRelKey] || [];
	if(!hasDuplicateRelation(data,relation[fName][fRelKey],data.$.schema._pK, undefined, data.$.schema)){
		relation[fName][fRelKey].push(data);
	}
}	

function establishLink(db,forward,backward,data,relatedRecord,index,ignorePartial, isDuplicate,partRemoveOnly){
	if(!relatedRecord){
		return "ERR13";
	}
	if( !checkForCorrectRelation(db, forward, relatedRecord) ){
		return "ERR14";
	}
	var fRelKey = forward.relKey, 
	lyte = db.lyte,
	isPoly = forward.opts && forward.opts.polymorphic, 
	type = isPoly ? relatedRecord._type : undefined,
	ignoreRel = {};
	if(forward.relType == "belongsTo"){
		if(data[fRelKey] !== relatedRecord){
			(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)( lyte, data, fRelKey, relatedRecord, undefined, true );
		}
		if(data.$.partial && Object.keys(data.$.partial).length && data.$.partial[fRelKey]){
			delete data.$.partial[fRelKey];
		}
	}
	else if(forward.relType === "hasMany"){
		if(!data[fRelKey]){
			(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(lyte,data,fRelKey,[],undefined,true);
		}
		if(!data[fRelKey].schema){
			var relDef = relatedRecord.$.schema;
			if(isPoly && type){
				_defProp(data[fRelKey], "polymorphic", true);
				relDef = db.getSchemaObj(relDef.extend);
			}
			establishObsBindings(data,data.$.schema._properties);
			defArrUtls(data[fRelKey]);
			defPolyUtls(data[fRelKey]);
			defUtls(data[fRelKey],relDef,data,fRelKey);
		}
		var mdl = forward ? getSchemaObj(db, forward.relatedTo) : undefined;
		if( isDuplicate == false || !hasDuplicateRelation(relatedRecord, data[fRelKey], (forward?mdl._pK : undefined),type, mdl) ){
			if(index != undefined){
				handleArrOp(db.lyte, data[fRelKey], "insertAt", relatedRecord, index);
				// if(typeof Lyte.arrayUtils != "undefined"){
				// 	Lyte.arrayUtils(data[fRelKey],"insertAt",index,relatedRecord);						
				// }
				// else{
				// 	data[fRelKey].splice(index, 0, relatedRecord);
				// }	
			}
			else{
				handleArrOp(db.lyte, data[fRelKey],"push",relatedRecord);
			}
		}
		var ret;

		if((!ignorePartial || partRemoveOnly)&& forward.opts && forward.opts.serialize){
			ret = partialData(data, fRelKey, relatedRecord, "added",undefined,partRemoveOnly);
			ignoreRel.relKey = fRelKey;
			ignoreRel.model = data.$.schema._name;
		}
	}
	var fnest = false;
	if(!ignorePartial){
		fnest = ret ? false : true;
	}
	// if(forward == backward){
	// 	singleEstablishLink(forward,data,relatedRecord);
	// 	return true;
	// }
	if(backward === null){
		if(relatedRecord.hasOwnProperty(bRelKey)){
			delete relatedRecord[bRelKey];
		}
		return true;
	}
	if(backward.dummy || forward == backward){
		singleEstablishLink(forward,data,relatedRecord);
	}
	else{
		var bRelKey = backward.relKey, relRecMod = relatedRecord.$.schema;
		if( !checkForCorrectRelation(db, backward, data) ){
			return "ERR14";
		}
		if(backward.relType == "belongsTo"){
			if(relatedRecord[bRelKey] != undefined  && relatedRecord[backward.relKey] !== data){
				toDemolishLink(relRecMod, relatedRecord, backward, ignorePartial);
			}
			if(relatedRecord[bRelKey] !== data){
				(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(lyte,relatedRecord, bRelKey, data, undefined, true);
			}
			if(relatedRecord.$.partial && Object.keys(relatedRecord.$.partial).length && relatedRecord.$.partial[bRelKey]){
				delete relatedRecord.$.partial[bRelKey];
			}
		}
		else if(backward.relType === "hasMany"){
			if(!relatedRecord[bRelKey]){
				(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(lyte,relatedRecord, bRelKey, [], undefined, true);
			}
			if(!relatedRecord[bRelKey].schema){
				defArrUtls(relatedRecord[bRelKey]);
				defPolyUtls(relatedRecord[bRelKey]);
				defUtls(relatedRecord[bRelKey],data.$.schema,relatedRecord,bRelKey);
			}
			var bMdl = backward ? getSchemaObj(db, backward.relatedTo) : undefined;
			if( !hasDuplicateRelation(data, relatedRecord[bRelKey], (backward ? bMdl._pK : undefined), type, bMdl) ){
				handleArrOp(db.lyte, relatedRecord[bRelKey],"push",data);
			}
			var bret;
			if((!ignorePartial || partRemoveOnly) && backward.opts && backward.opts.serialize){
				bret = partialData(relatedRecord, bRelKey, data, "added" , undefined,partRemoveOnly);
			}
			var bnest;
			if(!ignorePartial){
				bnest = bret ? false : true;
			}
		} 
	}
	if(fnest){
		if(forward && forward.opts && forward.opts.deepNest){
			var type = "added";
			if(data[forward.relKey].partial && data[forward.relKey].partial.get(relatedRecord.$.pK)){
				type = data[forward.relKey].partial.get(relatedRecord.$.pK).type;
			}
			setDeepNest(data, forward.relKey, relatedRecord.$.pK, "added", undefined, relatedRecord);
			bnest = false;
		}
		// addDeepNest(relatedRecord, undefined, !ignorePartial ? "added" : undefined, ignoreRel);
	}
	if(bnest){
		if(backward && backward.opts && backward.opts.deepNest){
			setDeepNest(relatedRecord, backward.relKey, data.$.pK, "added", undefined, data);
		}
	}
	return true;
}

function removeFromStore(def,keys,fromStore,ignorePartial, delayPer, onlyRem, deep, parentRel ,partOnlyRem){
	var data = def.data,
	db = def.db,
	lyte = db.lyte;
	if(data.length == 0){
		return;
	}
	if(!Array.isArray(keys)){
		keys = [keys];
	}
	var pKey = def._pK;
	for(var i=0; i<keys.length; i++){
		var index = getIndex(data, pKey, keys[i]);
		if(index == -1){
			continue;
		}
		var rec = data[index];
		var pK = rec.$.pK;
		var relations = def.relations;
		if(rec.$.isNew){
			onlyRem = delayPer = undefined;
			fromStore = true;
		} 
		if(relations.size){
			toDemolishRelation(def, index, ignorePartial, onlyRem, delayPer,partOnlyRem);	
		}
		var deleted;
		if(delayPer !== true && onlyRem !== false){
			deleted = handleArrOp(db.lyte, data,"removeAt",undefined,index,1);
			deep && deleted && deleted.length ? deepRelIter("unload", def, deleted[0], parentRel) : undefined;
			def.emit("remove", [deleted[0]]);
			db.emit("remove", [def._name,deleted[0]]);	
			if(def._properties){
				demoLishObserverBindings(rec, def._properties);
			}
		}
		if(fromStore === true){
			(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(lyte, rec.$, "isUnloaded", true);
			var scpObj = rec.$.__scpObj;
			for(var key in scpObj){
				var sid = scpObj[key];
				var sidArr = sid.split("_");
				var nestObj = _slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.nestScp[sidArr[0]];
				nestObj ? (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.removeNestScp)(nestObj._data, sidArr[0], sidArr[1], undefined, rec, undefined, undefined, {model: def._name, pK:rec.$.pK, attr: key}) : undefined;
			}
			var cqueries = db.schema.cachedQueries;
			if(cqueries){
				var n=def._name, Nm = cqueries[n]
				if(Nm && Nm.length){
					for(var j=Nm.length-1; j>=0; j--){
						var obj = Nm[j];
						if(obj.hasDeletedRecords){
							if(obj.data){
								var ind = obj.data[n].indexOf(rec);
								if(ind !== -1){
									Nm.splice(j,1);					
								}
							}
						}
					}					
				}
			}
		}
		if(onlyRem == true){
			continue;
		}
		var remRec = deleted ? deleted[0] : rec;
		if(!fromStore){
			(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)( lyte, remRec.$, "isDeleted", true);
			changePersist(remRec, true);
			// deleted[0].$.isDeleted = true;
			if((delayPer !== true && onlyRem !== false) && (remRec.$.isNew || remRec.$.isModified)){
				deleteFromArray(def.dirty, remRec.$.pK);
			}
			if(!remRec.$.isNew){
				addTo_Del(def, remRec, index);
				// model._deleted.push(deleted[0]);
			}
			var cqueries = db.schema.cachedQueries;		
			if(cqueries){
				var n=def._name, Nm = cqueries[n];
				if(Nm && Nm.length){
					for(var j=Nm.length-1; j>=0; j--){
						var obj = Nm[j];
						if(obj && obj.data){
							var ind = obj.data[n].indexOf(rec);
							if(ind != -1){
								obj.hasDeletedRecords = true;
							}							
						}
					}					
				}
			}
		}
		var ind;
		if(Array.isArray(def.dirty) && (ind = def.dirty.indexOf(pK)) != -1){
			def.dirty.splice(ind, 1);
		}
	}
}

function removeChildRecords(db,scope,record,recMap,partOnlyRem){
	if(!recMap.get(record) && scope){
		recMap.set(record,true);
		var pkval=record?record.$.pK:undefined,arrPK=[]
		var r = scope._fldGrps.inherit;
		for(var v in r){
			var fkey = r[v].relKey?r[v].relKey:undefined
			if(record && fkey){
				if(scope.fieldList[fkey].relType=="belongsTo" && record[scope.fieldList[fkey].relKey]){
					removeChildRecords(db,getSchemaObj(db,scope.fieldList[fkey].relatedTo),record[scope.fieldList[fkey].relKey],recMap);
				}
				else if(scope.fieldList[fkey].relType=="hasMany" && record[scope.fieldList[fkey].relKey]){
					var len = record[scope.fieldList[fkey].relKey].length;
					for(var v1=len-1; v1>=0; v1--){
						removeChildRecords(db,getSchemaObj(db,scope.fieldList[fkey].relatedTo),record[scope.fieldList[fkey].relKey][v1],recMap);
					}
				}
			}
		}
		arrPK.push(pkval);
		removeFromStore(scope,arrPK,true,true,undefined,undefined,partOnlyRem);
	}
}

function rBinherit(scope,recmp){
	var record=scope.entity,
	rel=scope.schema._fldGrps.inherit;
	for(var v in rel){
		if(rel[v].opts && rel[v].opts.inherit && rel[v].relatedTo!=scope.schema._name && record[rel[v].relKey]){
			if(rel[v].relType === "belongsTo"){
				var _record = record[rel[v].relKey]
				if(_record && !recmp.get(_record)){
					recmp.set(_record,true);
					// rollBackRecord(_record.$,{inherit:true});
					// rBinherit(_record.$,recmp);
					_record.$.revert();
				}
			}
			else if (rel[v].relType === "hasMany"){
				var rel_len = record[rel[v].relKey].length;
				if(rel_len != 0 ){
					for(var j=0; j<rel_len; j++){
						var _record = record[rel[v].relKey][j]
						if(_record && !recmp.get(_record)){
							recmp.set(_record,true);
							// rollBackRecord(_record.$,{inherit:true});
							// rBinherit(_record.$,recmp);
							_record.$.revert()
						}
					}
				}
			}
		}
	}
}

function toChildJSON(db,model,reltype,record,relKey,parent,recmp,addNotDefinedFields){
	var mdl=getSchemaObj(db,model),mdlf=mdl.fieldList,rel={},pk;
	if(!Array.isArray(record)){
		record=[record];
	}
	for(var i =0 ;i<record.length; i++){
		if(!recmp.get(record[i])){
			var pval = getpKVal(record[i],mdl);
			recmp.set(record[i],pval);
		}
		if(!addNotDefinedFields){
			for (var fldKeys in record[i]){
				if(!mdlf.hasOwnProperty(fldKeys)){
					delete record[i][fldKeys];
				}
			}
		}
		mdl.relations.forEach(function(s){
			for(var j=0; j<s.length; j++){
				var v = s[j].relKey?s[j].relKey:undefined;
				if(v && mdlf[v] && mdlf[v].type == "relation" && record[i][mdlf[v].relKey]){
					if(record[i][mdlf[v].relKey] && mdlf[v].opts && mdlf[v].opts.inherit){
						if(mdlf[v].relType =="hasMany" && record[i][mdlf[v].relKey]){
							for (var v1=0; v1<record[i][mdlf[v].relKey].length; v1++){
								pval=getpKVal(record[i][mdlf[v].relKey][v1],getSchemaObj(db , mdlf[v].relatedTo));
								if(!recmp.get(record[i][mdlf[v].relKey][v1])){
									recmp.set(record[i][mdlf[v].relKey][v1],pval);
									toChildJSON(db,mdlf[v].relatedTo,mdlf[v].relType,record[i][mdlf[v].relKey][v1],mdlf[v].relKey,mdlf[v].relatedTo,recmp,addNotDefinedFields);
									 //store.$.toChildJSON(mdlf[v].relatedTo,mdlf[v].relType,record[i][mdlf[v].relKey][v1],mdlf[v].relKey,mdlf[v].relatedTo,recmp,str);
									if(typeof(record[i][mdlf[v].relKey][v1]) == "object"){
										record[i][mdlf[v].relKey][v1]=Object.assign({},record[i][mdlf[v].relKey][v1]);
									}
								}
								else if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(record[i][mdlf[v].relKey][v1]) && recmp.get(record[i][mdlf[v].relKey][v1])){
									if(typeof pval == "object"){
										record[i][mdlf[v].relKey][v1] = pval;
									}
									else{
										var robj = {};
										robj[(mdlf[v].relatedTo)._pK] = pval;
										record[i][mdlf[v].relKey][v1] = robj;
									}
									record[i][mdlf[v].relKey][v1]=(typeof pval == "object")?pval:{[getSchemaObj(db , mdlf[v].relatedTo)._pK]:pval};
								}
							}
						}
						else if(mdlf[v].relType =="belongsTo" && record[i][mdlf[v].relKey]){
							pval=getpKVal(record[i][mdlf[v].relKey],getSchemaObj(db,mdlf[v].relatedTo));
							if(!recmp.get(record[i][mdlf[v].relKey])){
								recmp.set(record[i][mdlf[v].relKey],pval);
								toChildJSON(db,mdlf[v].relatedTo,mdlf[v].relType,record[i][mdlf[v].relKey],mdlf[v].relKey,mdlf[v].relatedTo,recmp,addNotDefinedFields);
								record[i][mdlf[v].relKey] = Object.assign({},record[i][mdlf[v].relKey])
							}
							else{
								record[i][mdlf[v].relKey]=(typeof pval == "object")?pval:{[getSchemaObj(db , mdlf[v].relatedTo)._pK]:pval}
							}
						}
						if(Object.keys(record[i][mdlf[v].relKey]).length==0){
							delete record[i][mdlf[v].relKey];
						}
					}
					else if(Lyte.isRecord(record[i][mdlf[v].relKey])||(mdlf[v].relType == "hasMany" && Lyte.isRecord((record[i][mdlf[v].relKey][0])))){
						getRelations(mdl, mdlf[v].relKey, getSchemaObj(db,mdlf[v].relatedTo), rel);
						idSerialize(db,record[i],rel,true);
					}
				}
			}
		})
		if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(record[i])){
			record[i]=Object.assign({},record[i]);
		}
	}
}

function toDemolishRelation(def,index,ignorePartial,onlyRem,delayPers,partOnlyRem){
	var record = def.data[index], 
	relations = def.relations,
	db = def.db;
	relations.forEach(function(rel, key){
		for(var i=0; i<rel.length; i++){
			var relation = rel[i],
			relDef = getSchemaObj(db, relation.relatedTo);
			if(relDef){
				var relPriKey = relDef._pK, 
				relkey = relation.relKey;
				// if(def._name == relDef._name){
				// 	var data = relDef.data,index1,index2;
				// 	for(index1=0 ; index1<data.length; index1++){
				// 		var item=data[index1];
				// 		if(Array.isArray(item[relkey])){
				// 			for(var index2=0;index2<item[relkey].length;index2++){
				// 				var value = item[relkey][index2];
				// 				if(value[relPriKey] == record[relPriKey] && onlyRem !== false)
				// 				{
				// 					handleArrOp(db.lyte, item[relkey],"removeAt",undefined,index2,1);
				// 				}
				// 			}
				// 		}
				// 		else if (isEntity(item[relkey])){
				// 			if(item[relkey][relPriKey] == record[relPriKey] && onlyRem !== false)
				// 				{
				// 					item[relkey] = undefined ;
				// 				}
				// 		}
				// 	}
				// }
				if(!record[relation.relKey] && !relation.dummy){
					continue;
				}
				toDemolishLink(def, record, relation, ignorePartial, onlyRem, delayPers,partOnlyRem);
			}
		}		
	});
}

function toDemolishLink(def,record,relation,ignorePartial,onlyRem,delayPers,partOnlyRem){
	var db = def.db,
	records = record[relation.relKey], 
	priKey = def._pK,  
	relDef = relation.relatedTo;
	if(!relDef){
		return;
	}
	var bRelation = getBackwardRel(def, relation, getSchemaObj(db, relDef));
	if(relation.dummy || (relation == bRelation)){
		records = getRelatedRecord(record,getSchemaObj(db, relation.relatedTo),relation.dummy);
	}
	if(bRelation){
		if(Array.isArray(records)){
			for(var i=0; i<records.length; i++){
				demolishLink(db, record, priKey, records[i], bRelation.relKey, relation, bRelation, ignorePartial, undefined, onlyRem, delayPers,partOnlyRem);
			} 
		}
		else if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(records)){
			demolishLink(db, record, priKey, records, bRelation.relKey, relation, bRelation, ignorePartial, undefined, onlyRem, delayPers,partOnlyRem);
		}
	}
}

function demolishSingleRelation(record,fName,key,relatedRecord,priKey,onlyRem,delayPers){
	var arr,index;
	if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(record)){
		arr = record.$._relationships;
		if(arr && arr[fName] && arr[fName][key] && (onlyRem !== false && delayPers !== true)){
			arr = arr[fName][key];
			index = getIndex(arr,priKey,relatedRecord[priKey]);
			if(index > -1){
				arr.splice(index,1);
			}
		}
	}
} 

function demolishLink(db, record, priKey, relatedRecord, bRelKey, relation, bRelation, ignorePartial, ignoreAttrCheck, onlyRem, delayPers, partOnlyRem){
	var links = relatedRecord[bRelKey], 
	relMod = relatedRecord.$.schema,
	lyte = relMod.Lyte,
	pK = record.$.pK, 
	poly = links ? links.polymorphic : undefined, 
	polymorphicType;
	if(Array.isArray(links)){
		var ind = getIndex(links, priKey, pK, poly ? record._type : undefined), 
		_attrs = relatedRecord.$._attributes, 
		initialVal = _attrs.hasOwnProperty(bRelKey) && _attrs[bRelKey] && _attrs[bRelKey].size  ? relatedRecord.$.getInitialValues(bRelKey) : undefined, 
		toRem = links.partial && links.partial.has(record) && links.partial.get(record).type == "added" ? true : false;
		if(ind != -1 && (toRem || (onlyRem !== false && delayPers !== true))){
			poly ? polymorphicType = links[ind].$.schema._name : undefined;
			handleArrOp(lyte, relatedRecord[bRelKey],"removeAt",undefined,ind,1);
		}
		if(!ignoreAttrCheck && initialVal){
			if(!hasRecordsArrayChanged(relatedRecord, bRelKey, initialVal)){
				   delete relatedRecord.$._attributes[bRelKey];
				   if(!Object.keys(relatedRecord.$._attributes).length){
					//    changeModified(lyte, relatedRecord, false, relatedRecord.$.pK)
					   (0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(lyte, relatedRecord.$, "isModified", false);
					   changePersist(relatedRecord, true);
					   if(!relatedRecord.$.isNew){
						   deleteFromArray(relMod.dirty, relatedRecord[relMod._pK]);
						   if(!relatedRecord.$.dN || (relatedRecord.$.dN && !Object.keys(relatedRecord.$.dN).length)){
							removeParentNesting(relatedRecord);
						}			
					}
				}
			}
		}
	}
	else if( links && (typeof links == "object" || (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(links)) && (onlyRem !== false && delayPers !== true) ){
		if(lyte != undefined && lyte.objectUtils != undefined){
			lyte.objectUtils(relatedRecord, "delete", bRelKey, undefined, undefined, true);
		}
		else {
			delete relatedRecord[bRelKey];
		}
	}
	else{
		demolishSingleRelation(relatedRecord,record.$.schema._name,relation.relKey,record,priKey, onlyRem, delayPers);
	}
	if(!bRelation){
		bRelation = relMod.fieldList[bRelKey];
	}
	if((!ignorePartial || partOnlyRem )&& onlyRem !== true){
		var relType, isPartial, ret, nest, serz;
		if(bRelation){
			if(bRelation.opts){
				isPartial = bRelation.opts.serialize == "partial";
				serz = bRelation.opts.serialize ? true : false;
				nest = bRelation.opts.deepNest;
			}
			var relType = bRelation ? bRelation.relType : undefined;
		}
		// if(delayPers && bRelation && bRelation.opts && /^(id|record)$/.test(bRelation.opts.serialize)){
		// 	return;
		// }
		if(relType == "belongsTo" && serz && !record.$.isNew){
			var partObj = relatedRecord.$.partial = relatedRecord.$.partial || {};
			partObj = partObj[bRelKey] = partObj[bRelKey] || new Map();
			if(!partObj.has(record)){
				partObj.set(record, {});
			}
			partObj = partObj.get(record);
			partObj.type = "removed";
		}
		if(bRelation && bRelation.opts && bRelation.opts.serialize){
			ret = partialData(relatedRecord, bRelKey, record, "removed", polymorphicType ,partOnlyRem);
			nest = ret && relType == "hasMany" ? false : nest;
		}
		if(nest == true){
			makeDirty(relatedRecord, "removed", bRelation, pK, undefined, record);
			addDeepNest(relatedRecord);
		}
	}
	if(ignorePartial){
		if(bRelation && bRelation.opts && bRelation.opts.serialize){
			partialData(relatedRecord, bRelKey, record, "delete", polymorphicType);
			var _attrs = relatedRecord.$._attributes, _attr = _attrs[bRelKey];
			if(_attr && _attr.size && _attr.get(record)){
				_attr.delete(record);
			}
			if(_attr && _attr.size){
				delete relatedRecord.$._attributes[bRelKey];
			}
		}
	}
}

function validateAndMerge(def, data, partialObj, mergeErr, ignoreStrict){
	var db = def.db;
	if(!def.rel){
		def.rel  = {};
	}
	var pkVal = getpKVal(data, def);
	if(pkVal === undefined){
		return { type:"error", args:["LD28", def._name, (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(data) ? data : JSON.stringify(data)]};				
	}

	var record = db.cache.getEntity(def.def, getpKVal(data, def));
	if(!record || !(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(record)){
		return { type:"error", args:["LD04",(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(data) ? data : JSON.stringify(data)]};
	}
	if(!ignoreStrict && record.$.strict && (record.$.isNew || record.$.isModified || record.$.isDeleted)){
		return { type:"error", args:["LD29"]};
	}
	mergeData(db, record, data, partialObj, mergeErr);
	if(def.didLoad){
		var callBack = def.didLoad;
		for(var i=0;i<callBack.length;i++){
			callBack[i].apply(record);				
		}
	}
	return { data : record};
}

function mergeData(db,record,data,partialObj,mergeErr){
	if(!record || !data){
		return;
	}
	var def = record.$.schema, field, _estObsBind = false;
	if(mergeErr){
		mergeError(def, record, data);
	}
	for(var key in data){
		field = def.fieldList[key];
		if(field){
			if(field.type != "relation"){
				var empD = getDsrzEmpData(def, field, def._name);
				var boolChk = !empD && data[key]
				if(data.hasOwnProperty(key) && (boolChk || empD) && db.dataType.hasOwnProperty(field.type) && db.dataType[field.type].hasOwnProperty("deserialize")){
					data[key] = db.dataType[field.type].deserialize(data[key],key,def._name,getpKVal(data,def));
				}
				var isPropPresent = def._properties && def._properties.hasOwnProperty(key), propObj = {};
				if(isPropPresent){
					propObj[key] = def._properties[key];
					demoLishObserverBindings(record, propObj);
				}
				(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(db.lyte,record,key,data[key],undefined,true);
				def._properties && def._properties.hasOwnProperty(key) ? _estObsBind = true : undefined;
			}
			else if(field && field.type == "relation"){
				var todo = {};
				var rel = {};
				getRelations(db, record.$.schema, key, getSchemaObj(db, field.relatedTo), rel);
				var bMod = rel.forward.relatedTo;
				if(field.relType == "hasMany" && partialObj && partialObj[key] && partialObj[key].replace){
					var rec_ar=record[key]._recMap,arr_rec=[];
					rec_ar.forEach(function(rec,key_i){
						arr_rec.push(key_i);
					})
					arr_rec.forEach(function(i){
						if(db.cache.getEntity(field.relatedTo,i).$.isNew){
							removeFromStore(getSchemaObj(db,field.relatedTo),i,true);
						}
						else{
							demolishLink(db, db.cache.getEntity(field.relatedTo,i),db.cache.getEntity(field.relatedTo,i).$.schema._pK,record,rel.forward.relKey,undefined,undefined,true,true);
							if(rel.backward != null){
								demolishLink(db,record,def._pK,db.cache.getEntity(field.relatedTo,i),rel.backward.relKey,rel.forward,undefined,true,true);
							}
						}
					})
					delete partialObj[key];
				}
				var result = compareRelations(db, record,data,key,field,partialObj ? partialObj[key] : undefined ,todo, mergeErr);
				mergeRecords(db, todo, result, def, getSchemaObj(db, bMod), record, key, data, rel, partialObj, mergeErr);
			}
		}
		else if(key != "$"){
			(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)( db.lyte,record,key,data[key],undefined, true );
		}
	}
	if(_estObsBind){
		establishObsBindings(record, def._properties);
	}
}

function mergeRecords(db, todo, result, def, bMod, record, key, data, rel, partialObj, mergeErr){
	if(!rel){
		var rel = {};
		getRelations(db, def, key, bMod, rel);	
	}
	var pK = def._pK;
	if(rel.forward.relType == "hasMany" && isEmptyArray(data[key])){
		(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(db.lyte, record, key, [], undefined, true);
		establishObsBindings(record,record.$.schema._properties);
		defArrUtls(record[key]);
		defPolyUtls(record[key]);
		defUtls(record[key],bMod,record,key);
	}
	if(Array.isArray(todo.add)){
		todo.add.forEach(function(item){
			createAndRelate(def.db, def, bMod, record, key, item, rel, partialObj);
		});
	}
	if(Array.isArray(todo.remove)){
		todo.remove.forEach(function(obj){
			var pkVal = obj.pK, schemaName = obj.schema, _def = db.getSchema(schemaName);
			demolishLink(db, record, pK, db.cache.getEntity(_def, pkVal), rel.backward.relKey,  rel.forward, rel.backward, true); 
			demolishLink(db, db.cache.getEntity(_def, pkVal), db.getSchemaObj(schemaName)._pK, record, rel.forward.relKey, rel.backward, rel.forward, true); 
		});
	}
	if(record && record.hasOwnProperty(key)){
		deleteDeepNest(record, key);
		if(Array.isArray(record[key]) && record[key].hasOwnProperty("partial")){
			var partObj = record[key].partial, partKeys = [];
			partObj.forEach(function(value, partKey){
				partKeys.push(partKey);
				record[key].partial.delete(partKey);
			});
		}
	}
	switch(result){
		case 0:{
			if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(record[key])){
				demolishLink(db, record, pK, record[key], rel.backward.relKey, rel.forward, rel.backward, true); 
				demolishLink(db, record[key], bMod._pK, record, rel.forward.relKey, rel.backward, rel.forward, true); 								
			}
			createAndRelate(def.db, def, bMod, record, key, data[key], rel, partialObj);
			break;
		}
		case 1:{
			break;
		}
		case 2:{
			mergeData(db,record[key],data[key],undefined,mergeErr);
			break;
		}
		default : break;    
	}
}

function compareRelations(db,record,data,key,field,partialObj,todo,mergeErr){
	//return 0 - not same, 1 -same, 2 - merge, 3 - partial add, 4 - delete and partial add
	var def = getSchemaObj(db, field.relatedTo), 
	pK = def._pK, 
	result = [];
	if(field.relType == "belongsTo"){
		if(partialObj && partialObj.$.type === "removed" && (!data || (data && comparePk(record, getpKVal(data, def))))){
			return 1;
		}
		return compareRecordWithObj(record[key],data[key],pK, partialObj,mergeErr);
	}else{
		var isPartial = false;
		if((partialObj && partialObj.partial)){
			isPartial = true;
		}
		if(!isPartial && (!record.hasOwnProperty(key) || (record && record.hasOwnProperty(key) && (isEmpty(record[key]) || isEmptyArray(record[key]))))){
			if(todo){
				var arr = data[key] || [];
				arr.forEach(function(item){
					var add = todo.add = todo.add || [];
					add.push(item);
				});
				return;
			}
			return 0;
		}
		var len = data[key] ? data[key].length : 0,
		old=0,
		status=1,
		oldPks = [];
		for(var i=0;i<len;i++){
			var obj = data[key][i];
			if(partialObj && partialObj[i] && partialObj[i].$.type == "removed"){
				continue;
			}
			var ind = getIndex(record[key], pK, (typeof obj == "object") ? getpKVal(obj,def) : obj);
			if(ind == -1){
				if(todo){
					var add = todo.add = todo.add || [];
					add.push(obj);
				}
				status = 0;
				continue;
			}
			oldPks.push(record[key][ind].$.pK);
			var res = compareRecordWithObj(record[key][ind],obj,pK,partialObj ? partialObj[i] : undefined,mergeErr);
			if(res == 1){
				old++;
			}
			if(res == 2){
				mergeData(db,record[key][ind],obj, partialObj ? partialObj[i] : undefined, mergeErr);
			}
			else if(res == 0){
				status = 0;
			}
		}
		if(todo && !isPartial){
			var arr = record[key] || [];
			arr.forEach(function(item){
				var pkVal = item.$.pK;
				if(oldPks.indexOf(pkVal) == -1){
					var remove = todo.remove = todo.remove || [];
					remove.push({pK: pkVal, schema: item.$.schema._name});
				}
			});
		}
	}
}

function compareRecordWithObj(rec,obj,pK,partialObj, mergeErr){
	if( !rec || !(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(rec) ){
		return 0;
	}
	var recDef = rec.$.schema, 
	db = recDef.db,
	isComp = recDef.isComp, 
	recFields = recDef.fieldList;
	if(!isComp) {
		var field = recDef.fieldList[pK];
		if(typeof obj == field.type ){
			if(rec[pK] == obj){
				return 1;
			}
			else{
				return 0;
			}
		}
	}
	if(obj && typeof obj == "object"){
		if(!comparePk(rec, getpKVal(obj, recDef))){
			return 0;
		}
		for(var data_key in obj){
			var field = recFields[data_key];
			if(field){
				if(field.type == "relation"){
					var todo = {};
					var res = compareRelations(db, rec, obj, data_key, field, partialObj ? partialObj[data_key] : undefined, todo, mergeErr);
					mergeRecords(db, todo, res, recDef, getSchemaObj(db, field.relatedTo), rec, data_key, obj, undefined, partialObj);
				}
				else if(rec[data_key] != obj[data_key]){
					return 2;
				}                    
			}
			else{
				if(rec[data_key] != obj[data_key]){
					return 2;
				}
			}	
		}
		return 1;
	}
	return 0;
}

function rllBckRecArr(db, oldVal, ins, def, field){
	var rel = {}, 
	pK = def._pK,
	bDef = getSchemaObj(db, field.relatedTo),
	relPK = bDef._pK;
	getRelations(db, def, field.relKey, bDef, rel);
	if(oldVal.size){
		var keys = Array.from(oldVal.keys()).reverse();
		var self = this;
		keys.forEach(function(itm, idx){
			var val = oldVal.get(itm);
			if(val._type == "added"){
				var relatedRecord = itm;
				if(!relatedRecord.$.isUnloaded){
					demolishLink(db, relatedRecord, relPK, ins, rel.forward.relKey, rel.forward);
					if(rel.backward != null){
						demolishLink(db, ins, pK, relatedRecord, rel.backward.relKey, rel.forward);
					}
				}
			}
			else if(val._type == "removed"){
				var relatedRecord = itm;
				if(!relatedRecord.$.isUnloaded){
					establishLink(db, rel.forward, rel.backward, ins, relatedRecord, val.index);
				}
			}			
		});
	}
	else{
		for(var i=oldVal.length-1; i>=0; i--){
			var records = oldVal[i].records;
			if(oldVal[i]._type == "added"){
				for(var j=0; j<records.length; j++){
					var relatedRecord = records[j];
					if(recChk(db.lyte, relatedRecord)){ // temp check to know if record exist in store
						demolishLink(db, relatedRecord, relPK, ins, rel.forward.relKey);
						if(rel.backward != null){
							demolishLink(db, ins, pK, relatedRecord, rel.backward.relKey, rel.forward);
						}
					}
				}
			}
			else if(oldVal[i]._type == "removed"){
				for(var j=records.length-1; j>=0; j--){
					var relatedRecord = records[j];
					if(recChk(db.lyte, relatedRecord)){ // temp check to know if record exist in store
						establishLink(db, rel.forward, rel.backward, ins, relatedRecord, oldVal[i]._indices[j]);
					}
				}
			}
			else if(oldVal[i]._type == "changed"){
				var currentRecords = ins[field.relKey];
				if(!Array.isArray(currentRecords)){
					currentRecords = [currentRecords]; 
				}
				var self = this;
				var kLen = currentRecords.length;
				for(var k=0; k<kLen; k++){
					var relatedRecord = currentRecords[0];
					if(relatedRecord != undefined && recChk(db.lyte, relatedRecord)){
						demolishLink(db, relatedRecord, relPK, ins, rel.forward.relKey);
						if(rel.backward != null){
							demolishLink(db, ins, pK, relatedRecord, rel.backward.relKey,rel.forward);
						}
					}
				}
				if(!Array.isArray(records)){
					records = [records];
				}
				for(var j=0; j<records.length; j++){
					var relatedRecord = records[j];
					if(typeof relatedRecord == "string"){
						relatedRecord = db.cache.getEntity(rel.forward.relatedTo,relatedRecord);
					}
					if(relatedRecord != undefined && recChk(db.lyte, relatedRecord)){ // temp check to know if record exist in store
						establishLink(db, rel.forward, rel.backward, ins, relatedRecord, undefined);
					}
				}						
			}
		}
	}
}

function sortBy(field, order){
	var fieldArr = mapBy.call(this, field),
	def = this.schema;
	var fie = def.fieldList[field];
	if(fie && fie.type == "string"){
		fieldArr.sort();
		if(order == "desc"){
			fieldArr.reverse();
		}                
	}
	else{
		fieldArr.sort(function(a,b){return a-b;});
		if(order == "desc"){
			fieldArr.sort(function(a,b){return b-a;});
		}
	}
	var oldArr = this.slice(0), newArr = [];
	for(var i=0; i<fieldArr.length; i++){
		if(fieldArr[i] == undefined){
			continue;
		}
		var index = getIndex(oldArr, field, fieldArr[i]);
		newArr.push(oldArr[index]);
		oldArr.splice(index, 1);
	}
	if(oldArr.length > 0){
		if(order == "desc"){
			newArr = newArr.concat(oldArr);
		}
		else{
			newArr = oldArr.concat(newArr);
		}				
	}
	defArrUtls(newArr);
	defUtls(newArr,this.schema);
	return newArr;
}

function mapBy(field){
	return this.map(function(value){
		return value.$.get(field);
	});
}

function revertToOldVal(ins, attr, oldVal, rel){
	if(oldVal == undefined || oldVal.length == 0){
		return;
	}
	else{
		if(!Array.isArray(oldVal)){
			oldVal = [oldVal];
		}
		for(var i =0; i<oldVal.length; i++){
			var fRec = oldVal[i];
			establishLink(ins.$.schema.db, rel.forward, rel.backward, ins, fRec, undefined);
		}
	}
}

function removePartial(ins, key){
	var parObj = ins.$.partial;
	if(parObj && parObj[key] ){
		delete parObj[key];
	}
}

function rollBackDelete(def, pkVal, index){
	var arr = [], db = def.db;
	if(!pkVal){
		def._deleted.forEach(function(itm){
			arr.push(itm);
		});
	}
	else{
		var deleted = def._deleted, obj = deleted.get(pkVal), pK = def._pK;
		arr = [obj];
	}
	var len = arr.length;
	for(var i=len-1;i>=0;i--){
		var obj = arr[i];
		var rec = obj.data;
		//var currentInd = findCurrentInd(model, pkVal);
		var isRecInDef = def.data._recMap ? def.data._recMap.get(rec.$.pK) : (def.data.indexOf(rec) !== -1) ;
		if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(rec)){
			(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(db.lyte, rec.$, "isDeleted", false);
			changePersist(rec, true);
			var isDuplicate = isDuplicateEntity(def, rec);
			if(!isRecInDef){
				if(index){
					handleArrOp(db.lyte, def.data,"insertAt",rec,obj.index);
					// db.$.modifyDelInd(model, pkVal);
				}
				else{
					handleArrOp(db.lyte, def.data,"push",rec);
				}
				def.emit("add", [rec]);
				db.emit("add", [def._name,rec]);	
				var relArr = def.relations;
				if(relArr){
					rollBackDeleteRel(db, def, rec, relArr);
				}
			}
			else{
				removeParentNesting(rec);
				addDeepNest(rec, undefined, "added");
			}
			// else{
			// 	Lyte.error("Cannot rollback record of model, since another instance of same record exists in store");
			// }
			var cqueries = db.schema.cachedQueries;	
			if(cqueries){
				var n=def._name, Nm = cqueries[n];
				if(Nm && Nm.length){
					for(var j=Nm.length-1; j>=0; j--){
						var obj = Nm[j];
						if(obj && obj.hasDeletedRecords){
							var ind = obj.data[n].indexOf(rec);
							if(ind != -1){
								delete obj.hasDeletedRecords;
							}							
						}
					}					
				}
			}
			if(rec.$.isNew || rec.$.isModified){
				checkAndAddToArray(def.dirty, rec[def._pK]);
			}
			_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.clrRecErr(rec.$, pK, "ERR17");
			!isDuplicate ? def.data._recMap.set(typeof rec.$.pK == "object" ? rec.$.pK : rec.$.pK.toString(), rec) : undefined; //old handling
			def._deleted.delete(rec.$.pK);
		}
	}
}

function rollBackDeleteRel(db, def, rec, relArr){
	relArr.forEach(function(rel){
		var rLen = rel.length;
		for(var j=0;j<rLen;j++){
			var item = rel[j];
			var key = item.relKey, bRel, bMod;
			//if(rec.hasOwnProperty(key)){
				bMod = item.relatedTo;
				bRel = getBackwardRel(def,item,getSchemaObj(db, bMod));
				var data = rec[key];
				if(!item.relKey || (item == bRel)){
					data = getRelatedRecord(rec,getSchemaObj(db , item.relatedTo),item.dummy?item.dummy:item.relKey)
				}
				else{
					data = rec[item.relKey];
				}
				if(Array.isArray(data)){
					var dLen = data.length;
					for(var k=0; k<dLen; k++){
						if(item == bRel){
							establishLink(db,bRel,item,data[k],rec,undefined,false)
						}else{
							establishLink(db,item,bRel,rec,data[k],undefined,false);	
						}									
					}
				}
				else{
					if(item == bRel){
						establishLink(db,bRel,item,data,rec,undefined,false)
					}else{
						establishLink(db,item,bRel,rec,data,undefined,false);
					}
				}
			//}
		}						
	});
}
function rollBackNew(def, record, pK){
	removeFromStore(def, record.$.pK, true);
	// var pkVal = record.$.pK;
	// var index = this.getIndex(model.data, pK, pkVal);
	// store.$.toDemolishRelation(model, index);
	// this.handleArrOp(model.data,"removeAt",undefined,index,1);
	// // record.$.isNew = false;
	// store.$.cmpSet(record.$, "isNew", false);
	// store.$.cmpSet(record, "$",  {});
	// model.emit("remove", [record]);
	// store.emit("remove", [model._name,record]);

}

function hasRecordsArrayChanged(record, attr, old){
	var arr = old || record.$.getInitialValues(attr), 
	changed = true;
	if(arr && arr.length == record[attr].length){
		changed = false;
		for(var i=0; i<arr.length; i++){
			if(record[attr].indexOf(arr[i]) == -1){
				return true;
			}
		}
	}
	return changed;
}

function cacheQuery(db, name, cacheQuery, data, status){
    var cq = db.schema.cachedQueries;
    cq = db.schema.cachedQueries = cq || {};
    cq = cq[name] = cq[name] || [];
    cq.push({cacheQuery : cacheQuery, data : data, status : status});
}

function cacheRecordQuery(db, name, key, cacheQuery, data, status){
    var crq = db.schema.cachedRecordQueries;
    crq = db.schema.cachedRecordQueries = crq || {};
    crq = crq[name] = crq[name] || {};
    crq = crq[key] = crq[key] || [];
    crq.push({cacheQuery : cacheQuery, data : data, status : status});
}

function isDefData(data){
    if(Array.isArray(data) && (data.schemaless || (data.schema && data.schema.__class === _Schema_js__WEBPACK_IMPORTED_MODULE_5__.Schema && !data.polymorphic))){
        return true;
    } 
}

function handleArrOp(lyte,data,type,obj,pos,len){
    len = len != undefined ? len : 0;
    // var toBind = typeof lyte.arrayUtils != "undefined" ? true : false, 
	var ret, sort, arrayUtils = lyte && lyte.$utils && lyte.$utils.arrayUtils ? lyte.$utils.arrayUtils : undefined;
	if(data.key && data.entity){
		var fld = data.entity.$.schema.fieldList[data.key], srtObs = false;
		if(fld && fld.opts && fld.opts.sort){
			if(fld.opts.sort.sortFn){
				sort = fld.opts.sort.sortFn;
				if(fld.opts.sort.observes){
					srtObs = true;
				}
			}
			else{
				sort = { sortBy: fld.opts.sort.sortBy, sortOrder: fld.opts.sort.sortOrder };
			}
		}
	}
    switch(type){
        case "push": {
            if(isDefData(data)){
                data._recMap == undefined ? _defProp(data, "_recMap", new Map()) : undefined;
				if(!data.schemaless){
					data._recMap.set(typeof obj.$.pK == "object" ? obj.$.pK : obj.$.pK.toString(), obj);
				}
				else{
					data._recMap.set(obj[data.pK], obj);					
				}
            }
			if(!sort){
				ret = arrayUtils ? arrayUtils(data, "push", obj) : data.push(obj);
			}
			else{
				ret = arrayUtils ? arrayUtils(data, "sort", sort, [obj]) : data.push(obj);
			}
			if(srtObs && obj && obj.$){
				!obj.$.hasOwnProperty("srtObs") ? _defProp(obj.$, "srtObs", true, false, true) : undefined;
			}
            break;
        }
        case "removeAt": {
            if(isDefData(data)){
                var cpyLen = len;
                for(var i=0;i<cpyLen;i++){
					var mpKey = undefined;
					if(!data.schemaless){
						var pkVal = data[pos+i] ? data[pos+i].$.pK : undefined;
						pkVal = ((typeof pkVal == "object") ? pkVal : pkVal.toString());
						mpKey = pkVal;
					}
					else{
						mpKey = data[pos+i][data.pK];
					}
                    mpKey !== undefined && data._recMap ? data._recMap.delete(mpKey) : undefined;
                }
            }
			var _rec = data[pos];
			if(srtObs && _rec && _rec.$ && !changeRelPkMaps(_rec, undefined, undefined, "srtObsChk", data.key)){
				_rec.$.hasOwnProperty("srtObs") ? _rec.$.srtObs = false : undefined;
			}
            // ret =  data.$splice ? data.$splice(pos,len) : data.splice(pos,len);
			ret = arrayUtils ? arrayUtils(data, "splice", pos, len) : data.splice(pos,len);
            break;
        }
        case "insertAt": {
            if(isDefData(data)){
                data._recMap == undefined ? _defProp(data, "_recMap", new Map()) : undefined;
				if(!data.schemaless){
					data._recMap.set(typeof obj.$.pK == "object" ? obj.$.pK : obj.$.pK.toString(), obj);
				}
				else{
					data._recMap.set(obj[data.pK], obj);					
				}
            }
            // ret = data.$splice ? data.$splice(pos,len,obj) : data.splice(pos,len,obj);
			if(!sort){
				ret = arrayUtils  ? arrayUtils(data, "splice", pos, len, obj) : data.splice(pos, len, obj);
			}
			else{
				ret = arrayUtils ? arrayUtils(data, "sort", sort, [obj]) : data.splice(pos,len,obj);
			}
			if(srtObs && obj && obj.$){
				!obj.$.hasOwnProperty("srtObs") ? _defProp(obj.$, "srtObs", true, false, true) : undefined;
			}
            break;
        }
        case "replaceAt": {
            // ret = data.$splice ? data.splice(pos,len,obj) : data.splice(pos,len,obj);
			if(!sort){
				ret = arrayUtils  ? arrayUtils(data, "splice", pos, 1, obj) : data.splice(pos, 1, obj);
			}
			else {
				ret = arrayUtils  ? arrayUtils(data, "splice", pos, 1, obj) : data.splice(pos, 1, obj);
			}
			if(srtObs && obj && obj.$){
				!obj.$.hasOwnProperty("srtObs") ? _defProp(obj.$, "srtObs", true, false, true) : undefined;
			}
			break;
        }
		case "sort" : {
			ret = arrayUtils ? arrayUtils(data, "sort", sort) : undefined;	
			break;
		}
        default: {
            _dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.error(lyte,"LD07", type);
            break;
        }
    }
    return ret;
}

function defArrUtls(obj){
    Object.defineProperties(obj, {
        filterBy : {
            value : filterBy
        },
        sortBy : {
            value : sortBy
        },
        mapBy : {
            value : mapBy
        }
    });
}

function defPolyUtls(obj){
    Object.defineProperties(obj,{
        add : {
            value : add
        },
        remove : {
            value : remove
        }
    })
}

function defUtls(obj,def,ins,key){
    if(def){
        _defProp(obj, "schema", def);
    }
    if(ins){
        _defProp(obj, "entity", ins, false, true);
    }
    if(key){
        _defProp(obj, "key", key);
    }
}

function defPar(arr){
    _defProp(arr, "partial", new Map());
}

function _defProp(scp, key, val, enume, write, conf){
    enume = (enume === undefined) ? false : enume;
    write = (write === undefined) ? false : write;
	conf = (conf === undefined) ? false : conf;
    Object.defineProperty(scp, key, {
        value : val,
        enumerable : enume,
        writable : write,
		configurable : conf
    });
}


function removePartialKeys(db, data, schema){
    var rels = schema.relations,
	db = schema.db;
	rels.forEach(function(relArr, key){
		relArr.forEach(function(rel){
			var relObj = {}, 
			inv, 
			bMod = rel.relatedTo;
			if(bMod){
				var inv = getBackwardRel(schema, rel, getSchemaObj(db, bMod));
				if(inv && inv.relType == "hasMany" && inv.opts && inv.opts.serialize){
					var relKey = rel.relKey, invRelKey = inv.relKey, invObj = data[relKey];
					if(invObj){
						if(Array.isArray(invObj)){
							invObj.forEach(function(invRelRec){
								var invRelObj = invRelRec[invRelKey];
								if(invRelObj && invRelObj.partial && invRelObj.partial.get(data)){
									invRelObj.partial.delete(data);
								}		
							});
						}
						else if(invObj[invRelKey]){
							var invRelObj = invObj[invRelKey];
							if(invRelObj && invRelObj.partial && invRelObj.partial.get(data)){
								invRelObj.partial.delete(data);
							}
						}
					}
				}
			}
		});		
	});
}

function mergeResponse(db, data , schema , response , pK , partialObj, cPersist){
    var db = schema.db;
	removePartialKeys(db, data, schema, pK);
    if(partialObj && Object.keys(partialObj).length){
        mergeNewDataKeys(db, partialObj, data, response, cPersist);
    }
    if(mergeError(schema, data, response)){
        return;
    }
    var isRec = db.cache.getEntity(data.$.schema.def, data.$.pK), 
	dirtyId, 
	mergeDone = false,
	result;
    if(data.$.isDeleted){
       mergeDeletedRec(db, partialObj, data, cPersist);
    }
    if(data.$.isNew && isRec){
        mergeDone = mergeNewRecord(db, partialObj, data, response, true, cPersist);
    }
    if(data.$.isModified && isRec){
        mergeModifiedRec(db, partialObj, data, response, true, mergeDone, cPersist);
    }
    if(schema.dirty.length){
        deleteFromArray(schema.dirty, dirtyId);
    }
    if(partialObj && Object.keys(partialObj).length && response && !mergeDone){
        if(response){
            if(isRec){
                result = validateAndMerge(schema, response, partialObj, true, true);
				if(result && result.data){
					result = result.data;
				}
				else if(result && result.type){
					Array.isArray(result.args) ? result.args.splice(0,0,db.lyte) : [db.lyte]
					_dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror[result.type].apply(_dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror, result.args || [db.lyte]);
				}
            }
            else{
                result = insertIntoStore(db, schema.def, response, undefined, undefined, partialObj);
            }
        }					
    }
    // var dirty = data.$.isDirty();
    // for(var j=0; j < dirty.length ;j++){
    //     var records = data[dirty[j]];
    //     if(Array.isArray(records)){
    //         for(var k=0;k<records.length;k++){
    //             if(isEntity(records[k])){
    //                 cmpSet(db.lyte, records[k].$, "isModified", false);
	// 				changePersist(records[k], true);
    //             }
    //         }
    //     }
    //     else if(isEntity(records)){
    //         cmpSet(db.lyte, records.$, "isModified", false);
	// 		changePersist(records, true);
    //     }
    // }
    removeDirtyStack(data, partialObj);
    // removeDeepNest(data);
}

function removeDirtyStack(data,partial){
    if(partial && partial._removedAttr && Object.keys(partial._removedAttr).length !=0){
		for(var key in data.$._attributes){
			if(!partial._removedAttr.hasOwnProperty(key)){
				delete data.$._attributes[key];
			}
		}
	}
	else{
		data.$._attributes = {};
	}
	// data.$._attributes={};
	data.$.undoStack = genUnRedoStack();
	data.$.redoStack = genUnRedoStack();
	delete data.$._savedState;
	_ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.clrRecErr(data.$); 
}

function mergeNewDataKeys(db, partialObj, data, response, cPersist){
    if(partialObj && ((data && data.partial && data.partial.size) || partialObj.partial == true)){ //true checked since partial key can come in this 
        if(Array.isArray(partialObj)){	
			var rep = partialObj.replace?partialObj.replace:false;				
            partialObj.forEach(function(item, index){
                if(item.$){
                    var pK = item.$.schema._pK;
                    var ind = getIndex(data, pK, item.$.pkVal);
                    if(item.$.onlyDetach === true){
						if(data.entity && data.key){
							deleteDeepNest(data.entity,data.key,item.$.pkVal);
						}
                        handleArrOp(db.lyte, data, "removeAt", undefined, ind, 1);
                    }
                    else{
						if(rep && item.$.record && item.$.record.$.isNew){
							rep = true;
						}
						else{
							mergeNewDataKeys(db, item, ind != -1 ? data[ind] : undefined, response ? response[index] : undefined, cPersist);
						}
						data.partial ? data.partial.delete(item.$.pkVal) : undefined;
                    }
					if(!item._removedAttr || (item._removedAttr && Object.keys(item._removedAttr).length)){
						data.partial ? data.partial.delete(item.$.pkVal) : undefined;
					}
                }
            });
			if(Array.isArray(data) && data.partial && data.partial.size && data.entity && data.key && data.entity.$.schema){
				var relFld = data.entity.$.schema.fieldList[data.key], toRemPart = [];
				if(relFld.opts && /^(id|record)$/.test(relFld.opts.serialize)){
					data.partial.forEach(function(pObj, pKey){
						if(pObj.type == "removed"){
							toRemPart.push(pKey);
						}
					});
					toRemPart.forEach(function(rItm){
						var rec = db.cache.getEntity(db.getSchema(data.schema._name), rItm) || db.cache.getEntity(db.getSchema(data.schema._name), rItm, true);
						data.partial.delete(rItm);
						rec ? removeParentNesting(rec) : undefined;
					});	
				}
			}
        }
    }
    else if(partialObj && partialObj.$ && partialObj.$.type){
        if(partialObj.$.onlyDetach){ //only for belongsTo
			var parent = partialObj.$.parent;
			if(parent && parent.$.partial && parent.$.partial[partialObj.$.relKey] && parent.$.partial[partialObj.$.relKey].has(partialObj.$.pkVal) && parent.$.partial[partialObj.$.relKey].get(partialObj.$.pkVal).type == "removed"){                        
				var rec = db.cache.getEntity(db.getSchema(partialObj.$.schema.__class), partialObj.$.pkVal) || store.peekRecord(partialObj.$.model, partialObj.$.pkVal, true);
				parent.$.partial[partialObj.$.relKey].delete(partialObj.$.pkVal);
				if(!parent.$.partial[partialObj.$.relKey].size){
					delete parent.$.partial[partialObj.$.relKey];
					if(!Object.keys(parent.$.partial).length){
						delete parent.$.partial;
					}
				}
				rec ? removeParentNesting(rec) : undefined;
			}
		}
		else{
			mergePartialObj(db,partialObj, data, response, undefined, cPersist);
		}
    }
    else{
        if(Array.isArray(partialObj)){
            partialObj.forEach(function(item, index){
                mergeNewDataKeys(db, item, data[index], response ? response[index] : undefined, cPersist);
            });
        }
        else if(typeof partialObj == "object"){
            for(var key in partialObj){
                mergeNewDataKeys(db, partialObj[key], data[key], response ? response[key] : undefined, cPersist);
            }
        }
    }
}

function mergeError(schema, data, response){
    if(response && response.$ && response.$.isError){
        if(response.$.error){
            var obj = response.$.error;
            for(var key in obj){
                if(schema.fieldList.hasOwnProperty(key)){
                    _ValidationError__WEBPACK_IMPORTED_MODULE_1__.ValidationError.setRecErr(data.$, key, obj[key]);
                }
            }
        }
		if(response.$.revert){
			data.$.revert();
		}
		delete response.$.revert;
        delete response.$.error;
        delete response.$.isError;
        return true;
    }
}

function mergePartialObj(db, partialObj, data, response, doMerge, cPersist){
    var prec = db.cache.getEntity(partialObj.$.schema.def, partialObj.$.pkVal), data = data || prec, isRec = prec ? true : false, mergeDone;
    if(partialObj && partialObj.$ && partialObj.$.processed){
        return;
    }
    if(mergeError(db.schema[partialObj.$.schema], data, response)){
        return;
    }
	if(partialObj.$.type == "removed"){
        mergeDeletedRec(db, partialObj, data, cPersist);
        return;
    }
    else if((partialObj.$.type == "added" || (data && data.$ && data.$.isNew == true)) && isRec){
        mergeDone = mergeNewRecord(db, partialObj, data, response, doMerge, cPersist);
    }
    else if((partialObj.$.type == "modified" || partialObj.$.type == "related" || (data && data.$ && data.$.isModified == true)) && isRec){
        mergeModifiedRec(db, partialObj, data, response, doMerge, mergeDone, cPersist);
    }
    if(isRec){
        if(partialObj.$.type != "removed"){
            for(var key in partialObj){
                var part = partialObj[key];
                mergeNewDataKeys(db, part, data[key], response ? response[key] : undefined,cPersist);
            }
        }
        if(data.$.partial && Object.keys(data.$.partial)){
            data.$.partial = new Map();
        }
        removeDirtyStack(data,partialObj);
    }
}

function mergeNewRecord(db, partialObj, data, response, doMerge, cPersist){
	var mdl = partialObj.$ ? partialObj.$.schema : data.$.schema,
	pKeys = mdl._arrPk, 
	oldPk = data.$.pK, 
	lyte = db.lyte,
	rec = db.cache.getEntity(mdl.def, oldPk), 
	result, 
	partRec = partialObj.$ ? partialObj.$.entity : undefined;
	if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(partRec) && partRec !== rec){
		return;
	}
	if(rec){
		var oldRelPk = typeof oldPk == "object" ? oldPk : oldPk.toString(), 
		crProcessed = false;
		if(cPersist !== true){
			pKeys.forEach(function(item){
				if(!response || !response.hasOwnProperty(item)){
					_dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror.error(lyte,"LD16", mdl._name, (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(data) ? (typeof data.$.pK == "object" ? JSON.stringify(data.$.pK) : data.$.pK) : undefined);
					return;
				}	
				(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(lyte, data, item, response[item], undefined, true);
				crProcessed = true;
			});
			var newPk = getpKVal(data);
			(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(lyte, data.$, "pK", getpKVal(data));
			var newRelPk = typeof newPk == "object" ? newPk : newPk.toString();
			if(mdl.data._recMap){
				mdl.data._recMap.delete(oldRelPk);
				mdl.data._recMap.set(newRelPk, data);
			}
			changeRelPkMaps(data, oldRelPk, newRelPk);
			updateNestScp(data, oldPk);
		}
		if(crProcessed && partialObj && partialObj.$ ){
			partialObj.$.processed = true;
		}
		if(doMerge && cPersist !== true){
			result = validateAndMerge(mdl, response, partialObj, true, true);
			if(result && result.data){
				result = result.data;
			}
			else if(result && result.type){
				Array.isArray(result.args) ? result.args.splice(0,0,db.lyte) : [db.lyte]
				_dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror[result.type].apply(_dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror, result.args || [db.lyte]);
			}
		}
		(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(lyte, data.$, "isNew", false);
		if(partialObj.hasOwnProperty("_removedAttr") && Object.keys(partialObj._removedAttr).length!=0){
			return result;
		}
		(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(lyte, data.$, "isModified", false);
		changePersist(data, true);
		deleteFromArray(mdl.dirty, oldPk);
		if(!data.$.dN || ( data.$.dN && Object.keys(data.$.dN).length == 0 )){
			removeParentNesting(data);
		}
	}
	return result;
}

function mergeModifiedRec(db, partialObj, data, response, doMerge, mergeDone, cPersist){
	var dirtyId = !dirtyId ? data.$.pK : dirtyId, result, lyte = db.lyte;
	if(!data.$.isDeleted && response && !mergeDone && cPersist !== true){
		if(response && doMerge){
			result =  validateAndMerge(data.$.schema, response, partialObj, true, true);
			if(result && result.data){
				result = result.data;
			}
			else if(result && result.type){
				Array.isArray(result.args) ? result.args.splice(0,0,db.lyte) : [db.lyte]
				_dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror[result.type].apply(_dberror__WEBPACK_IMPORTED_MODULE_3__.Dberror, result.args || [db.lyte]);
			}
		}
		mergeDone = true;						
	}
	// changeModified(lyte, data, false, data.$.pK);
	if(partialObj && partialObj.hasOwnProperty("_removedAttr") && partialObj._removedAttr.length){
		return result;
	}
	(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(lyte, data.$, "isModified", false);
	changePersist(data, true);
	deleteFromArray(data.$.schema.dirty , data.$.pK)
	if(!data.$.dN || ( data.$.dN && Object.keys(data.$.dN).length == 0 )){
		removeParentNesting(data);
	}
	return result;
} 

function mergeDeletedRec(db, partialObj, data){
	var pkVal, schema, obj;
	if(partialObj){
		schema = partialObj.$.schema;
		pkVal = partialObj.$.pkVal;
	}
	else if(data){
		schema = data.$.schema;
		pkVal = data.$.pK;
	}
	obj = schema._deleted.get(pkVal); 
	var rec = obj ? obj.data : undefined;
	var isRec = db.cache.getEntity(schema.def, pkVal);
	if(rec){
		(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(db.lyte, rec.$, "isDeleted", false);
		(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(db.lyte, rec.$, "isUnloaded", true);
		(0,_commonUtils__WEBPACK_IMPORTED_MODULE_0__.cmpSet)(db.lyte, rec.$, "isPersisted", true);
		var scpObj = rec.$.__scpObj;
		for(var key in scpObj){
			var sid = scpObj[key];
			var sidArr = sid.split("_");
			var nestObj = _slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.nestScp[sidArr[0]];
			nestObj ? (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.removeNestScp)(nestObj._data, sidArr[0], sidArr[1], undefined, rec, undefined, undefined, {model:schema._name, pK: pkVal, attr: key}) : undefined;
		}	
		schema._deleted.delete(pkVal);
		removeParentNesting(rec);
	}
	if(isRec){
		removeFromStore(schema, pkVal, true, undefined, undefined, true);
		removeParentNesting(isRec);
	}
	else{
		var cqueries = db.schema.cachedQueries;
		if(cqueries){
			var n=schema._name, Nm = cqueries[n];
			if(Nm && Nm.length){
				for(var i=Nm.length-1; i>=0; i--){
					var obj = Nm[i];
					if(obj.hasDeletedRecords){
						if(obj.data){
							var ind = obj.data[n].indexOf(rec);
							if(ind !== -1){
								Nm.splice(i,1);					
							}
						}
					}
				}					
			}
		}
	}
	if(partialObj && partialObj.$ && partialObj.$.parent){
		partialObj.$.parent.$.partial = {};
	}
	partialObj && partialObj.$ ? partialObj.$.processed = true : undefined;
}

function changeRelPkMaps(data, oldPk, newPk, type, changedField){
	var schema = data.$.schema,
	db = schema.db,
	lyte = db.lyte,
	relations = schema.relations;
	relations.forEach(function(rels, key){
		var relsLen = rels.length;
		for(var i=0; i<relsLen; i++){
			var itm = rels[i];
			var attr = itm.relKey, relType = itm.relType, inv;
			if(data.hasOwnProperty(attr)){
				var relRec = data[attr],
				bMod = getSchemaObj(db, itm.relatedTo), 
				inv, 
				isSortDef;
				if(bMod){
					inv = getBackwardRel(schema,itm,bMod);
					if(inv && inv.relType == "hasMany"){
						isSortDef = inv.opts && inv.opts.sort && inv.opts.sort.sortFn && inv.opts.sort.observes;
						if(relType == "belongsTo" && (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(relRec)){
							switch(type){
								case "sort":
								case "srtObsChk": {
									if(relRec && Array.isArray(relRec[inv.relKey])){
										if(type == "sort"){
											if(isSortDef && inv.opts.sort.observes.indexOf(changedField) != -1){
												handleArrOp(lyte, relRec[inv.relKey], "sort");
											}
										}
										else if(changedField !== inv.relKey){
											return true;
										}
									}
									break;
								}
								default: {
									relRec[inv.relKey] && relRec[inv.relKey]._recMap && relRec[inv.relKey]._recMap.delete(oldPk) ? relRec[inv.relKey]._recMap.set(newPk, data) : undefined;
								}
							}
						}
						else if(relType == "hasMany" && Array.isArray(relRec)){
							var relRecLen = relRec.length;
							for(var l=0;l<relRecLen;l++){
								var rec = relRec[l];
								switch(type){
									case "sort":
									case "srtObsChk": {
										if(rec && Array.isArray(rec[inv.relKey])){
											if(type == "sort"){
												if(isSortDef && inv.opts.sort.observes.indexOf(changedField) != -1){
													handleArrOp(lyte, rec[inv.relKey], "sort");
												}
											}
											else if(changedField !== inv.relKey){
												return true;
											}
										}
										break;
									}
									default: {
										(0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(rec) && rec[inv.relKey] && rec[inv.relKey]._recMap && rec[inv.relKey]._recMap.delete(oldPk) ? rec[inv.relKey]._recMap.set(newPk, data) : undefined;
									}
								}
							}
						}
					}
				}
			}
		}
	});

	var _rels = data.$._relationships;
	for(var md in _rels){
		var mdObj = _rels[md];
		var mdlIns = getSchemaObj(db, db.getSchema(md));
		for(var attr in mdObj){
			var arr = mdObj[attr];
			var fldObj = mdlIns.fieldList[attr];
			var isSortDef = fldObj.opts && fldObj.opts.sort && fldObj.opts.sort.sortFn && fldObj.opts.sort.observes;
			var arrLen = arr.length;
			for(var j=0; j<arrLen; j++){
				var rec = arr[j];
				var relData = rec[attr];
				if(Array.isArray(relData)){
					switch(type){
						case "sort":
						case "srtObsChk": {
							if(Array.isArray(relData)){
								if(type == "sort"){
									if(isSortDef && fldObj.opts.sort.observes.indexOf(changedField) != -1){
										handleArrOp(lyte, relData, "sort");
									}
								}
								else if(changedField !== fldObj.relKey){
									return true;
								}
							}
							break;		
						}
						default : {
							relData._recMap && relData._recMap.delete(oldPk) ? relData._recMap.set(newPk, data) : undefined;
						}
					}
				}
			}
		}
	}
}

function updateNestScp(obj, oldPk){
	if((0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.isEntity)(obj)){
		var scpObj = obj.$.__scpObj || {};
		for(var key in scpObj){
			var val = scpObj[key];
			val = val.split("_")[0];
			if(_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.nestScp && _slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.nestScp.hasOwnProperty(val) && _slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.nestScp[val].model){
				var mp1 = _slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.nestScp[val].model.get(obj.$.schema._name);
				if(mp1.has(oldPk)){
					var val = mp1.get(oldPk);
					mp1.delete(oldPk);
					mp1.set(obj.$.pK, val);
				}
				// Lyte.nestScp[val].pK = record.$.pK;
			}
		}
	}
}

function getDsrzEmpData(schema, field){
	if(field.hasOwnProperty("deserializeEmptyData")){
		return field.deserializeEmptyData;
	}
	else{
		var desrz = getFromCB(schema.db, "serializer", schema.serializer, "deserializeEmptyData");
		if(desrz !== undefined){
			return desrz;
		}
	}
	return false;
}

function defpayObjUtls(db,scope){
	Object.defineProperties(scope,{
		set:{
			value: payloadSet.bind({db,scope})
		},
		remove:{
			value: payloadRemove.bind({db,scope})
		}
	})
}

function defPayArrUtls(db,scope){
	Object.defineProperties(scope,{
		add : {
			value : payloadAdd.bind({db,scope})
		},
		remove : {
			value : payloadRemove.bind({db,scope})
		}
	})
}

function payloadAdd(key,index){
	if(!Array.isArray(key)){
		key=[key];
	}
	var schemaName = this.scope._schema,partObj=this.scope._partialObj,payload=this.scope._payloadObj;
	var def = this.db.getSchema(schemaName);
	var field = {opts : { serialize : this.scope._serialize}};
	var _pk = {} , partial={};
	for(var i =0 ; i<key.length; i++){
		if(partObj._removedRecords && partObj._removedRecords.hasOwnProperty(key[i])){
			delete partObj._removedRecords[key[i]];
			_pk = partObj._removedRecords[key[i]]._payload;
			partial = partObj._removedRecords[key[i]]._partial;
		}
		else{
			var record=this.db.cache.getEntity(def,key[i]);
			var data = PayloadSerialize(this.db,field,_pk,record,undefined,getSchemaObj(this.db,def),partial)
			_pk = data.payload;
			partial= data.partial;
		}
		if(!this.scope.partRecMap.get(key[i])){
			if( index != undefined && typeof index == "number"){
				this.db.lyte.arrayUtils(partObj,"insertAt",index,partial);
				this.db.lyte.arrayUtils(payload,"insertAt",index,_pK);
				index=index++;
			}
			else{
				this.db.lyte.arrayUtils(partObj,"push",partial);
				this.db.lyte.arrayUtils(payload,"push",_pk);
			}
			this.scope.partRecMap.set(key[i],true);
		}
	}
}
function payloadRemove(key){
	var modelName = this.scope._schema,partObj=this.scope._partialObj,payload=this.scope._payloadObj;
	if(!Array.isArray(key)){
		key=[key];
	}
	for(var j =0; j<key.length; j++){
		if(Array.isArray(payload)){
			var len=payload.length;
			if(this.scope._serialize && this.scope._serialize == "id"){
				if(payload.includes(key[j])){
					var _index = payload.indexOf(key[j]);
					payload.splice(_index,1);
				}
			}
			else{
				for(var i =0; i<len; i++){
					if(partObj[i] && partObj[i].$.pkVal == key[j]){
						!partObj.hasOwnProperty("_removedRecords") ? Object.defineProperties(partObj,{ _removedRecords :{ value : { [partObj[i].$.pkVal] :{ _partial:partObj[i] , _payload : payload[i]} } } } ):partObj._removedRecords[partObj[i].$.pkVal] = { _partial:partObj[i] , _payload : payload[i]};
						this.db.lyte.arrayUtils(partObj,"removeAt",i,1);
						this.db.lyte.arrayUtils(payload,"removeAt",i,1);
						this.scope.partRecMap.delete(key[j]);
					}
				}
			}
		}
		else{
			if(payload[key[j]]){
				partObj.hasOwnProperty("_removedAttr") && !partObj._removedAttr.hasOwnProperty(key[j])? partObj._removedAttr[key[j]]={ _partial:partObj[key[j]] , _payload : payload[key[j]]} : !partObj.hasOwnProperty("_removedAttr") ? Object.defineProperties(partObj,{ _removedAttr : { value : { _partial:partObj[key[j]] , _payload : payload[key[j]]} } }):undefined;
				if(partObj[key[j]]){
					partObj._removedAttr[key[j]]._partial = partObj[key[j]];
					this.db.lyte.objectUtils(partObj,"delete",key[j]);
				}
				this.db.lyte.objectUtils(payload,"delete",key[j]);
			}
		}
	}
}
function payloadSet(fkey){
	if(!Array.isArray(fkey)){
		fkey=[fkey];
	}
	var schemaName=this.scope._schema,pk=this.scope._pkVal,payload=this.scope._payloadObj , def = this.db.getSchema(schemaName);
	var record = this.db.cache.getEntity(def , pk ), partial=this.scope._partialObj , model=getSchemaObj(this.db,def);
	for(var i_key=0; i_key<fkey.length; i_key++){
		var key = fkey[i_key];
		if(!this.scope._payloadObj[key]){
			if(partial.hasOwnProperty("_removedAttr")){
				if(partial._removedAttr.hasOwnProperty(key) && partial._removedAttr[key] != true){
					payload[key]=partial._removedAttr[key]._payload;
					if(partial._removedAttr[key]._partial){
						partial[key] = partial._removedAttr[key]._partial;
					}
					this.db.lyte.objectUtils(partial._removedAttr,"delete",key);
					return;
				}
			}
			var field = model.fieldList[key];
			if(record[key] && field.type == "relation"){
				if(field.relType == "hasMany"){
					partial[key]=[];
					payload[key]=[];
					if(field.opts && field.opts.serialize=="id"){
						payLoadIdSerialize(this.db,payload,key,record,model,field,partial)
					}
					_defProp(payload[key], "$", {});
					defPayArrUtls(this.db,payload[key].$);
					Object.defineProperties(payload[key].$,{
						_key:{
							value:field.relKey
						},
						_partialObj:{
							value:partial[key]
						},
						_schema:{
							value:field.relatedTo._name
						},
						_payloadObj:{
							value:payload[key]
						},
						replace:{
							value:replaceCheck,
							writable:true
						},
						partRecMap : {
							value: new Map()
						}
					})
					if(field.opts && field.opts.serialize && !payload[key].$.serialize){
						Object.defineProperty(payload[key].$,"_serialize",{
							value : field.opts.serialize
						})
					}
					if(field.opts && field.opts.serialize!="id" || !field.opts){
						if(field.opts.serialize == "record"){
							for(i=0; i<record[key].length; i++){
								payload[key].$.add(record[key][i].$.pK);
							}
						}
						if(field.opts.serialize=="partial"){
							var dirtyRecords = record[key].partial;
							dirtyRecords.forEach(function(value,pk){
								payload[key].$.add(pk);
							})
						}
					}
				}
				else{
					partial[key]={};
					payload[key]={};
					var data = PayloadSerialize(this.db,field,payload[key],record[key],key,getSchemaObj(this.db,field.relatedTo),partial[key]);
					payload[key]=data.payload
					partial[key]=data.partial
				}
			}
			else{
				payload[key]=record[key];
				partial[key]=record[key];
			}
		}

	}
}
function payLoadIdSerialize(db,payload,key,record,model,field,partial){
	var rel={};
	payload[key] = (0,_slyte_core_src_lyte_utils_js__WEBPACK_IMPORTED_MODULE_2__.deepCopyObject)(record[key]);
	getRelations(db,model,key,getSchemaObj(db,field.relatedTo),rel);
	idSerialize(db,payload,rel,undefined,partial);
}
function PayloadSerialize(db,field,payload,record,key,model,partial){
	var getPayloadData=typeof record.$.pK =="object" ? record.$.pK:{[record.$.schema._pK]:record.$.pK};
	var mdl = model;
	var data, part, isModifiedFlag = false;
	if(field.opts && field.opts.serialize){
		part =  initPartialObj(model._name);
		if(field.opts.serialize == "record"){
			getPayloadData = toJSON(db,model._name,record,undefined,undefined,part);
		}
		if(field.opts.serialize == "partial"){
			var dirty = isDirty(db,record,mdl.relations);
			var rec = record;
			if(rec.$.isModified ||(dirty && dirty.length)){
				data = updateJSON(db,rec,mdl,dirty);
				getPayloadData = toJSON(db,model._name,data,undefined,undefined,part)
				isModifiedFlag = true;
			}
			else{
				part.obj.set( record.$.pK , partial)
			}
		}
		partial = part.obj.get( record.$.pK ) || partial;
		var partobj ={
			pkVal : {
				value : record.$.pK
			},
			type : {
				value : "related"
			},
			schema : {
				value : mdl
			},
			record : {
				value : record[key] || record
			}
		}
		if(isModifiedFlag == true){
			partobj.type.value="modified"
		}
		if(getPayloadData){
			var argObj = {
				entityData : getPayloadData,
				cachedData : record
			}
			payload = _Serializer__WEBPACK_IMPORTED_MODULE_6__.Serializer.serializeRecords(db,model._name,getPayloadData,record,undefined,"serializeEntity",undefined,argObj,part.obj)
		}
		if(field.opts && field.opts.serialize == "id"){
			getPayloadData=record.$.pK
		}
		if(typeof payload == "object"){
			if(partial && !partial.$){
				_defProp(partial, "$", {});
			}
			var nPartial = 	partial.$;
			Object.defineProperties(nPartial,partobj);
			if(field.opts && field.opts.serialize && payload.$ && !payload.$._serialize && field.relType == "belongsTo"){
				Object.defineProperty(payload.$,"_serialize",{
					value : field.opts.serialize
				})
			}
		}
		var data = {
			"payload": payload,
			"partial": partial
		}
		return data;
	}
}
function replaceCheck(bool){
	_defProp(this._partialObj,"replace",bool)
}




/***/ }),

/***/ 47455522:
/*!*********************************************!*\
  !*** ./node_modules/@slyte/router/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "History": () => (/* reexport safe */ _src_history__WEBPACK_IMPORTED_MODULE_0__.History),
/* harmony export */   "Route": () => (/* reexport safe */ _src_route__WEBPACK_IMPORTED_MODULE_2__.Route),
/* harmony export */   "Router": () => (/* reexport safe */ _src_router__WEBPACK_IMPORTED_MODULE_3__.Router),
/* harmony export */   "RouterMap": () => (/* reexport safe */ _src_map_parser__WEBPACK_IMPORTED_MODULE_1__.RouterMap)
/* harmony export */ });
/* harmony import */ var _src_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/history */ 37522066);
/* harmony import */ var _src_map_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/map-parser */ 89428711);
/* harmony import */ var _src_route__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/route */ 7677563);
/* harmony import */ var _src_router__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/router */ 82018310);







/***/ }),

/***/ 33961434:
/*!*************************************************!*\
  !*** ./node_modules/@slyte/router/src/go-to.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linkToRegistration": () => (/* binding */ linkToRegistration)
/* harmony export */ });
/* harmony import */ var _router_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./router-errors */ 72780963);
/* harmony import */ var _router_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./router-utils */ 65320879);



const startFromStr = "start-from",
ltPropStr = "lt-prop",
routeStr = "route",
pReplace = `${ltPropStr}-replace`,
pStartFrom = `${ltPropStr}-${startFromStr}`,
pFragment = `${ltPropStr}-fragment`,
pDp = `${ltPropStr}-dp`,
pQp = `${ltPropStr}-qp`,
pTd = `${ltPropStr}-td`,
pData = `${ltPropStr}-data`,
pTrans = `${ltPropStr}-trans`,
pMeta = `${ltPropStr}-meta`,
refreshHRouteStr = `refresh-${routeStr}`,
pRefreshRoute = `${ltPropStr}-${refreshHRouteStr}`,
linktoStr = "link-to",
ltPropWarning = `Error while parsing ltProp in ${ltPropStr}`,
pRoute = `${ltPropStr}-${routeStr}`;
const parse = JSON.parse;

function linkToRegistration(lyte,LR,config) {
    LR.__lp.navigationCompleted = function(trans) {
        if(config.linkActiveClass && config.allLinks[trans.target]) {
            config.allLinks[trans.target].forEach(function(tag) {
                if(!tag.classList.contains(config.linkActiveClass)) {
                    tag.classList.add(config.linkActiveClass);
                    config.activeLinkTags.push(tag);
                }
            });
        }
    }

    LR.__lp.mutateCache = function(target) {
        if(config.allLinks[target]) {
            config.allLinks[target].forEach(function(tag) {
                if(config.linkActiveClass) {
                    tag.classList.add(config.linkActiveClass);
                }
                config.activeLinkTags.push(tag);
                var aTag = tag.getElementsByTagName('A')[0]
                if(aTag) {
                    aTag.setAttribute("href", LR.getURL(tag.getMatchedObject())); 
                }
            });
        }
    }

    class LinkTo extends HTMLElement {
        static get observedAttributes() {
            return [pRoute, pDp, pFragment, pQp, ltPropStr, 'lt-prop-class', 'lt-prop-id', 'lt-prop-rel', 'lt-prop-title', 'lt-prop-style', 'lt-prop-target','lt-prop-data-tabindex', 'lt-prop-aria-attributes','lt-prop-tabindex','lt-prop-aria-label'];
        }
        attributeChangedCallback(attr, oldValue, newValue) {
            if(this.matched && this.hasAttribute("lyte-rendered")) {
                let Atag = this.getElementsByTagName('A')[0];
                if(Atag) {
                    //If attr is ltProp
                    if(attr === ltPropStr) {
                        this.handleLtProp();
                        if(!this.hasAttribute("lt-prop-custom")) {
                            this.setCustomAttributes(Atag, true);
                        }
                        this.constructHref(Atag);
                    } else if(/^(lt-prop-route|lt-prop-fragment|lt-prop-dp|lt-prop-qp)$/.test(attr)) {
                        //if it is a route transition attribute
                        this.getMatchedObject();
                        this.constructHref(Atag, attr, oldValue, newValue);
                    } else if(!this.hasAttribute('lt-prop-custom')) {
                        //for rest of the attributes
                        Atag.setAttribute(attr.substring(8), newValue);
                    }
                }
            }
        }

        connectedCallback() {
            this.ltProp = this.ltProp || {};
            this.handleLtProp();
            if(this.hasAttribute("lyte-rendered")) {
                if(this.getElementsByTagName('A')[0] && !this.matched) {
                    this.getMatchedObject();
                }
                return;
            } 
            var isCustom = this.hasAttribute("lt-prop-custom") || this.ltProp.custom,
            aTag;
            if(isCustom) {
                if(aTag = this.getElementsByTagName('A')[0]) {
                    this.getMatchedObject();
                    this.constructHref(aTag);
                }
            } else {
                aTag = document.createElement("a");
                while(this.childNodes[0]) {
                    aTag.appendChild(this.childNodes[0]);
                }
                this.setCustomAttributes(aTag);
                this.getMatchedObject();
                this.constructHref(aTag);
                this.appendChild(aTag);
            }
            if(lyte.$.modules.component) {
                this._linkToEventId = lyte.$.modules.component[0].addAction(this, "click", function(event) {
                    linkToEventListener(event, this);
                }, this);
            } else {
                this.addEventListener("click", linkToEventListener);
            }
            this.setAttribute("lyte-rendered", "");
        }

        modifyLinkToTagsInRoute(remove) {
            var strRoute = Array.isArray(this.matched.route) ? this.matched.route.join('.') : this.matched.route,
            allLinks = config.allLinks[strRoute];
            if(remove) {
                if(allLinks) {
                    let pos = allLinks.indexOf(this);
                    if(pos != -1) {
                        allLinks.splice(pos,1);
                    }
                }
            } else {
                if(allLinks) {
                    allLinks.push(this);
                } else {
                    config.allLinks[strRoute] = [this];
                }
            }
            if(config.cacheRoutes[strRoute]) {
                let routesObj = config.routes,
                routes;
                if(remove) {
                    if(this.matched) {
                        routes = remove;
                    } else {
                        return;
                    }
                } else {
                    routes = this.matched.route;
                }
                if(!routes) {
                    return;
                } 
                routes = Array.isArray(routes) ? routes : _dotSerperator(routes);
                for(var i = 0,l = routes.length,r; i < l; i++) {
                    r = routes[i];
                    routesObj =  (0,_router_utils__WEBPACK_IMPORTED_MODULE_1__._getObj)(r,routesObj);
                    if(!routesObj || !routesObj.__lp) {
                        _router_errors__WEBPACK_IMPORTED_MODULE_0__.RouterError.error(lyte,422,routes,i);
                        return false;
                    }
                    var def = routesObj.__lp.handler && routesObj.__lp.options;
                    if(remove) {
                        let pos = def.cacheLinks.indexOf(this);
                        if(pos !== -1) {
                            def.cacheLinks.splice(pos,1);
                        }
                    } else if(def.qpdef) {
                        def.cacheLinks.push(this);  
                    }
                }
            }
        }

        disconnectedCallback() {
            let m = this.modifyLinkToTagsInRoute.bind(this);
            if(lyte.$.component && !lyte.$.component.shouldIgnoreDisconnect()) {
                if(this.matched && this.matched.route) {
                    m(this.matched.route);
                }
                if(this._linkToEventId) {
                    lyte.$.component.removeLyteEventListener(this, this._linkToEventId);
                }
            }
        }
        
        handleLtProp(ignoreError) {
            var ltProp = this.getAttribute(ltPropStr);
            if(ltProp) {
                try{
                    this.ltProp = parse(ltProp);
                } catch(e) {
                    if(!ignoreError) {
                        lyte.error(ltPropWarning,ltProp);
                    }
                }
            }
        }

        setCustomAttributes(linkTag, onlyLtProp) {
            for(let key in this.ltProp) {
                if(/^(id|class|style|target)$/.test(key)) {
                    linkTag.setAttribute(key, this.ltProp[key]);
                }
            }
            if(!onlyLtProp) {
                for(let i=0,attr,attrName; attr = this.attributes[i]; i++) {
                    if((attrName = attr.nodeName) !== ltPropStr && /^(lt-prop-id|lt-prop-rel|lt-prop-class|lt-prop-style|lt-prop-target|lt-prop-data-tabindex|lt-prop-tabindex|lt-prop-aria-label|lt-prop-aria-attributes)$/.test(attrName)) {
                        linkTag.setAttribute(attrName.substring(8), attr.nodeValue);
                    }
                }
            }
        }

        constructHref(linkTag, attr, oldValue) {
            var href,
            m = this.modifyLinkToTagsInRoute.bind(this);
            if(href = LR.getURL.call(this,this.matched)) { /* deepCopyObj this.matched. ??*/
                linkTag.setAttribute("href", href); 
                if(attr === pRoute) {
                    m(oldValue);
                    m();
                } else {
                    m();
                }
            }
        }
    }
    
    LinkTo.prototype.getMatchedObject = function() {
        var matched = this.matched || {},
        ga = this.getAttribute.bind(this),
        dynamicParams = ga(pDp) || this.ltProp.dp || [],
        queryParams = ga(pQp) || this.ltProp.qp || {};
        if(!(dynamicParams instanceof Array)) {
            try {
                dynamicParams = parse(dynamicParams);  
            } catch(e) {
                _router_errors__WEBPACK_IMPORTED_MODULE_0__.RouterError.error(lyte,"498A","dynamicParams",this.outerHTML);
                return;
            }
        }
        if(!(queryParams instanceof Object)) {
            try{
                queryParams = parse(queryParams);
                if(Array.isArray(queryParams)) {
                    _router_errors__WEBPACK_IMPORTED_MODULE_0__.RouterError.error(lyte,"498A","queryParams",this.outerHTML);
                    return;
                }
            } catch(e) {
                _router_errors__WEBPACK_IMPORTED_MODULE_0__.RouterError.error(lyte,"498A","queryParams",this.outerHTML);
                return;
            }
        }
        var routeFromAlias = _router_utils__WEBPACK_IMPORTED_MODULE_1__._getRouteFromAlias.call(lyte,{route : ga(pRoute) || this.ltProp.route, map : config.aliasRouteMap});/* ga(pRoute) || this.ltProp.route; */
        matched.route = routeFromAlias.route;
        matched.alias = routeFromAlias.alias;
        matched.fragment = ga(pFragment) || this.ltProp.fragment;
        matched.dynamicParams = dynamicParams || [];
        matched.queryParams = queryParams || {};
        matched.refreshRoute = ga(pRefreshRoute) != undefined ? ga(pRefreshRoute) : this.ltProp[refreshHRouteStr];
        matched.refreshRoute = (matched.refreshRoute == "" || matched.refreshRoute == 'true') ? matched.route.join(".") : matched.refreshRoute;
        matched.startFrom = ga(pStartFrom) || this.ltProp[startFromStr];
        return this.matched = matched;
    };
    customElements.define(linktoStr, LinkTo);
    customElements.define("go-to", (function() {
        class GoTo extends LinkTo {}
        return GoTo;
    })());

    function linkToEventListener(event, linkTo) {
        if(event.button == 2 || event.defaultPrevented) {
            return;
        }
        var targetElem = linkTo || event.currentTarget;
        if(targetElem.children[0].tagName === "A" && (event.ctrlKey == true || event.metaKey == true || event.which == 2 || (targetElem.children[0].hasAttribute("target") && targetElem.children[0].getAttribute("target") !== "_self")) ) {
            return;  
        }
        event.preventDefault();
        if(!targetElem.matched) {
            targetElem.getMatchedObject();
        }
        var matched = Object.assign({},targetElem.matched);
        matched.route = Array.isArray(matched.route) ? matched.route.join('.') : matched.route;
        var replace = targetElem.ltProp.replace  || targetElem.hasAttribute(pReplace),
        transitionInstance = LR[replace && replace != "false" ? "replaceWith" : "navigateTo"](targetElem.matched);
        targetElem.handleLtProp(true)
        var transObj = {},
        transProp,
        ltProp = targetElem.ltProp;
        if(transProp = targetElem.getAttribute(pMeta) || targetElem.getAttribute(pTrans) || (ltProp && ltProp.meta)) {
            try{
                transObj = parse(transProp);  
            } catch(e) {
                _router_errors__WEBPACK_IMPORTED_MODULE_0__.RouterError.error(lyte,"498A", pMeta , linkTo.outerHTML);
            }
        }
        let transitionData = targetElem.getAttribute(pData) || targetElem.getAttribute(pTd) || (ltProp && ltProp.data);
        if(transitionData/* = (transitionData || transObj.data)*/) {
            if(typeof transitionData === "string") {
                try {
                    transitionData = parse(transitionData);
                } catch(e) {
                    _router_errors__WEBPACK_IMPORTED_MODULE_0__.RouterError.error(lyte,"498A", pData , linkTo.outerHTML);
                }
            }
            transObj.data = transitionData;
        }
        for(var key in transObj) {
            transitionInstance[key] = transObj[key];
        }
    }
}



/***/ }),

/***/ 37522066:
/*!***************************************************!*\
  !*** ./node_modules/@slyte/router/src/history.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "History": () => (/* binding */ History)
/* harmony export */ });
/* harmony import */ var _router_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./router-utils */ 65320879);
/* harmony import */ var _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @slyte/core/src/lyte-utils */ 60768251);



class Location {
    constructor(obj) {
        var ignore = ["reload","ancestorOrigins","replace","toString","assign"]
        for(var key in obj) {
            if(ignore.indexOf(key) == -1) {
                this[key] = obj[key];
            }
        }
    }
}

class History {
    constructor({ historyType, popState, parent}) {
        var __lh = this.__lh = {
            historyType : parent && parent.history.type || historyType,
            allowHistoryChange : false,
            fromHistory : false,
            historyLength : 1,
            exp : {                
            }
        };
        this.parent = parent;

        window.addEventListener('popstate', function(event) {
            __lh.fromHistory = true;
            setHistoryObj.call(this, event.state);
            popState(event);
        }.bind(this));
       

        // Object.defineProperty(this.constructor.prototype, 'state', {
        //     get : function() {
        //         return this.getData();
        //     },
        //     set : function(data) {
        //         if(this.__lh.allowHistoryChange) {
        //             debugger;
        //             this.__lh.allowHistoryChange = false;
        //         } else {
        //             lyte.warn('setting on data will not be pushed to history. If needed, use `LR.history.replaceState`.');
        //         }
        //         return data;
        //     }
        // });

        __lh.exp.pushState = this.pushState = function(data, title, url, metaData) {
            url = mergeWithParentUrl.call(this,{url})
            return stateChange.call(this, data,title,url,metaData);
        };
    
        __lh.exp.replaceState = this.replaceState = function(data,title,url,metaData) {
            url = mergeWithParentUrl.call(this,{url})
            return stateChange.call(this,data,title,url,metaData, true);
        };
        __lh.exp.go = this.go = history.go
        __lh.exp.back = this.back = history.back
        __lh.exp.forward = this.forward = history.forward
        __lh.exp.length = this.length = history.length
        Object.defineProperty(this,"scrollRestoration",{
            get : () => {
                return history.scrollRestoration;
            },
            set : (value) => {
                history.scrollRestoration = value;
            }
        })
    
        this.getMeta = function() {
            var meta = history.state && history.state.meta
            return meta;
        }

        function mergeWithParentUrl({url}) {
            if(this.parent) {
                debugger;
                var i,
                pUrl = this.parent.history.url,
                serch = ((i = url.indexOf('?')) != -1) ? "?"+url.slice(i+1) : "";
                serch = this.parent.history.search+serch;
                if(url.indexOf("#") != -1) {
                    url = (0,_router_utils__WEBPACK_IMPORTED_MODULE_0__._delimit)(url.split("#")[1])
                }
                if(this.__lh.historyType == "hash") {
                    pUrl = this.parent.path
                    url = pUrl+ url
                } else if(pUrl.indexOf("#")) {
                    pUrl = this.parent.path + url + (0,_router_utils__WEBPACK_IMPORTED_MODULE_0__._delimit)(pUrl.split("#")[1])
                } 
                url += (serch ? "?"+serch : "");
            }
            return url
        }
        
        __lh.exp.getData = this.getData = function() {
            return history.state && history.state.data;
        }
        
        // this.getHistoryObj = function() {
        //     var retObj =  {
        //         historyType : historyType,
        //         index : this.__lh.currentMeta ?  this.__lh.currentMeta.__lh.index : 0,
        //         fromHistory : this.__lh.fromHistory ? (this.__lh.prevMeta ? (this.__lh.prevMeta.__lh.index < this.__lh.currentMeta.__lh.index ? 'forward' : 'back') : 'reload') : false,
        //         initial : this.__lh.historyLength == 0
        //     }
        //     // allowHistoryChange = true;
        //     retObj.state = history.state;
        //     retObj.meta = this.getMeta() || {};
        //     retObj.data = this.getData() || {};
        //     return retObj;
        // }
    }
}

function getHistoryState(obj) {
    /* 
    {
            matched : obj.matched,
            url : obj.url,
            index : obj.fromHistory ? (this.getMeta() ? this.getMeta().index : historyLength) : ((obj.replace && this.getMeta()) ? this.getMeta().index : (historyLength = historyLength+1))
        }

        state data which needs to be pushed to history. 
        - Matched object is added to process url directly with history back and forward.
        - Index is used to detect browser back or forward.
    */
    var metaData = obj.metaData || {},
    currentMeta = this.__lh.prevMeta = this.__lh.currentMeta;
    metaData.__lh = {
        index : obj.replace ? (currentMeta ? currentMeta.__lh.index : this.__lh.historyLength-1) : (currentMeta ? currentMeta.__lh.index+1 : this.__lh.historyLength),
        url : obj.url,
        title : obj.title
    }
    return {
        meta : this.__lh.currentMeta = metaData,
        data : obj.data
    };
}

function stateChange(data,title,url, metaData, replace) {
    var args = [getHistoryState.call(this, {data , metaData, replace, title, url}) , title] 
    if(url) {
        /* support for windows, undefined is appended to url */
        args.push(url)
    }
    // this.__lh.prevMeta = history.state && history.state.meta;
    window.history[replace ? "replaceState" : "pushState"].apply(window.history, args);
    var hstry = setHistoryObj.call(this) //this.getHistoryObj();
    // this.__lh.index = his.index;
    if(!hstry.fromHistory && !replace) {
        this.__lh.historyLength++;
    }
    return hstry;
}

function setHistoryObj(popHistory) {
    var self = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_1__.deepCopyObject)(this);
    if(popHistory) {
        self.__lh.currentMeta = self.__lh.prevMeta = popHistory.meta;
        return self.__lh.exp;
    }
    self.__lh.exp = new Location(window.location);
    var href = self.getMeta() && self.getMeta().__lh.url || window.location.href,
    urlSplit = href.split("?"),
    search = urlSplit[1] || "",
    hash = urlSplit[0].split("#")[1] || "";
    self.__lh.exp.index = self.__lh.index = self.__lh.currentMeta ?  self.__lh.currentMeta.__lh.index : 0;
    self.__lh.exp.fromHistory = self.__lh.fromHistory = self.__lh.fromHistory ? (self.__lh.prevMeta ? (self.__lh.prevMeta.__lh.index < self.__lh.currentMeta.__lh.index ? 'forward' : 'back') : 'reload') : false;
    self.__lh.exp.initial = self.__lh.initial = self.__lh.historyLength == 0;
    self.__lh.exp.data = self.getData && self.getData() || history.state && history.state.data;
    self.__lh.exp.url = href;
    self.__lh.exp.type = this.parent ? this.parent.history.type : this.__lh.historyType;
    self.__lh.exp.href = self.__lh.exp.origin+self.__lh.exp.pathname+href;
    self.__lh.exp.search = search && "?"+search;
    self.__lh.exp.hash = hash && "#"+hash;
    self.__lh.state = history.state;
    self.__lh.currentMeta = self.__lh.prevMeta = self.getMeta && self.getMeta() || history.state && history.state.meta;
    return self.__lh.exp;
}


    

/***/ }),

/***/ 89428711:
/*!******************************************************!*\
  !*** ./node_modules/@slyte/router/src/map-parser.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RouterMap": () => (/* binding */ RouterMap),
/* harmony export */   "_parseRouteMap": () => (/* binding */ _parseRouteMap),
/* harmony export */   "_traverseMap": () => (/* binding */ _traverseMap)
/* harmony export */ });
/* harmony import */ var _slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/router/src/router-utils */ 65320879);


const parseRouteMappingStr = "parseRouteMapping",
functionStr = "function";
var  mapObj = {}, 
pathStringArr = [], 
routeStringArr = [],
_config,
_initialRegisterRoute,
routesObj;

class RouterMap {
    constructor() {
        this.aliasPrefix = [];
        this.lazyRoute = this.route;
        this.mountRoute = this.route;

        this.setAlias = function(lyte,_config,alias,route) {
            var _alias="";
            if(alias) {
                if(this.aliasPrefix.length) {
                    this.aliasPrefix.forEach((a) => {
                        _alias += a;
                    });
                }
                alias = _alias+alias
            };
            if(_config.aliasRouteMap[alias]) {
                lyte.error('Duplicate entries found for alias "'+ alias +'". Existing entry will be overwritten');
            }
            _config.aliasRouteMap[alias] = route;
            _config.routeAliasMap[route] = alias;
        };
    }

    route(routeName, obj, nestedFn) {
        // var lazyRoute;
        // if(typeof obj.class == functionStr && obj.class.name == "__routeProm__") {
        //     // className = obj.cName;
        //     lazyRoute = true
        // }
        // if(!obj.class) {
        //     return "No route file map"
        // };
        if(typeof obj == "object"/*  || lazyRoute*/) {
            if(!obj.path) {
                obj.path = (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._delimit)(routeName);
            } else {
                if((0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._strPresence)(obj.path,"?")) {
                    var split = obj.path.split('?');
                    obj.defQP = (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._frameQueryParams)(split[1]);
                    obj.path = split[0] || "/";
                }  
            }
            if(obj.queryParams) {
                obj.defQP = obj.queryParams;
            }
        } else {
            if(typeof obj == functionStr) {
                nestedFn = obj;
            }
            obj = {path : (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._delimit)(routeName) /* ,cName : obj.class.name */};  
        }
        mapObj = (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._getObj)(pathStringArr,_config.routeHash)[obj.path] = {__lp : {}};
        if(obj.path == '/') {
            pathStringArr.push('/');
        } else {
            var trimedPath = obj.path;
            if((0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._dynamicRouteCheck)(trimedPath) || (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._wildcardRouteCheck)(trimedPath)) {
                (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._splitPath)(trimedPath).every(function(seg,index,arr) {
                if((0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._dynamicRouteCheck)(seg) || (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._wildcardRouteCheck)(seg)) {
                    var dkey;
                    if((0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._dynamicRouteCheck)(seg)) {
                        dkey = seg.replace(":","");
                    } else  {
                        dkey = seg.replace("*","");
                        obj.wildcard = mapObj.__lp.wildcard = true;
                        obj.sufix = mapObj.__lp.sufix = [];
                        for(var i = index+1,j; j = arr[i]; i++) {
                            mapObj.__lp.sufix.push(j);
                        }
                    }
                    obj.dkey = mapObj.__lp.dkey = dkey;
                    obj.dIndex = mapObj.__lp.dIndex = index;
                    return false;
                }
                return true;
                });
            } 
            pathStringArr.push(trimedPath);
        }
        if(obj && obj.mount) {
            mapObj.__lp.mount = true;
        }
        var routes = (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._getObj)(routeStringArr,routesObj) || routesObj;
        routeStringArr.push(routeName);
        mapObj.__lp.route = Array.from(routeStringArr);
        routes[routeName] ? (Object.assign(routes[routeName].__lp,obj)) : (routes[routeName] = {__lp : obj});
        if(obj.alias) {
            this.setAlias(this.lyte,_config,obj.alias,mapObj.__lp.route.join('.'))
        }
        if(obj.handler.name == "__routeProm__") {
            // obj.then = function(routeStringArr,data) {
            //     debugger;
            //     _initialRegisterRoute(routeStringArr,data[obj.cName]);    
            // }.bind(undefined,Array.from(routeStringArr))
        } else {
            _initialRegisterRoute(routeStringArr,obj.handler);
        }
        if(nestedFn) {
            nestedFn.call(this,{});
        }
        // if(obj && obj.mount) {
        //     _config.dependenciesApps[obj.mount] = _config.dependenciesApps[obj.mount] ? _config.dependenciesApps[obj.mount].push(routeStringArr) : [routeStringArr]
        //     obj.mount.prototype.map.call(this,{});
        // }
        routeStringArr.pop();
        pathStringArr.pop();
        this.aliasPrefix.pop();
    }
    include(mapClass, obj) {
        try {
            obj = obj || {};
            if(obj.aliasPrefix) {
                this.aliasPrefix.push(obj.aliasPrefix)
            }
            obj && new mapClass().map.call(this,{});
        } catch(e) {
            console.error(e, "Error in includes")
        }
    }
}

RouterMap.__lMod = "RouterMap";

function _parseRouteMap(MapClass,{ lyte, config , initialRegisterRoute }) {
    _config = config;
    _initialRegisterRoute = initialRegisterRoute;
    lyte.time(parseRouteMappingStr);
    routesObj = _config.routes ? _config.routes : (_config.routes = {})
    var ins = new MapClass({ lyte }),
    err = ins.map(_config);
    if(typeof err == "string") { lyte.log(err)};
    lyte.time(parseRouteMappingStr);
    return routesObj;
}

function _traverseMap(path, config) {
    if(!path) {
     return;
    }
    var selectedPaths = [],
    fragment;
    if(config.historyType) {
        var fragSplit = path.split('#');
        if(fragment = fragSplit[1]) {
            path = fragSplit[0];
        }
    }
    var pathSplit = path.split('?');
    path = decodeURI(pathSplit[0]);
    if(path == '/') {
        if((0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._getObj)(['/'],config.routeHash)) {
            selectedPaths.push([path]);  
        } else {
            return;
        }
    } else {
        var params = pathSplit[1],
        pathSplitArr = (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._splitPath)(path);
        var pathLevel = 0,
        pathArrLevel = [0],
        exactMatch,
        matchedPath = [];
        matchedPath.dynamicParams = [];
        findPossibleMatch(config.routeHash);

        function checkArrayMatch(arr1,arr2,l,pathObj,matchedPath) {
            if(!(pathObj.__lp.wildcard || pathObj.__lp.dkey)) {
            var prevObj;
            if(prevObj = (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._getObj)(matchedPath,config.routeHash).__lp) {
                if(prevObj.wildcard) {
                var pathArr = arr2.slice(l);
                if(!(l += pathArr.indexOf(arr1[0]))) {
                    return false;
                }  
                }
            }
            }
            for(var i = 0,a1;a1 = arr1[i]; i++,l++) {
            if(a1 != arr2[l] && !(0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._dynamicRouteCheck)(a1)) {
                if((0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._wildcardRouteCheck)(a1)) {
                if(pathObj.__lp.sufix.length) {
                    l = arr2.indexOf(pathObj.__lp.sufix[0])-1; 
                }
                } else if(arr1[l] == '/') {
                l--;
                } else {
                return false;  
                }
            }
            }
            return l;
        }

        function findPossibleMatch(mapObj) {
            for(var mapPath in mapObj) {
                if(!exactMatch) {
                    var pathObj = mapObj[mapPath],
                    innerLevel;
                    if(mapPath != "__lp") {
                        var mapPathSplit = (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._splitPath)(mapPath);
                        if(mapPathSplit) {
                            if((innerLevel = checkArrayMatch(mapPathSplit,pathSplitArr,pathLevel,pathObj,matchedPath)) !== false) {
                            pathArrLevel.push(innerLevel);
                            pathLevel = pathArrLevel[pathArrLevel.length-1];
                                if(pathSplitArr.length == pathLevel || pathObj.__lp.mount) {
                                    var path = Array.from(matchedPath.concat(mapPath));
                                    if(pathObj["/"]) {
                                        path = path.concat('/');
                                    }
                                    selectedPaths.push(path);
                                    if(pathObj.__lp.wildcard || pathObj.__lp.dkey || pathObj.__lp.mount) {
                                        pathArrLevel.pop();
                                        pathLevel = pathArrLevel[pathArrLevel.length-1];
                                    } else {
                                        if(!/[:*]/.test(path.join(''))) {
                                            exactMatch = path;  
                                        }
                                        return;
                                    }
                                } else {
                                    var innerRoutes = Object.keys(pathObj);
                                    matchedPath.push(mapPath);
                                    if(pathSplitArr[pathLevel]) {
                                    if(pathObj.__lp.wildcard && !pathObj.__lp.sufix.length && innerRoutes.length == 1) {
                                        var wildcard= Array.from(matchedPath);
                                        if(pathObj["/"]) {
                                        wildcard = wildcard.concat('/');
                                        }
                                        selectedPaths.push(wildcard);
                                    } else if(innerRoutes.length > 1) {
                                        findPossibleMatch(pathObj);    
                                    }
                                    } 
                                    matchedPath.pop();
                                    pathArrLevel.pop();
                                    pathLevel = pathArrLevel[pathArrLevel.length-1];
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if(exactMatch) {
        return [exactMatch,path,params,fragment];
    } else if(selectedPaths.length == 1) {
        return [selectedPaths[0],path,params,fragment];
    } else if(selectedPaths.length) {
        return [getBestMatch(getStaticMatches(selectedPaths),selectedPaths),path,params,fragment];

        function getBestMatch(staticMatches, selectedPaths, position) {
            position = position || 0;
            var traversedStaticMatch = traversedStaticMatch || traverseArray(staticMatches),
            maxStaticSeg = Math.max(...traversedStaticMatch[position]),
            duplicatePos;
            while(duplicatePos = checkForArrayDuplicates(traversedStaticMatch[position], maxStaticSeg, selectedPaths, staticMatches)) {
                position = position+1;
                var newSelectedPaths = [],
                newStaticMatches = [];
                for(var i = 0,l = duplicatePos.length; i < l; i++) {
                    newSelectedPaths.push(selectedPaths[i]);
                    newStaticMatches.push(staticMatches[i]);
                }
                var newSelectedPathsFiltered = [],
                newStaticMatchesFiltered = [];
                for(var i = 0,l = newStaticMatches.length; i < l; i++) {
                    if(newStaticMatches[i][position] != undefined) {
                        newSelectedPathsFiltered.push(newSelectedPaths[i]);
                        newStaticMatchesFiltered.push(newStaticMatches[i]);
                    }
                }
                if(!newSelectedPathsFiltered.length) {
                    return newSelectedPaths[0];
                } else if(newSelectedPathsFiltered.length == 1) {
                    return newSelectedPathsFiltered[0];
                }
                return getBestMatch(newStaticMatchesFiltered, newSelectedPathsFiltered, position);
            }
            return selectedPaths[traversedStaticMatch[position].indexOf(maxStaticSeg)];
        }
        

        function getStaticMatches(selectedPaths) {
            var staticSegmentsInMatch = [];
            for(var i = 0,l = selectedPaths.length; i < l; i++) {
                var arr = Array.from(selectedPaths[i]),
                staticPath = 0,
                result = [];
                if(arr[0] == "/") {
                    arr.shift();
                }
                if(arr[arr.length-1] == "/") {
                    arr.pop();
                }
                var counter = -1;
                arr.every(function(seg,i) {
                    var noWildcard = true;
                    (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._splitPath)(seg).every(function(innerSeg,j) {
                    counter++;
                    if(innerSeg == pathSplitArr[counter]) {
                        staticPath++;
                        if(arr.length == i+1){
                        result.push(staticPath);
                        }
                        return true;
                    } else if(innerSeg.indexOf(':') != -1) {
                        result.push(staticPath);
                        staticPath = 0;
                        return true;
                    } else {
                        if(innerSeg.indexOf('*') != -1) {
                        noWildcard = false;
                        }
                        result.push(staticPath);
                        return false;
                    }
                    });  
                    return noWildcard;
                });
                staticSegmentsInMatch.push(result);
            }
            return staticSegmentsInMatch;
        }
    } else {
        return false;
    }
}

function checkForArrayDuplicates(arr, value) {
    var pos = [];
    for(var i = 0,l = arr.length;i < l; i++) {
        if(arr[i] == value) {
            pos.push(i);
        }
    }
    return pos.length == 1 ? false : pos;
}

function traverseArray(arr) {
    var res = [],
    maxArrLen = 0;
    for(var i = 0,l = arr.length; i < l; i++) {
        var a = arr[i];
        maxArrLen = a.length > maxArrLen ? a.length : maxArrLen;
    }
    for(var i=0,a ;a = arr[i]; i++) {
        for(var j=0; j<maxArrLen; j++) {
            res[j] = res[j] || [];    
            res[j][i] = a[j];
        } 
    }
    return res;
}



/***/ }),

/***/ 7677563:
/*!*************************************************!*\
  !*** ./node_modules/@slyte/router/src/route.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Route": () => (/* binding */ Route)
/* harmony export */ });
/* harmony import */ var _slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/router/src/router-utils */ 65320879);
/* harmony import */ var _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @slyte/core/src/service */ 76099455);



var routeStr = "route",
objectStr = "object";
/*convert to custom class*/
class Route extends _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_1__.Service {
    constructor({ i, routeName, options, init})  {
		super();
		const { lyte, LR } = options;
		this.routeName = routeName;
		this.$router = LR;
		Object.defineProperties(this,{
			"navigation" : {
				get : function() {
					return LR.__lp.nav.get(this)._trans;
				}
			}, 
			"__lp" : {
				get : function() {
					return LR.__lp.nav.get(this).rOpts[i];
				},
				set : function(key, value) {
					if(key == "toBeUsed") {
						if(this.__lp.toBeUsed.length){
							var self = this;
							lyte.extendService({services : this.__lp.toBeUsed || [], type: routeStr, ins: this, callback : function(serv, key, aName, serName){
								var obj = {};
								obj.key = key;
								obj.service = serName;
								lyte.extendService({services : [obj], type: routeStr, ins: self});
							}});
						}
					}
					LR.__lp.nav.get(this).rOpts[i][key] = value;
				}
			},
			"$" : {
				get : function() {
					return LR.__lp.nav.get(this).rOpts[i].$;
				},
				set : function(key, value) {
					LR.__lp.nav.get(this).rOpts[i].$[key] = value;
				}
			},
			"currentData" : {
				get : function() {
					return LR.__lp.nav.get(this).rOpts[i].currentData;
				},
				set : function(value) {
					LR.__lp.nav.get(this).rOpts[i].currentData = value;
				}
			}
		});
		// this.parent = routes[i-1] instanceof Promise ? routes[i-1].then(function() {this.parent = routes[i-1]}.bind(this)) : routes[i-1];
		// this.removeFromCache = function(arr) {
		// 	lyte.removeFromCache.assign.call(lyte,arr);
		// };
		this.replaceWith = LR.replaceWith;
		this.navigateTo = LR.navigateTo;
		this.navigateForward = LR.navigateForward;
		this.navigateBack = LR.navigateBack;
		this.refresh = function(obj) {
			var refreshFrom = (0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._dotSerperator)(this.__lp.objPath).length-1,
			trans = options.trans,
			route = Array.from(trans.matched.route),
			processed = {
				matched : trans.matched,
				R : trans.R,
				rOpts : trans.rOpts,
				transComp : {
					unRendered : route.splice(refreshFrom),
					rendered : route
				}
			};
			trans.abort({state : 308, iAbort : true});
			options.newTransInfo = {replace : true, data : trans.data, fromHistory : false, url : trans.url};
			if(obj && obj.refreshTemplate) {
				processed.refreshFrom = refreshFrom;
			}
			return options.dispatch(trans.url, processed)._trans;
		};
		this.setTitle = function(title) {
			d.title = this.title = title;
		};
		this.getQueryParams = function() {
			return this.__lp.param.queryParams;
		};
		this.getDynamicParam = function() {
			return this.__lp.param.dynamicParam;
		};
		Object.defineProperty(this,'$lg', {
			value : lyte.__gl
		});
		this.getRouteInstance = function(routeName) {
			return LR.getRouteInstance(routeName);
		};
		this.setDynamicParam = function(value) {
			if(value && this.__lp.param.dynamicParam && this.__lp.param.dynamicParam != value) {
				var dynamicParams = Array.from(options.trans.matched.dynamicParams);
				options.trans.matched.dpObj
				dynamicParams.splice(this.__lp.objPath.split(".").length-1, 1, value);
				return paramChangeTrans(options, cloneMatchedObj(options.trans.matched,{dynamicParams : dynamicParams}));
			}
			return options.trans._trans;
		};

		this.setQueryParams = function(key,value,opts)  {
			var obj = {},
			refresh;
			if(typeof key == objectStr) {
				obj = key;
				opts = value;
			} else {
				obj[key] = value;
			}
			if(typeof opts == objectStr) {
				refresh = opts.refresh;
			}
			refresh = opts;
			var matched = cloneMatchedObj(options.trans.matched,{queryParams : Object.assign({},options.trans.matched.queryParams,obj)});
			if(!(0,_slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._compareObj)(options.trans.matched.queryParams,matched.queryParams)) {
				matched.refreshData = matched.refreshData == undefined ? refresh : matched.refreshData;
				return paramChangeTrans(options, matched);
			}
			return options.trans._trans;
		};
		//give support for remove query params
		this.throwEvent = typeof lyte.$.component !== "undefined" && lyte.$.component.throwEvent;
		init(this)
		if(this.init) {this.init();}
	}
}

Route.__lMod = "Route";
Route.register = _slyte_router_src_router_utils__WEBPACK_IMPORTED_MODULE_0__._register;

function paramChangeTrans(options, matched) {
	var url = options.constructURLFromRoute(matched),
	processed = {
		matched : matched,
		R : options.trans.R,
		rOpts : options.trans.rOpts
	};
	options.newTransInfo = {
		data: options.trans.data,
		url: url,
		fromHistory: false
	};
	options.dispatch(url, options.decideTransition(processed));
	return options.newTrans._trans;
}

function cloneMatchedObj(matched, data) {
	var obj = Object.assign({}, matched);
	obj.route = data.route || Array.from(matched.route)
	obj.dynamicParams = data.dynamicParams || Array.from(matched.dynamicParams)
	obj.queryParams = data.queryParams || Object.assign({}, matched.queryParams)
	delete obj.refreshRoute;
	delete obj.refreshData;
	return obj;
	// var obj = Object.assign({},matched);
	// obj.route = data.route || Array.from(matched.route);
	// obj.dynamicParams = data.dynamicParams || Array.from(matched.dynamicParams);
	// obj.queryParams = data.queryParams || Object.assign({},matched.queryParams);
	// return obj;
}



// src = prevInstance || this.constructor,
// routePredefined = options.routePredefined;
// for(var key in src) {
// 	if(_strPresence(routePredefined,key)) {
// 		this.#__lp__.fns[key] = src[key];
// 	} else if(key == "actions") {
// 		if(typeof ins.constructor.actions == "function") {
// 			ins.actions = ins.constructor.actions();
// 		}
// 		options.fns.actions = RouteClass.actions && RouteClass.actions() || {};
// 	} 
// else if(prevInstance) {
// 	if(key != "__lp") {
// 		this[key] = src[key]; // need to remove this;
// 	}
// } 
// }
// routePredefined.forEach(function(key) {
// 	if(key == "actions") {
// 		if(typeof ins.constructor.actions == "function") {
// 			ins.actions = ins.constructor.actions();
// 		}

// 		options.fns.actions = RouteClass.actions && RouteClass.actions() || {};
// 	} else {
// 		options.fns[key] = RouteClass.prototype[key]
// 	}
// 	delete RouteClass.prototype[key];
// });

// for(var key in src) {
// 	if(prevInstance || !_strPresence(routePredefined,key)) {
// 		if(key != "__lp") {
// 			this[key] = src[key];
// 		}
// 	} 
// }

// [beforeFetch,fetch,afterFetch].forEach(function(key) {
// 	Object.defineProperties(this.$, {
// 		[key] : {
// 			get : function() {
// 				return this.__lt.rOpts[i].$[key];
// 			},
// 			set : function() {
// 				this.__lt.rOpts[i].$[key] = value;
// 			}
// 		}
// 	})
// })
// this.__lp = deepCopyObject(prevInstance && prevInstance.__lp || routeOptions);
// this.__lp = deepCopyObject((prevInstance && prevInstance.__lp) || RouteClass.__lp); make only one instance
// delete this.__lt.rendered;
// this.transition = this.navigation = options.newTrans._trans;
// if(processed.transComp && !processed.transComp.rendered[i] && processed.transComp.redirected) {
// 	if(processed.transComp.redirected.i < i) {
// 		delete this.__lp.loadDependencies;
// 		delete this.__lp.loadResources;
// 		this.$ = {};
// 		delete this.currentModel;
// 	} else if(processed.transComp.redirected.i != i) {
// 		delete this.__lp.stencils;
// 	}
// } else {
// 	delete this.__lp.stencils;
// }
// this.__lp.param = {
// 	queryParams :{},
// 	dynamicParam : undefined
// }
// this.__lp.queryParams = {};

/***/ }),

/***/ 72780963:
/*!*********************************************************!*\
  !*** ./node_modules/@slyte/router/src/router-errors.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RouterError": () => (/* binding */ RouterError)
/* harmony export */ });
/* harmony import */ var _node_modules_slyte_core_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../../node_modules/@slyte/core/index.js */ 182578);


class RouterError extends _node_modules_slyte_core_index_js__WEBPACK_IMPORTED_MODULE_0__.Logger {
    static getErrorMessage(code) {
        arguments[0] = `LR${code}`
        var msg = super.getErrorMessage.apply(this,arguments);
        return msg;
    }
}

RouterError.errorCodes = {
    LR400 : `url "{0}" is not defined in router.`,
    LR400A : `Base path of url is not specified.`,
    LR422 : `There is no route definition for the route {args[1].splice(0,args[2]+1).join('.')}.`,
    LR498 : `Invalid argument {0}`,
    LR498A : `Invalid argument {0} provided in {1}.`,
    LR499 : `Dynamic params for the route {0} is not provided.`,
    LR499A : `Dynamic params for the route {0} is not provided {args[2].outerHTML}.`,
    LR499B: `Transition tried without arguments.`,
    LR405 : `Method invocation before Router initialized.`,
     // LR203 : `Data provided for component is not valid.`,
     LR428 : `There is no outlet named {0}.`,
     LR420A : `Error in {0} of route {1}.`,
     LR420 : `Promise rejected`
    //  LR424 : `File not loaded in {0} of route {1}.\n {args[3][0].target.outerHTML}`,
};




// var lyte;

// function _getError() {
//     var args = arguments,
//     error;
//     switch(args[0]) {
//         case 400 :
//             error = args[1] ? "url '"+args[1]+"' is not defined in router." : "Base path of url is not specified.";
//             break;
//         case 422 :
//             error = "There is no route definition for the route "+(args[1].splice(0,args[2]+1).join('.'))+".";
//             break;
//         case 424 : 
//             error = "File not loaded in "+args[1]+ " of route "+args[2]+".\n"+args[3][0].target.outerHTML;
//             break;
//         case 498: 
//             error = "Invalid argument " + args[1] + (args[2] ? " provided in "+args[2] : ".");
//             break;
//         case 499 : 
//             error = args[1] ? ("Dynamic params for the route "+args[1]+" is not provided" + (args[2] && args[2].outerHTML  ? " in "+args[2].outerHTML : ".")) : "Transition tried without arguments.";
//             break;
//         case 420 : 
//             error = (args[3]? "Promise rejected" : "Error")+" in "+args[1]+" of route "+args[2]+".";
//             break;
//         case 428 : 
//             error = "There is no outlet named "+args[1]+".";
//             break;
//         case 203 :
//             error =  "Data provided for component is not valid.";
//             break;
//         case 405 :
//             error =  "Method invocation before Router initialized.";
//             break;
//     }
//     return 'LR '+args[0]+': '+error;
// }

// function _bindLyteInstanceToError(ins) {
//     lyte = ins;
// }

// function _consoleError() {
//     return lyte.error(arguments[0].stack ? arguments[0] : _getError.apply(this,arguments),arguments[3]);
// }

// export {
//     _bindLyteInstanceToError,
//     _getError,
//     _consoleError
// }



// class ValidationError extends Dberror{
//     static errorCodes = {
//         ERR01 : "Primary key cannot be modified", 
//         ERR02 : "Mandatory prop cannot be empty", 
//         ERR03 : "Type of value does not match the specified data type",
//         ERR04 : "Value is greater than the maximum value allowed",
//         ERR05 : "Value is less than the minimum value allowed", 
//         ERR06 : "Length of string/array is greater than the maximum limit allowed", 
//         ERR07 : "Length of string/array is less than the minimum limit allowed",
//         ERR08 : "String does not match the specified pattern", 
//         ERR09 : "Values in array are not unique", 
//         ERR10 : "Value is not equal to the specified constant", 
//         ERR11 : "Schema of related field is not defined",
//         ERR12 : "Schema of backward relation is not defined", 
//         ERR13 : "Entity not found", 
//         ERR14 : "Schema does not match the schema defined in the related field", 
//         ERR15 : "Error in creating a entity as a relation",
//         ERR16 : "Entity with primary key already exists", 
//         ERR17 : "Value cannot be changed because entity has been deleted", 
//         ERR18 : "Action not defined", 
//         ERR19 : "Schema not defined",
//         ERR20 : "Key not specified", 
//         ERR21 : "'one' relationship expects a single object/id", 
//         ERR22 : "Type not specified for polymorphic relation", 
//         ERR23: "Primary Key value not present", 
//         ERR24: "Error while relating entities", 
//         ERR25: "Backward relation not present",
//         ERR26: "Primary key value cannot be undefined or null",
//         ERR27: `Observer can observe only string data type value, {0} value cannot be observed in the function named '{0}' in the component '{1}'`,
//         ERR29: "Property not defined in the object",
//         ERR30: "Property's value is not an instanceof the mentioned class"      
//     }
//     constructor(lyte, attr, obj, message){
//         super();
//         Object.defineProperties(this, {
//              : {
//                 value : {isError : true , error:message?message:{}}
//             }
//         });
//         if(attr){
//             ValidationError.setError(lyte,this,attr,obj);
//         }    
//     }

//     static setError(lyte,err,attr,codeObj){
//         if(err..hasOwnProperty("error")){
//             if(Array.isArray(attr)){
//                 attr.forEach(function(itm){
//                     cmpSet(lyte, err..error, itm, codeObj);
//                 });
//             }
//             else{
//                 cmpSet(lyte, err..error,attr,codeObj);
//             }
//         }
//         else{
//             ValidationError.error("LD03",err,attr);
//         }
//     }

//     static setRecErr(ent, field, code, value){
//         var lyte = ent.schema.Lyte;
//         cmpSet(lyte, ent, "isError", true);
//         var errObj = code;
//         if(typeof errObj == "object"){
//             cmpSet(lyte, ent.error,field,errObj);
//         }
//         else{
//             if(typeof code == "string"){
//                 var errMes = ValidationError.errorCodes[code];
//                 if(errMes){
//                     errObj = {code : code, message : ValidationError.errorCodes[code]};
//                 }
//                 else{
//                     errObj = code;
//                 }
//             }
//             cmpSet(lyte, ent.error, field, errObj);
//             if(value){
//                 cmpSet(lyte, ent.error[field],"value",value);
//             }				
//         }
// 		var db = ent.schema.db;
//         emit(db,"error",ent.entity,field,errObj);
//     }

//     static clrRecErr(ent, field, code){
//         var lyte = ent.schema.Lyte;
//         var objUtl = lyte.objectUtils;
//         var err = ent.error;
//         if(code){
//             if(ent.error.code == code){
//                 if(typeof objUtl != "undefined"){
//                     objUtl(err,"delete",field);
//                 }
//                 else{
//                     delete err[field];                        
//                 }
//             }
//         }
//         else if(field){
//             if(typeof objUtl != "undefined"){
//                 objUtl(err,"delete",field);
//             }
//             else{
//                 delete err[field];                       
//             }
//         }
//         else{
//             if(typeof objUtl != "undefined"){
//                 for(var err in err){
//                     objUtl(err,"delete",err);
//                 }
//             }	
//             else{
//                 ent.error = {};
//             }   
//         }
//         if(Object.keys(ent.error).length == 0){
//             cmpSet(lyte, ent, "isError", false);
//         }
//     }
// }

// class ConnectorError extends Dberror {
//     constructor(msg, xhr){
//         super();
//         this.message = msg;
//         this.xhr = xhr;
//     }
// }

// class SerializerError extends Dberror{
//     constructor(msg, xhr){
//         super();
//         this.message = msg;
//         this.xhr = xhr;
//     }
// }

// export { ValidationError, Dberror, ConnectorError, SerializerError };

/***/ }),

/***/ 65320879:
/*!********************************************************!*\
  !*** ./node_modules/@slyte/router/src/router-utils.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_checkIfSameRoute": () => (/* binding */ _checkIfSameRoute),
/* harmony export */   "_compareObj": () => (/* binding */ _compareObj),
/* harmony export */   "_delimit": () => (/* binding */ _delimit),
/* harmony export */   "_dotSerperator": () => (/* binding */ _dotSerperator),
/* harmony export */   "_dynamicRouteCheck": () => (/* binding */ _dynamicRouteCheck),
/* harmony export */   "_frameDynamicParams": () => (/* binding */ _frameDynamicParams),
/* harmony export */   "_frameQueryParams": () => (/* binding */ _frameQueryParams),
/* harmony export */   "_getObj": () => (/* binding */ _getObj),
/* harmony export */   "_getRouteFromAlias": () => (/* binding */ _getRouteFromAlias),
/* harmony export */   "_normalizeTransitionParams": () => (/* binding */ _normalizeTransitionParams),
/* harmony export */   "_register": () => (/* binding */ _register),
/* harmony export */   "_splitPath": () => (/* binding */ _splitPath),
/* harmony export */   "_strPresence": () => (/* binding */ _strPresence),
/* harmony export */   "_validateURL": () => (/* binding */ _validateURL),
/* harmony export */   "_wildcardRouteCheck": () => (/* binding */ _wildcardRouteCheck),
/* harmony export */   "scriptExecution": () => (/* binding */ scriptExecution)
/* harmony export */ });
/* harmony import */ var _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @slyte/core/src/lyte-utils */ 60768251);
/* harmony import */ var _router_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./router-errors */ 72780963);



const _strPresence = (str, char) => str.includes(char),

_dotSerperator = (str) => str.split('.').filter(Boolean),

_dynamicRouteCheck = (route) => _strPresence(route,":"),

_wildcardRouteCheck = (route) => _strPresence(route,"*"),

_delimit = (seg) => seg[0] == "/" ? seg : "/"+seg,

_splitPath = (path) => path.match(/[^/?]+/g) || [];

function scriptExecution(scriptNode) {
    for(var i=0,currentScript;currentScript = scriptNode[i];i++) {
        var parent = currentScript.parentNode,
        s = d.createElement("script");
        for(var j = 0,attributes;attributes = currentScript.attributes[j]; j++) {
        s.setAttribute(attributes.name, attributes.value);
        }
        s.innerHTML = currentScript.innerHTML;
        parent.appendChild(s);
        parent.removeChild(currentScript);
    }
}

function _compareObj(obj1,obj2) {
    var obj1keys = Object.keys(obj1),
    obj2keys = Object.keys(obj2);
    if(obj1keys.length != obj2keys.length) {
    return false;
    } else {
    for(var key in obj1) {
        if(obj1[key] != obj2[key]) {
        return false;
        }
    }
    return true;
    }
}

function _register({hash}) {
	this._hash = hash;
};

function _getObj(arr,obj) {
    /**
     *  get nested property from an object
     * @params {array} array
     * @params {object} object
     * @returns
     */
    if(!obj) {
        return;
    } else if(!arr) {
        return obj;
    } else if(!Array.isArray(arr) && typeof arr == 'string') {
        arr = _dotSerperator(arr);
    }
    arr.every(function(key)  {
        if(obj && obj[key]) {
            obj = obj[key];
            return true;
        }
        return obj = false;
    });
    return obj;
}

function _frameQueryParams(url) {
    if(url) {
        var qp = {},
        split,
        params = _strPresence(url,"?") ? url.split("?")[1] : url;
        params = _strPresence(params,"&") ? params.split(/&/g) : [params];
        for(var i = 0,l = params.length; i < l; i++) {
            qp[(split = params[i].split('='))[0]] = split[1] ? decodeURIComponent(split[1]) : split[1];
        }
        return qp;
    } 
}

function _frameDynamicParams(url,matched, routesObj) {
    var dynamicParam,
    fdp,
    framedDP = [],
    urlSplit = _splitPath(url.split('?')[0]);
    for(var i = 0,l = matched.route.length,r; i < l; i++) {
        r = matched.route[i];
        routesObj = _getObj([r],routesObj);
        var routeObj =  routesObj.__lp;
        if(routeObj.wildcard) {
            if(routeObj.sufix.length) {
            var dp = urlSplit.slice(0,urlSplit.indexOf(routeObj.sufix[0]));
            fdp = decodeURI(dp.join('/'));
            pop(dp.concat(routeObj.sufix),urlSplit);
            } else {
            fdp = decodeURI(urlSplit.join('/'));
            }
        } else if(routeObj.dkey) {
            dynamicParam = urlSplit[routeObj.dIndex];
            pop(_splitPath(routeObj.path),urlSplit);
            fdp = decodeURI(dynamicParam);
        } else {
            pop(_splitPath(routeObj.path),urlSplit);
            fdp = undefined;
        }
        framedDP.push(fdp);
    };
    return framedDP;
}

function _validateURL(url) {
    url = url.replace(/\/\//g,'/');
    url = url.replace(/\/\?/g,'?');
    return url;
}

function _normalizeTransitionParams(obj) {
    // To normalize argument for transition, returns matched obj from obj or native tranisitionTo argument.
    var params;
    if(typeof obj == "object") {
        params = obj;
    } else {
        params = {
            queryParams : {},
            dynamicParams : []
        };
        Array.from(arguments).forEach(function(arg,index) {
            if(Array.isArray(arg)) {
                _router_errors__WEBPACK_IMPORTED_MODULE_0__._consoleError.call(lyte,498,JSON.stringify(arg));
                return;
        } else {
            if(index == 0) {
                params.route = arg;
        } else if(arg && typeof arg == "object") {
            params.queryParams = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_1__.deepCopyObject)(arg);
            } else {
                params.dynamicParams.push(arg);
            }  
        }
        });
    }
    return params;
}

function _getRouteFromAlias(obj) {
	var route = obj.route,
    alias;
	if(typeof route == "string") {
        if(route.indexOf('$') == 0) {
            alias = route.split('$')[1],
            map = obj.map;
            // if(map || (map = config.engineConf[config.mountedEngines[obj.parent]].aliasRouteMap)) {
            // }
                if(map[alias]) {
                    route = map[alias]
                } else {
                    _router_errors__WEBPACK_IMPORTED_MODULE_0__._consoleError.call(this,obj.route+' is not a valid route alias')
                    return;
                }
        }
        route = route.split('.');
	}
    return { route, alias};
}

function _checkIfSameRoute(transInfo1, transInfo2) {
    if(transInfo1 && transInfo2 && transInfo1.route == transInfo2.route && transInfo1.fragment == transInfo2.fragment && transInfo1.dynamicParams.length === transInfo2.dynamicParams.length && _compareObj(transInfo1.queryParams,transInfo2.queryParams)) {
        if(transInfo1.dynamicParams.length) {
            for(let i = 0,dynamicParam; dynamicParam = transInfo1.dynamicParams[i]; i++) {
                if(dynamicParam != transInfo2.dynamicParams[i]){
                    return false;
                }
            }
        }
        return true;
    }
    return false;
};

function pop(path,urlSplit) {
    for(var i = 0,l = path.length; i < l; i++) {
        urlSplit.shift();
    };
}



/***/ }),

/***/ 82018310:
/*!**************************************************!*\
  !*** ./node_modules/@slyte/router/src/router.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Router": () => (/* binding */ Router)
/* harmony export */ });
/* harmony import */ var _slyte_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @slyte/core */ 74043124);
/* harmony import */ var _slyte_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @slyte/core */ 46823552);
/* harmony import */ var _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @slyte/core/src/lyte-utils */ 60768251);
/* harmony import */ var _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @slyte/core/src/service */ 76099455);
/* harmony import */ var _go_to__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./go-to */ 33961434);
/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./history */ 37522066);
/* harmony import */ var _map_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map-parser */ 89428711);
/* harmony import */ var _router_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./router-errors */ 72780963);
/* harmony import */ var _router_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./router-utils */ 65320879);









/*-----------string declaration starts------------*/
const routeStr = "route",
RouterStr = "Router",
RouteStr = "Route",
fetchStr = "fetch",
FetchStr = "Fetch",
forceFetchStr = `force${FetchStr}`,
NavigationStr = "Navigation",
NavigateStr = "Navigate",
pendingStr = "pending",
completedStr = "completed",
abortedStr = "aborted",
beforeStr = "before",
afterStr = "after",
didStr = "did",
willStr = "will",
nestedForcedPromisesStr = "nestedForcedPromises",
constructRunLoopStr = "constructRunLoop",
getRequirementsStr = "getRequirements",
divertStr = "divert",
renderStr = "render",
onErrorStr = "onError",
beforeLoadStr = "beforeLoad",
onBeforeLoadStr = "onBeforeLoad",
LINKTOStr = "LINK-TO",
stateChangeStr = "stateChange",
DestroyStr = "Destroy",
TemplateStr = "Template",
RouteNavigationStr = `Route${NavigateStr}`,
afterRenderStr = `${afterStr}Render`,
beforeExitStr = `${beforeStr}Exit`,
didDestroyStr = didStr + DestroyStr,
pRoute = `lt-prop-${routeStr}`,
NavigationAbortedStr = `${NavigationStr} ${abortedStr}.`,
NavigationResumedStr = `${NavigationStr} resumed.`,
NavigationPausedStr = 	`${NavigationStr} paused.`,
NavigationComletedStr = `${NavigationStr} ${completedStr}.`,
beforeFetchStr = beforeStr + FetchStr,
afterFetchStr = afterStr + FetchStr,
pushStateStr = "pushState",
replaceStateStr = "replaceState",
willNavigateStr = willStr + NavigateStr,
didNavigateStr = didStr + NavigateStr,
beforeRouteNavigationStr = beforeStr+RouteStr + NavigationStr,
afterRouteNavigationStr = afterStr+RouteStr + NavigationStr,
beforeTemplateDestroyStr = beforeStr+TemplateStr + DestroyStr,
renderLoadingTemplateStr = `${renderStr}Loading${TemplateStr}`,
depricatedStr = "depricated",
html5Str = "html5",
stringStr = "string",
nestedPromisesStr = "nestedPromises",
renderTemplateWarning = `${renderStr} hook should return either component or HTML. Rendering of HTML directly into the DOM within the ${renderStr} hook is ${depricatedStr}.`,
__routeProm__Str = "__routeProm__",
/*-----------string declaration ends------------*/
fontColor = "MediumOrchid",
dloc = document.location,
resolvedPromise = Promise.resolve(),
emptyFn = function() {};

function getHook(routeInstance, hook) {
	return routeInstance.__lp.fns[hook]
}

function getAction(routeInstance, action) {
	return routeInstance.__lp.fns.actions && routeInstance.__lp.fns.actions[action]
}

/*convert to custom class*/
class Router extends _slyte_core_src_service__WEBPACK_IMPORTED_MODULE_5__.Service {
    constructor(a) {
        super(a)

        this.__lp = {
            version : "1.0.0-beta.4",
            pendingReg : [],
            mountedApps : {},
            config : {},
            nav : new WeakMap()
        };

        this.checkIfSameRoute = _router_utils__WEBPACK_IMPORTED_MODULE_4__._checkIfSameRoute;
        var newTransInfo,
		newTransInfoClone,
		newTransInfoTimer,
		lHistory,
		config = {
			historyType : false,
			baseURL : "",
			deferInit : false,
			preserveUrlOnBrowserNavigation : false,
			queryParamOptions : { cache : true},
			routeHash : {},
			urlCache : {},
			aliasRouteMap : {},
			routeAliasMap : {},
			cacheRoutes : {},
			allLinks : {},
			activeLinkTags : []
		},
		trans,
		prevTrans,
		newTrans,
		visibleTrans,
		historyObj,
		initialLoad = true,
		fromHistoryGo = false,
		processedDispatch;

        const run = {},
		lyte = this.$app,
		LR = this;

        lyte.extendEventListeners(this);

        run[getRequirementsStr] = function(hook,index) {
			const r = this.routes[index],
			res = r.__lp.loadResources =  [],
			dep = r.__lp.loadDependencies = [],
			callback = r.__lp.fns[hook];
			if(callback) {
				callHookWithoutPromise.call(this,callback,hook,index,[r.__lp.param, res, dep]);
			} 
			r.__lp.req = {
				resources : r.__lp.loadResources = Promise.all(res).then(function() {
					if(LR.__lp.nav.get(r)) {
						r.__lp.resourcesLoaded = true
					}
				}),
				dependencies : r.__lp.loadDependencies = Promise.all(dep).then(function() {
					if(LR.__lp.nav.get(r)) {
						r.__lp.dependenciesLoaded = true	
					}
				})
			}
			return resolvedPromise;
		}

        run[beforeFetchStr] = 
		run[fetchStr] = 
		run[afterFetchStr] = function(hook,index) {
			var routeInstance = this.routes[index],
			args = [getHook(routeInstance, hook),routeInstance];
			args.push(hook == afterFetchStr ? [routeInstance.currentData, routeInstance.__lp.param] : [routeInstance.__lp.param]);
			return callHookWithPromise.apply(this,args).then(setDataIn$,setDataIn$);
			function setDataIn$(data) {
				routeInstance.$[hook] = data;
				if(hook == fetchStr) {
					routeInstance.currentData = data;
				}
			}
		};

        run[divertStr] = function(hook,index) {
			var routeInstance = this.routes[index];
			return callHookWithPromise.apply(this,[getHook(routeInstance,hook),routeInstance,[routeInstance.currentData, routeInstance.__lp.param]]);
		};

        run[onErrorStr] = function(hook,index,err,state,options) {
			setPendingResume.call(trans,trans.prom);
			trans._trans.triggerEvent(onErrorStr,{error : err,hook : hook});
			var errIns = this.routes[index];
			for(; index >= 0 && !this.aborted && this.paused; index--) {
				var instance = this.routes[index];
				lyte.log(onErrorStr+" of "+ instance.routeName,routeStr,fontColor);
				if(callAction.call(this,onErrorStr,index,[err,this._trans, instance.__lp.param, hook]) == false) {
					break;
				}  
			}
			if(!options || !options.consoled) {
				_consoleErrorFromCallback(err,hook,errIns.routeName,state,options);
			}
		};

        run[willNavigateStr] = function(hook,index) {
			if(callAction.call(prevTrans,hook,index,[trans._trans]) == false) {
				removeHook(trans.runLoop.previous,hook);
			}
			return resolvedPromise;
		};

        run[beforeRouteNavigationStr] = function() {
			if(validateTransition(this)) {
				var pt;
				if(pt = prevTrans && prevTrans._trans) {
					delete pt.abort;
					delete pt.pause;
				}
				var obj = {
					prevNav : pt,
					nav : trans._trans,
					location : {fromHistory : (initialLoad ? "reload" : (newTrans && newTrans.navigationType ? false : true)), initial : initialLoad}
				}
				var callback = LR[beforeRouteNavigationStr]
				callback && callback.call(LR, obj.prevNav, obj.nav , obj.location);
				triggerEventOnInsAndClass(beforeRouteNavigationStr, obj)
			}
			return resolvedPromise;	
		};

        function triggerEventOnInsAndClass(ev,args) {
			trans._trans.triggerEvent(ev,args);
			LR.triggerEvent(ev, args);
			lyte.triggerEvent(ev, args);
		}

        run[afterRouteNavigationStr] = function(_trans) {
			var callback = LR[afterRouteNavigationStr];
			callback && callback.call(LR, _trans);
			triggerEventOnInsAndClass(afterRouteNavigationStr, {nav : _trans})
		};

        run[beforeLoadStr] = function(hook,index) {
			var routeProp = this.routes[index].__lp;
			if(routeProp.fns[hook]) {
				lyte.log(`${beforeLoadStr} callback is ${depricatedStr}. Use ${renderLoadingTemplateStr} callback`);
			}
			callHookWithoutPromise.call(this,routeProp.fns[hook],hook,index,[routeProp.param]);
			return resolvedPromise;
		};

        run[onBeforeLoadStr] = function() {
			return new Promise(function(resolve,reject) {
				for(var len = trans.matched.route.length, i=1; i <= len && validateTransition(trans); i++) {
					var l = len-i,
					// actions,
					routeInstance = trans.routes[l];
					// if((actions = routeInstance.__lp.fns.actions) && actions.onBeforeLoad) {
					// 	// lyte.log(onBeforeLoadStr +' action is depricated. Use beforeLoad callback');
					// }
					if(!(routeInstance instanceof Promise) && trans.onLoadCalled.indexOf(l) == -1) {
						trans.onLoadCalled.push(l)
						if((callAction.call(trans,onBeforeLoadStr,l,[routeInstance.__lp.param]) == false) || (trans.onLoadCalled.length == len) || (i == len)) {
							resolve();
							break;
						}
					} else if(i == len){resolve();}
				}
			});
		};

        run[afterRenderStr] =
		run[didNavigateStr] = function(hook,index) {
			return new Promise(function(resolve, reject) {
				var routeInstance = this.routes[index],
				st = setTimeout(function() {
					if(hook == afterRenderStr) {
						this.rOpts[index].rendered = true;
						callHookWithPromise.call(this,getHook(routeInstance, hook),routeInstance,[routeInstance.currentData,routeInstance.__lp.param,routeInstance.component]).then(function(data) {
							if(!trans.routes[index+1]) {
								trans._trans.triggerEvent(afterRenderStr);
							}
							resolve(data);
						}, function(data) {
							reject(data);
						});
					} else {
						run.removeTemplate.call(this);
						if(callAction.call(this,hook,index,[routeInstance.__lp.param, trans._trans]) == false) {
							removeHook(trans.runLoop.current,hook);
							index = 0;
						}
						setVisibleTrans.call(this)
						resolve();
						lyte.time(this.prom.hook + this.prom.index);
						if(index == 0) {
							transitionCompleted({state : 200});
						}
					}
				}.bind(this,hook,index),0);
				this.fns.push(st);          
			}.bind(this));
		};

        run[beforeExitStr] = function(hook,index) {
			var prevTransRouteInstance = prevTrans.routes[index];
			return callHookWithPromise.call(this,prevTransRouteInstance.__lp.fns[hook],prevTransRouteInstance,[prevTransRouteInstance.currentData, prevTransRouteInstance.__lp.param]);
		};

        // run.getMountApp = function(hook,index) {
        // 	var ins = trans.routes[index];
        // 	var prom = callHookWithPromise.call(this,ins.__lp.fns[hook],ins,[ins.__lp.param]).then(function(resp) {
        // 		resp.$.mountedTo = {path : LR.getURL(ins.__lp.objPath), app : lyte};
        // 		LR.__lp.mountedApps[ins.__lp.objPath] = resp;
        // 	});
        // 	return prom
        // };

        run[renderLoadingTemplateStr] = function(hook, index) {
			var route = this.routes[index],
  			loadingTemplate = callHookWithoutPromise.call(this,route.__lp.fns[hook],hook,index,[route.__lp.param]),
			outlet;
			// routeProp.stencils = loadingTemplate || {};
			if(loadingTemplate && loadingTemplate.outlet && (outlet = getOutlet(loadingTemplate.outlet,route.parent))) {
				if(outlet.childNodes[0]) {
					triggerTemplateDestroy({outlet,route},false);
				}
				route.outlet = outlet;
				if(loadingTemplate.component) {
					renderComp(outlet, loadingTemplate.component, {data : loadingTemplate.data , ins : route, hook,index , registry : loadingTemplate.registry || LR.__lp.config.registry})
				} else if(loadingTemplate.html) {
					renderHTML(outlet, loadingTemplate.html)
				}
			}
			return resolvedPromise;
		};

        run[renderStr] = function(hook,index) {
			var routeInstance = this.routes[index],
			callback = routeInstance.__lp.fns[hook] || routeInstance.__lp.fns.renderTemplate;
			if(callback) {
				run.removeTemplate.call(this);
				setVisibleTrans.call(this)
				// if(routeInstance.outlet) {
				// 	routeInstance.outlet.innerHTML = "";
				// }
				var renderTemplate = callHookWithoutPromise.call(
                    this,
                    callback,
                    hook,
                    index,
                    [routeInstance.currentData, routeInstance.__lp.param]
                ),
				outlet;
				if(validateTransition(this)) {
					if(renderTemplate && (routeInstance.outletName = outlet = (renderTemplate.outlet || routeInstance.outlet))) {
						var data = routeInstance.currentData;
						if(routeInstance.outlet = outlet = getOutlet(renderTemplate.outlet,routeInstance.parent)) {
							var  obj = {
								outlet : renderTemplate.outlet,
								route : routeInstance
							};
							if(renderTemplate.component) {
								if(routeInstance.component && !renderTemplate.reRender && (routeInstance.component.localName == renderTemplate.component._compName) && routeInstance.outlet == outlet && outlet.contains(routeInstance.component)) {
									// componentDataCheck.call(this,data,routeInstance,hook,index);
									routeInstance.component.setData(data)
								} else {
									triggerTemplateDestroy(obj,false);
									routeInstance.component = renderComp(outlet, renderTemplate.component,{data, ins : routeInstance , hook,index , registry : renderTemplate.registry || LR.__lp.config.registry})
								}
							} else if(renderTemplate.html) {
								routeInstance.component = undefined;
								triggerTemplateDestroy(obj,false);
								renderHTML(outlet, renderTemplate.html)
							}
						} else {
							_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error(lyte,428,renderTemplate.outlet);
						}
					} else {
						lyte.warn(renderTemplateWarning);
					}
				}  
			} else if(validateTransition(this) && this.runLoop.templateToRemove && this.routes.length == index+1) {
				run.removeTemplate.call(this);
			}
			return resolvedPromise;
		};

        // function componentDataCheck(data,routeInstance,hook,index) {
        // 	if(data) {
        // 		if(typeof data != "object" && Array.isArray(data)) {
        // 			processError.call(this,{stopTrans : true, err :Error(RouterError.getErrorMessage(203)).stack,instance :routeInstance,hook : hook,index : index});
        // 		}   
        // 	}
        // }

        function renderHTML(outlet, html) {
			outlet.innerHTML = html;
			var scripts = outlet.getElementsByTagName('script');
			if(scripts.length) {
				(0,_router_utils__WEBPACK_IMPORTED_MODULE_4__.scriptExecution)(Array.from(scripts),outlet);
			}
		}

        function renderComp(outlet, component, {data, ins, hook,index, registry }) {
			if(typeof component == stringStr) {
				console.error(`Component name cannot be ${stringStr}`);
				return;
			}
			// componentDataCheck.call(this,data,ins,hook,index);
			var compIns = component._render({
				outlet : outlet,
				data : data,
				options : {clearOutlet : true},
				registryInstance : registry,
				_route : ins.__lp.objPath
			})
			return compIns;
		}

        function getOutlet(outlet,parent) {
			var _outlet;
			if(parent) {
				_outlet =  parent.outlet ? parent.outlet.querySelector(outlet) : undefined;
				if(!_outlet) {
					return getOutlet(outlet,parent.parent);
				}
			} else if(!(_outlet = document.querySelector(outlet))) {
				return false;
			}
			return _outlet;
		}

        run.removeTemplate = function() {
			var arr = this.runLoop.templateToRemove;
			if(!this.cleared) {
				if(prevTrans && arr) {
					templateDelete.call(visibleTrans,arr);
				}
				this.cleared = true;
				delete this.runLoop.templateToRemove;
				// lyte.removeFromCache();
			}
		};

        function setVisibleTrans() {
			if(visibleTrans != this) {
				visibleTrans = this;
				// if(prevTrans != LR.__lp.visibleTrans) {
				// 	removeNavWeakMap(LR.__lp.visibleTrans,this)
				// }
				LR.__lp.visibleTrans = visibleTrans;
			}
		}

        function validateTransition(trans) {
			return !trans.aborted && !trans.paused;
		}

        function addToHistory(obj) {
			var type = obj.replace ? replaceStateStr : pushStateStr;
			obj.title = obj.title || document.title;
			/* support for windows, undefined is appended to url */
			var args = [obj.data, obj.title]
			args.push(config.historyType ? (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._delimit)(shiftBaseURL(obj.url, true)) : '#' + (config.slashAfterHash ? (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._delimit)(obj.url) : (obj.url[0] == "/" && obj.url.length > 1 ? obj.url.substring(1,obj.url.length) : obj.url)));
			args.push(obj.meta);
			LR.location = lHistory[type].apply(lHistory,args);
			if(trans) {
				trans.location = LR.location
			}
		}

        this.getRouteDefinition = function(arr,def) {
			if(arr == "*" || !arr) {
				return config.routes;
			} else {
			def = def || config.routes;
			def = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._getObj)(arr,def);
				return def && def.__lp && def.__lp.handler || undefined;  
			}
		}

        this.setConfig = function(defConfig) {
			for(var key in defConfig) {
				if(key == "queryParamOptions") {
					config.queryParamOptions.cache = defConfig.queryParamOptions.cache;
				} else if(key == "historyType"){
					config[key] = defConfig[key] == html5Str;
				} else if(key == "history"){
					config.historyType = defConfig.history == html5Str;
				} else {
					config[key] = defConfig[key];
				}
			}
			this.__lp.config = config;
		}
        this.setConfig(this.getConfig && this.getConfig());
        this.__lp.config.registry = this.getComponentRegistry && this.getComponentRegistry();

        configureRoutes.call(this,this.__lp.config && this.__lp.config.baseMap && this.__lp.config.baseMap);

        function configureRoutes(baseMap) {
			_map_parser__WEBPACK_IMPORTED_MODULE_2__._parseRouteMap.call(this,baseMap, {lyte, config, initialRegisterRoute });
			for(var i = 0,l = this.__lp.pendingReg.length; i < l; i++) {
				registerRoute.apply({},this.__lp.pendingReg[i]);
			}
			this.__lp.pendingReg = [];
			this.__lp.routesConfigured = true;
		}

        function init () {
			if(!config.deferInit && !LR.__lp.initCalled) {
				if(lyte.$.isApp) {
					LR.init();
				} else {
					setTimeout(function() {
						LR.init();
					},0)
				}
			} else {
				return;
			}
		}

        this.init = function(r) {
			if(!this.__lp.initCalled) {
				this.__lp.initCalled = true;
			} else {
				return;
			}
			if(this.onInit) { this.onInit();}
			lHistory = new _history__WEBPACK_IMPORTED_MODULE_1__.History({
				historyType : LR.__lp.config.historyType ? html5Str : "hash",
				popState : popState
			}) 
			this.history = lHistory.__lh.exp;
			this.pushData = function(data,title,url) {
				lHistory.pushState(data,title,url,lHistory.getMeta());
			}
			this.replaceData = function(data,title,url) {
				lHistory.replaceState(data,title,url,lHistory.getMeta());
			}
			this.navigateBack = function(value) {
				if(!value) {
					lHistory.back.call(history);
				} else {
					lHistory.go.call(history,value);
				}
			}
			this.navigateForward = function(value) {
				if(!value) {
					lHistory.forward.call(history);
				} else {
					lHistory.go.call(history,value);
				}

			}
			this.scrollRestoration = lHistory.scrollRestoration;
			function popState(onChangeEvent) {
				var goValue,
				meta,
				url = getUrlFromMeta(onChangeEvent);
				historyObj = {
					fromHistory : true,
					url : url
				};
				if(onChangeEvent && lHistory.getData()) {
					historyObj.data = lHistory.getData();
				}
				if(config.preserveUrlOnBrowserNavigation) {
					if(fromHistoryGo) {
						fromHistoryGo = false;
						return;
					}
					if(lHistory && prevTrans && (meta = lHistory.getMeta()) && (lHistory.__lh.currentMeta.__lh.index !=  meta.__lh.index)) {
						fromHistoryGo = true
						goValue = lHistory.__lh.currentMeta.__lh.index - meta.__lh.index;
						history.go(goValue);
					}
					// if(lHistory && prevTrans && (meta = lHistory.getMeta()) && (prevTrans.history.index !=  meta.__lh.index)) {
					// 	fromHistoryGo = true
					// 	// goValue = prevTrans.history._meta.__lh.index - meta.__lh.index;
					// 	goValue = trans.history.__lh.prevMeta.__lh.index - meta.__lh.index;
					// 	history.go(goValue);
					// }
				}
				historyObj.goValue = goValue;
				if(trans && !trans.aborted) {
					trans.abort({state : 308, iAbort : true});
			   	}
				dispatch(url);
			}
			if(lyte.$.isApp) {
				if(config.historyType) {
					popState();
				} else {
					historyObj = {
						fromHistory : true,
						url : getLocation()
					};
					dispatch(historyObj.url);
				}
				(0,_go_to__WEBPACK_IMPORTED_MODULE_0__.linkToRegistration)(lyte,this,config);
			}
			return this;
		};

        function getUrlFromMeta(onChangeEvent) {
			var url;
			if(!(lHistory.getMeta() && (url = lHistory.getMeta().url))) {
				if(config.historyType) {
					url = getLocation();
				} else {
					var newURL = onChangeEvent && onChangeEvent.newURL || dloc.hash;
					url = checkForEmptyPath(newURL.replace(/.*#/, ''));
				}  
			}
			return url;
		}

        function setRouteDef(dir, {RouteClass, options}) {
			var cache = config.routes,
			len = dir.length,
			dirLen = len - 1;
			for(var i = 0, key; i < len; i++) {
				key = dir[i];
				if (dirLen === i) {
					var obj = cache[key];
					if (obj && obj.__lp) {
						obj.__lp.handler = RouteClass;
						obj.__lp.options = options
					} else if (obj) {
						obj.__lp = { class : RouteClass, options };
					} else {
						cache[key] = { __lp: { class : RouteClass,  options } };
					}
				} else if (!cache[key]) {
					cache[key] = {};
				}
				cache = cache[key];
			}
		}

        function convertMatchedObjToRouteInfo(matched) {
			var info = {
				route : matched.route.join("."),
				fragment : matched.fragment,
				dynamicParams : matched.dynamicParams.filter(_arrayClean),
				queryParams : matched.queryParams

			};
			return info;
		}

        function _arrayClean(e) {
			return e != undefined;
		}

        this.replaceWith = function() {
			return routeTransition.call(this,_router_utils__WEBPACK_IMPORTED_MODULE_4__._normalizeTransitionParams.apply(this,arguments), true);   
		};

        this.navigateTo = function() {
			return routeTransition.call(this,_router_utils__WEBPACK_IMPORTED_MODULE_4__._normalizeTransitionParams.apply(this,arguments));  
		};

        /**
		 * @functionType getURL 
		 *  To get url for a route
		 * @author authorName
		 * @version 1.0.0
		 * @params {string} routeName
		 * @params {options} options
		 * @params {function} nestedRoute 
		 * @returns
		 */
        this.getURL = function(matched) {
			if(matched) {
				if(!matched.route) {
					matched = _router_utils__WEBPACK_IMPORTED_MODULE_4__._normalizeTransitionParams.apply(this,arguments)
				} else if(!matched.queryParams) {
					matched.queryParams = {}
				}
				var url,
				l,
				linkTo = this.tagName == LINKTOStr,
				cache = config.urlCache,
				matchedCache,
				sticky = config.queryParamOptions.cache;
				if(!sticky && (matchedCache = cache[Array.isArray(matched.route) ? matched.route.join('.') : matched.route])) {
					url = matchedCache.url;
					if(l = matched.dynamicParams && matched.dynamicParams.length) {
						for(var i = 0; i < l; i++) {
							url = url.replace('<<dp>>',matched.dynamicParams[i]);	
						}
					} else if(url.indexOf('<<dp>>') != -1) {
						_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error(lyte,linkTo ? "499A" : 499,matched.route,linkTo ? this : undefined);
					}
					if(!matched.queryParams) {matched.queryParams = {}}
					for(var key in matchedCache.defQP) {
						if(!matched.queryParams[key] && matchedCache.defQP[key]) {
							matched.queryParams[key] = matchedCache.defQP[key];
						}
					}
					url = appendQueryParamsAndFrag(url,matched);
				} else {
					if(linkTo) {
						url = constructURLFromRoute.apply(this,arguments);
					} else {
						url = constructURLFromRoute.call(this,matched);
					}
				}
				if(url) {
					url = config.historyType ? shiftBaseURL(url, true) : '#'+url;
					return url;
				}
			}
		};

        this.getRoute = function(url) {
			var matched = traverse(shiftBaseURL(url),true);
			if(matched && !matched.error) {
				if(config.routeAliasMap[matched.route]) {
					matched.alias = config.routeAliasMap[matched.route];
				}
				matched.dynamicParams = matched.dynamicParams.filter(_arrayClean);
				matched.route = matched.route.join('.');
				return matched;  
			}
		};

        function routeTransition(args, replace ) {
			var processed = normalizeMatchedObj.call(this,args);
			if(processed.error) {
				if(trans.running) {
					trans.pause();
					run[onErrorStr].call(trans,trans.prom.hook,trans.prom.index,processed.error,"420A",{ consoled : true});
				}
				return;
			}
			if(replace) {
				processed.matched.replace = true;
			}
			if(!LR.__lp.initCalled) {
				_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error(lyte,405);
				return 
			}
			var matched = processed.matched,
			currRoute;
			processed.currRoute = currRoute = matched.route.join('.');
			matched.refreshRoute && currRoute == prevTrans.info.route;
			routeOptions.newTransInfo = newTransInfo = {
				replace : matched.replace || (matched.refreshRoute && LR.checkIfSameRoute(convertMatchedObjToRouteInfo(processed.matched),convertMatchedObjToRouteInfo(prevTrans.matched)) ? true :  matched.replace),
				title : trans ? trans.title : document.title,
				fromHistory : false
			};
			var url = dispatchTransition(processed);
			if(url && newTrans) {
				newTrans.navigationType = replace ? replaceStateStr : pushStateStr;
				lyte.log(`${NavigateStr} to ${currRoute} ${url}`,routeStr);
				return newTrans._trans;  
			} else {
				lyte.log(`${NavigateStr} failed`);
				return {};
			}
		}

        function getLocation(obj) {
			if(config.historyType) {
				var path = checkForEmptyPath(dloc.pathname + dloc.search + (dloc.hash || ""));
				path = shiftBaseURL(path);
				return (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._delimit)(path);  
			} else if(obj && obj.withHash)	{
				return (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._delimit)(checkForEmptyPath(dloc.hash));
			} else {
				return (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._delimit)(checkForEmptyPath(dloc.hash.replace('#','')));
			}
		}

        function checkForEmptyPath(path) {
			if(!path) {
				path = '/'
			}
			return path;
		}

        function shiftBaseURL(path,append) {
			var baseURL;
			if((baseURL = config.baseURL) && path) {
			baseURL = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._delimit)(baseURL);
			if(path.indexOf(baseURL) == 0 && !append) {
				return path.replace(baseURL,'');
			} else if(append && path.indexOf(baseURL) != 0) {
				return baseURL+path;
			} 
			} 
			return path;
		}

        function constructURLFromRoute(matched) {
			if(matched && matched.route) {
				var strRoute;
				if(!Array.isArray(matched.route)) {
					matched.route = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._dotSerperator)(strRoute = matched.route);
				} else {
					strRoute = matched.route.join('.')
				}
				matched.queryParams = matched.queryParams || {};
				matched.dynamicParams = matched.dynamicParams || [];
				matched.refreshData = false;
				var url,
				sameRoute = !!trans,
				dynamicPos = matched.dynamicParams.length != matched.route.length,
				dynamicParamPos = 0,
				linkTo = this && this.tagName == LINKTOStr,
				routeObj = config.routes,
				templateUrl = url = '',
				defQPTemp = {},
				route;
				for(var i = 0, l = matched.route.length; i < l; i++) {
					route = matched.route[i];
					if(sameRoute && trans.matched.route[i] != route) {
						sameRoute = false;
					}
					routeObj = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._getObj)(route,routeObj);
					if(!(routeObj && routeObj.__lp && routeObj.__lp.path)) {
						_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error(lyte,422,matched.route,i);
						return false;
					}
					var def = routeObj.__lp.handler && routeObj.__lp.handler.name != __routeProm__Str ? routeObj.__lp.handler : undefined,
					rOpts = routeObj.__lp.options;
					// if(!def && !linkTo) {
					// 	_consoleError.call(lyte,422,matched.route,i);
					// }
					var path = routeObj.__lp.path,
					defaultQP;
					if(!def) {
						if(defaultQP = routeObj.__lp.defQP) {
						for(var key in defaultQP) {
							if(matched.queryParams && !matched.queryParams.hasOwnProperty(key)) {
								defQPTemp[key] = matched.queryParams[key] = defaultQP[key];
							} else {
								defQPTemp[key] = defaultQP[key];
							} 
						}
						}
					} else if(def.queryParams) {
						defaultQP = routeObj.__lp.defQP;
						var qpdef = rOpts.qpdef;
						for(var key in qpdef) {
							if(!matched.queryParams.hasOwnProperty(key)) {
								if(sameRoute && qpdef[key].cache) {
									matched.queryParams[key] = trans.rOpts[i].param.queryParams[key];
								} else if(defaultQP && defaultQP.hasOwnProperty(key)) {
									defQPTemp[key] = matched.queryParams[key] = defaultQP[key];
								}
							}
							if(!linkTo && !matched.refreshData && qpdef[key].refreshData) {
								matched.refreshData = true;
							}
						}
					}
					if(routeObj.__lp.dkey) {
						var dynamicPathSplit = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._splitPath)(path),
						dynamicPathSplitTemp = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._splitPath)(path),
						pos = dynamicPos ? dynamicParamPos : i;
						if(!matched.dynamicParams || !matched.dynamicParams[pos]) {
							_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error(lyte,linkTo ? "499A" : 499,route,linkTo ? this : undefined);
						return false;   
						} else {
							dynamicPathSplit[routeObj.__lp.dIndex] = encodeURI(matched.dynamicParams[pos]);
							dynamicPathSplitTemp[routeObj.__lp.dIndex] = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._delimit)('<<dp>>');
							templateUrl += (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._delimit)(dynamicPathSplitTemp.join('/')); 
							url += (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._delimit)(dynamicPathSplit.join('/')); 
							dynamicParamPos++;
						} 
					} else {
						templateUrl += (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._delimit)(path);
						url += (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._delimit)(path);
					}
				}
				if(!config.cacheRoutes[strRoute]) {
					config.urlCache[strRoute] = {url : (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._validateURL)(templateUrl), defQP : defQPTemp};
				}
				return appendQueryParamsAndFrag(url,matched);
			}
		}

        function appendQueryParamsAndFrag(url,matched) {
			url = url[url.length-1] == '/' && url.length != 1 ? url.slice(0,-1) : url;
			if(matched.queryParams) {
				var ques = true;
				for(var key in matched.queryParams) {
					if(matched.queryParams[key] != undefined) {
						if(ques) {
							url += '?';
							ques = false
						} else {
							url += '&';
						}
						url+= key+'='+encodeURIComponent(matched.queryParams[key]);  
					}
				}
			}
			if(config.historyType && matched.fragment) {
			url = url+"#"+matched.fragment;
			}
			return (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._validateURL)(url);
		}

        var invokeRunLoop;
        function dispatch(path,processed) {
			let history;
			lyte.time(RouteNavigationStr);
			if(path && config.baseURL && document.location.pathname.indexOf(config.baseURL) == -1) {
				_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error(lyte,"400A");
				return;
			}
			processed = processed || (!initialLoad && (history = lHistory.getMeta()) && history.matched && history.__lh.url == getLocation({withHash : true}) /* && history.__lh.url.indexOf(path) != -1 */ ? normalizeMatchedObj(history.matched) : traverse(path));
			if(!processed || processed.error) {return};
			clearTimeout(invokeRunLoop);
			processed.prevTrans = processed.prevTrans || LR.__lp.prevTrans;
			processed.path = processed.path || path;
			processed.transComp = processed.transComp || getTransitionDiffernce(processed.prevTrans, processed.matched,processed.R);
			invoke(processed);
			lyte.triggerEvent("navigationStart", {prevTrans : prevTrans && prevTrans._trans, nextTrans : newTrans._trans});
			invokeRunLoop = setTimeout(function() {
				if(processed.matched.route.length) {
					downloadLazyRoutes(processed)
					newTrans._data = newTrans._trans.data ? (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(newTrans._trans.data) : {};
					if(trans && trans.state == 102 && newTrans && LR.checkIfSameRoute(newTrans.info,trans.info) && !trans.aborted && JSON.stringify(trans._data) == JSON.stringify(newTrans._data)) {
						if(trans.iPause == true) {
							trans.resume();    
						}
						return;
					} else if(trans && trans.state == 102) {
						trans.abort({state : 409}); 
					}
					newTrans.transComp = processed.transComp;
					// if(trans) {
					// 	newTrans.pRoutes = trans.routes;
					// }
					routeOptions.trans = trans = newTrans;
					newTrans.runLoop = constructPrevRunLoop(processedDispatch = processed);
					newTransInfo = routeOptions.newTransInfo;
					trans.run();
					// trans.transComp = processed.transComp = processed.transComp || getTransitionDiffernce(processed.prevTrans, processed.matched,processed.R);
					// routeOptions.trans = trans = newTrans;
					// newTransInfo = routeOptions.newTransInfo;
					// if(trans._trans.data) {
					// 	newTransInfo.data = trans._trans.data;
					// }
					// newTransInfo.meta = trans.meta = {matched : trans.matched}
					// newTransInfo.state = trans.stateObj = getHistoryState({
					// 	replace : newTransInfo.replace,
					// 	data : newTransInfo.data,
					// 	url : trans.url,
					// 	matched : trans.matched,
					// 	fromHistory : newTransInfo.fromHistory
					// });
					// getHistoryObj(newTransInfo);
					
				} 
			},0);
			return newTrans;
		}

        function downloadLazyRoutes(processed) {
			var R = processed.R,
			promArr = [];
			R.forEach(function(fn,i) {
				if(fn.name == __routeProm__Str) {
					var dirArr = processed.matched._routes[i],
					routeDetail = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._getObj)(dirArr, config.routes);
					promArr.push(fn.call(routeDetail.__lp).then(function(data) {
						initialRegisterRoute(dirArr, data[routeDetail.__lp.cName]);
						processed.R[i] = routeDetail.__lp.handler;
					}));
				}
			})
			return Promise.all(promArr);
		}

        function getTransitionDiffernce(prevTrans, matched, R) {
			var like = true,
			similar = true,
			rendered = [],
			common = [],
			unRendered = [],
			templateToRemove,
			currRoute = matched.route.join('.'),
			r,
			tar = "";   
	
			if(prevTrans) {
				var prevMatched = prevTrans.matched,
				route,
				startFrom = matched.refreshRoute && currRoute == prevTrans.info.route ?  matched.refreshRoute : matched.startFrom;
				for(var i = 0, l = matched.route.length; i < l; i++) {
					route = matched.route[i];
					tar = tar + (tar ? "." : "") + route;
					if(similar && route == prevMatched.route[i] && (!startFrom || tar != startFrom)) {
						r = R ? R[i] : LR.getDefinition(route.slice(0,i));
						if(r.name != __routeProm__Str && like && compareRoute(matched._routes[i],i,prevMatched,matched)) {
							common.push(route);
							if(prevTrans.rOpts[i].rendered) {
								rendered.push(route);  
							} else {
								// like = false; dont change this code. It is commented for decideTransition function
								unRendered.push(route);  
							}
						} else {
							like = false;
							unRendered.push(route);
						}
					} else {
						similar = false;
						if(templateToRemove == undefined && prevTrans.routes[i] && prevTrans.rOpts[i].rendered != -1 && prevTrans.routes[i].outlet) {
							templateToRemove = i;
						}
						unRendered.push(route);
					}
				}
				if(prevMatched.route.length > matched.route.length) {
					var index = matched.route.length;
					if(templateToRemove == undefined && prevTrans.rOpts[i].rendered/* && prevTrans.routes[i].outlet */) {
					templateToRemove = index;
					}
				}
			} else {
				unRendered = unRendered.concat(matched.route);
			}
			return { rendered, unRendered, common, templateToRemove };
		}

        function compareRoute(rArr,index,prevMatched,matched) {
			var same = true,
			routeObj = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._getObj)(rArr,config.routes),
			ropt = routeObj.__lp.options;
			if(!ropt.queryParams && !routeObj.__lp.dkey) {
				return true;
			}
			if(routeObj.__lp.dkey && prevMatched.dynamicParams[index] != matched.dynamicParams[index]) {
				return false;
			} else if(ropt.queryParams && matched.refreshData) {
				ropt.queryParams.every(function(key) {
					if(same && ropt.qpdef[key].refreshData && (matched.queryParams || prevMatched.queryParams) && matched.queryParams[key] != prevMatched.queryParams[key]) {
					return same = false;
					} else {
					return true;
					} 
				});
			}
			return same;
		}

        const basicHooks = [fetchStr,divertStr,renderStr,afterRenderStr];

        function constructPrevRunLoop() {
			lyte.time(constructRunLoopStr);
			var b4Exit = [],
			willNavigate = [],
			b4RouteTrans = [{hook : beforeRouteNavigationStr}];
			if(prevTrans) {
				for(var i = prevTrans.matched.route.length-1,r;r = prevTrans.matched.route[i]; i--) {
					var r1 = trans.matched._routes[i];
					if(!r1 || (r1.join('.') != prevTrans.matched._routes[i].join('.'))) {
						b4Exit.push({hook : beforeExitStr, index : i});
					}
					willNavigate.push({hook : willNavigateStr, index : i});
				}
				lyte.time(constructRunLoopStr);
				return {previous : willNavigate.concat(b4RouteTrans).concat(b4Exit) ,current : b4Exit};
			}
			return {};
			// return { previous : b4RouteTrans };
		}

        function pushFetchHooks(loop, index) {
			loop.push(
				{hook : beforeFetchStr, index : index},
				{hook : fetchStr, index : index},
				{hook : afterFetchStr, index : index})
		}

        function convertToFF({ trans, index }) {
			var r = trans.routes[index];
			if(typeof r.__lp.fns.forceFetch && callHookWithoutPromise.call(trans,r.__lp.fns.forceFetch,forceFetchStr,index,[])) {
				trans.runLoop.forceFetch[index] = []
				pushFetchHooks((trans.runLoop.forceFetch[index] = []),index)
				trans.runLoop.current.every(function(obj,i) {
					if(obj.hook == beforeFetchStr && obj.index == index) {
						trans.runLoop.current.splice(i, 3);
						return false;
					}
					return true;
				})
				r.__lp.fetchStatus = pendingStr;
			}
		}

        function constructRunLoop(processed) {
			lyte.time(constructRunLoopStr);
			var transComp = processed.transComp,
			runLoop = trans.runLoop = {
				previous : [],
				current : [],
				forceFetch : {}
			},
			current = runLoop.current,
			// forceFetch = {},
			loadingTemplate = [],
			req = [],
			didTransit = [];
			
			if(transComp.rendered && transComp.rendered.length) {
				transComp.rendered.forEach(function(hook,index) {
					trans.rOpts[index].rendered = true;
					current.push({hook : divertStr,index : index});
					didTransit.push({hook : didNavigateStr,index : trans.matched.route.length-index-1});
				});
			}
			if(transComp.unRendered && transComp.unRendered.length) {
				transComp.unRendered.forEach(function(hook,orgIndex) {
					var index = transComp.rendered.length+orgIndex,
					r = trans.routes[index];
					if(!transComp.redirected || (transComp.redirected && transComp.redirected.index != index)) {
						loadingTemplate.push({hook : renderLoadingTemplateStr, index})
						req.push({hook : getRequirementsStr,index});
					}
					basicHooks.forEach(function(h,i) {
						if(i == 0) {
							if(!transComp.redirected || (transComp.redirected && transComp.redirected.index != index)) {
								pushFetchHooks(current,index)
								// if(!transComp.unRendered[orgIndex+1] && trans.matched.mountRoute) {
								// 	current.push({hook : "getMountApp", index});
								// }		
								if(r instanceof Promise) {
									r.then(function() {
										convertToFF({trans, index})
									})
								} else {
									convertToFF({trans, index})
								}
							}
						}  else {
							current.push({hook : h, index}); 
							if(h == renderStr && transComp.unRendered[orgIndex+1]) {
								current.push({hook : renderLoadingTemplateStr,index : index+1});
							}    
						}
					});  
					didTransit.push({hook : didNavigateStr,index : trans.matched.route.length-index-1});
				});		
			}
			trans.runLoop.current = [{hook : onBeforeLoadStr}].concat(loadingTemplate).concat(req).concat(current).concat(didTransit)
			if(!prevTrans) {
				trans.runLoop.current.unshift({hook : beforeRouteNavigationStr})
			}
			runLoop.templateToRemove = (prevTrans && prevTrans.runLoop.templateToRemove) ? prevTrans.runLoop.templateToRemove : [];
			if(transComp.templateToRemove != undefined) {
				runLoop.templateToRemove.push({index : transComp.templateToRemove, routes : visibleTrans.routes});
			}
			lyte.time(constructRunLoopStr);
		}

        function invoke(processed) {
			routeOptions.newTrans = LR.__lp.newTrans = newTrans = new Navigation(processed);
			newTrans.url = processed.path;
			newTrans.runLoop = {};
			newTrans._trans = limitTransition(newTrans);
			lyte.extendEventListeners(newTrans._trans);
			if(historyObj) {
				routeOptions.newTransInfo = newTransInfo = historyObj;
				newTransInfo.url = processed.path;
				newTrans._trans.data = historyObj.data || lHistory.getData() || {};
				newTransInfo.replace = true;
				historyObj = undefined;
			} else if(newTrans._trans.data) {
				LR.history.replaceState(newTrans._trans.data);
			}
		}

        function abortRunningPromises(trans) {
			if(trans.runningProm) {
				trans.runningProm.reject(abortedStr);  
			}
			if(trans.fRunningProm) {
				trans.fRunningProm.reject(abortedStr);   
			}
		}

        var navId = 0;
        function Navigation(processed) {
			this.navId = navId = navId+1;
			this.matched = processed.matched;
			this.target = processed.matched.target;
			this.logs = [];
			this.onLoadCalled = [];
			this.fns = [];

			this.getDynamicParams = function() {
				var dpObj = {};
				if(this.matched.dynamicParams) {
					this.matched.dynamicParams.forEach(function(dp,i) {
						if(dp) {
							var routesObj = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._getObj)(this.matched._routes[i], config.routes)
							dpObj[routesObj.__lp.dkey] = dp;
						}
					}.bind(this))
				}
				return dpObj;
			};
			this.pending = {
				dependencies : new Set(),
				resources : new Set(),
				forceFetch : new Set()
			};
			this.info = {
				route : processed.matched.target,
				queryParams : processed.matched.queryParams,
				dynamicParams : processed.matched.dynamicParams.filter(_arrayClean),
				alias : processed.matched.alias
			};
			if(processed.matched.fragment) {
				this.info.fragment = processed.matched.fragment;
			}
			this.R = processed.R;
			this.rOpts = processed.rOpts;
			this.running = this.aborted = this.paused = false;
			this.abort = function(obj) {
				if(newTransInfo && newTransInfo.goValue) {
					fromHistoryGo = false;
				}
				this.abort = emptyFn;
				abortRunningPromises(this);
				this.aborted = true;
				if(!obj) {
					obj = {state : 308};
				} 
				if(this.running) {
					lyte.log(NavigationAbortedStr,routeStr);
				}
				if(!obj.iAbort) {
					delete this.runLoop.templateToRemove;
				}
				transitionCompleted(obj);
			}.bind(this);
			this.pause = function (obj) {
			lyte.log(NavigationPausedStr, routeStr);
			if (obj && obj.iPause) {
				this.iPause = true;
			} else {
				this.iPause = false;
				this.state = this._trans.state = 307;
				this._trans.triggerEvent(stateChangeStr,this.state);
			}
			this.paused = trans.prom || true;
			this.resume = this._trans.resume = function (t) {
				t = t || this;
				if (t.prom != t.eProm) {
					if (!t.pendingResume) {
						t.pendingResume = t.resume;
						delete t._trans.resume;
						delete t.resume;
					}
					return;
				}
				delete t._trans.resume;
				delete t.resume;
				lyte.log(NavigationResumedStr, routeStr);
				if (t.paused) {
					var state,
					prom = t.prom;
					if(t.paused != true) {
						state = t.paused.state;
					}
					if (t.runLoop[state]) {
						if(state == forceFetchStr) {
							var newProm = t.runLoop.forceFetch[prom.index];
							if(newProm[0] && prom.hook == newProm[0].hook) {
								newProm.splice(0, 1);
							}
						} else if(t.runLoop[state][0] && t.runLoop[state][0].hook == t.paused.hook && t.runLoop[state][0].index == t.paused.index) {
							removeHook(t.runLoop[state], t.paused.hook, t.paused.index);
						}
					}
					t.iPause = t.paused = false;
					t.state = t._trans.state = 102;
					this._trans.triggerEvent(stateChangeStr,t.state);
					if(this.forceFetchRunning) {
						if(t.runLoop.forceFetch[prom.index][0]) {
							t.run(t.runLoop.forceFetch[prom.index][0]);
						} else {
							t.routes[prom.index].__lp.fetchStatus = completedStr;
							if (t.pending.waitingForFF != undefined && t.pending.waitingForFF == prom.index) {
								delete t.pending.waitingForFF;
								t.run();
							}
						}
					} else {
						if(state && state == forceFetchStr && !t.runLoop.forceFetch[prom.index][0]) {
							t.routes[prom.index].__lp.fetchStatus = completedStr;
						} 
						t.run();  
					}
				}
			}.bind(this);
			return this._trans;
			}.bind(this);
		}

        function templateDelete(arr) {
		/* clears outlet, from parent to child */
			for(var i = 0,l = arr.length,obj; i < l; i++) {
				obj = arr[i];
				for (var inst, j = obj.routes.length - 1; j >= obj.index; j--) {
					inst = obj.routes[j];
					if (inst.outlet) {
						triggerTemplateDestroy({outlet : inst.outletName, route : inst},true)
						inst.outlet.innerHTML = "";
						if(!trans.routes[j] || trans.routes[j].__lp.objPath != inst.__lp.objPath) {
							callDidDestroy.call(this,inst,j,obj);
						}
					}
				}
			}
		}

        function triggerTemplateDestroy(obj) {
			LR.triggerEvent(beforeTemplateDestroyStr,obj);
			lyte.triggerEvent(beforeTemplateDestroyStr,obj);
		}

        function callDidDestroy(inst,index) {
			lyte.log(didDestroyStr+" of "+ inst.routeName,routeStr,fontColor);
			lyte.time(didDestroyStr+index);
			callHookWithoutPromise.call(this,inst.didDestroy,didDestroyStr,index,[inst.currentData, inst.__lp.param]);
			lyte.time(didDestroyStr+index);
		}

        var stoppableHooks = [getRequirementsStr,beforeFetchStr,fetchStr,afterFetchStr];
        // error in these hooks should pause transition and call onerror action
        function errorStoppableHook(hook) {
			return (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._strPresence)(stoppableHooks,hook);
		}

        function callHookWithPromise(callback,instance, args) {
			/* executes route hooks which will returns promise */
			if(callback) { 
				var resp,
				t = trans,
				prom = trans.prom,
				hook = prom.hook,
				index = prom.index,
				stopNav = errorStoppableHook(hook),
				self = this;
				return new Promise(function(resolve,reject) {
					try {
						t.logs.push(hook +' of route '+instance.routeName+ ' called');
						var result = callback.apply(instance,args);
						if(stopNav && result) { /* check why stopTrans is needed? */
							result = (0,_slyte_core__WEBPACK_IMPORTED_MODULE_7__.resolvePromises)(result);
						}
						resp = Promise.resolve(result);
					} catch(err) {
						processError.call(self,{hook : hook, index : index, stopNav , err : err,instance : instance, promise : {resolve : resolve, reject : reject}});
						return;
					}
					resp.then(function(data) {
						if(prom.state != "previous" && trans._trans != (LR.__lp.nav.get(instance) && instance.navigation)) {
							t.logs.push("old navigation's promise rejected");
							reject()
						} else {
							resolve(data);
							callback.then && callback.then.success.apply(this,arguments);
						}
					},function(err) {
						t.prom = prom;
						reject(err)
						callback.then && callback.then.failure.apply(this,arguments)
						processError.call(self,{hook, index,stopNav,err,instance, PR : true});
					});  
				});
			} else {
				return resolvedPromise;
			}
		}

        function callHookWithoutPromise(callback,hook,index,args,splInstance) {
			/* executes route hooks which wont return promise  */
			if(callback) {
				var instance = this.routes[index];
				try {
					trans.logs.push(hook +' of route '+instance.routeName+ ' called');
					return callback.apply(splInstance || instance,args);
				} catch(err) {
					processError.call(this,{hook, index, stopNav : errorStoppableHook(hook),err,instance});
					return;
				}  
			}
		}

        function callAction(hook,index,args) {
			/* executes route's actions  */
			var action,
			routeInstance = this.routes[index] && this.routes[index];
			if(action = getAction(routeInstance, hook)) {
				try {
					trans.logs.push(`${hook} of ${routeStr} ${routeInstance.routeName} called.`);
					if(action.apply(routeInstance,args) == false) {
						return false;
					}
				} catch(e) {
					_consoleErrorFromCallback(e,hook,routeInstance.routeName);
					return false;
				} 
			}
		}

        function _consoleErrorFromCallback(err,hook,routeName,state,options) {
			if(typeof err == stringStr || (typeof err == "object" && err.stack && !err.$)) {
				if(!err.stack) {
					err = Error(err);
				}
				err.$ = true;
				var internalErr = _router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.getErrorMessage(state) || _router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.getErrorMessage("420A",hook,routeName);
				err.stack = err.stack.replace(err.message,err.message = err.message+"\n\t"+internalErr);
				_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error(lyte,err);
			} else {
				_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error(lyte,state,hook,routeName,err,options && options.PR);
			}
		}

        function processError(options) {
			/* handles error in hooks */
			var instance = options.instance,
			stopNav = options.stopNav,
			err = options.err,
			hook = options.hook,
			index = options.index;
			if(stopNav) {
				trans.pause();
				run[onErrorStr].call(this,hook,index,err,"420",options);
			} else {
				_consoleErrorFromCallback(err,hook,instance.routeName);
				// if(_strPresence([willNavigateStr,didNavigateStr,beforeExitStr,redirectStr],hook)) {
					if(options.promise) {
						options.promise.resolve();
					}
				// } else {
					// trans.abort({state : 4, iAbort : true});
				// }
			}  
		}

        function runLoopPromise(fn,fnName,loop,success,failure) {
			success = success || emptyFn;
			failure = failure || function(error) {
				if(error != abortedStr) {
					_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error(lyte,error);
				}
			};
			new Promise(function(resolve,reject) {
				if(fnName == nestedForcedPromisesStr ) {
					this.fRunningProm = {resolve : resolve, reject : reject};
					fn.call(this,this.runLoop.forceFetch,resolve);
				} else {
					this.runningProm = {resolve : resolve, reject : reject};
					fn.call(this,this.runLoop,loop,resolve);  
				}
			}.bind(this)).then(success,failure);
		}

        Navigation.prototype.run = function (pausedForcedProm) {
			if(pausedForcedProm) {
				nestedForcedPromises.call(this, this.runLoop.forceFetch , this.fRunningProm.resolve ,pausedForcedProm);
				return;
			}
			processRunLoop.call(this);
		};

        function processRunLoop() {
			runLoopPromise.call(trans,nestedPromises,nestedPromisesStr,'previous',function() {
			if(processedDispatch && !trans.running && !trans.aborted ) {
				initRoute(trans, processedDispatch);
				if(processedDispatch.hasOwnProperty("refreshFrom")) {
					for(var i = processedDispatch.refreshFrom,r; r = newTrans.routes[i]; i++) {
						delete r.component;
					}
				}
				document.title = this.title = this.routes[this.routes.length-1].title || document.title;
				if(trans._trans.data) {
					newTransInfo.data = trans._trans.data;
				}
				newTransInfo.meta = trans.meta = {matched : trans.matched}
				trans.state = trans._trans.state = 102;
				trans._trans.triggerEvent(stateChangeStr,trans.state);
				if(newTransInfo) {
					if(config.preserveUrlOnBrowserNavigation && newTransInfo.fromHistory) {
						// if(newTransInfo) {
							// if(config.preserveUrlOnBrowserNavigation) {
						if(/* newTransInfo.fromHistory && */ !!newTransInfo.goValue) {
							fromHistoryGo = true;
							history.go(-(newTransInfo.goValue));
						}
						newTransInfo.data = trans._trans.data || newTransInfo.data;
						// newTransInfo.state.data = trans._trans.data || newTransInfo.state.data;
						newTransInfoClone = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(newTransInfo);
						trans.stateObj = newTransInfo.state;
						newTransInfoTimer = setInterval(function() {
							if(!newTransInfoClone) {
								clearInterval(newTransInfoTimer);
								return;
							}
							if(!fromHistoryGo) {
								clearInterval(newTransInfoTimer);
								addToHistory(newTransInfoClone);
								newTransInfoClone = undefined;
								
							}
						},0)
					} else {
						newTransInfo.data = trans._trans.data || newTransInfo.data;
						// newTransInfo.state.data = trans._trans.data || newTransInfo.state.data;
						addToHistory(newTransInfo);
						trans.stateObj = newTransInfo.state;
					}
				}

					// 	newTransInfo.data = trans._trans.data || newTransInfo.data;
					// 	// newTransInfo.state.data = trans._trans.data || newTransInfo.state.data;
					// 	newTransInfoClone = deepCopyObject(newTransInfo);
					// 	trans.stateObj = newTransInfo.state;
					// 	newTransInfoTimer = setInterval(function() {
					// 		if(!newTransInfoClone) {
					// 			clearInterval(newTransInfoTimer);
					// 			return;
					// 		}
					// 		if(!fromHistoryGo) {
					// 			clearInterval(newTransInfoTimer);
					// 			addToHistory(newTransInfoClone);
					// 			newTransInfoClone = undefined;
								
					// 		}
					// 	},0)
					// } else {
					// 	newTransInfo.data = trans._trans.data || newTransInfo.data;
					// 	// newTransInfo.state.data = trans._trans.data || newTransInfo.state.data;
					// 	addToHistory(newTransInfo);
					// 	trans.stateObj = newTransInfo.state;
					// }
				// }
				LR.__lp.trans = trans;            
				processedDispatch.previous = false;
				constructRunLoop(processedDispatch);
				setParamsInInst(processedDispatch);
				routeOptions.newTransInfo = processedDispatch = newTransInfo = undefined;
				trans.running = true;
			}
			runLoopPromise.call(trans,nestedPromises,nestedPromisesStr,'current');
			}.bind(this));
		}

        function setPendingResume(promise) {
			trans.eProm = promise;
			if (this.pendingResume) {
			var resume = this.pendingResume;
			delete this.pendingResume;
			resume();
			}
		}

        function nestedForcedPromises(forcedLoop, resolve, promise) {
			if (validateTransition(this) && forcedLoop) {
				if(!promise) {
					for(var key in forcedLoop) {
						var routeLoop = forcedLoop[key],
						p = routeLoop[0];
						if(p) {
							if(!p.running) {
								nestedForcedPromises.call(this, forcedLoop, resolve,p);    
							}
						}
					}
					return;
				}
				var routeInstance = this.routes[promise.index];
				promise.state = forceFetchStr;
				trans.prom = promise;
				if (promise.hook == beforeFetchStr && !routeInstance.__lp.dependenciesLoaded) {
					routeInstance.__lp.loadDependencies.then(function() {
						nestedForcedPromises.call(this, this.runLoop.forceFetch , this.fRunningProm.resolve ,this.runLoop.forceFetch[promise.index][0]);
					}.bind(this))
					return;
				}
				logCallbacks(promise);
				forcedLoop[promise.index][0].running = true;
				forcedLoop[promise.index].splice(0, 1);
				lyte.time(promise.hook+promise.index);
				run[promise.hook].call(this, promise.hook, promise.index).then(function (data) {
					lyte.time(promise.hook+promise.index);
					setPendingResume.call(trans, trans.prom);
					if(promise.hook == afterFetchStr) {
						routeInstance.__lp.fetchStatus = completedStr;
						if (this.pending.waitingForFF != undefined && this.pending.waitingForFF == promise.index) {
							delete this.pending.waitingForFF;
							nestedPromises.call(this,this.runLoop,"current",this.runningProm.resolve);
						}
					} else if(promise.hook == fetchStr) {
						if(forcedLoop[promise.index][0] && forcedLoop[promise.index][0].hook == afterFetchStr) {
							nestedForcedPromises.call(this, forcedLoop, resolve,forcedLoop[promise.index][0]);	
						}
					} else {
						if(forcedLoop[promise.index][0] && forcedLoop[promise.index][0].hook == fetchStr) {
							nestedForcedPromises.call(this, forcedLoop, resolve,forcedLoop[promise.index][0]);	
						}
					}
				}.bind(this),function() {debugger;});
			} else {
				this.forceFetchRunning = false;
			}
		}

        function logCallbacks(promise) {
			if(lyte.config.debug) {
				var hook = promise.hook,
				index = promise.index;
				if([beforeRouteNavigationStr, onBeforeLoadStr].indexOf(promise.hook) != -1) {
					lyte.log(hook,routeStr,fontColor);
					return;  
				}
				var route = promise.state == "previous" ? prevTrans.R[index] : trans.R[index];
				lyte.log(hook +' of route '+route.routeName,routeStr,fontColor);    
			}
		}

        function nestedPromiseCall(promise, routeInstance, loop, state, resolve) {
			if(promise.hook == beforeFetchStr && !routeInstance.__lp.dependenciesLoaded) {
				routeInstance.__lp.loadDependencies.then(function() {
					if(LR.__lp.nav.get(routeInstance)) {
						routeInstance.__lp.dependenciesLoaded = true
						nestedPromises.call(this,loop,state,resolve);
					}
				}.bind(this));
				return;
			} else if(promise.hook == renderStr && !routeInstance.__lp.resourcesLoaded) {
				routeInstance.__lp.loadResources.then(function() {
					if(LR.__lp.nav.get(routeInstance)) {
						routeInstance.__lp.resourcesLoaded = true
						nestedPromises.call(this,loop,state,resolve);
					}
				}.bind(this));
				return;
			} else if(promise.hook == divertStr && routeInstance.__lp.fns.forceFetch && routeInstance.__lp.fetchStatus == pendingStr) {
				if(!this.forceFetchRunning) {
					this.forceFetchRunning = true;
					runLoopPromise.call(this,nestedForcedPromises,nestedForcedPromisesStr);
				}
				this.pending.waitingForFF = promise.index;
				return;
			} else {
				promise.state = state;
				trans.prom = promise;
				logCallbacks(promise);
				lyte.time(promise.hook+promise.index);
				run[promise.hook].call(this,promise.hook,promise.index).then(function(data) {
					lyte.time(promise.hook+promise.index);
					setPendingResume.call(trans,trans.prom);
					if(this.runningProm.resolve == resolve) {
					removeHook(loop[state],promise.hook,promise.index);
					nestedPromises.call(this,loop,state,resolve);  
					}
				}.bind(this));
			}
		}

        function nestedPromises(loop,state,resolve) {
			if(validateTransition(this)) {
				var runLoop = loop[state];
				if(runLoop && runLoop.length) {
					var promise = runLoop[0],
					routeInstance = state == "previous"? prevTrans.routes[promise.index] : this.routes[promise.index];
					if(routeInstance instanceof Promise) {
						routeInstance.then(function() {
							if(this.onLoadCalled.length && runLoop[0].hook != onBeforeLoadStr) {
								runLoop.unshift({hook : onBeforeLoadStr});
							}
							nestedPromises.call(this, loop, state, resolve);
						}.bind(this))
						return;
					} else {
						nestedPromiseCall.call(this,promise, routeInstance, loop, state, resolve)
					}
				} else if(resolve) {
					resolve();
				}
			} else if(this.paused && this.runningProm) {
				this.runningProm.reject(abortedStr);  
			}
		}

        function removeHook(loop,hook,index) {
			for(var i = 0,obj;obj = loop[i]; i++) {
				if(obj.hook == hook) {
					if(index != undefined) {
						if(index == obj.index) {
							loop.splice(i,1);
							break;
						}
					} else {
						loop.splice(i,1);
						i--;
					}
				}
			}
		}

        function transitionCompleted(obj) {
			/* called after a atransition is completed or aborted*/
			trans.fns = [];
			if(trans.running) {
				if(trans == newTrans) {
					routeOptions.newTrans = LR.__lp.newTrans = newTrans = undefined;  
				}
				if(newTransInfoClone) {
					clearInterval(newTransInfoTimer);
					addToHistory(newTransInfoClone);
					newTransInfoClone = undefined;
				}
				LR.__lp.navigationCompleted && LR.__lp.navigationCompleted(trans)
				for(var i = 0,l = trans.fns.length; i < l; i++) {
					clearTimeout(trans.fns[i]);
				};
				
				trans.pendingResume = undefined;
				trans.running = false;
				trans.state = trans._trans.state = obj.state;
				trans._trans.triggerEvent(stateChangeStr,trans.state);
				if(initialLoad || trans.state == 200) {
					removeNavWeakMap(visibleTrans, trans)
					routeOptions.prevTrans = LR.__lp.prevTrans = prevTrans = trans;
					lyte.log(NavigationComletedStr,routeStr);
					lyte.time(RouteNavigationStr);
					if(config.historyType && trans.info.fragment) {
						var elem;
						if((elem = document.getElementById(trans._trans.info.fragment)) && elem.scrollIntoView && (LR.beforeScroll && LR.beforeScroll(trans._trans) != false)) {
							elem.scrollIntoView();
						}
					}
					run[afterRouteNavigationStr](trans._trans);
				} else if(obj.iAbort || visibleTrans == trans) {
					// removeNavWeakMap(prevTrans, trans)
					routeOptions.prevTrans = LR.__lp.prevTrans = prevTrans = trans;
					if (trans.state && trans.state != 201) {
					run[afterRouteNavigationStr](trans._trans);
					}
				} else {
					if (trans.state && trans.state != 201) {
						run[afterRouteNavigationStr](trans._trans);
					}
					// removeNavWeakMap(trans, newTrans || prevTrans)
					routeOptions.trans = LR.__lp.trans = trans = prevTrans;  
				}
				if(initialLoad) {
					initialLoad = false;
				}
			} else if(prevTrans){
				routeOptions.trans = LR.__lp.trans = trans = prevTrans;
			}
		}

        function removeNavWeakMap(visibleTrans,trans) {
			LR.__lp.nav = new WeakMap();
			[visibleTrans,trans].forEach(function(t) {
				if(t) {
					t.routes.forEach(function(ins) {
						LR.__lp.nav.set(ins,t)
					}) 
				}
			})
			// if(p && (visibleTrans && p != visibleTrans)) {
			// 	setTimeout(function() {
			// 		p.routes.forEach(function(route,i) {
			// 			if(/*!t.rOpts[i] || p.rOpts[i].objPath != t.rOpts[i].objPath || */p.routes[i] != t.routes[i]) {
			// 				LR.__lp.nav.delete(route);
			// 			}
			// 		})
			// 	},0)
			// }
		}

        function traverse(path, get) {
			if(path) {
				var routeObj = (0,_map_parser__WEBPACK_IMPORTED_MODULE_2__._traverseMap)(path, config)
				if(routeObj) {
					return pathProcessor.apply(this,[get].concat(routeObj));
				} else {
					_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error(lyte,"400A",config.baseURL && path.indexOf(config.baseURL) != 0 ? '' : path);
					return { error : true }
				}
			}
		}

        function pathProcessor(get,selectedPath,path,params,fragment) {
			var newURL,
			orgMatched,
			newMatched,
			matched = {
			route : (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._getObj)(selectedPath,config.routeHash).__lp.route,
			queryParams : params ? (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._frameQueryParams)(params) : {}
			};
			if(config.historyType) {
				matched.fragment = fragment;
			}
			matched.dynamicParams = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._frameDynamicParams)(path,matched,config.routes);
			if(get) {return matched;}
			matched.dpProcessed = true;
			var transInfo = normalizeMatchedObj(matched);
			if(transInfo != false) {
				orgMatched = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(transInfo.matched);
				newMatched = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(transInfo.matched);
				if(!transInfo.matched.hasOwnProperty('refreshData')) {
					if(!constructURLFromRoute(transInfo.matched)) {
						return;
					}
				}
				newURL = constructURLFromRoute(newMatched);
				if(!(0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._compareObj)(newMatched.queryParams,orgMatched.queryParams)) {
					addToHistory({replace : true,state : window.history.state,url : newURL,fromHistory : true});
					transInfo.path = newURL;
				}  
			}
			return transInfo;
		}

        function setParamsInInst(processed) {
			if(config.linkActiveClass) {
				config.activeLinkTags.forEach(function(tag) {
						tag.classList.remove(config.linkActiveClass);
				});
			}
			config.activeLinkTags = [];
			var R,
			r,
			matched = processed.matched;
			try {
				function linkTagPush(tag) {
					if(tag.getAttribute('lt-prop-route') == matched.target && activeLinkTags.indexOf(tag) == -1) {
						activeLinkTags.push(tag);
					}
				}
				function setParams(i){
					var rOpts = trans.rOpts[i];
					// r = trans.routes[i];
					if(rOpts.qpdef) {
						for(var key in rOpts.qpdef) {
							rOpts.param.queryParams[key] = matched.queryParams[key];
						};
					}
					rOpts.param.dynamicParam = matched.dynamicParams[i];
					if(i+1 == l) {
						rOpts.linkTags.forEach(linkTagPush);
					}
				}

				function callSetParams(i) {
					setParams(i)
				}
				
				for(var i = 0,l = trans.R.length; i < l; i++) {
					if(trans.routes[i] instanceof Promise) {
						trans.routes[i].then(callSetParams.bind(this,i))
					} else {
						setParams(i)
					}
					
				}
				LR.__lp.mutateCache(matched.target)
			} catch(e) {
				_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error(lyte,e);
			}
			return;
		}

        function initialRegisterRoute() {
			if(config.routes) {
				registerRoute.apply({},arguments);
			} else {
				this.__lp.pendingReg.push(arguments);
			}
		}

        function registerRoute(dir,RouteClass) {
			if(RouteClass.name != __routeProm__Str) {
				var options = {fns : {actions : {}}, $ : {}}
				if(!RouteClass.__lp || !RouteClass.__lp.fns) {
					RouteClass.__lp = { fns : options.fns };
					[renderLoadingTemplateStr,getRequirementsStr,forceFetchStr,beforeFetchStr,fetchStr,afterFetchStr,divertStr,renderStr,afterRenderStr,"actions",beforeExitStr/*,"getMountApp"*/].forEach(function(key) {
						var prop = RouteClass.prototype[key];
						options.fns[key] = prop
						delete RouteClass.prototype[key];
					});
					if(typeof RouteClass.actions == "function") {
						options.fns.actions = RouteClass.prototype.actions = RouteClass.actions();
					}
					// RouteClass.prototype.routeName = dir[dir.length-1];
				} else {
					options.fns = RouteClass.__lp.fns;
				}
				options.objPath = dir.join('.');
				options.cacheLinks = [];
				options.linkTags = [];
				options.param = {
					queryParams :{},
					dynamicParam : undefined
				};
				var cache = config.queryParamOptions.cache;
				if(options.queryParams = RouteClass.queryParams) {
					options.qpdef = {};
					options.$ = {};
					RouteClass.queryParams.forEach(function(qp,i) {
						if(typeof qp == stringStr) {
							options.qpdef[qp] = {
							cache : cache,
							refreshData : true
						};
						if(config.cacheRoutes[dir] == undefined && cache) {
							config.cacheRoutes[dir] = cache
						}
					} else if(typeof qp == "object") {
						for(var key in qp) {
							options.qpdef[key] = {
								cache : qp[key].hasOwnProperty('cache') ? qp[key].cache : cache,
								refreshData : qp[key].hasOwnProperty('refreshData') ? qp[key].refreshData : true
							};
							if(!config.cacheRoutes[dir] && options.qpdef[key].cache) {
								config.cacheRoutes[options.objPath] = true
							}
						}
						RouteClass.queryParams[i] = key;
						}
					});  
				}
				RouteClass.routeName = dir[dir.length -1];
				setRouteDef(dir,{RouteClass, options});
			}
		}

        const transPredefined = ['runLoop','running','paused','R','routes',abortedStr,'prom','run',pendingStr,'matched','fns','rOpts','logs','onLoadCalled','getDynamicParams'];

        function limitTransition(int) {
			var _trans = new navigation(int);
			int.state = _trans.state = 201;
			return _trans;
		}

        function dummy() {
			/*
			Dont delete this function.
			This one is to avoid function to be merged during minification.
			*/
			var _trans = new navigation(int);
		}

        function navigation(int) {
			for(var prop in int) {
				if(transPredefined.indexOf(prop) == -1) {
					if(prop == 'info') {
						this.info = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(int[prop]);
					} else {
						this[prop] = int[prop];
					}
				}
			}
		}

        this.getRouteInstance = function(routeName,t) {
			var newTrans;
			if(LR && LR.__lp.initCalled && (newTrans = (t || (LR.__lp && LR.__lp.trans) || trans)) && newTrans.routes) {
				var routeLen = newTrans.routes.length;
				if(!routeName) {
					return newTrans.routes[routeLen-1];
				} else if(routeName == "*") {
					return newTrans.routes;
				} else {
					var reqRouteLen = routeName.split('.').length-1,
					reqRoute = newTrans.routes[reqRouteLen];
					return reqRoute && reqRoute.__lp.objPath == routeName ? reqRoute : undefined;
				}
			}
		};

        function normalizeMatchedObj(obj) {
			// To construct dynamic params array.
			if(obj.route) {
				var routesObj = config.routes,
				// parentRouteObj,
				matched,
				// def,
				R = [],
				rOpts = [],
				errorCheck = function(route,i) {
					routesObj = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._getObj)(route,routesObj);
					if(!routesObj) {
						throw Error(_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.getErrorMessage("400A",matched.target));
					}
					R.push(routesObj.__lp.handler)
				};
				if(obj._routes) {
					matched = obj;
				} else {
					var routeFromAlias = _router_utils__WEBPACK_IMPORTED_MODULE_4__._getRouteFromAlias.call(this,{route : obj.route, map : config.aliasRouteMap});
					matched = {
						route : routeFromAlias.route, /* Array.isArray(obj.route) ? obj.route : _dotSerperator(obj.route), */
						alias : routeFromAlias.alias,
						queryParams : obj.queryParams || {},
						dynamicParams : [],
						fragment : obj.fragment,
						target : "",
						refreshRoute : obj.refreshRoute,
						startFrom : obj.startFrom,
						_routes : []
					};
					if(obj.dynamicParams) {
						if(obj.dpProcessed) {
							matched.dynamicParams = Array.from(obj.dynamicParams);
						} else {
							var dynamicParams =  Array.from(obj.dynamicParams);
						}
					}
				}
				try {
					matched.route.forEach(obj._routes ? errorCheck : function(route,i) {
						matched.target = matched.target ? matched.target+'.'+route : route;
						matched._routes.push((0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._dotSerperator)(matched.target));
						errorCheck(route,i)
						if(dynamicParams) {
							matched.dynamicParams.push(routesObj.__lp.dkey ? dynamicParams.shift() : undefined);
						}
					});
					var r = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._getObj)(matched._routes[matched._routes.length-1],config.routes)
					if(r && r.__lp.mount) {
						matched.mountRoute = true
					}
					if(dynamicParams && dynamicParams.length) {
						lyte.error(`Extra dynamic params found. Provide exact numbers dynamic params required for the ${transitionStr} ${JSON.stringify(dynamicParams)}`);
					}
				} catch(e) {
					_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error(lyte,e);
					return {error : e};
				}
				return { 
					rOpts,
					matched,
					R
				};
			} else {
				if(this.tagName == LINKTOStr) {
					_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error(lyte,"498A", pRoute ,this.outerHTML);
				} else {
					_router_errors__WEBPACK_IMPORTED_MODULE_3__.RouterError.error(lyte,"499B");  
				}
			}
		}

        function initRoute(trans, processed, from) {
			trans.routes = [];
			processed.rOpts = processed.rOpts || [];
			var RouteClass,
			routeObj,
			matched = processed.matched,
			refMatch = processed.prevTrans,
			similarRoute = true;
			trans.routes = [];

			function pushRoute(i, routeObj, ins) {
				LR.__lp.nav.set(ins, newTrans);
				ins.parent = newTrans.routes[i-1] instanceof Promise ? newTrans.routes[i-1].then(function() {ins.parent = newTrans.routes[i-1]}.bind(this)) : newTrans.routes[i-1];
				trans.rOpts[i] = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(routeObj.__lp.options);
				newTrans.routes[i] = ins
			}

			function promFunc({routeStringArr, i, routeObj}, res) {
				routeObj.__lp.handler().then(function(data) {
					initialRegisterRoute(routeStringArr,(trans.R[i] = RouteClass = routeObj.__lp.handler = data[routeObj.__lp.cName]));
					lyte.scopedInstance(RouteClass,[{ i ,routeName : routeStringArr[i],options : routeOptions, init : pushRoute.bind(this,i,routeObj)}],emptyFn,[LR]);
					res()
				}.bind(routeObj));
			};

			for(var i = from || 0, route; route = matched.route[i]; i++) {
				routeObj = (0,_router_utils__WEBPACK_IMPORTED_MODULE_4__._getObj)(newTrans.matched._routes[i], config.routes);
				RouteClass = routeObj.__lp.handler;
				if(!RouteClass) {return false;}
				if(refMatch && similarRoute && refMatch.matched && refMatch.matched.route[i] == route) {
					modifyInstance({route : refMatch.routes[i],i,processed, nav : newTrans});
					// lyte.scopedInstance(RouteClass,[rOpts,trans.routes,i,processed,routeOptions,refMatch.routes[i]],pushRoute.bind(this,i),[LR]);
				} else {
					if(RouteClass.name == __routeProm__Str) {
						trans.routes.push(new Promise(promFunc.bind(this, {routeStringArr : matched._routes[i], i, routeObj})))
					} else {
						lyte.scopedInstance(RouteClass,[{i ,routeName : route, options : routeOptions, init : pushRoute.bind(this,i, routeObj)}],emptyFn,[LR]);
					}
					similarRoute = false;
				}
			}
			refMatch = undefined;
		}

        function modifyTransition(trans) {
			if(trans.changedInstance) {
				trans.routes.forEach(function(route,i) {
					LR.__lp.nav.set(route,trans);
					LR.__lp.nav.get(route).rOpts = trans.rOpts[i]
				})
			}
			return trans;
		}

        function modifyInstance({route, i, processed, nav }) {
			var rOpts = nav.rOpts[i] = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_6__.deepCopyObject)(LR.__lp.nav.get(route).rOpts[i])
			LR.__lp.nav.set(route, nav);
			delete rOpts.rendered;
			if(processed.transComp && !processed.transComp.rendered[i] && processed.transComp.redirected) {
				if(processed.transComp.redirected.index < i) {
					delete rOpts.loadDependencies;
					delete rOpts.loadResources;
					route.$.beforeFetch = route.$.fetch = route.$.afterFetch = undefined;
				} else if(processed.transComp.redirected.index != i) {
					delete rOpts.stencils;
				}
			} else {
				delete rOpts.stencils;
			}
			nav.routes[i] = route;
		}

        function dispatchTransition(processed) {
			const url = constructURLFromRoute(processed.matched);
			if(url) {
				processed.path = newTransInfo.url = url;
				dispatch(url,decideTransition(processed));
			}
			return url;
		}

        const allHooks = [getRequirementsStr,beforeFetchStr,fetchStr,afterFetchStr,divertStr,renderStr,afterRenderStr];
        function decideTransition(processed) {
			/* determines which transition to consider as previous transition */
			if(trans) {
				if(trans.running) {
					var matched = processed.matched;
					if(trans.state == 102 && trans.prom && trans.prom.hook == divertStr) {
						var transComp = getTransitionDiffernce(trans,matched,processed.R),
						transitioningRoute = allHooks.indexOf(trans.prom.hook) <= 6 ? trans.prom.index : trans.prom.index+1,
						visibleTransComparison = getTransitionDiffernce(visibleTrans,matched,processed.R);
						if(transComp.common.length < visibleTransComparison.common.length) {
							if(trans.runLoop.templateToRemove.length) {
								trans.runLoop.templateToRemove.pop();
							}
							if(transComp.rendered.length < visibleTransComparison.rendered.length) {
								processed.prevTrans = modifyTransition(visibleTrans);
							}
							transComp = visibleTransComparison;
							if(trans.prom.index <= visibleTransComparison.common.length -1) {
								transComp.redirected = trans.prom;
							}
						} else if(transComp.common.length-1 >= transitioningRoute) {
							if(trans.prom.index <= transComp.common.length -1) {
								processed.prevTrans = trans;
								transComp.redirected = trans.prom;
							}
						}  
					}
					const info = {
						route : matched.target,
						queryParams : matched.queryParams,
						dynamicParams : matched.dynamicParams.filter(_arrayClean)
					};
					if(LR.checkIfSameRoute(trans.info,info) && !trans.aborted) {
						trans.pause({iPause : true});  
					} else {
						trans.abort({state : 409, iAbort : true});
					}
					processed.transComp = transComp;
				} else if(trans && !trans.aborted) {
					trans.abort({state : 409, iAbort : true});
				}
			}
			return processed;
		}

        if(lyte.$.modules.triggerEvent) {
			lyte.$.modules.triggerEvent("add", "router", this);
		}
        var routeOptions = {
			lyte,
			dispatch,
			LR,
			constructURLFromRoute,
			decideTransition
		}
        _slyte_core__WEBPACK_IMPORTED_MODULE_8__.Lyte.domContentLoaded(init);
        return this;
    }
}

Router.__lMod = RouterStr;
Router.register = _router_utils__WEBPACK_IMPORTED_MODULE_4__._register;



/***/ })

}]);
//# sourceMappingURL=lyte.js.map