import { ComponentRegistry } from "@slyte/component";
import { Lyte, prop } from "@slyte/core";

/*convert to custom class and register*/
class ImportShadowStyle extends ComponentRegistry.Component {
    static _template = "<template tag-name=\"import-shadow-style\"> </template>";
    static _dynamicNodes = [];
    static _observedAttributes = ["src","responseText","lessCss","name","cache"];
    data(){
        return {
            src : prop("string"),
            responseText : prop("string"),
            lessCss : prop("object"),
            cache : prop("boolean")
        }		
    }
    init(){
        var src = this.getData("src");
        var cache = this.getData("cache");
        // var callee = this.$node._callee;
        // if(!callee){
        //     Lyte.error("import-shadow-style must be");
        //     return;
        // }
        var shadowObj = this.$component._shadow;
        var id = shadowObj.generateId();
        this.$node._id = id;
        if(src){
            let rootNode = this.$node.getRootNode();
            let hostEle = shadowObj.getHostElement(rootNode);
            var shadowParent = hostEle ? hostEle : Lyte.$.shadowDiv;
            shadowObj.importStyle[id] = {"src" : src ,"cache" : [],response : "", "status": "pending"};
            shadowObj.placeHolderTraversing([shadowParent],src,id);
            if(shadowObj.importSrc.indexOf(src) == -1){
                shadowObj.importSrc.$push(src);
            }
            else if(cache == false){
                //go to send request
                // debugger;
            }
            else{
                //already thr
                for (var key in shadowObj.importStyle) {
                    if(shadowObj.importStyle[key].src == src){
                        if(shadowObj.importStyle[key].status == "pending"){
                            shadowObj.importStyle[key].cache.$push({"shadowParent":shadowParent,"this":this,"id":id});
                            return;
                        }
                        else if(shadowObj.importStyle[key].status == "resolved"){
                            shadowObj.importStyle[id].status = "resolved";
                            shadowObj.importStyle[id].response = shadowObj.importStyle[key].response;
                            shadowObj.traversing(shadowParent,this,shadowObj.importStyle[key].response,src,id);
                            return;
                        }
                    }
                }

            }
            var self = this;
            var promise1 = new Promise(function(resolve, reject) {
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function() {
                    if (this.readyState == 4 && this.status == 200) {
                        resolve(this.responseText);
                    }
                }
                xhttp.open("GET", src);
                xhttp.send();
            });
            promise1.then(function(response){
                if(response == ""){
                    Lyte.warn("The response is empty in import-shadow-style");
                    return;
                }
                if(!this.$node){
                    Lyte.error("import-shadow-style component is destroyed before setting response");
                    return;
                }
                var lessObj = {};
                response = response.split("/*! __lyteComponent */");  
                response.forEach(function(res){
                    var compNameRegex = /\/\*\!\s*(componentName\=\s*)(\"|\')(.*)(\"|\')\s*(starts)\s\*\//g;
                    // res = res.trim();
                    var compReg = compNameRegex.exec(res);
                    if(compReg){
                        var compName = compReg[3];
                        // var regexExp = new RegExp("/\\*!\\s(componentName\\=\s*)(\"|\')"+compName+"(\"|\')\s*starts\\s\\*\\/(.\|\\n|\\s)*\\/\\*!\\s(componentName\\=\s*)(\"|\')"+compName+"(\"|\')\s*end\\s\\*/", "\g");
                        // var css = res.match(regexExp);
                        lessObj[compName] = res;
                    }
                });
                lessObj.lessSrc = src;
                var id = this.$node._id;
                shadowObj.importStyle[id].response = lessObj;
                shadowObj.importStyle[id].status = "resolved";
                shadowObj.traversing(shadowParent,this,lessObj,src,id);
                if(shadowObj.importStyle[id].cache.length > 0){
                    shadowObj.importStyle[id].cache.forEach(function(obj){
                        if(!obj.traversed){
                            var cacheId = obj.id;
                            shadowObj.importStyle[cacheId].response = lessObj;
                            shadowObj.importStyle[cacheId].status = "resolved";
                            // obj.response = lessObj;
                            shadowObj.traversing(obj.shadowParent,obj.this,lessObj,src,obj.id);
                            obj.traversed = true; 
                            obj.this = undefined;
                            obj.shadowParent = undefined;
                        }
                    })
                }
            }.bind(self))
        }else{
            Lyte.warn("Not a valid url in import-shadow-style")
        }
    }
}
export default ImportShadowStyle;