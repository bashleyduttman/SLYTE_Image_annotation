//ignorei18n_start
import {ComponentRegistry,_LC} from "@slyte/component";
import { Service } from "@slyte/core/src/service";

/*convert to custom class and register*/
class View extends Service{
    static __lMod = "View";
    constructor(regIns){
        super()
        regIns.viewPortSettings = _LC.viewPortSettings;
        regIns.isInViewPort = _LC.isInViewPort;
        if(!regIns.registeredHelpers.lyteViewPort){
            regIns.registeredHelpers.lyteViewPort = this.constructor.viewHelper;
        }
    }
    static register(){
        ComponentRegistry.addFakeDirective(this,"view");
        var defHelpers = ComponentRegistry._defaultHelpers;
        defHelpers["lyteViewPort"] = this.viewHelper;
    }
    static viewHelper(node,config){   
        let compName = node._callee.localName;
        let switchNode = node._parentSwitch; 
        if(switchNode._viewPortRendered){
            return true;
        }
        switchNode._vpNode = node;
        let disableViewPort = config;
        let pve = _LC.pendingViewPortElements;
        let promise;
        switchNode._disable = {};
        if(config && typeof config == "object"){
            switchNode._custom = true;
            disableViewPort = config.disableViewPort;
            if(config.viewIn || config.viewOut){
                promise = true;
                switchNode._viewIn = config.viewIn ? Object.assign(config.viewIn) : undefined;
                switchNode._viewOut = config.viewOut ? Object.assign(config.viewOut) : undefined;
                let _res,_rej;
                switchNode._renderPromise = new Promise(function(res,rej){
                    _res = res;
                    _rej = rej;
                });
                switchNode._promiseObject = {
                    resolvedByLyte : false,
                    spouse : switchNode._viewIn,
                    resolve : function(){
                        if(!switchNode._viewOut._afterAppendCalled && switchNode._viewOut.beforeRemove && switchNode._renderPromise && !switchNode._viewOut._beforeRemoveCalled){
                            switchNode._viewOut.beforeRemove.apply(switchNode._viewOut,[switchNode._promiseObject]);
                        }
                        if(switchNode._renderPromise){
                            _res();
                        }
                    },
                    reject : function(){
                        switchNode._renderPromise._reject = true;
                        _rej();
                    }
                }
                switchNode._renderPromise.then(function(){
                    if(!switchNode._callee.component){
                        return;
                    }
                    switchNode._renderPromise._resolved = true;
                    let ind = pve.indexOf(switchNode);
                    if(ind != -1){
                        pve.splice(ind,1)
                    }
                    let viewInIns = switchNode._viewIn;
                    if(viewInIns && viewInIns.beforeAppend){
                        viewInIns.beforeAppend.apply(viewInIns);
                    }
                    _LC._executeIfTemplates(switchNode);
                    if(viewInIns && viewInIns.afterAppend){
                        viewInIns.afterAppend.apply(viewInIns);
                    }
                    switchNode._renderPromise = null;
                },function(){
                    Lyte.error("Promise rejected - Viewport cannot be toggled.");
                })
            }
        }
        if(!disableViewPort){
            if(!_LC._doneRaf[compName]){
                requestAnimationFrame(function () {
                    requestAnimationFrame(function () {
                        let inViewTemplates = [];
                        var arr = Array.from(pve);
                        for(var i=arr.length-1;(i >= 0);i--) {
                            let temp = arr[i];
                            if(temp.tagName == "TEMPLATE" && temp._callee && !temp._callee._destroyed){
                                // var actTemp = _LC.getActViewPortTemplate(temp);
                                let switchNode = temp; 
                                let viewOutIns = switchNode._viewOut;
                                if(viewOutIns && viewOutIns.afterAppend){
                                    viewOutIns.afterAppend.apply(viewOutIns,[switchNode._promiseObject]);
                                    viewOutIns._afterAppendCalled = true;
                                }
                                if(_LC.isViewPortTemplate(temp) && !temp._callee._destroyed){
                                    if(_LC._isInViewPort(temp,temp._callee)){
                                        inViewTemplates.push(pve.splice(i,1)[0]);
                                        temp._inPve = false;
                                        temp._viewPortRendered = true;
                                    }
                                }
                                // actTemp._inPve = temp._inPve;
                                // actTemp._viewPortRendered = temp._viewPortRendered;
                            }
                        }
                        for(let i=0; i<inViewTemplates.length; i++){
                            _LC._executeIfTemplates(inViewTemplates[i]);
                        }
                        _LC._doneRaf[compName] = false;
                        if(inViewTemplates.length) {
                            requestAnimationFrame(function() {
                                requestAnimationFrame(function() {
                                    _LC.executePendingViewPort();
                                });
                            });    
                        }
                    });
                });
                _LC._doneRaf[compName] = true;
            }
            if(pve.indexOf(switchNode) == -1){
                switchNode._inPve = true;
                pve.push(switchNode); 
            }
            return false;
        }else if(pve.length){
            // let fakeTemp = _LC.getFakeTemplate(switchNode);
            let ind = pve.indexOf(switchNode);
            if(ind != -1){
                pve[ind]._inpve = false;
                pve[ind]._viewPortRendered = true;
                pve.splice(ind,1);
            }
        }
        return true;
    }
    rmCaseContent(node){
        var pve = _LC.pendingViewPortElements;
        if(node._inPve && pve.length){
            let ind = pve.indexOf(node);
            if(ind != -1){
                pve.splice(ind,1);
            }
        }
        if(node.getAttribute("__vp") == "c-old"){
            let ind = pve.indexOf(node._callee);
            if(ind != -1){
                pve.splice(ind,1);
            }
        }
    }
    connectedCallback(comp){
        var isViewPort;
        if(comp._initProperties && comp._initProperties.hasOwnProperty('lyteViewPort')){
            isViewPort = comp._initProperties.lyteViewPort;
        }
        else{
            isViewPort = comp.component.data.lyteViewPort;
        }
        if(isViewPort && comp.component.constructor._template.getAttribute("__vp") != "c-new") {
            if(!_LC.isViewPortPending) {
                requestAnimationFrame(function() {
                    requestAnimationFrame(function() {
                        _LC.executePendingViewPort();
                    });
                });
                _LC.isViewPortPending = true;
            }
            _LC.pendingViewPortElements.$push(comp);
        }
    }
    actualConnectedCallback(comp,content){
        if(comp.component.data.lyteViewPort) {
            comp._vpc = true;
            // if(Lyte._ie) {
            //     for(var i=0;i<content.childNodes.length;i++) {
            //         if(content.childNodes[i].tagName) {
            //             comp._dummyViewPortF = content.childNodes[i];
            //             break;
            //         }
            //     }
            //     for(var i=content.childNodes.length-1;i>=0;i--) {
            //         if(content.childNodes[i].tagName) {
            //             comp._dummyViewPortL = content.childNodes[i];
            //             break;
            //         }
            //     }
            // } else {
                comp._dummyViewPortF = content.children[0];
                comp._dummyViewPortL = content.children[content.children.length - 1];
            // }
            // comp.appendChild(content);
        }
    }
    disconnectedCallback(comp){
        var pve = _LC.pendingViewPortElements;
        if(comp.component.data.lyteViewPort) {
            let index = pve.indexOf(comp);
            if(index != -1) {
                pve.splice(index, 1);
            }
        }
        if(_LC.viewPortSettings.handlePendingItems && comp._vpc) {
            _LC.executeVpe = true;
        }
        if(pve.length){
            for(let i=0; i<pve.length; i++){
                if(pve[i] && pve[i].tagName == "TEMPLATE" && pve[i].getAttribute("is") == "switch" && pve[i]._callee == comp){
                    pve.splice(i,1);
                    i--;
                }
            }
        }
    }
    actualDisconnected(){
        if(_LC.executeVpe){
            _LC.viewPortSettings.executePendingViewPortElements();
            _LC.executeVpe = false;
        }
    }
}
_LC.pendingViewPortElements = [];
_LC.isInViewPort = function(el) {
    var rect = el.getBoundingClientRect();
    return ((rect.top >= 0 && rect.top <= (window.innerHeight || document.documentElement.clientHeight)) || (rect.bottom >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) ));

}
_LC._doneRaf = {};
_LC._isInViewPort = function(node){
    node._isViewPortPending = true;
    var fchild = node._caseContent[0];
    if(fchild && _LC.isInViewPort(fchild)) {
        node._isInView = true;
        if(node._custom){
            let viewOutIns = node._viewOut;
            if(viewOutIns && !node._renderPromise._resolved && viewOutIns.beforeRemove){
                node._promiseObject.resolvedByLyte = true;
                viewOutIns._beforeRemoveCalled = true;
                viewOutIns.beforeRemove.apply(viewOutIns,[node._promiseObject]);
            }else if(!node._renderPromise._reject){
                return true;
            }    
        }
        // if(node._inView && !node._renderPromise._resolved && !node._disable.inView){
        //     node._inView.apply(this,[node._promiseObject]);
        // }
        else{
            return true;
        }
    }
}
_LC._executeIfTemplates = function(node){
    if(node._currentScope == "default"){
        node._vpNode._attributes.case = true;
    }else{
        node._tempList[node._currentScope]._attributes.case = true;
    }
    var isYieldContext,contextSwitchInfo;
    if (node._cx || node.nodeType === 2 && node.ownerElement._cx) {
        contextSwitchInfo = node._cx || node.ownerElement._cx;
        var contextSwitchArray = [];
        _LC.changeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo);
    } else if (node.tagName === "LYTE-YIELD" && node._callee._cx) {
        isYieldContext = true;
        contextSwitchInfo = node._callee._cx;
        var contextSwitchArray = [];
        _LC.changeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo, true);
    }
    node._callee.updateSwitchHelper("if", node, node._cx, true, true);
    if (contextSwitchInfo) {
        _LC.removeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo, isYieldContext);
    }
    node._isViewPortPending = false;
    if(node.getAttribute("__vp") == "c-new"){
        node._callee.setData("lyteViewPort",false);//af chcek
    }
}
_LC.isViewPortTemplate = function(node){
    if((node.tagName == "TEMPLATE" || node._origTemplate) && node.getAttribute("is") == "switch"){
        return true;
    }
}
_LC.executePendingViewPort = function() {
    var pve = _LC.pendingViewPortElements;
    if(!pve.length) {
        return;
    }
    var arr = Array.from(pve);
    var inViewPortElements = [];
    for(var i=arr.length-1;(i >= 0);i--) {
        let ele = arr[i];
        if(_LC.isViewPortTemplate(ele)){
            // let actTemp = _LC.getActViewPortTemplate(ele);
            if(_LC._isInViewPort(ele,ele._callee)){
                inViewPortElements.push(pve.splice(i,1)[0]);
                ele._inPve = false;
                ele._viewPortRendered = true;
            }
            // actTemp._inPve = ele._inPve;
            // actTemp._viewPortRendered = ele._viewPortRendered;
        }
        else if(_LC.isInViewPort(ele._dummyViewPortF) || _LC.isInViewPort(ele._dummyViewPortL)) {
            ele._dummyViewPortF = ele._dummyViewPortL = undefined;
            inViewPortElements.push(pve.splice(i,1)[0]);
        }
    }

    _LC.isViewPortPending = false;

    for(var j=0;j<inViewPortElements.length;j++) {
        let ele = inViewPortElements[j];
        if(_LC.isViewPortTemplate(ele)){
            _LC._executeIfTemplates(ele);
        }else{
            ele.setData("lyteViewPort", false);
        }
    }
    if(inViewPortElements.length) {
        requestAnimationFrame(function() {
            requestAnimationFrame(function() {
                _LC.executePendingViewPort();
            });
        });    
    }
}
_LC.viewPortSettings = {
    debounce : 0,
    executePendingViewPortElements : function() {
        _LC.executePendingViewPort();
    }
}
window.addEventListener("resize", function() {
    requestAnimationFrame(function() {
        requestAnimationFrame(function() {
            _LC.executePendingViewPort();     
        })    
    });
});

document.addEventListener("scroll", function() {
    var debounceTime = _LC.viewPortSettings.debounce
    if(debounceTime) {
        if(_LC.viewPortScrollDebounce) {
            clearTimeout(_LC.viewPortScrollDebounce);
        }
        _LC.viewPortScrollDebounce = setTimeout(function() {
                requestAnimationFrame(function() {
                    requestAnimationFrame(function() {
                        _LC.executePendingViewPort();        
                    }) 
                });
                _LC.viewPortScrollDebound = undefined;
        },debounceTime);
    } else {
        requestAnimationFrame(function() {
            requestAnimationFrame(function() {
                _LC.executePendingViewPort();        
            }) 
        });
        
    }
}, true);
export default View;
//ignorei18n_end