

/**
 * DOMPurify
 **/
'use strict'; // No I18N
(function(factory) {
    window.DOMPurify = factory(window);
}(function factory(window) {

    var DOMPurify = function(window) {
        return factory(window);
    };

    /**
     * Version label, exposed for easier checks
     * if DOMPurify is up to date or not
     */
    DOMPurify.version = '0.8.5'; // No I18N

    /**
     * Array of elements that DOMPurify removed during sanitation.
     * Empty if nothing was removed.
     */
    DOMPurify.removed = [];

    if (!window || !window.document || window.document.nodeType !== 9) {
        // not running in a browser, provide a factory function
        // so that you can pass your own Window
        DOMPurify.isSupported = false;
        return DOMPurify;
    }

    var document = window.document;
    var originalDocument = document;
    var DocumentFragment = window.DocumentFragment;
    var HTMLTemplateElement = window.HTMLTemplateElement;
    var Node = window.Node;
    var NodeFilter = window.NodeFilter;
    var NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap;
    var Text = window.Text;
    var Comment = window.Comment;
    var DOMParser = window.DOMParser;

    // As per issue #47, the web-components registry is inherited by a
    // new document created via createHTMLDocument. As per the spec
    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
    // a new empty registry is used when creating a template contents owner
    // document, so we use that as our parent document to ensure nothing
    // is inherited.
    if (typeof HTMLTemplateElement === 'function') { // No I18N
        var template = document.createElement('template'); // No I18N
        if (template.content && template.content.ownerDocument) {
            document = template.content.ownerDocument;
        }
    }
    var implementation = document.implementation;
    var createNodeIterator = document.createNodeIterator;
    var getElementsByTagName = document.getElementsByTagName;
    var createDocumentFragment = document.createDocumentFragment;
    var importNode = originalDocument.importNode;

    var hooks = {};

    /**
     * Expose whether this browser supports running the full DOMPurify.
     */
    DOMPurify.isSupported =
        typeof implementation.createHTMLDocument !== 'undefined' && // No I18N
        document.documentMode !== 9;

    /* Add properties to a lookup table */
    var _addToSet = function(set, array) {
        var l = array.length;
        while (l--) {
            if (typeof array[l] === 'string') { // No I18N
                array[l] = array[l].toLowerCase();
            }
            set[array[l]] = true;
        }
        return set;
    };

    /* Shallow clone an object */
    var _cloneObj = function(object) {
        var newObject = {};
        var property;
        for (property in object) {
            if (object.hasOwnProperty(property)) {
                newObject[property] = object[property];
            }
        }
        return newObject;
    };

    /**
     * We consider the elements and attributes below to be safe. Ideally
     * don't add any new ones but feel free to remove unwanted ones.
     */

    /* allowed element names */
    var ALLOWED_TAGS = null;
    var DEFAULT_ALLOWED_TAGS = _addToSet({}, []);

    /* Allowed attribute names */
    var ALLOWED_ATTR = null;
    var DEFAULT_ALLOWED_ATTR = _addToSet({}, []);

    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
    var FORBID_TAGS = null;

    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
    var FORBID_ATTR = null;

    /* Decide if ARIA attributes are okay */
    var ALLOW_ARIA_ATTR = true;

    /* Decide if custom data attributes are okay */
    var ALLOW_DATA_ATTR = true;

    /* Decide if unknown protocols are okay */
    var ALLOW_UNKNOWN_PROTOCOLS = false;

    /* Output should be safe for jQuery's $() factory? */
    var SAFE_FOR_JQUERY = false;

    /* Output should be safe for common template engines.
     * This means, DOMPurify removes data attributes, mustaches and ERB
     */
    var SAFE_FOR_TEMPLATES = false;

    /* Specify template detection regex for SAFE_FOR_TEMPLATES mode */
    var MUSTACHE_EXPR = /\{\{[\s\S]*|[\s\S]*\}\}/gm;
    var ERB_EXPR = /<%[\s\S]*|[\s\S]*%>/gm;

    /* Decide if document with <html>... should be returned */
    var WHOLE_DOCUMENT = false;

    /* Decide if all elements (e.g. style, script) must be children of
     * document.body. By default, browsers might move them to document.head */
    var FORCE_BODY = true;

    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html string.
     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
     */
    var RETURN_DOM = false;

    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html string */
    var RETURN_DOM_FRAGMENT = false;

    /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM
     * `Node` is imported into the current `Document`. If this flag is not enabled the
     * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by
     * DOMPurify. */
    var RETURN_DOM_IMPORT = false;

    /* Output should be free from DOM clobbering attacks? */
    var SANITIZE_DOM = true;

    /* Keep element content when removing element? */
    var KEEP_CONTENT = true;

    /* Tags to ignore content of when KEEP_CONTENT is true */
    var FORBID_CONTENTS = _addToSet({}, [
        'audio', 'head', 'math', 'script', 'svg', 'video', 'style' // No I18N
    ]);

    /* Tags that are safe for data: URIs */
    var DATA_URI_TAGS = _addToSet({}, [
        'audio', 'video', 'img', 'source', 'image' // No I18N
    ]);

    /* Attributes safe for values like "javascript:" */ // No I18N
    var URI_SAFE_ATTRIBUTES = _addToSet({}, [
        'alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', // No I18N
        'summary', 'title', 'value', 'style', 'xmlns' // No I18N
    ]);

    /* Keep a reference to config to pass to hooks */
    var CONFIG = null;

    /* Ideally, do not touch anything below this line */
    /* ______________________________________________ */

    var formElement = document.createElement('form'); // No I18N

    /**
     * _parseConfig
     *
     * @param  optional config literal
     */
    var _parseConfig = function(cfg) {
        /* Shield configuration object from tampering */
        if (typeof cfg !== 'object') { // No I18N
            cfg = {};
        }

        /* Set configuration parameters */
        ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? // No I18N
            _addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
        ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? // No I18N
            _addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
        FORBID_TAGS = 'FORBID_TAGS' in cfg ? // No I18N
            _addToSet({}, cfg.FORBID_TAGS) : {};
        FORBID_ATTR = 'FORBID_ATTR' in cfg ? // No I18N
            _addToSet({}, cfg.FORBID_ATTR) : {};
        ALLOW_ARIA_ATTR         = cfg.ALLOW_ARIA_ATTR           !== false; // Default true
        ALLOW_DATA_ATTR         = cfg.ALLOW_DATA_ATTR           !== false; // Default true
        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS   ||  false; // Default false
        SAFE_FOR_JQUERY         = cfg.SAFE_FOR_JQUERY           ||  false; // Default false
        SAFE_FOR_TEMPLATES      = cfg.SAFE_FOR_TEMPLATES        ||  false; // Default false
        WHOLE_DOCUMENT          = cfg.WHOLE_DOCUMENT            ||  false; // Default false
        RETURN_DOM              = cfg.RETURN_DOM                ||  false; // Default false
        RETURN_DOM_FRAGMENT     = cfg.RETURN_DOM_FRAGMENT       ||  false; // Default false
        RETURN_DOM_IMPORT       = cfg.RETURN_DOM_IMPORT         ||  false; // Default false
        FORCE_BODY              = cfg.FORCE_BODY                !== false; // Default true
        SANITIZE_DOM            = cfg.SANITIZE_DOM              !== false; // Default true
        KEEP_CONTENT            = cfg.KEEP_CONTENT              !== false; // Default true

        if (SAFE_FOR_TEMPLATES) {
            ALLOW_DATA_ATTR = false;
        }

        if (RETURN_DOM_FRAGMENT) {
            RETURN_DOM = true;
        }

        if (cfg.ADD_URI_SAFE_ATTR) {
            _addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
        }

        /* Add #text in case KEEP_CONTENT is set to true */
        if (KEEP_CONTENT) {
            ALLOWED_TAGS['#text'] = true; // No I18N
        }

        // Prevent further manipulation of configuration.
        // Not available in IE8, Safari 5, etc.
        if (Object && 'freeze' in Object) { // No I18N
            Object.freeze(cfg);
        }

        CONFIG = cfg;
    };

    /**
     * _forceRemove
     *
     * @param  a DOM node
     */
    var _forceRemove = function(node) {
        DOMPurify.removed.push({
            element: node
        });
        try {
            node.parentNode.removeChild(node);
        } catch (e) {
            node.outerHTML = ''; // No I18N
        }
    };

    /**
     * _removeAttribute
     *
     * @param  an Attribute name
     * @param  a DOM node
     */
    var _removeAttribute = function(name, node) {
        DOMPurify.removed.push({
            attribute: node.getAttributeNode(name),
            from: node
        });
        node.removeAttribute(name);
    };

    /**
     * _initDocument
     *
     * @param  a string of dirty markup
     * @return a DOM, filled with the dirty markup
     */
    var _initDocument = function(dirty) {
        /* Create a HTML document using DOMParser */
        var doc, body;

        if (FORCE_BODY) {
            dirty = '<remove></remove>' + dirty; // No I18N
        }

        try {
            doc = new DOMParser().parseFromString(dirty, 'text/html'); // No I18N
        } catch (e) {}
        /* Some browsers throw, some browsers return null for the code above
           DOMParser with text/html support is only in very recent browsers.
           See #159 why the check here is extra-thorough */
        if (!doc || !doc.documentElement) {
            doc = implementation.createHTMLDocument(''); // No I18N
            body = doc.body;
            body.parentNode.removeChild(body.parentNode.firstElementChild);
            body.outerHTML = dirty;
        }

        /* Work on whole document or just its body */
        if (typeof doc.getElementsByTagName === 'function') { // No I18N
            return doc.getElementsByTagName(
                WHOLE_DOCUMENT ? 'html' : 'body')[0]; // No I18N
        }
        return getElementsByTagName.call(doc,
            WHOLE_DOCUMENT ? 'html' : 'body')[0]; // No I18N
    };

    /**
     * _createIterator
     *
     * @param  document/fragment to create iterator for
     * @return iterator instance
     */
    var _createIterator = function(root) {
        return createNodeIterator.call(root.ownerDocument || root,
            root,
            NodeFilter.SHOW_ELEMENT |
            NodeFilter.SHOW_COMMENT |
            NodeFilter.SHOW_TEXT,
            function() {
                return NodeFilter.FILTER_ACCEPT;
            },
            false
        );
    };

    /**
     * _isClobbered
     *
     * @param  element to check for clobbering attacks
     * @return true if clobbered, false if safe
     */
    var _isClobbered = function(elm) {
        if (elm instanceof Text || elm instanceof Comment) {
            return false;
        }
        if (typeof elm.nodeName !== 'string' || // No I18N
            typeof elm.textContent !== 'string' || // No I18N
            typeof elm.removeChild !== 'function' || // No I18N
            !(elm.attributes instanceof NamedNodeMap) ||
            typeof elm.removeAttribute !== 'function' || // No I18N
            typeof elm.setAttribute !== 'function' // No I18N
        ) {
            return true;
        }
        return false;
    };

    /**
     * _isNode
     *
     * @param object to check whether it's a DOM node
     * @return true is object is a DOM node
     */
    var _isNode = function(obj) {
        return (
            typeof Node === "object" ? obj instanceof Node : obj && // No I18N
            typeof obj === "object" && typeof obj.nodeType === "number" && // No I18N
            typeof obj.nodeName === "string" // No I18N
        );
    };

    /**
     * _sanitizeElements
     *
     * @protect nodeName
     * @protect textContent
     * @protect removeChild
     *
     * @param   node to check for permission to exist
     * @return  true if node was killed, false if left alive
     */
    var _sanitizeElements = function(currentNode) {
        var tagName, content;
        /* Execute a hook if present */
        _executeHook('beforeSanitizeElements', currentNode, null); // No I18N

        /* Check if element is clobbered or can clobber */
        if (_isClobbered(currentNode)) {
            _forceRemove(currentNode);
            return true;
        }

        /* Now let's check the element's type and name */ // No I18N
        tagName = currentNode.nodeName.toLowerCase();

        /* Execute a hook if present */
        _executeHook('uponSanitizeElement', currentNode, { // No I18N
            tagName: tagName,
            allowedTags: ALLOWED_TAGS
        });

        /* Remove element if anything forbids its presence */
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            /* Keep content except for black-listed elements */
            if (KEEP_CONTENT && !FORBID_CONTENTS[tagName] &&
                typeof currentNode.insertAdjacentHTML === 'function') { // No I18N
                try {
                    currentNode.insertAdjacentHTML('AfterEnd', currentNode.innerHTML); // No I18N
                } catch (e) {}
            }
            _forceRemove(currentNode);
            return true;
        }

        // TODO: Study about effects of '{{}}' in styles to make this more safe!
        // This check is to prevent '<' from being HTML encoded when used in style.
        // It will be CSS Encoded in the else block below
        if (tagName != "style") {  // No I18N
            /* Convert markup to cover jQuery behavior */
            if (SAFE_FOR_JQUERY && !currentNode.firstElementChild &&
                (!currentNode.content || !currentNode.content.firstElementChild) &&
                /</g.test(currentNode.textContent)) {
                DOMPurify.removed.push({
                    element: currentNode.cloneNode()
                });
                currentNode.innerHTML = currentNode.textContent.replace(/</g, '&lt;'); // No I18N
            }
            /* Sanitize element content to be template-safe */
            if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
                /* Get the element's text content */
                content = currentNode.textContent;

                content = content.replace(MUSTACHE_EXPR, ' '); // No I18N
                content = content.replace(ERB_EXPR, ' '); // No I18N

                if (currentNode.textContent !== content) {
                    DOMPurify.removed.push({
                        element: currentNode.cloneNode()
                    });
                    currentNode.textContent = content;
                }
            }
        }

        //Encode the '<' in style tags in CSS context like '\3c '
        else{
            /* Convert markup to cover jQuery behavior */
            if (SAFE_FOR_JQUERY && !currentNode.firstElementChild &&
                (!currentNode.content || !currentNode.content.firstElementChild) &&
                /</g.test(currentNode.textContent)) {
                DOMPurify.removed.push({
                    element: currentNode.cloneNode()
                });
                currentNode.innerHTML = currentNode.textContent.replace(/</g, '\\3c '); // No I18N
            }
        }

        /* Execute a hook if present */
        _executeHook('afterSanitizeElements', currentNode, null); // No I18N

        return false;
    };

    var DATA_ATTR = /^data-[-\w.\u00B7-\uFFFF]/;
    var ARIA_ATTR = /^aria-[-\w]+$/;
    var IS_ALLOWED_URI = /^(?:(?:https?|mailto|tel):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i;
    var IS_SCRIPT_OR_DATA = /^(?:\w+script|data):/i;
    /* This needs to be extensive thanks to Webkit/Blink's behavior */
    var ATTR_WHITESPACE = /[\x00-\x20\xA0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;

    /**
     * _sanitizeAttributes
     *
     * @protect attributes
     * @protect nodeName
     * @protect removeAttribute
     * @protect setAttribute
     *
     * @param   node to sanitize
     * @return  void
     */
    var _sanitizeAttributes = function(currentNode) {
        var attr, name, value, lcName, idAttr, attributes, hookEvent, l;
        /* Execute a hook if present */
        _executeHook('beforeSanitizeAttributes', currentNode, null); // No I18N

        attributes = currentNode.attributes;

        /* Check if we have attributes; if not we might have a text node */
        if (!attributes) {
            return;
        }

        hookEvent = {
            attrName: '', // No I18N
            attrValue: '', // No I18N
            keepAttr: true,
            allowedAttributes: ALLOWED_ATTR
        };
        l = attributes.length;

        /* Go backwards over all attributes; safely remove bad ones */
        while (l--) {
            attr = attributes[l];
            name = attr.name;
            value = attr.value.trim();
            lcName = name.toLowerCase();

            /* Execute a hook if present */
            hookEvent.attrName = lcName;
            hookEvent.attrValue = value;
            hookEvent.keepAttr = true;
            _executeHook('uponSanitizeAttribute', currentNode, hookEvent); // No I18N
            value = hookEvent.attrValue;

            /* Remove attribute */
            // Safari (iOS + Mac), last tested v8.0.5, crashes if you try to
            // remove a "name" attribute from an <img> tag that has an "id" // No I18N
            // attribute at the time.
            if (lcName === 'name' && // No I18N
                currentNode.nodeName === 'IMG' && attributes.id) { // No I18N
                idAttr = attributes.id;
                attributes = Array.prototype.slice.apply(attributes);
                _removeAttribute('id', currentNode); // No I18N
                _removeAttribute(name, currentNode);
                if (attributes.indexOf(idAttr) > l) {
                    currentNode.setAttribute('id', idAttr.value); // No I18N
                }
            } else {
                // This avoids a crash in Safari v9.0 with double-ids.
                // The trick is to first set the id to be empty and then to
                // remove the attriubute
                if (name === 'id') { // No I18N
                    currentNode.setAttribute(name, ''); // No I18N
                }
                _removeAttribute(name, currentNode);
            }

            /* Did the hooks approve of the attribute? */
            if (!hookEvent.keepAttr) {
                continue;
            }

            /* Make sure attribute cannot clobber */
            if (SANITIZE_DOM &&
                (lcName === 'id' || lcName === 'name') && // No I18N
                (value in document || value in formElement)) {
                continue;
            }

            /* Sanitize attribute content to be template-safe */
            if (SAFE_FOR_TEMPLATES) {
                value = value.replace(MUSTACHE_EXPR, ' '); // No I18N
                value = value.replace(ERB_EXPR, ' '); // No I18N
            }

            /* Allow valid data-* attributes: At least one character after "-" // No I18N
               (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
               XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
               We don't need to check the value; it's always URI safe. */ // No I18N
            var emptyBlockFiller = false; //Hack-fix for git preventing empty blocks in code
            if (ALLOW_DATA_ATTR && DATA_ATTR.test(lcName)) {
                // This attribute is safe
                emptyBlockFiller = true;
            } else if (ALLOW_ARIA_ATTR && ARIA_ATTR.test(lcName)) {
                // This attribute is safe
                emptyBlockFiller = true;
            }
            /* Otherwise, check the name is permitted */
            else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
                continue;
            }
            /* Check value is safe. First, is attr inert? If so, is safe */
            else if (URI_SAFE_ATTRIBUTES[lcName]) {
                // This attribute is safe
                emptyBlockFiller = true;
            }
            /* Check no script, data or unknown possibly unsafe URI
               unless we know URI values are safe for that attribute */
            else if (IS_ALLOWED_URI.test(value.replace(ATTR_WHITESPACE, ''))) { // No I18N
                // This attribute is safe
                emptyBlockFiller = true;
            }
            /* Keep image data URIs alive if src/xlink:href is allowed */
            else if (
                (lcName === 'src' || lcName === 'xlink:href') && // No I18N
                value.indexOf('data:') === 0 && // No I18N
                DATA_URI_TAGS[currentNode.nodeName.toLowerCase()]) {
                // This attribute is safe
                emptyBlockFiller = true;
            }
            /* Allow unknown protocols: This provides support for links that
               are handled by protocol handlers which may be unknown ahead of
               time, e.g. fb:, spotify: */
            else if (
                ALLOW_UNKNOWN_PROTOCOLS &&
                !IS_SCRIPT_OR_DATA.test(value.replace(ATTR_WHITESPACE, ''))) { // No I18N
                // This attribute is safe
                emptyBlockFiller = true;
            }
            /* Check for binary attributes */
            else if (!value) {
                // binary attributes are safe at this point
                emptyBlockFiller = true;
            }
            /* Anything else, presume unsafe, do not add it back */
            else {
                continue;
            }

            /* Handle invalid data-* attribute set by try-catching it */
            try {
                currentNode.setAttribute(name, value);
                DOMPurify.removed.pop();
            } catch (e) {}
        }

        /* Execute a hook if present */
        _executeHook('afterSanitizeAttributes', currentNode, null); // No I18N
    };

    /**
     * _sanitizeShadowDOM
     *
     * @param  fragment to iterate over recursively
     * @return void
     */
    var _sanitizeShadowDOM = function(fragment) {
        var shadowNode;
        var shadowIterator = _createIterator(fragment);

        /* Execute a hook if present */
        _executeHook('beforeSanitizeShadowDOM', fragment, null); // No I18N

        while ((shadowNode = shadowIterator.nextNode())) {
            /* Execute a hook if present */
            _executeHook('uponSanitizeShadowNode', shadowNode, null); // No I18N

            /* Sanitize tags and elements */
            if (_sanitizeElements(shadowNode)) {
                continue;
            }

            /* Deep shadow DOM detected */
            if (shadowNode.content instanceof DocumentFragment) {
                _sanitizeShadowDOM(shadowNode.content);
            }

            /* Check attributes, sanitize if necessary */
            _sanitizeAttributes(shadowNode);
        }

        /* Execute a hook if present */
        _executeHook('afterSanitizeShadowDOM', fragment, null); // No I18N
    };

    /**
     * _executeHook
     * Execute user configurable hooks
     *
     * @param  {String} entryPoint  Name of the hook's entry point
     * @param  {Node} currentNode
     */
    var _executeHook = function(entryPoint, currentNode, data) {
        if (!hooks[entryPoint]) {
            return;
        }

        hooks[entryPoint].forEach(function(hook) {
            hook.call(DOMPurify, currentNode, data, CONFIG);
        });
    };

    /**
     * sanitize
     * Public method providing core sanitation functionality
     *
     * @param {String|Node} dirty string or DOM node
     * @param {Object} configuration object
     */
    DOMPurify.sanitize = function(dirty, cfg) {
        var body, importedNode, currentNode, oldNode, nodeIterator, returnNode;
        /* Make sure we have a string to sanitize.
           DO NOT return early, as this will return the wrong type if
           the user has requested a DOM object rather than a string */
        if (!dirty) {
            dirty = '<!-->'; // No I18N
        }

        /* Stringify, in case dirty is an object */
        if (typeof dirty !== 'string' && !_isNode(dirty)) { // No I18N
            if (typeof dirty.toString !== 'function') { // No I18N
                throw new TypeError('toString is not a function'); // No I18N
            } else {
                dirty = dirty.toString();
            }
        }

        /* Check we can run. Otherwise fall back or ignore */
        if (!DOMPurify.isSupported) {
            if (typeof window.toStaticHTML === 'object' || // No I18N
                typeof window.toStaticHTML === 'function') { // No I18N
                if (typeof dirty === 'string') { // No I18N
                    return window.toStaticHTML(dirty);
                } else if (_isNode(dirty)) {
                    return window.toStaticHTML(dirty.outerHTML);
                }
            }
            return dirty;
        }

        /* Assign config vars */
        _parseConfig(cfg);

        /* Clean up removed elements */
        DOMPurify.removed = [];

        if (dirty instanceof Node) {
            /* If dirty is a DOM element, append to an empty document to avoid
               elements being stripped by the parser */
            body = _initDocument('<!-->'); // No I18N
            importedNode = body.ownerDocument.importNode(dirty, true);
            if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') { // No I18N
                /* Node is already a body, use as is */
                body = importedNode;
            } else {
                body.appendChild(importedNode);
            }
        } else {
            /* Exit directly if we have nothing to do */
            if (!RETURN_DOM && !WHOLE_DOCUMENT && dirty.indexOf('<') === -1) { // No I18N
                return dirty;
            }

            /* Initialize the document to work on */
            body = _initDocument(dirty);

            /* Check we have a DOM node from the data */
            if (!body) {
                return RETURN_DOM ? null : ''; // No I18N
            }
        }
        /* Remove first element node (ours) if FORCE_BODY is set */
        if (FORCE_BODY) {
            _forceRemove(body.firstChild);
        }
        /* Get node iterator */
        nodeIterator = _createIterator(body);
        /* Now start iterating over the created document */
        while ((currentNode = nodeIterator.nextNode())) {

            /* Fix IE's strange behavior with manipulated textNodes #89 */
            if (currentNode.nodeType === 3 && currentNode === oldNode) {
                continue;
            }

            /* Sanitize tags and elements */
            if (_sanitizeElements(currentNode)) {
                continue;
            }

            /* Shadow DOM detected, sanitize it */
            if (currentNode.content instanceof DocumentFragment) {
                _sanitizeShadowDOM(currentNode.content);
            }

            /* Check attributes, sanitize if necessary */
            _sanitizeAttributes(currentNode);

            oldNode = currentNode;
        }

        /* Return sanitized string or DOM */
        if (RETURN_DOM) {

            if (RETURN_DOM_FRAGMENT) {
                returnNode = createDocumentFragment.call(body.ownerDocument);

                while (body.firstChild) {
                    returnNode.appendChild(body.firstChild);
                }
            } else {
                returnNode = body;
            }

            if (RETURN_DOM_IMPORT) {
                /* adoptNode() is not used because internal state is not reset
                   (e.g. the past names map of a HTMLFormElement), this is safe
                   in theory but we would rather not risk another attack vector.
                   The state that is cloned by importNode() is explicitly defined
                   by the specs. */
                returnNode = importNode.call(originalDocument, returnNode, true);
            }

            return returnNode;
        }

        return WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    };

    /**
     * addHook
     * Public method to add DOMPurify hooks
     *
     * @param {String} entryPoint
     * @param {Function} hookFunction
     */
    DOMPurify.addHook = function(entryPoint, hookFunction) {
        if (typeof hookFunction !== 'function') { // No I18N
            return;
        }
        hooks[entryPoint] = hooks[entryPoint] || [];
        hooks[entryPoint].push(hookFunction);
    };

    /**
     * removeHook
     * Public method to remove a DOMPurify hook at a given entryPoint
     * (pops it from the stack of hooks if more are present)
     *
     * @param {String} entryPoint
     * @return void
     */
    DOMPurify.removeHook = function(entryPoint) {
        if (hooks[entryPoint]) {
            hooks[entryPoint].pop();
        }
    };

    /**
     * removeHooks
     * Public method to remove all DOMPurify hooks at a given entryPoint
     *
     * @param  {String} entryPoint
     * @return void
     */
    DOMPurify.removeHooks = function(entryPoint) {
        if (hooks[entryPoint]) {
            hooks[entryPoint] = [];
        }
    };

    /**
     * removeAllHooks
     * Public method to remove all DOMPurify hooks
     *
     * @return void
     */
    DOMPurify.removeAllHooks = function() {
        hooks = {};
    };

    return DOMPurify;
}));

/**
 * Custom Functions for Sanitizer
 **/

function addToSet(set, array) {
    var l = array.length;
    while (l--) {
        set[array[l]] = true;
    }
    return set;
};

function addObjsToSet(set, set2) {
    for (var each in set2) {
        if (set2.hasOwnProperty(each)) {
            set[each] = true;
        }
    }
    return set;
};

function removeFromSet(set, key) {
    var set2 = {};
    for (var eachKey in set) {
        if (set.hasOwnProperty(eachKey)) {
            if (eachKey != key) {
                set2[eachKey] = set[eachKey];
            }
        }
    }
    return set2;
}

/**
 * Sanitizer
 **/
;
(function(factory) {
    //Setting base configuration: Start---------------------------------------------------------
    var config = {};
    config.ALLOW_ARIA_ATTR = true;
    config.ALLOW_DATA_ATTR = true;
    config.ALLOW_UNKNOWN_PROTOCOLS = false;
    config.SAFE_FOR_JQUERY = false;
    config.SAFE_FOR_TEMPLATES = false;
    config.WHOLE_DOCUMENT = false;
    config.RETURN_DOM = false;
    config.RETURN_DOM_FRAGMENT = false;
    config.RETURN_DOM_IMPORT = false;
    config.FORCE_BODY = true;
    config.SANITIZE_DOM = true;
    config.KEEP_CONTENT = true;
    config.STYLE_VALIDATION = true;
    config.REMOVE_ONEVENTS = true;
    config.ALLOWED_STYLE = 'NONE' //Values can be either 'INLINE', 'INTERNAL', 'ALL', 'NONE' // No I18N
    config.ALLOWED_TAGS = "a|abbr|acronym|address|area|article|aside|audio|b|bdi|bdo|big|blink|blockquote|body|br|button|canvas|caption|center|cite|code|col|colgroup|content|data|datalist|dd|decorator|del|details|dfn|dir|div|dl|dt|element|em|fieldset|figcaption|figure|font|footer|form|h1|h2|h3|h4|h5|h6|head|header|hgroup|hr|html|i|img|input|ins|kbd|label|legend|li|main|map|mark|marquee|menu|menuitem|meter|nav|nobr|ol|optgroup|option|output|p|pre|progress|q|rp|rt|ruby|s|samp|section|select|shadow|small|source|spacer|span|strike|strong|sub|summary|sup|table|tbody|td|template|textarea|tfoot|th|thead|time|title|tr|track|tt|u|ul|var|video|wbr|#text".split("|"); // No I18N
    config.ALLOWED_ATTR = "accept|action|align|alt|autocomplete|background|bgcolor|border|cellpadding|cellspacing|checked|cite|class|clear|color|cols|colspan|coords|datetime|default|dir|disabled|download|enctype|face|for|headers|height|hidden|high|href|hreflang|id|ismap|label|lang|list|loop|low|max|maxlength|media|method|min|multiple|name|noshade|novalidate|nowrap|open|optimum|pattern|placeholder|poster|preload|pubdate|radiogroup|readonly|rel|required|rev|reversed|role|rows|rowspan|spellcheck|scope|selected|shape|size|span|srclang|start|src|step|summary|tabindex|title|target|type|usemap|valign|value|width|xmlns|sandbox".split("|"); // No I18N
    config.ALLOWED_STYLE_PROPS = "azimuth|background|background-attachment|background-color|background-image|background-position|content|background-repeat|border-collapse|border-color|border-top-color|border-right-color|border-bottom-color|border-left-color|bottom|caption-side|clear|color|cue-after|cue-before|direction|display|elevation|empty-cells|float|font-size|font-size-adjust|font-stretch|font-style|font-variant|font-weight|height|left|letter-spacing|line-height|list-style-image|list-style-position|list-style-type|marker-offset|max-height|max-width|min-height|min-width|orphans|outline-color|overflow|page-break-after|page-break-before|page-break-inside|pause-after|pause-before|pitch|pitch-range|position|richness|right|size|speak|speak-header|speak-numeral|speak-punctuation|speech-rate|stress|table-layout|text-indent|text-transform|top|unicode-bidi|vertical-align|visibility|volume|white-space|widows|width|word-spacing|border-style|border-top-style|border-right-style|border-bottom-style|border-left-style|border-top-width|border-right-width|border-bottom-width|border-left-width|border-width|margin|margin-top|margin-right|margin-bottom|margin-left|outline-style|outline-width|padding|padding-top|padding-right|padding-bottom|padding-left|border|border-top|border-right|border-bottom|border-left|cue|list-style|marks|outline|pause|text-decoration|border-spacing|clip|counter-increment|clip|cursor|text-shadow|font|font-family|page|play-during|text-align|voice-family".split("|"); // No I18N
    config.FORBID_TAGS = []; //Add any forbidden tags here
    config.FORBID_ATTR = []; //Add any forbidden attrs here

    config.ALLOWED_TAGS_OBJ = {}; //Do not change.
    config.ALLOWED_ATTR_OBJ = {}; //Do not change.
    config.FORBID_TAGS_OBJ = {}; //Do not change.
    config.FORBID_ATTR_OBJ = {}; //Do not change.

    config.ADD_URI_SAFE_ATTR = [];
    config.EXTENDS = ["GLOBAL_ATTRIBUTES", "GLOBAL_TAGS", "FORBID_TAGS", "FORBID_ATTR", "GLOBAL_APPEND_ATTRIBUTES", "GLOBAL_ATTRIBUTE_RULES", "ADD_URI_SAFE_ATTR", "TAG_RULES"]; // No I18N
    config.TAG_RULES = {
        "a" : { // No I18N
            "APPEND_ATTRIBUTES" : [{ // No I18N
                "NAME": "rel", // No I18N
                "VALUE": "noopener noreferrer", // No I18N
                "CRITERIA": [{ // No I18N
                    "NAME": "target", // No I18N
                    "CONTAINS": "_blank" // No I18N
                }]
            }]
        }
    };
    config.GLOBAL_APPEND_ATTRIBUTES = [];
    config.GLOBAL_ATTRIBUTE_RULES = {};
    // Setting base configuration: End-----------------------------------------------------------

    ZSEC.util.defineProperty(ZSEC, 'HTMLPurifier', factory(config, DOMPurify(window)), true, false, false, true); // No I18N
    delete window.DOMPurify; //We are deleting the base DOMPurify Instance

}(function factory(config, DOM) {
    var defaultForbiddenTags        = addToSet({}, ['script']); // No I18N
    var defaultForbiddenAttr        = addToSet({}, []);

    var allowedConfigArray          = ['ALLOW_ARIA_ATTR', 'ALLOW_DATA_ATTR', 'ALLOW_UNKNOWN_PROTOCOLS', 'SAFE_FOR_JQUERY', 'SAFE_FOR_TEMPLATES', 'WHOLE_DOCUMENT', 'RETURN_DOM', 'RETURN_DOM_FRAGMENT', 'RETURN_DOM_IMPORT', 'FORCE_BODY', 'SANITIZE_DOM', 'KEEP_CONTENT', 'ALLOWED_STYLE_PROPS']; // No I18N
    var inheritableConfigArray      = ['ALLOWED_TAGS', 'ALLOWED_ATTR', 'FORBID_TAGS', 'FORBID_ATTR']; // No I18N
    var inheritableConfigObjArray   = ['ALLOWED_TAGS_OBJ', 'ALLOWED_ATTR_OBJ', 'FORBID_TAGS_OBJ', 'FORBID_ATTR_OBJ']; // No I18N
    var otherExtendableConfigArray  = ["ADD_URI_SAFE_ATTR", "GLOBAL_APPEND_ATTRIBUTES", "GLOBAL_ATTRIBUTE_RULES", "TAG_RULES"]; // No I18N
    var allowedConfig               = addToSet({}, allowedConfigArray);
    var inheritableConfig           = addToSet({}, inheritableConfigArray);
    var inheritableConfigObj        = addToSet({}, inheritableConfigObjArray);
    var otherExtendableConfig       = addToSet({}, otherExtendableConfigArray);
        otherExtendableConfig       = addToSet(otherExtendableConfig, inheritableConfigArray);
        otherExtendableConfig       = addToSet(otherExtendableConfig, inheritableConfigObjArray);
    var allConfigFlags              = addToSet({}, allowedConfigArray.concat(["STYLE_VALIDATION", "ALLOWED_STYLE", "EXTENDS", "REMOVE_ONEVENTS", "GLOBAL_ATTRIBUTES", "GLOBAL_TAGS"], inheritableConfigArray, inheritableConfigObjArray, otherExtendableConfigArray)); // No I18N

    var defaultTagRules = {
        "iframe": { // No I18N
            "NAME": "iframe", // No I18N
            "ATTRIBUTE_RULES": { // No I18N
                "sandbox": { // No I18N
                    "NAME": "sandbox", // No I18N
                    "NOT_CONTAINS": ["allow-top-navigation", "allow-popups-to-escape-sandbox"], // No I18N
                    "DEFAULT_VALUE": "allow-popups allow-forms allow-scripts allow-same-origin" // No I18N
                }
            },
            "APPEND_ATTRIBUTES": [{ // No I18N
                "NAME": "sandbox", // No I18N
                "VALUE": "allow-popups allow-forms allow-scripts allow-same-origin" // No I18N
            }]
        }
    };

    var emptyBlockFiller = false; //Hack-fix for git preventing empty blocks in code
    var altered;

    // List of CSS Properties allowed when config["STYLE"] is set as "VALIDATE" // No I18N
    var allowedStyleProps = addToSet({}, config.ALLOWED_STYLE_PROPS);

    // This is to parse the additionalConfigurations that are passed while calling the sanitize function.
    // It returns the configuration that is sent to the sanitizer function.
    function parseConfig(cfg) {
        if (!cfg || cfg.constructor !== Object) {
            return config;
        }
        var customConfig = {};
        for (var each in config) {
            if (config.hasOwnProperty(each)) {
                if (each in cfg) {
                    if (each in allowedConfig) {
                        if (cfg[each] == true || cfg[each] == false) {
                            customConfig[each] = cfg[each];
                        } else {
                            customConfig[each] = config[each];
                        }
                    }
                } else {
                    customConfig[each] = config[each];
                }
            }
        }
        if (customConfig.SAFE_FOR_TEMPLATES) {
            customConfig.ALLOW_DATA_ATTR = false;
        }
        if (customConfig.RETURN_DOM_FRAGMENT) {
            customConfig.RETURN_DOM = true;
        }
        if (customConfig.KEEP_CONTENT) {
            customConfig.ALLOWED_TAGS_OBJ['#text'] = true; // No I18N
        }

        return customConfig;
    }

    //The below function is necessary for properly adding the style validation hook
    function validateStyles(styles) {
        // Validate regular CSS properties
        for (var property in styles) {
            if(styles.hasOwnProperty(property) && styles[property].constructor == String) {
                if (styles[property] && allowedStyleProps[property]) {
                    //Add additional Validations here
                    emptyBlockFiller = true;
                } else if (styles[property]) {
                    if (property != 'cssText' && !/^\d.*/.test(property)) { // No I18N
                        styles[property] = ''; // No I18N
                        altered = true;
                    }
                }
            }
        }
    }

    //The cssRules.type determines whether it is a Media Query, KeyFrames Query, Regular CSS Query
    // https://developer.mozilla.org/en-US/docs/Web/API/CSSRule
    //The below function is necessary for properly adding the style validation hook
    function validateStyleSheet(cssStyleSheet) {
        for (var index = cssStyleSheet.length - 1; index >= 0; index--) {
            var rule = cssStyleSheet[index];
            if ((rule.type == 1 && rule.selectorText) || (rule.type == 8 && rule.keyText)) {
                if (rule.style) {
                    validateStyles(rule.style)
                }
            } else if ((rule.type == 4 || rule.type == 7) && rule.cssRules) {
                validateStyleSheet(rule.cssRules);
            }
        }
    }

    //The below function is necessary for properly adding the style validation hook
    function copyValidatedStyleSheet(output, cssStyleSheet) {
        for (var index = cssStyleSheet.length - 1; index >= 0; index--) {
            if (cssStyleSheet[index].type == 1 || cssStyleSheet[index].type == 4 || cssStyleSheet[index].type == 7) {
                output.push(cssStyleSheet[index].cssText);
            }
        }
    }

    //isValidAttributes the given value with the rules in the given criteria object.
    //Returns either true or false
    //All criteria must be satisfied to return true (AND condition)
    function isValidAttribute(criteria, node, isMandatory) {
        var isMandatory = isMandatory == undefined ? criteria.IS_MANDATORY : isMandatory;

        if (criteria.NAME && !node.hasAttribute(criteria.NAME.toLowerCase())) {
            return criteria.IS_FORBIDDEN || !isMandatory;
        }
        if (criteria.IS_FORBIDDEN) {
            return false;
        }
        var value = node.getAttribute(criteria.NAME.toLowerCase());
        if (value === undefined || value === null) {
            value = "";
        }
        if (value.constructor == String) {
            if(!criteria.DONT_TRIM){
                value = value.trim();
            }

            var caseSensitive = criteria.CASE_SENSITIVE || false;
            if (!caseSensitive) {
                value = value.toLowerCase();
            }
            if (criteria.MAX_LENGTH && value.length > criteria.MAX_LENGTH) {
                return false;
            }
            if (criteria.MIN_LENGTH && value.length < criteria.MIN_LENGTH) {
                return false;
            }
            if (criteria.REGEX != undefined){
                if(criteria.REGEX.constructor == RegExp && value.search(criteria.REGEX) == -1) {
                    return false;
                } else if(criteria.REGEX.constructor == Array){
                    for(var i = 0; i < criteria.REGEX.length; i++){
                        if(value.search(criteria.REGEX[i]) == -1){
                            return false;
                        }
                    }
                }
            }
        }
        if (criteria.LIST && criteria.LIST.indexOf(value) == -1) {
            return false;
        }
        if (criteria.TYPE == "INTEGER" || criteria.TYPE == "FLOAT") {
            var tempValue;
            try {
                tempValue = criteria.TYPE == "INTEGER" ? window.parseInt(value, 10) : window.parseFloat(value); // No I18N
            } catch (e) {
                return false;
            }
            if (window.isNaN(tempValue)) {
                return false;
            }
            if ((criteria.GREATER_THAN != undefined) && tempValue <= criteria.GREATER_THAN) {
                return false;
            }
            if ((criteria.GREATER_THAN_OR_EQUAL != undefined) && tempValue < criteria.GREATER_THAN_OR_EQUAL) {
                return false;
            }
            if ((criteria.LESSER_THAN != undefined) && tempValue >= criteria.LESSER_THAN) {
                return false;
            }
            if ((criteria.LESSER_THAN_OR_EQUAL != undefined) && tempValue > criteria.LESSER_THAN_OR_EQUAL) {
                return false;
            }
            if ((criteria.EQUAL != undefined) && tempValue != criteria.EQUAL) {
                return false;
            }
            if ((criteria.NOT_EQUAL != undefined) && tempValue == criteria.NOT_EQUAL) {
                return false;
            }
        } else if (value.constructor == String) {
            if (criteria.STARTS_WITH != undefined && value.indexOf(criteria.STARTS_WITH) != 0) {
                return false;
            }
            if (criteria.ENDS_WITH != undefined && value.lastIndexOf(criteria.ENDS_WITH) != (value.length - criteria.ENDS_WITH.length)) {
                return false;
            }
            if (criteria.CONTAINS != undefined){
                if(criteria.CONTAINS.constructor == String && value.indexOf(criteria.CONTAINS) == -1) {
                    return false;
                } else if(criteria.CONTAINS.constructor == Array){
                    for(var i = 0; i < criteria.CONTAINS.length; i++){
                        if(value.indexOf(criteria.CONTAINS[i]) == -1){
                            return false;
                        }
                    }
                }
            }
            if (criteria.NOT_CONTAINS != undefined){
                if(criteria.NOT_CONTAINS.constructor == String && value.indexOf(criteria.NOT_CONTAINS) > -1) {
                    return false;
                } else if(criteria.NOT_CONTAINS.constructor == Array){
                    for(var i = 0; i < criteria.NOT_CONTAINS.length; i++){
                        if(value.indexOf(criteria.NOT_CONTAINS[i]) > -1){
                            return false;
                        }
                    }
                }
            }
            if (criteria.EQUAL != undefined && value !== criteria.EQUAL) {
                return false;
            }
            if (criteria.NOT_EQUAL != undefined && value === criteria.NOT_EQUAL) {
                return false;
            }
        }
        return true;
    }

    // Helper functions to normalize the given sanitizer configuration
    function caseSensitivityNormalizerForAttributeRules(config) {
        if (!config) {
            return config;
        }
        if (config.constructor == Object) {
            for (var key in config) {
                if (config.hasOwnProperty(key)) {
                    config[key] = configCaseSensitivityNormalizer(config[key]);
                }
            }
        }
        return config;
    }

    function caseSensitivityNormalizerForAppendAttributes(config) {
        if (!config) {
            return config;
        }
        if (config.constructor == Array) {
            for (var i = 0; i < config.length; i++) {
                if (config[i].CRITERIA) {
                    for (var j = 0; j < config[i].CRITERIA.length; j++) {
                        config[i].CRITERIA[j] = configCaseSensitivityNormalizer(config[i].CRITERIA[j]);
                    }
                }
            }
        }
        return config;
    }

    function configCaseSensitivityNormalizer(config) {
        if (config) {
            var flags = ["STARTS_WITH", "ENDS_WITH", "CONTAINS", "EQUAL", "NOT_EQUAL", "LIST"]; // No I18N
            var caseSensitive = config.CASE_SENSITIVE || false;
            if (!caseSensitive) {
                for (var j = 0; j < flags.length; j++) {
                    var eachFlag = flags[j];
                    if (config[eachFlag]) {
                        config[eachFlag] = toLowerCaseValue(config[eachFlag]);
                    }
                }
            }
        }
        return config;
    }

    function toLowerCaseValue(value) {
        if (value && value.constructor == String) {
            return value.toLowerCase();
        } else if (value.constructor == Array) {
            for (var i = 0; i < value.length; i++) {
                value[i] = toLowerCaseValue(value[i]);
            }
        }
        return value;
    }

    function toMap(list, key) {
        if (!list || list.constructor == Object) {
            return list;
        }
        var res = {};
        for (var i = 0; i < list.length; i++) {
            var each = list[i];
            res[each[key]] = each;
        }
        return res;
    }

    function appendAttributes(appendConfig, node) {
        if (!appendConfig) {
            return;
        }
        for (var i = 0; i < appendConfig.length; i++) {
            var element = appendConfig[i];
            if (!node.hasAttribute(element.NAME.toLowerCase())) {
                var conditionSatisfied = true;
                if (element.CRITERIA) {
                    for (var j = 0; j < element.CRITERIA.length; j++) {
                        if (!isValidAttribute(element.CRITERIA[j], node, true)) {
                            conditionSatisfied = false;
                            break;
                        }
                    }
                }
                if (conditionSatisfied) {
                    node.setAttribute(element.NAME, element.VALUE);
                } else if (element.DEFAULT_VALUE != undefined) {
                    node.setAttribute(element.NAME, element.DEFAULT_VALUE);
                }
            }
        }
    }

    function extendTagRules(child, parent) {
        if (!parent || parent.constructor !== Object) {
            return child;
        }
        if (!child || child.constructor !== Object) {
            return parent;
        }
        for (var eachTagRule in parent) {
            if (parent.hasOwnProperty(eachTagRule) && eachTagRule in child) {
                if (child[eachTagRule].APPEND_ATTRIBUTES == undefined) {
                    child[eachTagRule].APPEND_ATTRIBUTES = parent[eachTagRule].APPEND_ATTRIBUTES;
                }
                if (child[eachTagRule].ATTRIBUTE_RULES == undefined) {
                    child[eachTagRule].ATTRIBUTE_RULES = parent[eachTagRule].ATTRIBUTE_RULES;
                }
            } else {
                child[eachTagRule] = parent[eachTagRule];
            }
        }
        return child;
    }

    function validateAttribute(node, validationConf, name) {
        if (validationConf && !isValidAttribute(validationConf, node)) {

            // Default Action will be "REMOVE_ATTRIBUTE" if no DEFAULT_VALUE is specified.
            // YET TO BE RELEASED:
            //
            // TODO: Check if ELEMENT can be removed
            // Also check if KEEP_CONTENT will be applied on element content
            //
            // One possible implementation is to take text content of the element,
            // create a new text node with the text content, link the previous
            // and next elements with this new element(insert the new element next to
            // the old element) and remove old element.

            if(validationConf.DEFAULT_VALUE !== undefined) {
                node.setAttribute(name, validationConf.DEFAULT_VALUE);
            } else {
                node.removeAttribute(name);
            }
            return false;
        }
        return true;
    }

    // Main initializer function. This is first called while setting value to ZSEC.HTMLPurifier, and thenduring all new sanitizer instance creation
    function initialize() {
        config.FORBID_TAGS_OBJ = addObjsToSet(config.FORBID_TAGS_OBJ, defaultForbiddenTags);
        config.FORBID_ATTR_OBJ = addObjsToSet(config.FORBID_ATTR_OBJ, defaultForbiddenAttr);

        for (var eachInheritableConfig in inheritableConfig) {
            if(inheritableConfig.hasOwnProperty(eachInheritableConfig)){
                config[eachInheritableConfig + "_OBJ"] = addToSet(config[eachInheritableConfig + "_OBJ"], config[eachInheritableConfig]) // No I18N
            }
        }

        //Clears any existing Hooks
        DOM.removeAllHooks();
        altered = false;

        //Hooks for Style Validation
        if (config.ALLOWED_STYLE == "NONE") { // No I18N
            config.FORBID_TAGS_OBJ = addToSet(config.FORBID_TAGS_OBJ, ['style']); // No I18N
            config.FORBID_ATTR_OBJ = addToSet(config.FORBID_ATTR_OBJ, ['style']); // No I18N
        }
        if (config.ALLOWED_STYLE == "INLINE" || config.ALLOWED_STYLE == "ALL") { // No I18N
            if (config.STYLE_VALIDATION) {
                // Hook to enforce CSS attribute sanitization
                DOM.addHook('afterSanitizeAttributes', function(node) { // No I18N
                    // Hack fix for baseURI + CSS problems in Chrome
                    if (!node.ownerDocument.baseURI) {
                        var base = document.createElement('base'); // No I18N
                        base.href = document.baseURI;
                        node.ownerDocument.head.appendChild(base);
                    }
                    // Check all style attribute values and validate them
                    if (node.hasAttribute('style')) { // No I18N
                        var output = ''; // No I18N
                        altered = false;
                        validateStyles(node.style);

                        if (altered) {
                            output = node.style.cssText;
                        } else {
                            output = node.getAttribute('style'); // No I18N
                        }

                        // re-add styles in case any are left
                        if (output.length) {
                            node.setAttribute('style', output); // No I18N
                        } else {
                            node.removeAttribute('style'); // No I18N
                        }
                    }
                });
            }
            if (config.ALLOWED_STYLE == "INLINE") { // No I18N
                config.FORBID_TAGS_OBJ = addToSet(config.FORBID_TAGS_OBJ, ['style']); // No I18N
                config.FORBID_ATTR_OBJ = removeFromSet(config.FORBID_ATTR_OBJ, 'style'); // No I18N

            }
        }
        if (config.ALLOWED_STYLE == "INTERNAL" || config.ALLOWED_STYLE == "ALL") { // No I18N
            if (config.STYLE_VALIDATION) {
                // Hook to enforce CSS Element sanitization
                DOM.addHook('uponSanitizeElement', function(node, data) { // No I18N
                    if (data.tagName === 'style') { // No I18N
                        if (node.sheet != null) {
                            var styleSheet = node.sheet.cssRules;
                            altered = false;
                            validateStyleSheet(styleSheet);
                            if (altered) {
                                var output = [];
                                copyValidatedStyleSheet(output, styleSheet);
                                node.textContent = output.join("\n"); // No I18N
                            }
                        }
                    }
                });
            }
            if (config.ALLOWED_STYLE == "INTERNAL") { // No I18N
                config.FORBID_ATTR_OBJ = addToSet(config.FORBID_ATTR_OBJ, ['style']); // No I18N
                config.FORBID_TAGS_OBJ = removeFromSet(config.FORBID_TAGS_OBJ, 'style'); // No I18N
            }
        }
        if (config.ALLOWED_STYLE == "ALL") { // No I18N
            config.FORBID_TAGS_OBJ = removeFromSet(config.FORBID_TAGS_OBJ, 'style'); // No I18N
            config.FORBID_ATTR_OBJ = removeFromSet(config.FORBID_ATTR_OBJ, 'style'); // No I18N
        }

        // Hook to set 'GLOBAL_ATTRIBUTE_RULES' rules
        if (config.GLOBAL_ATTRIBUTE_RULES || config.TAG_RULES) {
            DOM.addHook('afterSanitizeAttributes', function(node) { // No I18N
                var nodeName = node.nodeName.toLowerCase();
                var globalAttributeRule = config.GLOBAL_ATTRIBUTE_RULES;
                var tagAttributeRule = config.TAG_RULES && config.TAG_RULES[nodeName] && config.TAG_RULES[nodeName].ATTRIBUTE_RULES;
                var defaultTagAttributeRule = defaultTagRules && defaultTagRules[nodeName] && defaultTagRules[nodeName].ATTRIBUTE_RULES;

                var l = node.attributes.length;
                while (l--) {
                    var name = node.attributes[l].name;
                    var validationConf = tagAttributeRule && tagAttributeRule[name] || globalAttributeRule && globalAttributeRule[name];
                    if(validateAttribute(node, validationConf, name))
                    {
                        validateAttribute(node, defaultTagAttributeRule && defaultTagAttributeRule[name], name);
                    }
                }

            });
        }

        //Hook to set 'GLOBAL_APPEND_ATTRIBUTES' rules // No I18N
        if (config.GLOBAL_APPEND_ATTRIBUTES || config.TAG_RULES) {
            DOM.addHook('afterSanitizeAttributes', function(node) { // No I18N
                var name = node.nodeName.toLowerCase();
                appendAttributes(config.TAG_RULES && config.TAG_RULES[name] && config.TAG_RULES[name].APPEND_ATTRIBUTES, node);
                appendAttributes(config.GLOBAL_APPEND_ATTRIBUTES, node);
                appendAttributes(defaultTagRules && defaultTagRules[name] && defaultTagRules[name].APPEND_ATTRIBUTES, node);
            });
        }

        // Hook to remove all 'on' events
        if (config.REMOVE_ONEVENTS) {
            DOM.addHook('uponSanitizeAttribute', function(node, hookEvent) { // No I18N
                if (hookEvent.attrName.indexOf("on") == 0) {
                    hookEvent.keepAttr = false;
                }
            });
        }
    }

    //Validate the Configuration given by the user when creating a new sanitizer instance. This attaches any missing, but required, flags/params.
    function validateUserConfig(conf) {
        if (typeof conf == "object") { // No I18N

            /*
             * We tried to encode template content using the below 4 lines.
             * But it lead to double encoding issue because the value is inserted
             * using textContent but it is returned using innerHTML/outerHTML
             *
             * We do not have a solution to this issue as of now, so dropping support for this
             *
             * CODE:
             * value = value.replace(/\{\{/g,"&#x7b;&#x7b;"); // No I18N
             * value = value.replace(/\}\}/g,"&#x7d;&#x7d;"); // No I18N
             * value = value.replace(/<%/g,"&lt;&#x25;"); // No I18N
             * value = value.replace(/%>/g,"&#x25;&gt;"); // No I18N
             *
             */

            //Extending any configurations that may have been missed out

            conf.ALLOWED_TAGS = conf.GLOBAL_TAGS;
            conf.ALLOWED_ATTR = conf.GLOBAL_ATTRIBUTES;

            for (var eachFlag in allConfigFlags) {
                if (allConfigFlags.hasOwnProperty(eachFlag) && (conf[eachFlag] == undefined) && !(eachFlag in otherExtendableConfig)) {
                    conf[eachFlag] = config[eachFlag];
                }
            }

            conf.TAG_RULES = toMap(conf.TAG_RULES, "NAME"); // No I18N
            if (conf.TAG_RULES && conf.TAG_RULES.constructor == Object) {
                for (var tagName in conf.TAG_RULES) {
                    if(conf.TAG_RULES.hasOwnProperty(tagName)){
                        var tagRule = conf.TAG_RULES[tagName];
                        tagRule.ATTRIBUTE_RULES = caseSensitivityNormalizerForAttributeRules(toMap(tagRule.ATTRIBUTE_RULES, "NAME")); // No I18N
                        tagRule.APPEND_ATTRIBUTES = caseSensitivityNormalizerForAppendAttributes(tagRule.APPEND_ATTRIBUTES);
                    }
                }
            }
            conf.GLOBAL_ATTRIBUTE_RULES = caseSensitivityNormalizerForAttributeRules(toMap(conf.GLOBAL_ATTRIBUTE_RULES, "NAME")); // No I18N
            conf.GLOBAL_APPEND_ATTRIBUTES = caseSensitivityNormalizerForAppendAttributes(conf.GLOBAL_APPEND_ATTRIBUTES);

            if (conf.EXTENDS) {
                for (var i = 0; i < conf.EXTENDS.length; i++) {
                    var eachExtendConfig = conf.EXTENDS[i];
                    if (eachExtendConfig == "GLOBAL_TAGS") {
                        eachExtendConfig = "ALLOWED_TAGS"; // No I18N
                    }
                    if (eachExtendConfig == "GLOBAL_ATTRIBUTES") {
                        eachExtendConfig = "ALLOWED_ATTR"; // No I18N
                    }
                    switch (eachExtendConfig) {
                        case "ALLOWED_TAGS": // No I18N
                        case "ALLOWED_ATTR": // No I18N
                        case "FORBID_TAGS": // No I18N
                        case "FORBID_ATTR": // No I18N
                            eachExtendConfig += "_OBJ"; // No I18N
                            conf[eachExtendConfig] = {};
                            if (config[eachExtendConfig]) {
                                conf[eachExtendConfig] = addObjsToSet(conf[eachExtendConfig], config[eachExtendConfig]);
                            }
                            break;

                        case "ADD_URI_SAFE_ATTR": // No I18N
                        case "GLOBAL_APPEND_ATTRIBUTES": // No I18N
                            if (!conf[eachExtendConfig]) {
                                conf[eachExtendConfig] = [];
                            }
                            if (!config[eachExtendConfig] || config[eachExtendConfig].constructor !== Array){
                                break;
                            }
                            conf[eachExtendConfig] = conf[eachExtendConfig].concat(config[eachExtendConfig]);
                            break;

                        case "GLOBAL_ATTRIBUTE_RULES": // No I18N
                            if (!conf.GLOBAL_ATTRIBUTE_RULES) {
                                conf.GLOBAL_ATTRIBUTE_RULES = {};
                            }
                            if (config.GLOBAL_ATTRIBUTE_RULES && config.GLOBAL_ATTRIBUTE_RULES.constructor == Object) {
                                for (var eachAttributeRule in config.GLOBAL_ATTRIBUTE_RULES) {
                                    if (config.GLOBAL_ATTRIBUTE_RULES.hasOwnProperty(eachAttributeRule) && !conf.GLOBAL_ATTRIBUTE_RULES[eachAttributeRule]) {
                                        conf.GLOBAL_ATTRIBUTE_RULES[eachAttributeRule] = config.GLOBAL_ATTRIBUTE_RULES[eachAttributeRule]; // TODO: Clone the object instead of copying reference
                                    }
                                }
                            }
                            break;

                        case "TAG_RULES": // No I18N
                            if (!conf.TAG_RULES) {
                                conf.TAG_RULES = {};
                            }
                            conf.TAG_RULES = extendTagRules(conf.TAG_RULES, config.TAG_RULES)
                            break;
                    }
                }
            }

            for (var eachInheritableConfig in inheritableConfig) {
                //Set all inheritable configuration objects(ALLOWED_ATTR_OBJ,ALLOWED_TAGS_OBJ,etc.) in the configuration to an empty Object
                if(inheritableConfig.hasOwnProperty(eachInheritableConfig)){
                    if (!conf[eachInheritableConfig + "_OBJ"]) {
                        conf[eachInheritableConfig + "_OBJ"] = {}; // No I18N
                    }
                    if (conf[eachInheritableConfig] != undefined) {
                        if (conf[eachInheritableConfig].constructor === Array) {
                            conf[eachInheritableConfig + "_OBJ"] = addToSet(conf[eachInheritableConfig + "_OBJ"], conf[eachInheritableConfig])
                        }
                    } else { //If the inheritable array is not present in configuration
                        conf[eachInheritableConfig] = [];
                    }
                }
            }

            for (var k = 0; k < otherExtendableConfigArray.length; k++) {
                var eachOtherExtendableConfig = otherExtendableConfigArray[k];
                if (!conf[eachOtherExtendableConfig]) {
                    conf[eachOtherExtendableConfig] = [];
                }
            }

            if (conf.ALLOWED_STYLE == "ALL") { // No I18N
                conf.FORBID_TAGS_OBJ = removeFromSet(conf.FORBID_TAGS_OBJ, 'style'); // No I18N
                conf.FORBID_ATTR_OBJ = removeFromSet(conf.FORBID_ATTR_OBJ, 'style'); // No I18N
                conf.ALLOWED_TAGS_OBJ = addToSet(conf.ALLOWED_TAGS_OBJ, ['style']); // No I18N
                conf.ALLOWED_ATTR_OBJ = addToSet(conf.ALLOWED_ATTR_OBJ, ['style']); // No I18N
            } else if (conf.ALLOWED_STYLE == "INLINE") { // No I18N
                conf.FORBID_ATTR_OBJ = removeFromSet(conf.FORBID_ATTR_OBJ, 'style'); // No I18N
                conf.ALLOWED_ATTR_OBJ = addToSet(conf.ALLOWED_ATTR_OBJ, ['style']); // No I18N
                conf.FORBID_TAGS_OBJ = addToSet(conf.FORBID_TAGS_OBJ, ['style']); // No I18N
                conf.ALLOWED_TAGS_OBJ = removeFromSet(conf.ALLOWED_TAGS_OBJ, 'style'); // No I18N
            } else if (conf.ALLOWED_STYLE == "INTERNAL") { // No I18N
                conf.FORBID_TAGS_OBJ = removeFromSet(conf.FORBID_TAGS_OBJ, 'style'); // No I18N
                conf.ALLOWED_TAGS_OBJ = addToSet(conf.ALLOWED_TAGS_OBJ, ['style']); // No I18N
                conf.FORBID_ATTR_OBJ = addToSet(conf.FORBID_ATTR_OBJ, ['style']); // No I18N
                conf.ALLOWED_ATTR_OBJ = removeFromSet(conf.ALLOWED_ATTR_OBJ, 'style');  // No I18N
            } else if (conf.ALLOWED_STYLE == "NONE") { // No I18N
                conf.FORBID_TAGS_OBJ = addToSet(conf.FORBID_TAGS_OBJ, ['style']); // No I18N
                conf.FORBID_ATTR_OBJ = addToSet(conf.FORBID_ATTR_OBJ, ['style']); // No I18N
                conf.ALLOWED_TAGS_OBJ = removeFromSet(conf.ALLOWED_TAGS_OBJ, 'style'); // No I18N
                conf.ALLOWED_ATTR_OBJ = removeFromSet(conf.ALLOWED_ATTR_OBJ, 'style'); // No I18N
            }

            //Push all values in inheritable objects to the inheritable arrays
            //Again, once array is complete and up-to-date, copy the values from the inheritable arrays to the inheritable objects
            for (var eachInheritableConfigFlag in inheritableConfig) {
                if(inheritableConfig.hasOwnProperty(eachInheritableConfigFlag)){
                    for (var eachInheritableConfigObjKey in conf[eachInheritableConfigFlag + "_OBJ"]) { // No I18N
                        if(conf[eachInheritableConfigFlag + "_OBJ"].hasOwnProperty(eachInheritableConfigObjKey)){
                            conf[eachInheritableConfigFlag].push(eachInheritableConfigObjKey);
                        }
                    }
                    conf[eachInheritableConfigFlag + "_OBJ"] = addToSet(conf[eachInheritableConfigFlag + "_OBJ"], conf[eachInheritableConfigFlag]); // No I18N
                }
            }

            // Do any additional validations if it is present
            if (ZSEC.configValidator) {
                ZSEC.configValidator.HTMLPurifierValidation(conf, allConfigFlags, inheritableConfig, defaultForbiddenTags, defaultForbiddenAttr);
            }
        }

        //If no user configuration object is supplied, create a configuration with the default values
        else {
            conf = {};
            for (var each in config) {
                if(config.hasOwnProperty(each)){
                    conf[each] = config[each].valueOf();
                }
            }
        }
        return conf;
    }

    initialize();

    //Function to create new sanitizer instance based on the configuration
    var HTMLPurifier = function(conf) {
        conf = validateUserConfig(conf);
        return factory(conf, DOM(window));
    };


    //Function to sanitize the dirty content
    var sanitize = function(dirty, cfg) {
        var customConfig = parseConfig(cfg);
        var result = DOM.sanitize(dirty, customConfig);
        HTMLPurifier.removed = DOM.removed;
        return result;
    };

    HTMLPurifier.isSupported = DOM.isSupported;
    HTMLPurifier.removed = "";
    ZSEC.util.defineProperty(HTMLPurifier, 'sanitize', sanitize, false, false, true); // No I18N

    return HTMLPurifier;
}));