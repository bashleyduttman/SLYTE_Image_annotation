//$Id$

/**
 * @author: Patrick-2626 & Vigneshwar-5036
 *
 * @wiki: https://intranet.wiki.zoho.com/security/client-side-security.html
 *
 * Reference
 *  1)https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/
 *  2)https://github.com/danielstjules/blankshield
 */
'use strict'; // No I18N

if (!window.ZSEC) {
    Object.defineProperty(window, "ZSEC", { // No I18N
        value: {},
        writable: false,
        configurable: false,
        enumerable: false
    });
}
Object.defineProperty(ZSEC, "util", { // No I18N
    value: {},
    writable: false,
    configurable: false,
    enumerable: false
});

/**
 * polyfill
 * */

/**
 * below function will define Object.defineProperty if not defined.
 * Normal property addition through assignment(=) creates properties. But it show up during property enumeration (for...in loop or Object.keys method), whose values may be changed or deleted.
 * And it may even create some unusual behaviour
 * The Object.defineProperty method allows three extra details(configurable,writable, and enumerable) to be set for the value. By default all the value are true.
 * since defineProperty is not supported below IE-9 we have implemented fallback to directly assign value to the object
 * */


(function() {
    if (!Object.defineProperty || !(function() {
            try {
                Object.defineProperty({}, 'x', {}); // No I18N
                return true;
            } catch (e) {
                return false;
            }
        }())) {
        var orig = Object.defineProperty;
        Object.defineProperty = function(o, prop, desc) {
            // IE8 supports Object.defineProperty but only to be used on DOM objects. Using the same for native objects throws an error. hence trying built-in implementation if there are no exception.

            if (orig) {
                try {
                    return orig(o, prop, desc);
                } catch (e) {}
            }

            if (o !== Object(o)) {
                throw TypeError("Object.defineProperty called on non-object"); // No I18N
            }
            if (Object.prototype.__defineGetter__ && ('get' in desc)) { // No I18N
                Object.prototype.__defineGetter__.call(o, prop, desc.get);
            }
            if (Object.prototype.__defineSetter__ && ('set' in desc)) { // No I18N
                Object.prototype.__defineSetter__.call(o, prop, desc.set);
            }
            if ('value' in desc) { // No I18N
                o[prop] = desc.value;
            }
            return o;
        };
    }
}());


/**
 * it's a wrapper over Object.defineProperty for setting  data descriptors for object .A data descriptor is a property that has a value, which sets isWritable,isConfigurable,isEnumerable for an object. By default all configuration values are false.
 *
 * @param   {Object} obj
 * @param   {string} property
 * @param   {value}  value
 * @param   {boolean}  isOverrideDefaultValue
 * @param   {boolean}  isWritable
 * @param   {boolean}  isConfigurable
 * @param   {boolean}  isEnumerable
 * @returns {Object}
 */

ZSEC.util.defineProperty = function ZSECDefineProperty(obj, property, value, isOverrideDefaultValue, isWritable, isConfigurable, isEnumerable) {
    if (!isOverrideDefaultValue && property in obj) {
        return;
    }
    isWritable = isWritable == true;
    isConfigurable = isConfigurable == true;
    isEnumerable = isEnumerable == true;
    return Object.defineProperty(obj, property, {
        value: value,
        writable: isWritable,
        configurable: isConfigurable,
        enumerable: isEnumerable
    });
}

//initializing ZSEC values
ZSEC.util.defineProperty(ZSEC, 'version', "4.0", true); // No I18N
ZSEC.util.defineProperty(ZSEC, 'constants', ZSEC.constants || {}, true); // No I18N


/**
 * Array.indexOf function is not supported below IE-9 .
 * since defineProperty also is not supported below IE-9, And since there are many use cases where service teams are using property enumeration (for...in loop) for Arrays (which is not recommended)
 * the Array.indexOf function is stored in the variable(ZSEC.util.ArrayIndexOf) instead of assigning it directly to Array.prototype. And later it is called using ZSEC.util.ArrayIndexOf.call(params...)
 * */
ZSEC.util.ArrayIndexOf = Array.prototype.indexOf;
if (!ZSEC.util.ArrayIndexOf) {
    ZSEC.util.ArrayIndexOf = function(searchElement) {
        if (this === void 0 || this === null) {
            throw TypeError();
        }

        var t = Object(this);
        var len = t.length >>> 0;
        if (len === 0) {
            return -1;
        }

        var n = 0;
        if (arguments.length > 0) {
            n = Number(arguments[1]);
            if (isNaN(n)) {
                n = 0;
            } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
                n = (n > 0 || -1) * Math.floor(Math.abs(n));
            }
        }

        if (n >= len) {
            return -1;
        }

        var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);

        for (; k < len; k++) {
            if (k in t && t.charAt(k) === searchElement) {
                return k;
            }
        }
        return -1;
    };
}

/**
 * defining String.prototype.codePointAt if not defined already
 * Which is not supported bellow IE-11
 */

if (!String.prototype.codePointAt) {
    var codePointAt = function(position) {
        if (this == null) {
            throw TypeError();
        }
        var string = String(this);
        var size = string.length;
        // `ToInteger`
        var index = position ? Number(position) : 0;
        if (index != index) { // better `isNaN`
            index = 0;
        }
        // Account for out-of-bounds indices:
        if (index < 0 || index >= size) {
            return undefined;
        }
        // Get the first code unit
        var first = string.charCodeAt(index);
        var second;
        if ( // check if itâ€™s the start of a surrogate pair
            first >= 0xD800 && first <= 0xDBFF && // high surrogate
            size > index + 1 // there is a next code unit
        ) {
            second = string.charCodeAt(index + 1);
            if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
                // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            }
        }
        return first;
    };
    ZSEC.util.defineProperty(String.prototype, 'codePointAt', codePointAt, false); // No I18N
} else {
    ZSEC.util.defineProperty(String.prototype, 'codePointAt', String.prototype.codePointAt, true); // No I18N
}


/**
 * defining String.fromCodePoint if not defined already
 * Which is not supported in many browsers like IE ,Android ,Opera Mobile
 * */

if (!String.fromCodePoint) {
    var stringFromCharCode = String.fromCharCode;
    var floor = Math.floor;
    var fromCodePoint = function() {
        var MAX_SIZE = 0x4000;
        var codeUnits = [];
        var highSurrogate;
        var lowSurrogate;
        var index = -1;
        var length = arguments.length;
        if (!length) {
            return ''; // No I18N
        }
        var result = ''; // No I18N
        while (++index < length) {
            var codePoint = Number(arguments[index]);
            if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                codePoint < 0 || // not a valid Unicode code point
                codePoint > 0x10FFFF || // not a valid Unicode code point
                floor(codePoint) != codePoint // not an integer
            ) {
                throw RangeError('Invalid code point: ' + codePoint); // No I18N
            }
            if (codePoint <= 0xFFFF) { // BMP code point
                codeUnits.push(codePoint);
            } else { // Astral code point; split in surrogate halves
                // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                codePoint -= 0x10000;
                highSurrogate = (codePoint >> 10) + 0xD800;
                lowSurrogate = (codePoint % 0x400) + 0xDC00;
                codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 == length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
            }
        }
        return result;
    };
    ZSEC.util.defineProperty(String, 'fromCodePoint', fromCodePoint, false); // No I18N

} else {
    ZSEC.util.defineProperty(String, 'fromCodePoint', String.fromCodePoint, true); // No I18N
}

(function(){

    var Console = {
        log : function(input){
            //Only a static message is displayed for now. Support for giving API to user to customize message maybe given in future
            if (navigator && navigator.userAgent) {
                var userAgent = navigator.userAgent;
                var browser = userAgent.match(/opera|chrome|safari|firefox|msie|trident(?=\/)/i);
                if (browser && browser[0].search(/trident|msie/i) < 0){
                    //Supported  browser
                    window.console.log("%cSTOP!", "color:red;font-size:xx-large;font-weight:bold;");
                    window.console.log("%cThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\nSee https://en.wikipedia.org/wiki/Self-XSS for more details", "font-size:large;");
                    return;
                }
            }
            //Not supported browser
            window.console.log("STOP!\nThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\nSee https://en.wikipedia.org/wiki/Self-XSS for more details");
        }
    };

    ZSEC.util.defineProperty(ZSEC, 'Console', Console, true, false, false, true); // No I18N
})()

ZSEC.Console.log();


/**
 * Encoder
 * */
'use strict'; // No I18N
(function(encoder) {

    var characterToEntityMap = {};
    var characterToEntityArray = "34=&quot|38=&amp|60=&lt|62=&gt|160=&nbsp|161=&iexcl|162=&cent|163=&pound|164=&curren|165=&yen|166=&brvbar|167=&sect|168=&uml|169=&copy|170=&ordf|171=&laquo|172=&not|173=&shy|174=&reg|175=&macr|176=&deg|177=&plusmn|178=&sup2|179=&sup3|180=&acute|181=&micro|182=&para|183=&middot|184=&cedil|185=&sup1|186=&ordm|187=&raquo|188=&frac14|189=&frac12|190=&frac34|191=&iquest|192=&Agrave|193=&Aacute|194=&Acirc|195=&Atilde|196=&Auml|197=&Aring|198=&AElig|199=&Ccedil|200=&Egrave|201=&Eacute|202=&Ecirc|203=&Euml|204=&Igrave|205=&Iacute|206=&Icirc|207=&Iuml|208=&ETH|209=&Ntilde|210=&Ograve|211=&Oacute|212=&Ocirc|213=&Otilde|214=&Ouml|215=&times|216=&Oslash|217=&Ugrave|218=&Uacute|219=&Ucirc|220=&Uuml|221=&Yacute|222=&THORN|223=&szlig|224=&agrave|225=&aacute|226=&acirc|227=&atilde|228=&auml|229=&aring|230=&aelig|231=&ccedil|232=&egrave|233=&eacute|234=&ecirc|235=&euml|236=&igrave|237=&iacute|238=&icirc|239=&iuml|240=&eth|241=&ntilde|242=&ograve|243=&oacute|244=&ocirc|245=&otilde|246=&ouml|247=&divide|248=&oslash|249=&ugrave|250=&uacute|251=&ucirc|252=&uuml|253=&yacute|254=&thorn|255=&yuml|338=&OElig|339=&oelig|352=&Scaron|353=&scaron|376=&Yuml|402=&fnof|710=&circ|732=&tilde|913=&Alpha|914=&Beta|915=&Gamma|916=&Delta|917=&Epsilon|918=&Zeta|919=&Eta|920=&Theta|921=&Iota|922=&Kappa|923=&Lambda|924=&Mu|925=&Nu|926=&Xi|927=&Omicron|928=&Pi|929=&Rho|931=&Sigma|932=&Tau|933=&Upsilon|934=&Phi|935=&Chi|936=&Psi|937=&Omega|945=&alpha|946=&beta|947=&gamma|948=&delta|949=&epsilon|950=&zeta|951=&eta|952=&theta|953=&iota|954=&kappa|955=&lambda|956=&mu|957=&nu|958=&xi|959=&omicron|960=&pi|961=&rho|962=&sigmaf|963=&sigma|964=&tau|965=&upsilon|966=&phi|967=&chi|968=&psi|969=&omega|977=&thetasym|978=&upsih|982=&piv|8194=&ensp|8195=&emsp|8201=&thinsp|8204=&zwnj|8205=&zwj|8206=&lrm|8207=&rlm|8211=&ndash|8212=&mdash|8216=&lsquo|8217=&rsquo|8218=&sbquo|8220=&ldquo|8221=&rdquo|8222=&bdquo|8224=&dagger|8225=&Dagger|8226=&bull|8230=&hellip|8240=&permil|8242=&prime|8243=&Prime|8249=&lsaquo|8250=&rsaquo|8254=&oline|8260=&frasl|8364=&euro|8465=&image|8472=&weierp|8476=&real|8482=&trade|8501=&alefsym|8592=&larr|8593=&uarr|8594=&rarr|8595=&darr|8596=&harr|8629=&crarr|8656=&lArr|8657=&uArr|8658=&rArr|8659=&dArr|8660=&hArr|8704=&forall|8706=&part|8707=&exist|8709=&empty|8711=&nabla|8712=&isin|8713=&notin|8715=&ni|8719=&prod|8721=&sum|8722=&minus|8727=&lowast|8730=&radic|8733=&prop|8734=&infin|8736=&ang|8743=&and|8744=&or|8745=&cap|8746=&cup|8747=&int|8756=&there4|8764=&sim|8773=&cong|8776=&asymp|8800=&ne|8801=&equiv|8804=&le|8805=&ge|8834=&sub|8835=&sup|8836=&nsub|8838=&sube|8839=&supe|8853=&oplus|8855=&otimes|8869=&perp|8901=&sdot|8968=&lceil|8969=&rceil|8970=&lfloor|8971=&rfloor|10216=&lang|10217=&rang|9674=&loz|9824=&spades|9827=&clubs|9829=&hearts|9830=&diams"; // No I18N
    characterToEntityArray = characterToEntityArray.split("|");
    for (var each = 0; each < characterToEntityArray.length; each++) {
        var eachEntry = characterToEntityArray[each].split("=");
        characterToEntityMap[eachEntry[0]] = eachEntry[1];
    }

    function toCharCodeArr(charArr){
        var charCodeArr = [];
        for(var i = 0; i < charArr.length; i++){
            charCodeArr.push(charArr[i].charCodeAt(0));
        }
        return charCodeArr;
    }

    var config = {
        characterToEntityMap: characterToEntityMap,
        IMMUNE_HTML:        toCharCodeArr(new Array(',', '.', '-', '_', ' ')), // No I18N
        IMMUNE_HTMLATTR:    toCharCodeArr(new Array(',', '.', '-', '_')), // No I18N
        IMMUNE_CSS:         toCharCodeArr(new Array()),
        IMMUNE_JAVASCRIPT:  toCharCodeArr(new Array(',', '.', '_')) // No I18N
    }

    ZSEC.util.defineProperty(ZSEC, 'Encoder', encoder(config), true, false, false, true); // No I18N

}(function encoder(config) {

    var Encoder = {};
    var characterToEntityMap = config.characterToEntityMap;

    var hex = [];
    for (var c = 0; c < 0xFF; c++) {
        if (c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5A || c >= 0x61 && c <= 0x7A) {
            hex[c] = null;
        } else {
            hex[c] = c.toString(16);
        }
    };

    var getHexForNonAlphanumeric = function(c) {
        if (c < 256) {
            return hex[c];
        }
        return c.toString(16);
    };

    var encodeHTMCharacter = function(aImmune, c) {
        if (ZSEC.util.ArrayIndexOf.call(aImmune, c) != -1) {
            return String.fromCodePoint(c);
        }
        var hex = getHexForNonAlphanumeric(c);
        if (hex == null) {
            return String.fromCodePoint(c);
        }

        // returning space for non printable characters
        if ((c <= 0x1f && c != '\t' && c != '\n' && c != '\r') || (c >= 0x7f && c <= 0x9f) || c == ' ') { // No I18N
            return " "; // No I18N
        }

        var entityName = characterToEntityMap[c];
        if (entityName != null) {
            return entityName + ";"; // No I18N
        }

        return "&#x" + hex + ";"; // No I18N
    }

    var encodeJsCharacter = function(aImmune, c) {
        if (ZSEC.util.ArrayIndexOf.call(aImmune, c) != -1) {
            return String.fromCharCode(c);
        }
        var hex = getHexForNonAlphanumeric(c);
        if (hex == null) {
            return String.fromCharCode(c);
        }
        var tmp = c.toString(16);
        if (c < 256) {
            var pad = "00".substr(tmp.length); // No I18N
            return "\\x" + pad + tmp.toUpperCase(); // No I18N
        }
        pad = "0000".substr(tmp.length); // No I18N
        return "\\u" + pad + tmp.toUpperCase(); // No I18N
    };

    var encodeCssCharacter = function(aImmune, c) {
        if (ZSEC.util.ArrayIndexOf.call(aImmune, c) != -1) {
            return String.fromCodePoint(c);
        }

        var hex = getHexForNonAlphanumeric(c);
        if (hex == null) {
            return String.fromCodePoint(c);
        }

        return "\\" + hex + " "; // No I18N
    };

    /**
     * It iterate over the characters in sInput and calls characterEncoder to encode it. It iterate either by code unit or code point depend uppon the isHandleUnicodeChar value
     * @param   {Array} aImmune -> immune character list
     * @param   {String} sInput
     * @param   {Function}  characterEncoder
     * @param   {Boolean}  isHandleUnicodeChar -> if true iterate by codePoint
     */
    function encode(aImmune, sInput, characterEncoder, isHandleUnicodeChar) {

        if (sInput == null || sInput == undefined || "string" != typeof sInput) { // No I18N
            return sInput;
        }
        var out = ''; // No I18N
        for (var i = 0; i < sInput.length; i++) {
            if (isHandleUnicodeChar) {
                var c = sInput.codePointAt(i);
                out += characterEncoder(aImmune, c, isHandleUnicodeChar);
                if (c > 0xFFFF) {
                    i++;
                }
            } else {
                out += characterEncoder(aImmune, sInput.charCodeAt(i));

            }
        }
        return out;
    };


    /**
     * It encodes text which has to be rendered as element text, Here input has to be iterated by code point
     *@param  {String} input
     */
    Encoder.encodeForHTML = function encodeForHTML(input) {
        return encode(config.IMMUNE_HTML, input, encodeHTMCharacter, true);
    };


    /**
     * It encodes text which has to be rendered as html attribute value(except attributes executes as js example onclick,onblur etc...), Here input has to be iterated by code point
     *@param {String} input
     */
    Encoder.encodeForHTMLAttribute = function encodeForHTMLAttribute(input) {
        return encode(config.IMMUNE_HTMLATTR, input, encodeHTMCharacter, true);
    };


    /**
     * It encodes text which has to be rendered as value inside the script tag or html attribute which get executed as js(onclick,onblur etc...), Here input has to be iterated by code unit
     *@param {String} inputtriggertrigger
     */
    Encoder.encodeForJavaScript = function encodeForJavaScript(input) {
        return encode(config.IMMUNE_JAVASCRIPT, input, encodeJsCharacter, false);
    };

    /**
     * It encodes text which has to be rendered as css property name or value, Here input has to be iterated by code unit
     *@param {String} input
     */
    Encoder.encodeForCSS = function encodeForCSS(input) {
        return encode(config.IMMUNE_CSS, input, encodeCssCharacter, true);
    };

    if (Object.freeze) {
        Object.freeze(Encoder)
    }
    return Encoder;
}));

/**
 * DOMPurify
 **/
'use strict'; // No I18N
(function(factory) {
    window.DOMPurify = factory(window);
}(function factory(window) {

    var DOMPurify = function(window) {
        return factory(window);
    };

    /**
     * Version label, exposed for easier checks
     * if DOMPurify is up to date or not
     */
    DOMPurify.version = '0.8.5'; // No I18N

    /**
     * Array of elements that DOMPurify removed during sanitation.
     * Empty if nothing was removed.
     */
    DOMPurify.removed = [];

    if (!window || !window.document || window.document.nodeType !== 9) {
        // not running in a browser, provide a factory function
        // so that you can pass your own Window
        DOMPurify.isSupported = false;
        return DOMPurify;
    }

    var document = window.document;
    var originalDocument = document;
    var DocumentFragment = window.DocumentFragment;
    var HTMLTemplateElement = window.HTMLTemplateElement;
    var Node = window.Node;
    var NodeFilter = window.NodeFilter;
    var NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap;
    var Text = window.Text;
    var Comment = window.Comment;
    var DOMParser = window.DOMParser;

    // As per issue #47, the web-components registry is inherited by a
    // new document created via createHTMLDocument. As per the spec
    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
    // a new empty registry is used when creating a template contents owner
    // document, so we use that as our parent document to ensure nothing
    // is inherited.
    if (typeof HTMLTemplateElement === 'function') { // No I18N
        var template = document.createElement('template'); // No I18N
        if (template.content && template.content.ownerDocument) {
            document = template.content.ownerDocument;
        }
    }
    var implementation = document.implementation;
    var createNodeIterator = document.createNodeIterator;
    var getElementsByTagName = document.getElementsByTagName;
    var createDocumentFragment = document.createDocumentFragment;
    var importNode = originalDocument.importNode;

    var hooks = {};

    /**
     * Expose whether this browser supports running the full DOMPurify.
     */
    DOMPurify.isSupported =
        typeof implementation.createHTMLDocument !== 'undefined' && // No I18N
        document.documentMode !== 9;

    /* Add properties to a lookup table */
    var _addToSet = function(set, array) {
        var l = array.length;
        while (l--) {
            if (typeof array[l] === 'string') { // No I18N
                array[l] = array[l].toLowerCase();
            }
            set[array[l]] = true;
        }
        return set;
    };

    /* Shallow clone an object */
    var _cloneObj = function(object) {
        var newObject = {};
        var property;
        for (property in object) {
            if (object.hasOwnProperty(property)) {
                newObject[property] = object[property];
            }
        }
        return newObject;
    };

    /**
     * We consider the elements and attributes below to be safe. Ideally
     * don't add any new ones but feel free to remove unwanted ones.
     */

    /* allowed element names */
    var ALLOWED_TAGS = null;
    var DEFAULT_ALLOWED_TAGS = _addToSet({}, []);

    /* Allowed attribute names */
    var ALLOWED_ATTR = null;
    var DEFAULT_ALLOWED_ATTR = _addToSet({}, []);

    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
    var FORBID_TAGS = null;

    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
    var FORBID_ATTR = null;

    /* Decide if ARIA attributes are okay */
    var ALLOW_ARIA_ATTR = true;

    /* Decide if custom data attributes are okay */
    var ALLOW_DATA_ATTR = true;

    /* Decide if unknown protocols are okay */
    var ALLOW_UNKNOWN_PROTOCOLS = false;

    /* Output should be safe for jQuery's $() factory? */
    var SAFE_FOR_JQUERY = false;

    /* Output should be safe for common template engines.
     * This means, DOMPurify removes data attributes, mustaches and ERB
     */
    var SAFE_FOR_TEMPLATES = false;

    /* Specify template detection regex for SAFE_FOR_TEMPLATES mode */
    var MUSTACHE_EXPR = /\{\{[\s\S]*|[\s\S]*\}\}/gm;
    var ERB_EXPR = /<%[\s\S]*|[\s\S]*%>/gm;

    /* Decide if document with <html>... should be returned */
    var WHOLE_DOCUMENT = false;

    /* Decide if all elements (e.g. style, script) must be children of
     * document.body. By default, browsers might move them to document.head */
    var FORCE_BODY = true;

    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html string.
     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
     */
    var RETURN_DOM = false;

    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html string */
    var RETURN_DOM_FRAGMENT = false;

    /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM
     * `Node` is imported into the current `Document`. If this flag is not enabled the
     * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by
     * DOMPurify. */
    var RETURN_DOM_IMPORT = false;

    /* Output should be free from DOM clobbering attacks? */
    var SANITIZE_DOM = true;

    /* Keep element content when removing element? */
    var KEEP_CONTENT = true;

    /* Tags to ignore content of when KEEP_CONTENT is true */
    var FORBID_CONTENTS = _addToSet({}, [
        'audio', 'head', 'math', 'script', 'svg', 'video', 'style' // No I18N
    ]);

    /* Tags that are safe for data: URIs */
    var DATA_URI_TAGS = _addToSet({}, [
        'audio', 'video', 'img', 'source', 'image' // No I18N
    ]);

    /* Attributes safe for values like "javascript:" */ // No I18N
    var URI_SAFE_ATTRIBUTES = _addToSet({}, [
        'alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', // No I18N
        'summary', 'title', 'value', 'style', 'xmlns' // No I18N
    ]);

    /* Keep a reference to config to pass to hooks */
    var CONFIG = null;

    /* Ideally, do not touch anything below this line */
    /* ______________________________________________ */

    var formElement = document.createElement('form'); // No I18N

    /**
     * _parseConfig
     *
     * @param  optional config literal
     */
    var _parseConfig = function(cfg) {
        /* Shield configuration object from tampering */
        if (typeof cfg !== 'object') { // No I18N
            cfg = {};
        }

        /* Set configuration parameters */
        ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? // No I18N
            _addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
        ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? // No I18N
            _addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
        FORBID_TAGS = 'FORBID_TAGS' in cfg ? // No I18N
            _addToSet({}, cfg.FORBID_TAGS) : {};
        FORBID_ATTR = 'FORBID_ATTR' in cfg ? // No I18N
            _addToSet({}, cfg.FORBID_ATTR) : {};
        ALLOW_ARIA_ATTR         = cfg.ALLOW_ARIA_ATTR           !== false; // Default true
        ALLOW_DATA_ATTR         = cfg.ALLOW_DATA_ATTR           !== false; // Default true
        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS   ||  false; // Default false
        SAFE_FOR_JQUERY         = cfg.SAFE_FOR_JQUERY           ||  false; // Default false
        SAFE_FOR_TEMPLATES      = cfg.SAFE_FOR_TEMPLATES        ||  false; // Default false
        WHOLE_DOCUMENT          = cfg.WHOLE_DOCUMENT            ||  false; // Default false
        RETURN_DOM              = cfg.RETURN_DOM                ||  false; // Default false
        RETURN_DOM_FRAGMENT     = cfg.RETURN_DOM_FRAGMENT       ||  false; // Default false
        RETURN_DOM_IMPORT       = cfg.RETURN_DOM_IMPORT         ||  false; // Default false
        FORCE_BODY              = cfg.FORCE_BODY                !== false; // Default true
        SANITIZE_DOM            = cfg.SANITIZE_DOM              !== false; // Default true
        KEEP_CONTENT            = cfg.KEEP_CONTENT              !== false; // Default true

        if (SAFE_FOR_TEMPLATES) {
            ALLOW_DATA_ATTR = false;
        }

        if (RETURN_DOM_FRAGMENT) {
            RETURN_DOM = true;
        }

        if (cfg.ADD_URI_SAFE_ATTR) {
            _addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
        }

        /* Add #text in case KEEP_CONTENT is set to true */
        if (KEEP_CONTENT) {
            ALLOWED_TAGS['#text'] = true; // No I18N
        }

        // Prevent further manipulation of configuration.
        // Not available in IE8, Safari 5, etc.
        if (Object && 'freeze' in Object) { // No I18N
            Object.freeze(cfg);
        }

        CONFIG = cfg;
    };

    /**
     * _forceRemove
     *
     * @param  a DOM node
     */
    var _forceRemove = function(node) {
        DOMPurify.removed.push({
            element: node
        });
        try {
            node.parentNode.removeChild(node);
        } catch (e) {
            node.outerHTML = ''; // No I18N
        }
    };

    /**
     * _removeAttribute
     *
     * @param  an Attribute name
     * @param  a DOM node
     */
    var _removeAttribute = function(name, node) {
        DOMPurify.removed.push({
            attribute: node.getAttributeNode(name),
            from: node
        });
        node.removeAttribute(name);
    };

    /**
     * _initDocument
     *
     * @param  a string of dirty markup
     * @return a DOM, filled with the dirty markup
     */
    var _initDocument = function(dirty) {
        /* Create a HTML document using DOMParser */
        var doc, body;

        if (FORCE_BODY) {
            dirty = '<remove></remove>' + dirty; // No I18N
        }

        try {
            doc = new DOMParser().parseFromString(dirty, 'text/html'); // No I18N
        } catch (e) {}
        /* Some browsers throw, some browsers return null for the code above
           DOMParser with text/html support is only in very recent browsers.
           See #159 why the check here is extra-thorough */
        if (!doc || !doc.documentElement) {
            doc = implementation.createHTMLDocument(''); // No I18N
            body = doc.body;
            body.parentNode.removeChild(body.parentNode.firstElementChild);
            body.outerHTML = dirty;
        }

        /* Work on whole document or just its body */
        if (typeof doc.getElementsByTagName === 'function') { // No I18N
            return doc.getElementsByTagName(
                WHOLE_DOCUMENT ? 'html' : 'body')[0]; // No I18N
        }
        return getElementsByTagName.call(doc,
            WHOLE_DOCUMENT ? 'html' : 'body')[0]; // No I18N
    };

    /**
     * _createIterator
     *
     * @param  document/fragment to create iterator for
     * @return iterator instance
     */
    var _createIterator = function(root) {
        return createNodeIterator.call(root.ownerDocument || root,
            root,
            NodeFilter.SHOW_ELEMENT |
            NodeFilter.SHOW_COMMENT |
            NodeFilter.SHOW_TEXT,
            function() {
                return NodeFilter.FILTER_ACCEPT;
            },
            false
        );
    };

    /**
     * _isClobbered
     *
     * @param  element to check for clobbering attacks
     * @return true if clobbered, false if safe
     */
    var _isClobbered = function(elm) {
        if (elm instanceof Text || elm instanceof Comment) {
            return false;
        }
        if (typeof elm.nodeName !== 'string' || // No I18N
            typeof elm.textContent !== 'string' || // No I18N
            typeof elm.removeChild !== 'function' || // No I18N
            !(elm.attributes instanceof NamedNodeMap) ||
            typeof elm.removeAttribute !== 'function' || // No I18N
            typeof elm.setAttribute !== 'function' // No I18N
        ) {
            return true;
        }
        return false;
    };

    /**
     * _isNode
     *
     * @param object to check whether it's a DOM node
     * @return true is object is a DOM node
     */
    var _isNode = function(obj) {
        return (
            typeof Node === "object" ? obj instanceof Node : obj && // No I18N
            typeof obj === "object" && typeof obj.nodeType === "number" && // No I18N
            typeof obj.nodeName === "string" // No I18N
        );
    };

    /**
     * _sanitizeElements
     *
     * @protect nodeName
     * @protect textContent
     * @protect removeChild
     *
     * @param   node to check for permission to exist
     * @return  true if node was killed, false if left alive
     */
    var _sanitizeElements = function(currentNode) {
        var tagName, content;
        /* Execute a hook if present */
        _executeHook('beforeSanitizeElements', currentNode, null); // No I18N

        /* Check if element is clobbered or can clobber */
        if (_isClobbered(currentNode)) {
            _forceRemove(currentNode);
            return true;
        }

        /* Now let's check the element's type and name */ // No I18N
        tagName = currentNode.nodeName.toLowerCase();

        /* Execute a hook if present */
        _executeHook('uponSanitizeElement', currentNode, { // No I18N
            tagName: tagName,
            allowedTags: ALLOWED_TAGS
        });

        /* Remove element if anything forbids its presence */
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            /* Keep content except for black-listed elements */
            if (KEEP_CONTENT && !FORBID_CONTENTS[tagName] &&
                typeof currentNode.insertAdjacentHTML === 'function') { // No I18N
                try {
                    currentNode.insertAdjacentHTML('AfterEnd', currentNode.innerHTML); // No I18N
                } catch (e) {}
            }
            _forceRemove(currentNode);
            return true;
        }

        // TODO: Study about effects of '{{}}' in styles to make this more safe!
        // This check is to prevent '<' from being HTML encoded when used in style.
        // It will be CSS Encoded in the else block below
        if (tagName != "style") {  // No I18N
            /* Convert markup to cover jQuery behavior */
            if (SAFE_FOR_JQUERY && !currentNode.firstElementChild &&
                (!currentNode.content || !currentNode.content.firstElementChild) &&
                /</g.test(currentNode.textContent)) {
                DOMPurify.removed.push({
                    element: currentNode.cloneNode()
                });
                currentNode.innerHTML = currentNode.textContent.replace(/</g, '&lt;'); // No I18N
            }
            /* Sanitize element content to be template-safe */
            if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
                /* Get the element's text content */
                content = currentNode.textContent;

                content = content.replace(MUSTACHE_EXPR, ' '); // No I18N
                content = content.replace(ERB_EXPR, ' '); // No I18N

                if (currentNode.textContent !== content) {
                    DOMPurify.removed.push({
                        element: currentNode.cloneNode()
                    });
                    currentNode.textContent = content;
                }
            }
        }

        //Encode the '<' in style tags in CSS context like '\3c '
        else{
            /* Convert markup to cover jQuery behavior */
            if (SAFE_FOR_JQUERY && !currentNode.firstElementChild &&
                (!currentNode.content || !currentNode.content.firstElementChild) &&
                /</g.test(currentNode.textContent)) {
                DOMPurify.removed.push({
                    element: currentNode.cloneNode()
                });
                currentNode.innerHTML = currentNode.textContent.replace(/</g, '\\3c '); // No I18N
            }
        }

        /* Execute a hook if present */
        _executeHook('afterSanitizeElements', currentNode, null); // No I18N

        return false;
    };

    var DATA_ATTR = /^data-[-\w.\u00B7-\uFFFF]/;
    var ARIA_ATTR = /^aria-[-\w]+$/;
    var IS_ALLOWED_URI = /^(?:(?:https?|mailto|tel):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i;
    var IS_SCRIPT_OR_DATA = /^(?:\w+script|data):/i;
    /* This needs to be extensive thanks to Webkit/Blink's behavior */
    var ATTR_WHITESPACE = /[\x00-\x20\xA0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;

    /**
     * _sanitizeAttributes
     *
     * @protect attributes
     * @protect nodeName
     * @protect removeAttribute
     * @protect setAttribute
     *
     * @param   node to sanitize
     * @return  void
     */
    var _sanitizeAttributes = function(currentNode) {
        var attr, name, value, lcName, idAttr, attributes, hookEvent, l;
        /* Execute a hook if present */
        _executeHook('beforeSanitizeAttributes', currentNode, null); // No I18N

        attributes = currentNode.attributes;

        /* Check if we have attributes; if not we might have a text node */
        if (!attributes) {
            return;
        }

        hookEvent = {
            attrName: '', // No I18N
            attrValue: '', // No I18N
            keepAttr: true,
            allowedAttributes: ALLOWED_ATTR
        };
        l = attributes.length;

        /* Go backwards over all attributes; safely remove bad ones */
        while (l--) {
            attr = attributes[l];
            name = attr.name;
            value = attr.value.trim();
            lcName = name.toLowerCase();

            /* Execute a hook if present */
            hookEvent.attrName = lcName;
            hookEvent.attrValue = value;
            hookEvent.keepAttr = true;
            _executeHook('uponSanitizeAttribute', currentNode, hookEvent); // No I18N
            value = hookEvent.attrValue;

            /* Remove attribute */
            // Safari (iOS + Mac), last tested v8.0.5, crashes if you try to
            // remove a "name" attribute from an <img> tag that has an "id" // No I18N
            // attribute at the time.
            if (lcName === 'name' && // No I18N
                currentNode.nodeName === 'IMG' && attributes.id) { // No I18N
                idAttr = attributes.id;
                attributes = Array.prototype.slice.apply(attributes);
                _removeAttribute('id', currentNode); // No I18N
                _removeAttribute(name, currentNode);
                if (attributes.indexOf(idAttr) > l) {
                    currentNode.setAttribute('id', idAttr.value); // No I18N
                }
            } else {
                // This avoids a crash in Safari v9.0 with double-ids.
                // The trick is to first set the id to be empty and then to
                // remove the attriubute
                if (name === 'id') { // No I18N
                    currentNode.setAttribute(name, ''); // No I18N
                }
                _removeAttribute(name, currentNode);
            }

            /* Did the hooks approve of the attribute? */
            if (!hookEvent.keepAttr) {
                continue;
            }

            /* Make sure attribute cannot clobber */
            if (SANITIZE_DOM &&
                (lcName === 'id' || lcName === 'name') && // No I18N
                (value in document || value in formElement)) {
                continue;
            }

            /* Sanitize attribute content to be template-safe */
            if (SAFE_FOR_TEMPLATES) {
                value = value.replace(MUSTACHE_EXPR, ' '); // No I18N
                value = value.replace(ERB_EXPR, ' '); // No I18N
            }

            /* Allow valid data-* attributes: At least one character after "-" // No I18N
               (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
               XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
               We don't need to check the value; it's always URI safe. */ // No I18N
            var emptyBlockFiller = false; //Hack-fix for git preventing empty blocks in code
            if (ALLOW_DATA_ATTR && DATA_ATTR.test(lcName)) {
                // This attribute is safe
                emptyBlockFiller = true;
            } else if (ALLOW_ARIA_ATTR && ARIA_ATTR.test(lcName)) {
                // This attribute is safe
                emptyBlockFiller = true;
            }
            /* Otherwise, check the name is permitted */
            else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
                continue;
            }
            /* Check value is safe. First, is attr inert? If so, is safe */
            else if (URI_SAFE_ATTRIBUTES[lcName]) {
                // This attribute is safe
                emptyBlockFiller = true;
            }
            /* Check no script, data or unknown possibly unsafe URI
               unless we know URI values are safe for that attribute */
            else if (IS_ALLOWED_URI.test(value.replace(ATTR_WHITESPACE, ''))) { // No I18N
                // This attribute is safe
                emptyBlockFiller = true;
            }
            /* Keep image data URIs alive if src/xlink:href is allowed */
            else if (
                (lcName === 'src' || lcName === 'xlink:href') && // No I18N
                value.indexOf('data:') === 0 && // No I18N
                DATA_URI_TAGS[currentNode.nodeName.toLowerCase()]) {
                // This attribute is safe
                emptyBlockFiller = true;
            }
            /* Allow unknown protocols: This provides support for links that
               are handled by protocol handlers which may be unknown ahead of
               time, e.g. fb:, spotify: */
            else if (
                ALLOW_UNKNOWN_PROTOCOLS &&
                !IS_SCRIPT_OR_DATA.test(value.replace(ATTR_WHITESPACE, ''))) { // No I18N
                // This attribute is safe
                emptyBlockFiller = true;
            }
            /* Check for binary attributes */
            else if (!value) {
                // binary attributes are safe at this point
                emptyBlockFiller = true;
            }
            /* Anything else, presume unsafe, do not add it back */
            else {
                continue;
            }

            /* Handle invalid data-* attribute set by try-catching it */
            try {
                currentNode.setAttribute(name, value);
                DOMPurify.removed.pop();
            } catch (e) {}
        }

        /* Execute a hook if present */
        _executeHook('afterSanitizeAttributes', currentNode, null); // No I18N
    };

    /**
     * _sanitizeShadowDOM
     *
     * @param  fragment to iterate over recursively
     * @return void
     */
    var _sanitizeShadowDOM = function(fragment) {
        var shadowNode;
        var shadowIterator = _createIterator(fragment);

        /* Execute a hook if present */
        _executeHook('beforeSanitizeShadowDOM', fragment, null); // No I18N

        while ((shadowNode = shadowIterator.nextNode())) {
            /* Execute a hook if present */
            _executeHook('uponSanitizeShadowNode', shadowNode, null); // No I18N

            /* Sanitize tags and elements */
            if (_sanitizeElements(shadowNode)) {
                continue;
            }

            /* Deep shadow DOM detected */
            if (shadowNode.content instanceof DocumentFragment) {
                _sanitizeShadowDOM(shadowNode.content);
            }

            /* Check attributes, sanitize if necessary */
            _sanitizeAttributes(shadowNode);
        }

        /* Execute a hook if present */
        _executeHook('afterSanitizeShadowDOM', fragment, null); // No I18N
    };

    /**
     * _executeHook
     * Execute user configurable hooks
     *
     * @param  {String} entryPoint  Name of the hook's entry point
     * @param  {Node} currentNode
     */
    var _executeHook = function(entryPoint, currentNode, data) {
        if (!hooks[entryPoint]) {
            return;
        }

        hooks[entryPoint].forEach(function(hook) {
            hook.call(DOMPurify, currentNode, data, CONFIG);
        });
    };

    /**
     * sanitize
     * Public method providing core sanitation functionality
     *
     * @param {String|Node} dirty string or DOM node
     * @param {Object} configuration object
     */
    DOMPurify.sanitize = function(dirty, cfg) {
        var body, importedNode, currentNode, oldNode, nodeIterator, returnNode;
        /* Make sure we have a string to sanitize.
           DO NOT return early, as this will return the wrong type if
           the user has requested a DOM object rather than a string */
        if (!dirty) {
            dirty = '<!-->'; // No I18N
        }

        /* Stringify, in case dirty is an object */
        if (typeof dirty !== 'string' && !_isNode(dirty)) { // No I18N
            if (typeof dirty.toString !== 'function') { // No I18N
                throw new TypeError('toString is not a function'); // No I18N
            } else {
                dirty = dirty.toString();
            }
        }

        /* Check we can run. Otherwise fall back or ignore */
        if (!DOMPurify.isSupported) {
            if (typeof window.toStaticHTML === 'object' || // No I18N
                typeof window.toStaticHTML === 'function') { // No I18N
                if (typeof dirty === 'string') { // No I18N
                    return window.toStaticHTML(dirty);
                } else if (_isNode(dirty)) {
                    return window.toStaticHTML(dirty.outerHTML);
                }
            }
            return dirty;
        }

        /* Assign config vars */
        _parseConfig(cfg);

        /* Clean up removed elements */
        DOMPurify.removed = [];

        if (dirty instanceof Node) {
            /* If dirty is a DOM element, append to an empty document to avoid
               elements being stripped by the parser */
            body = _initDocument('<!-->'); // No I18N
            importedNode = body.ownerDocument.importNode(dirty, true);
            if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') { // No I18N
                /* Node is already a body, use as is */
                body = importedNode;
            } else {
                body.appendChild(importedNode);
            }
        } else {
            /* Exit directly if we have nothing to do */
            if (!RETURN_DOM && !WHOLE_DOCUMENT && dirty.indexOf('<') === -1) { // No I18N
                return dirty;
            }

            /* Initialize the document to work on */
            body = _initDocument(dirty);

            /* Check we have a DOM node from the data */
            if (!body) {
                return RETURN_DOM ? null : ''; // No I18N
            }
        }
        /* Remove first element node (ours) if FORCE_BODY is set */
        if (FORCE_BODY) {
            _forceRemove(body.firstChild);
        }
        /* Get node iterator */
        nodeIterator = _createIterator(body);
        /* Now start iterating over the created document */
        while ((currentNode = nodeIterator.nextNode())) {

            /* Fix IE's strange behavior with manipulated textNodes #89 */
            if (currentNode.nodeType === 3 && currentNode === oldNode) {
                continue;
            }

            /* Sanitize tags and elements */
            if (_sanitizeElements(currentNode)) {
                continue;
            }

            /* Shadow DOM detected, sanitize it */
            if (currentNode.content instanceof DocumentFragment) {
                _sanitizeShadowDOM(currentNode.content);
            }

            /* Check attributes, sanitize if necessary */
            _sanitizeAttributes(currentNode);

            oldNode = currentNode;
        }

        /* Return sanitized string or DOM */
        if (RETURN_DOM) {

            if (RETURN_DOM_FRAGMENT) {
                returnNode = createDocumentFragment.call(body.ownerDocument);

                while (body.firstChild) {
                    returnNode.appendChild(body.firstChild);
                }
            } else {
                returnNode = body;
            }

            if (RETURN_DOM_IMPORT) {
                /* adoptNode() is not used because internal state is not reset
                   (e.g. the past names map of a HTMLFormElement), this is safe
                   in theory but we would rather not risk another attack vector.
                   The state that is cloned by importNode() is explicitly defined
                   by the specs. */
                returnNode = importNode.call(originalDocument, returnNode, true);
            }

            return returnNode;
        }

        return WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    };

    /**
     * addHook
     * Public method to add DOMPurify hooks
     *
     * @param {String} entryPoint
     * @param {Function} hookFunction
     */
    DOMPurify.addHook = function(entryPoint, hookFunction) {
        if (typeof hookFunction !== 'function') { // No I18N
            return;
        }
        hooks[entryPoint] = hooks[entryPoint] || [];
        hooks[entryPoint].push(hookFunction);
    };

    /**
     * removeHook
     * Public method to remove a DOMPurify hook at a given entryPoint
     * (pops it from the stack of hooks if more are present)
     *
     * @param {String} entryPoint
     * @return void
     */
    DOMPurify.removeHook = function(entryPoint) {
        if (hooks[entryPoint]) {
            hooks[entryPoint].pop();
        }
    };

    /**
     * removeHooks
     * Public method to remove all DOMPurify hooks at a given entryPoint
     *
     * @param  {String} entryPoint
     * @return void
     */
    DOMPurify.removeHooks = function(entryPoint) {
        if (hooks[entryPoint]) {
            hooks[entryPoint] = [];
        }
    };

    /**
     * removeAllHooks
     * Public method to remove all DOMPurify hooks
     *
     * @return void
     */
    DOMPurify.removeAllHooks = function() {
        hooks = {};
    };

    return DOMPurify;
}));

/**
 * Custom Functions for Sanitizer
 **/

function addToSet(set, array) {
    var l = array.length;
    while (l--) {
        set[array[l]] = true;
    }
    return set;
};

function addObjsToSet(set, set2) {
    for (var each in set2) {
        if (set2.hasOwnProperty(each)) {
            set[each] = true;
        }
    }
    return set;
};

function removeFromSet(set, key) {
    var set2 = {};
    for (var eachKey in set) {
        if (set.hasOwnProperty(eachKey)) {
            if (eachKey != key) {
                set2[eachKey] = set[eachKey];
            }
        }
    }
    return set2;
}

/**
 * Sanitizer
 **/
;
(function(factory) {
    //Setting base configuration: Start---------------------------------------------------------
    var config = {};
    config.ALLOW_ARIA_ATTR = true;
    config.ALLOW_DATA_ATTR = true;
    config.ALLOW_UNKNOWN_PROTOCOLS = false;
    config.SAFE_FOR_JQUERY = false;
    config.SAFE_FOR_TEMPLATES = false;
    config.WHOLE_DOCUMENT = false;
    config.RETURN_DOM = false;
    config.RETURN_DOM_FRAGMENT = false;
    config.RETURN_DOM_IMPORT = false;
    config.FORCE_BODY = true;
    config.SANITIZE_DOM = true;
    config.KEEP_CONTENT = true;
    config.STYLE_VALIDATION = true;
    config.REMOVE_ONEVENTS = true;
    config.ALLOWED_STYLE = 'NONE' //Values can be either 'INLINE', 'INTERNAL', 'ALL', 'NONE' // No I18N
    config.ALLOWED_TAGS = "a|abbr|acronym|address|area|article|aside|audio|b|bdi|bdo|big|blink|blockquote|body|br|button|canvas|caption|center|cite|code|col|colgroup|content|data|datalist|dd|decorator|del|details|dfn|dir|div|dl|dt|element|em|fieldset|figcaption|figure|font|footer|form|h1|h2|h3|h4|h5|h6|head|header|hgroup|hr|html|i|img|input|ins|kbd|label|legend|li|main|map|mark|marquee|menu|menuitem|meter|nav|nobr|ol|optgroup|option|output|p|pre|progress|q|rp|rt|ruby|s|samp|section|select|shadow|small|source|spacer|span|strike|strong|sub|summary|sup|table|tbody|td|template|textarea|tfoot|th|thead|time|title|tr|track|tt|u|ul|var|video|wbr|#text".split("|"); // No I18N
    config.ALLOWED_ATTR = "accept|action|align|alt|autocomplete|background|bgcolor|border|cellpadding|cellspacing|checked|cite|class|clear|color|cols|colspan|coords|datetime|default|dir|disabled|download|enctype|face|for|headers|height|hidden|high|href|hreflang|id|ismap|label|lang|list|loop|low|max|maxlength|media|method|min|multiple|name|noshade|novalidate|nowrap|open|optimum|pattern|placeholder|poster|preload|pubdate|radiogroup|readonly|rel|required|rev|reversed|role|rows|rowspan|spellcheck|scope|selected|shape|size|span|srclang|start|src|step|summary|tabindex|title|target|type|usemap|valign|value|width|xmlns|sandbox".split("|"); // No I18N
    config.ALLOWED_STYLE_PROPS = "azimuth|background|background-attachment|background-color|background-image|background-position|content|background-repeat|border-collapse|border-color|border-top-color|border-right-color|border-bottom-color|border-left-color|bottom|caption-side|clear|color|cue-after|cue-before|direction|display|elevation|empty-cells|float|font-size|font-size-adjust|font-stretch|font-style|font-variant|font-weight|height|left|letter-spacing|line-height|list-style-image|list-style-position|list-style-type|marker-offset|max-height|max-width|min-height|min-width|orphans|outline-color|overflow|page-break-after|page-break-before|page-break-inside|pause-after|pause-before|pitch|pitch-range|position|richness|right|size|speak|speak-header|speak-numeral|speak-punctuation|speech-rate|stress|table-layout|text-indent|text-transform|top|unicode-bidi|vertical-align|visibility|volume|white-space|widows|width|word-spacing|border-style|border-top-style|border-right-style|border-bottom-style|border-left-style|border-top-width|border-right-width|border-bottom-width|border-left-width|border-width|margin|margin-top|margin-right|margin-bottom|margin-left|outline-style|outline-width|padding|padding-top|padding-right|padding-bottom|padding-left|border|border-top|border-right|border-bottom|border-left|cue|list-style|marks|outline|pause|text-decoration|border-spacing|clip|counter-increment|clip|cursor|text-shadow|font|font-family|page|play-during|text-align|voice-family".split("|"); // No I18N
    config.FORBID_TAGS = []; //Add any forbidden tags here
    config.FORBID_ATTR = []; //Add any forbidden attrs here

    config.ALLOWED_TAGS_OBJ = {}; //Do not change.
    config.ALLOWED_ATTR_OBJ = {}; //Do not change.
    config.FORBID_TAGS_OBJ = {}; //Do not change.
    config.FORBID_ATTR_OBJ = {}; //Do not change.

    config.ADD_URI_SAFE_ATTR = [];
    config.EXTENDS = ["GLOBAL_ATTRIBUTES", "GLOBAL_TAGS", "FORBID_TAGS", "FORBID_ATTR", "GLOBAL_APPEND_ATTRIBUTES", "GLOBAL_ATTRIBUTE_RULES", "ADD_URI_SAFE_ATTR", "TAG_RULES"]; // No I18N
    config.TAG_RULES = {
        "a" : { // No I18N
            "APPEND_ATTRIBUTES" : [{ // No I18N
                "NAME": "rel", // No I18N
                "VALUE": "noopener noreferrer", // No I18N
                "CRITERIA": [{ // No I18N
                    "NAME": "target", // No I18N
                    "CONTAINS": "_blank" // No I18N
                }]
            }]
        }
    };
    config.GLOBAL_APPEND_ATTRIBUTES = [];
    config.GLOBAL_ATTRIBUTE_RULES = {};
    // Setting base configuration: End-----------------------------------------------------------

    ZSEC.util.defineProperty(ZSEC, 'HTMLPurifier', factory(config, DOMPurify(window)), true, false, false, true); // No I18N
    delete window.DOMPurify; //We are deleting the base DOMPurify Instance

}(function factory(config, DOM) {
    var defaultForbiddenTags        = addToSet({}, ['script']); // No I18N
    var defaultForbiddenAttr        = addToSet({}, []);

    var allowedConfigArray          = ['ALLOW_ARIA_ATTR', 'ALLOW_DATA_ATTR', 'ALLOW_UNKNOWN_PROTOCOLS', 'SAFE_FOR_JQUERY', 'SAFE_FOR_TEMPLATES', 'WHOLE_DOCUMENT', 'RETURN_DOM', 'RETURN_DOM_FRAGMENT', 'RETURN_DOM_IMPORT', 'FORCE_BODY', 'SANITIZE_DOM', 'KEEP_CONTENT', 'ALLOWED_STYLE_PROPS']; // No I18N
    var inheritableConfigArray      = ['ALLOWED_TAGS', 'ALLOWED_ATTR', 'FORBID_TAGS', 'FORBID_ATTR']; // No I18N
    var inheritableConfigObjArray   = ['ALLOWED_TAGS_OBJ', 'ALLOWED_ATTR_OBJ', 'FORBID_TAGS_OBJ', 'FORBID_ATTR_OBJ']; // No I18N
    var otherExtendableConfigArray  = ["ADD_URI_SAFE_ATTR", "GLOBAL_APPEND_ATTRIBUTES", "GLOBAL_ATTRIBUTE_RULES", "TAG_RULES"]; // No I18N
    var allowedConfig               = addToSet({}, allowedConfigArray);
    var inheritableConfig           = addToSet({}, inheritableConfigArray);
    var inheritableConfigObj        = addToSet({}, inheritableConfigObjArray);
    var otherExtendableConfig       = addToSet({}, otherExtendableConfigArray);
        otherExtendableConfig       = addToSet(otherExtendableConfig, inheritableConfigArray);
        otherExtendableConfig       = addToSet(otherExtendableConfig, inheritableConfigObjArray);
    var allConfigFlags              = addToSet({}, allowedConfigArray.concat(["STYLE_VALIDATION", "ALLOWED_STYLE", "EXTENDS", "REMOVE_ONEVENTS", "GLOBAL_ATTRIBUTES", "GLOBAL_TAGS"], inheritableConfigArray, inheritableConfigObjArray, otherExtendableConfigArray)); // No I18N

    var defaultTagRules = {
        "iframe": { // No I18N
            "NAME": "iframe", // No I18N
            "ATTRIBUTE_RULES": { // No I18N
                "sandbox": { // No I18N
                    "NAME": "sandbox", // No I18N
                    "NOT_CONTAINS": ["allow-top-navigation", "allow-popups-to-escape-sandbox"], // No I18N
                    "DEFAULT_VALUE": "allow-popups allow-forms allow-scripts allow-same-origin" // No I18N
                }
            },
            "APPEND_ATTRIBUTES": [{ // No I18N
                "NAME": "sandbox", // No I18N
                "VALUE": "allow-popups allow-forms allow-scripts allow-same-origin" // No I18N
            }]
        }
    };

    var emptyBlockFiller = false; //Hack-fix for git preventing empty blocks in code
    var altered;

    // List of CSS Properties allowed when config["STYLE"] is set as "VALIDATE" // No I18N
    var allowedStyleProps = addToSet({}, config.ALLOWED_STYLE_PROPS);

    // This is to parse the additionalConfigurations that are passed while calling the sanitize function.
    // It returns the configuration that is sent to the sanitizer function.
    function parseConfig(cfg) {
        if (!cfg || cfg.constructor !== Object) {
            return config;
        }
        var customConfig = {};
        for (var each in config) {
            if (config.hasOwnProperty(each)) {
                if (each in cfg) {
                    if (each in allowedConfig) {
                        if (cfg[each] == true || cfg[each] == false) {
                            customConfig[each] = cfg[each];
                        } else {
                            customConfig[each] = config[each];
                        }
                    }
                } else {
                    customConfig[each] = config[each];
                }
            }
        }
        if (customConfig.SAFE_FOR_TEMPLATES) {
            customConfig.ALLOW_DATA_ATTR = false;
        }
        if (customConfig.RETURN_DOM_FRAGMENT) {
            customConfig.RETURN_DOM = true;
        }
        if (customConfig.KEEP_CONTENT) {
            customConfig.ALLOWED_TAGS_OBJ['#text'] = true; // No I18N
        }

        return customConfig;
    }

    //The below function is necessary for properly adding the style validation hook
    function validateStyles(styles) {
        // Validate regular CSS properties
        for (var property in styles) {
            if(styles.hasOwnProperty(property) && styles[property].constructor == String) {
                if (styles[property] && allowedStyleProps[property]) {
                    //Add additional Validations here
                    emptyBlockFiller = true;
                } else if (styles[property]) {
                    if (property != 'cssText' && !/^\d.*/.test(property)) { // No I18N
                        styles[property] = ''; // No I18N
                        altered = true;
                    }
                }
            }
        }
    }

    //The cssRules.type determines whether it is a Media Query, KeyFrames Query, Regular CSS Query
    // https://developer.mozilla.org/en-US/docs/Web/API/CSSRule
    //The below function is necessary for properly adding the style validation hook
    function validateStyleSheet(cssStyleSheet) {
        for (var index = cssStyleSheet.length - 1; index >= 0; index--) {
            var rule = cssStyleSheet[index];
            if ((rule.type == 1 && rule.selectorText) || (rule.type == 8 && rule.keyText)) {
                if (rule.style) {
                    validateStyles(rule.style)
                }
            } else if ((rule.type == 4 || rule.type == 7) && rule.cssRules) {
                validateStyleSheet(rule.cssRules);
            }
        }
    }

    //The below function is necessary for properly adding the style validation hook
    function copyValidatedStyleSheet(output, cssStyleSheet) {
        for (var index = cssStyleSheet.length - 1; index >= 0; index--) {
            if (cssStyleSheet[index].type == 1 || cssStyleSheet[index].type == 4 || cssStyleSheet[index].type == 7) {
                output.push(cssStyleSheet[index].cssText);
            }
        }
    }

    //isValidAttributes the given value with the rules in the given criteria object.
    //Returns either true or false
    //All criteria must be satisfied to return true (AND condition)
    function isValidAttribute(criteria, node, isMandatory) {
        var isMandatory = isMandatory == undefined ? criteria.IS_MANDATORY : isMandatory;

        if (criteria.NAME && !node.hasAttribute(criteria.NAME.toLowerCase())) {
            return criteria.IS_FORBIDDEN || !isMandatory;
        }
        if (criteria.IS_FORBIDDEN) {
            return false;
        }
        var value = node.getAttribute(criteria.NAME.toLowerCase());
        if (value === undefined || value === null) {
            value = "";
        }
        if (value.constructor == String) {
            if(!criteria.DONT_TRIM){
                value = value.trim();
            }

            var caseSensitive = criteria.CASE_SENSITIVE || false;
            if (!caseSensitive) {
                value = value.toLowerCase();
            }
            if (criteria.MAX_LENGTH && value.length > criteria.MAX_LENGTH) {
                return false;
            }
            if (criteria.MIN_LENGTH && value.length < criteria.MIN_LENGTH) {
                return false;
            }
            if (criteria.REGEX != undefined){
                if(criteria.REGEX.constructor == RegExp && value.search(criteria.REGEX) == -1) {
                    return false;
                } else if(criteria.REGEX.constructor == Array){
                    for(var i = 0; i < criteria.REGEX.length; i++){
                        if(value.search(criteria.REGEX[i]) == -1){
                            return false;
                        }
                    }
                }
            }
        }
        if (criteria.LIST && criteria.LIST.indexOf(value) == -1) {
            return false;
        }
        if (criteria.TYPE == "INTEGER" || criteria.TYPE == "FLOAT") {
            var tempValue;
            try {
                tempValue = criteria.TYPE == "INTEGER" ? window.parseInt(value, 10) : window.parseFloat(value); // No I18N
            } catch (e) {
                return false;
            }
            if (window.isNaN(tempValue)) {
                return false;
            }
            if ((criteria.GREATER_THAN != undefined) && tempValue <= criteria.GREATER_THAN) {
                return false;
            }
            if ((criteria.GREATER_THAN_OR_EQUAL != undefined) && tempValue < criteria.GREATER_THAN_OR_EQUAL) {
                return false;
            }
            if ((criteria.LESSER_THAN != undefined) && tempValue >= criteria.LESSER_THAN) {
                return false;
            }
            if ((criteria.LESSER_THAN_OR_EQUAL != undefined) && tempValue > criteria.LESSER_THAN_OR_EQUAL) {
                return false;
            }
            if ((criteria.EQUAL != undefined) && tempValue != criteria.EQUAL) {
                return false;
            }
            if ((criteria.NOT_EQUAL != undefined) && tempValue == criteria.NOT_EQUAL) {
                return false;
            }
        } else if (value.constructor == String) {
            if (criteria.STARTS_WITH != undefined && value.indexOf(criteria.STARTS_WITH) != 0) {
                return false;
            }
            if (criteria.ENDS_WITH != undefined && value.lastIndexOf(criteria.ENDS_WITH) != (value.length - criteria.ENDS_WITH.length)) {
                return false;
            }
            if (criteria.CONTAINS != undefined){
                if(criteria.CONTAINS.constructor == String && value.indexOf(criteria.CONTAINS) == -1) {
                    return false;
                } else if(criteria.CONTAINS.constructor == Array){
                    for(var i = 0; i < criteria.CONTAINS.length; i++){
                        if(value.indexOf(criteria.CONTAINS[i]) == -1){
                            return false;
                        }
                    }
                }
            }
            if (criteria.NOT_CONTAINS != undefined){
                if(criteria.NOT_CONTAINS.constructor == String && value.indexOf(criteria.NOT_CONTAINS) > -1) {
                    return false;
                } else if(criteria.NOT_CONTAINS.constructor == Array){
                    for(var i = 0; i < criteria.NOT_CONTAINS.length; i++){
                        if(value.indexOf(criteria.NOT_CONTAINS[i]) > -1){
                            return false;
                        }
                    }
                }
            }
            if (criteria.EQUAL != undefined && value !== criteria.EQUAL) {
                return false;
            }
            if (criteria.NOT_EQUAL != undefined && value === criteria.NOT_EQUAL) {
                return false;
            }
        }
        return true;
    }

    // Helper functions to normalize the given sanitizer configuration
    function caseSensitivityNormalizerForAttributeRules(config) {
        if (!config) {
            return config;
        }
        if (config.constructor == Object) {
            for (var key in config) {
                if (config.hasOwnProperty(key)) {
                    config[key] = configCaseSensitivityNormalizer(config[key]);
                }
            }
        }
        return config;
    }

    function caseSensitivityNormalizerForAppendAttributes(config) {
        if (!config) {
            return config;
        }
        if (config.constructor == Array) {
            for (var i = 0; i < config.length; i++) {
                if (config[i].CRITERIA) {
                    for (var j = 0; j < config[i].CRITERIA.length; j++) {
                        config[i].CRITERIA[j] = configCaseSensitivityNormalizer(config[i].CRITERIA[j]);
                    }
                }
            }
        }
        return config;
    }

    function configCaseSensitivityNormalizer(config) {
        if (config) {
            var flags = ["STARTS_WITH", "ENDS_WITH", "CONTAINS", "EQUAL", "NOT_EQUAL", "LIST"]; // No I18N
            var caseSensitive = config.CASE_SENSITIVE || false;
            if (!caseSensitive) {
                for (var j = 0; j < flags.length; j++) {
                    var eachFlag = flags[j];
                    if (config[eachFlag]) {
                        config[eachFlag] = toLowerCaseValue(config[eachFlag]);
                    }
                }
            }
        }
        return config;
    }

    function toLowerCaseValue(value) {
        if (value && value.constructor == String) {
            return value.toLowerCase();
        } else if (value.constructor == Array) {
            for (var i = 0; i < value.length; i++) {
                value[i] = toLowerCaseValue(value[i]);
            }
        }
        return value;
    }

    function toMap(list, key) {
        if (!list || list.constructor == Object) {
            return list;
        }
        var res = {};
        for (var i = 0; i < list.length; i++) {
            var each = list[i];
            res[each[key]] = each;
        }
        return res;
    }

    function appendAttributes(appendConfig, node) {
        if (!appendConfig) {
            return;
        }
        for (var i = 0; i < appendConfig.length; i++) {
            var element = appendConfig[i];
            if (!node.hasAttribute(element.NAME.toLowerCase())) {
                var conditionSatisfied = true;
                if (element.CRITERIA) {
                    for (var j = 0; j < element.CRITERIA.length; j++) {
                        if (!isValidAttribute(element.CRITERIA[j], node, true)) {
                            conditionSatisfied = false;
                            break;
                        }
                    }
                }
                if (conditionSatisfied) {
                    node.setAttribute(element.NAME, element.VALUE);
                } else if (element.DEFAULT_VALUE != undefined) {
                    node.setAttribute(element.NAME, element.DEFAULT_VALUE);
                }
            }
        }
    }

    function extendTagRules(child, parent) {
        if (!parent || parent.constructor !== Object) {
            return child;
        }
        if (!child || child.constructor !== Object) {
            return parent;
        }
        for (var eachTagRule in parent) {
            if (parent.hasOwnProperty(eachTagRule) && eachTagRule in child) {
                if (child[eachTagRule].APPEND_ATTRIBUTES == undefined) {
                    child[eachTagRule].APPEND_ATTRIBUTES = parent[eachTagRule].APPEND_ATTRIBUTES;
                }
                if (child[eachTagRule].ATTRIBUTE_RULES == undefined) {
                    child[eachTagRule].ATTRIBUTE_RULES = parent[eachTagRule].ATTRIBUTE_RULES;
                }
            } else {
                child[eachTagRule] = parent[eachTagRule];
            }
        }
        return child;
    }

    function validateAttribute(node, validationConf, name) {
        if (validationConf && !isValidAttribute(validationConf, node)) {

            // Default Action will be "REMOVE_ATTRIBUTE" if no DEFAULT_VALUE is specified.
            // YET TO BE RELEASED:
            //
            // TODO: Check if ELEMENT can be removed
            // Also check if KEEP_CONTENT will be applied on element content
            //
            // One possible implementation is to take text content of the element,
            // create a new text node with the text content, link the previous
            // and next elements with this new element(insert the new element next to
            // the old element) and remove old element.

            if(validationConf.DEFAULT_VALUE !== undefined) {
                node.setAttribute(name, validationConf.DEFAULT_VALUE);
            } else {
                node.removeAttribute(name);
            }
            return false;
        }
        return true;
    }

    // Main initializer function. This is first called while setting value to ZSEC.HTMLPurifier, and thenduring all new sanitizer instance creation
    function initialize() {
        config.FORBID_TAGS_OBJ = addObjsToSet(config.FORBID_TAGS_OBJ, defaultForbiddenTags);
        config.FORBID_ATTR_OBJ = addObjsToSet(config.FORBID_ATTR_OBJ, defaultForbiddenAttr);

        for (var eachInheritableConfig in inheritableConfig) {
            if(inheritableConfig.hasOwnProperty(eachInheritableConfig)){
                config[eachInheritableConfig + "_OBJ"] = addToSet(config[eachInheritableConfig + "_OBJ"], config[eachInheritableConfig]) // No I18N
            }
        }

        //Clears any existing Hooks
        DOM.removeAllHooks();
        altered = false;

        //Hooks for Style Validation
        if (config.ALLOWED_STYLE == "NONE") { // No I18N
            config.FORBID_TAGS_OBJ = addToSet(config.FORBID_TAGS_OBJ, ['style']); // No I18N
            config.FORBID_ATTR_OBJ = addToSet(config.FORBID_ATTR_OBJ, ['style']); // No I18N
        }
        if (config.ALLOWED_STYLE == "INLINE" || config.ALLOWED_STYLE == "ALL") { // No I18N
            if (config.STYLE_VALIDATION) {
                // Hook to enforce CSS attribute sanitization
                DOM.addHook('afterSanitizeAttributes', function(node) { // No I18N
                    // Hack fix for baseURI + CSS problems in Chrome
                    if (!node.ownerDocument.baseURI) {
                        var base = document.createElement('base'); // No I18N
                        base.href = document.baseURI;
                        node.ownerDocument.head.appendChild(base);
                    }
                    // Check all style attribute values and validate them
                    if (node.hasAttribute('style')) { // No I18N
                        var output = ''; // No I18N
                        altered = false;
                        validateStyles(node.style);

                        if (altered) {
                            output = node.style.cssText;
                        } else {
                            output = node.getAttribute('style'); // No I18N
                        }

                        // re-add styles in case any are left
                        if (output.length) {
                            node.setAttribute('style', output); // No I18N
                        } else {
                            node.removeAttribute('style'); // No I18N
                        }
                    }
                });
            }
            if (config.ALLOWED_STYLE == "INLINE") { // No I18N
                config.FORBID_TAGS_OBJ = addToSet(config.FORBID_TAGS_OBJ, ['style']); // No I18N
                config.FORBID_ATTR_OBJ = removeFromSet(config.FORBID_ATTR_OBJ, 'style'); // No I18N

            }
        }
        if (config.ALLOWED_STYLE == "INTERNAL" || config.ALLOWED_STYLE == "ALL") { // No I18N
            if (config.STYLE_VALIDATION) {
                // Hook to enforce CSS Element sanitization
                DOM.addHook('uponSanitizeElement', function(node, data) { // No I18N
                    if (data.tagName === 'style') { // No I18N
                        if (node.sheet != null) {
                            var styleSheet = node.sheet.cssRules;
                            altered = false;
                            validateStyleSheet(styleSheet);
                            if (altered) {
                                var output = [];
                                copyValidatedStyleSheet(output, styleSheet);
                                node.textContent = output.join("\n"); // No I18N
                            }
                        }
                    }
                });
            }
            if (config.ALLOWED_STYLE == "INTERNAL") { // No I18N
                config.FORBID_ATTR_OBJ = addToSet(config.FORBID_ATTR_OBJ, ['style']); // No I18N
                config.FORBID_TAGS_OBJ = removeFromSet(config.FORBID_TAGS_OBJ, 'style'); // No I18N
            }
        }
        if (config.ALLOWED_STYLE == "ALL") { // No I18N
            config.FORBID_TAGS_OBJ = removeFromSet(config.FORBID_TAGS_OBJ, 'style'); // No I18N
            config.FORBID_ATTR_OBJ = removeFromSet(config.FORBID_ATTR_OBJ, 'style'); // No I18N
        }

        // Hook to set 'GLOBAL_ATTRIBUTE_RULES' rules
        if (config.GLOBAL_ATTRIBUTE_RULES || config.TAG_RULES) {
            DOM.addHook('afterSanitizeAttributes', function(node) { // No I18N
                var nodeName = node.nodeName.toLowerCase();
                var globalAttributeRule = config.GLOBAL_ATTRIBUTE_RULES;
                var tagAttributeRule = config.TAG_RULES && config.TAG_RULES[nodeName] && config.TAG_RULES[nodeName].ATTRIBUTE_RULES;
                var defaultTagAttributeRule = defaultTagRules && defaultTagRules[nodeName] && defaultTagRules[nodeName].ATTRIBUTE_RULES;

                var l = node.attributes.length;
                while (l--) {
                    var name = node.attributes[l].name;
                    var validationConf = tagAttributeRule && tagAttributeRule[name] || globalAttributeRule && globalAttributeRule[name];
                    if(validateAttribute(node, validationConf, name))
                    {
                        validateAttribute(node, defaultTagAttributeRule && defaultTagAttributeRule[name], name);
                    }
                }

            });
        }

        //Hook to set 'GLOBAL_APPEND_ATTRIBUTES' rules // No I18N
        if (config.GLOBAL_APPEND_ATTRIBUTES || config.TAG_RULES) {
            DOM.addHook('afterSanitizeAttributes', function(node) { // No I18N
                var name = node.nodeName.toLowerCase();
                appendAttributes(config.TAG_RULES && config.TAG_RULES[name] && config.TAG_RULES[name].APPEND_ATTRIBUTES, node);
                appendAttributes(config.GLOBAL_APPEND_ATTRIBUTES, node);
                appendAttributes(defaultTagRules && defaultTagRules[name] && defaultTagRules[name].APPEND_ATTRIBUTES, node);
            });
        }

        // Hook to remove all 'on' events
        if (config.REMOVE_ONEVENTS) {
            DOM.addHook('uponSanitizeAttribute', function(node, hookEvent) { // No I18N
                if (hookEvent.attrName.indexOf("on") == 0) {
                    hookEvent.keepAttr = false;
                }
            });
        }
    }

    //Validate the Configuration given by the user when creating a new sanitizer instance. This attaches any missing, but required, flags/params.
    function validateUserConfig(conf) {
        if (typeof conf == "object") { // No I18N

            /*
             * We tried to encode template content using the below 4 lines.
             * But it lead to double encoding issue because the value is inserted
             * using textContent but it is returned using innerHTML/outerHTML
             *
             * We do not have a solution to this issue as of now, so dropping support for this
             *
             * CODE:
             * value = value.replace(/\{\{/g,"&#x7b;&#x7b;"); // No I18N
             * value = value.replace(/\}\}/g,"&#x7d;&#x7d;"); // No I18N
             * value = value.replace(/<%/g,"&lt;&#x25;"); // No I18N
             * value = value.replace(/%>/g,"&#x25;&gt;"); // No I18N
             *
             */

            //Extending any configurations that may have been missed out

            conf.ALLOWED_TAGS = conf.GLOBAL_TAGS;
            conf.ALLOWED_ATTR = conf.GLOBAL_ATTRIBUTES;

            for (var eachFlag in allConfigFlags) {
                if (allConfigFlags.hasOwnProperty(eachFlag) && (conf[eachFlag] == undefined) && !(eachFlag in otherExtendableConfig)) {
                    conf[eachFlag] = config[eachFlag];
                }
            }

            conf.TAG_RULES = toMap(conf.TAG_RULES, "NAME"); // No I18N
            if (conf.TAG_RULES && conf.TAG_RULES.constructor == Object) {
                for (var tagName in conf.TAG_RULES) {
                    if(conf.TAG_RULES.hasOwnProperty(tagName)){
                        var tagRule = conf.TAG_RULES[tagName];
                        tagRule.ATTRIBUTE_RULES = caseSensitivityNormalizerForAttributeRules(toMap(tagRule.ATTRIBUTE_RULES, "NAME")); // No I18N
                        tagRule.APPEND_ATTRIBUTES = caseSensitivityNormalizerForAppendAttributes(tagRule.APPEND_ATTRIBUTES);
                    }
                }
            }
            conf.GLOBAL_ATTRIBUTE_RULES = caseSensitivityNormalizerForAttributeRules(toMap(conf.GLOBAL_ATTRIBUTE_RULES, "NAME")); // No I18N
            conf.GLOBAL_APPEND_ATTRIBUTES = caseSensitivityNormalizerForAppendAttributes(conf.GLOBAL_APPEND_ATTRIBUTES);

            if (conf.EXTENDS) {
                for (var i = 0; i < conf.EXTENDS.length; i++) {
                    var eachExtendConfig = conf.EXTENDS[i];
                    if (eachExtendConfig == "GLOBAL_TAGS") {
                        eachExtendConfig = "ALLOWED_TAGS"; // No I18N
                    }
                    if (eachExtendConfig == "GLOBAL_ATTRIBUTES") {
                        eachExtendConfig = "ALLOWED_ATTR"; // No I18N
                    }
                    switch (eachExtendConfig) {
                        case "ALLOWED_TAGS": // No I18N
                        case "ALLOWED_ATTR": // No I18N
                        case "FORBID_TAGS": // No I18N
                        case "FORBID_ATTR": // No I18N
                            eachExtendConfig += "_OBJ"; // No I18N
                            conf[eachExtendConfig] = {};
                            if (config[eachExtendConfig]) {
                                conf[eachExtendConfig] = addObjsToSet(conf[eachExtendConfig], config[eachExtendConfig]);
                            }
                            break;

                        case "ADD_URI_SAFE_ATTR": // No I18N
                        case "GLOBAL_APPEND_ATTRIBUTES": // No I18N
                            if (!conf[eachExtendConfig]) {
                                conf[eachExtendConfig] = [];
                            }
                            if (!config[eachExtendConfig] || config[eachExtendConfig].constructor !== Array){
                                break;
                            }
                            conf[eachExtendConfig] = conf[eachExtendConfig].concat(config[eachExtendConfig]);
                            break;

                        case "GLOBAL_ATTRIBUTE_RULES": // No I18N
                            if (!conf.GLOBAL_ATTRIBUTE_RULES) {
                                conf.GLOBAL_ATTRIBUTE_RULES = {};
                            }
                            if (config.GLOBAL_ATTRIBUTE_RULES && config.GLOBAL_ATTRIBUTE_RULES.constructor == Object) {
                                for (var eachAttributeRule in config.GLOBAL_ATTRIBUTE_RULES) {
                                    if (config.GLOBAL_ATTRIBUTE_RULES.hasOwnProperty(eachAttributeRule) && !conf.GLOBAL_ATTRIBUTE_RULES[eachAttributeRule]) {
                                        conf.GLOBAL_ATTRIBUTE_RULES[eachAttributeRule] = config.GLOBAL_ATTRIBUTE_RULES[eachAttributeRule]; // TODO: Clone the object instead of copying reference
                                    }
                                }
                            }
                            break;

                        case "TAG_RULES": // No I18N
                            if (!conf.TAG_RULES) {
                                conf.TAG_RULES = {};
                            }
                            conf.TAG_RULES = extendTagRules(conf.TAG_RULES, config.TAG_RULES)
                            break;
                    }
                }
            }

            for (var eachInheritableConfig in inheritableConfig) {
                //Set all inheritable configuration objects(ALLOWED_ATTR_OBJ,ALLOWED_TAGS_OBJ,etc.) in the configuration to an empty Object
                if(inheritableConfig.hasOwnProperty(eachInheritableConfig)){
                    if (!conf[eachInheritableConfig + "_OBJ"]) {
                        conf[eachInheritableConfig + "_OBJ"] = {}; // No I18N
                    }
                    if (conf[eachInheritableConfig] != undefined) {
                        if (conf[eachInheritableConfig].constructor === Array) {
                            conf[eachInheritableConfig + "_OBJ"] = addToSet(conf[eachInheritableConfig + "_OBJ"], conf[eachInheritableConfig])
                        }
                    } else { //If the inheritable array is not present in configuration
                        conf[eachInheritableConfig] = [];
                    }
                }
            }

            for (var k = 0; k < otherExtendableConfigArray.length; k++) {
                var eachOtherExtendableConfig = otherExtendableConfigArray[k];
                if (!conf[eachOtherExtendableConfig]) {
                    conf[eachOtherExtendableConfig] = [];
                }
            }

            if (conf.ALLOWED_STYLE == "ALL") { // No I18N
                conf.FORBID_TAGS_OBJ = removeFromSet(conf.FORBID_TAGS_OBJ, 'style'); // No I18N
                conf.FORBID_ATTR_OBJ = removeFromSet(conf.FORBID_ATTR_OBJ, 'style'); // No I18N
                conf.ALLOWED_TAGS_OBJ = addToSet(conf.ALLOWED_TAGS_OBJ, ['style']); // No I18N
                conf.ALLOWED_ATTR_OBJ = addToSet(conf.ALLOWED_ATTR_OBJ, ['style']); // No I18N
            } else if (conf.ALLOWED_STYLE == "INLINE") { // No I18N
                conf.FORBID_ATTR_OBJ = removeFromSet(conf.FORBID_ATTR_OBJ, 'style'); // No I18N
                conf.ALLOWED_ATTR_OBJ = addToSet(conf.ALLOWED_ATTR_OBJ, ['style']); // No I18N
                conf.FORBID_TAGS_OBJ = addToSet(conf.FORBID_TAGS_OBJ, ['style']); // No I18N
                conf.ALLOWED_TAGS_OBJ = removeFromSet(conf.ALLOWED_TAGS_OBJ, 'style'); // No I18N
            } else if (conf.ALLOWED_STYLE == "INTERNAL") { // No I18N
                conf.FORBID_TAGS_OBJ = removeFromSet(conf.FORBID_TAGS_OBJ, 'style'); // No I18N
                conf.ALLOWED_TAGS_OBJ = addToSet(conf.ALLOWED_TAGS_OBJ, ['style']); // No I18N
                conf.FORBID_ATTR_OBJ = addToSet(conf.FORBID_ATTR_OBJ, ['style']); // No I18N
                conf.ALLOWED_ATTR_OBJ = removeFromSet(conf.ALLOWED_ATTR_OBJ, 'style');  // No I18N
            } else if (conf.ALLOWED_STYLE == "NONE") { // No I18N
                conf.FORBID_TAGS_OBJ = addToSet(conf.FORBID_TAGS_OBJ, ['style']); // No I18N
                conf.FORBID_ATTR_OBJ = addToSet(conf.FORBID_ATTR_OBJ, ['style']); // No I18N
                conf.ALLOWED_TAGS_OBJ = removeFromSet(conf.ALLOWED_TAGS_OBJ, 'style'); // No I18N
                conf.ALLOWED_ATTR_OBJ = removeFromSet(conf.ALLOWED_ATTR_OBJ, 'style'); // No I18N
            }

            //Push all values in inheritable objects to the inheritable arrays
            //Again, once array is complete and up-to-date, copy the values from the inheritable arrays to the inheritable objects
            for (var eachInheritableConfigFlag in inheritableConfig) {
                if(inheritableConfig.hasOwnProperty(eachInheritableConfigFlag)){
                    for (var eachInheritableConfigObjKey in conf[eachInheritableConfigFlag + "_OBJ"]) { // No I18N
                        if(conf[eachInheritableConfigFlag + "_OBJ"].hasOwnProperty(eachInheritableConfigObjKey)){
                            conf[eachInheritableConfigFlag].push(eachInheritableConfigObjKey);
                        }
                    }
                    conf[eachInheritableConfigFlag + "_OBJ"] = addToSet(conf[eachInheritableConfigFlag + "_OBJ"], conf[eachInheritableConfigFlag]); // No I18N
                }
            }

            // Do any additional validations if it is present
            if (ZSEC.configValidator) {
                ZSEC.configValidator.HTMLPurifierValidation(conf, allConfigFlags, inheritableConfig, defaultForbiddenTags, defaultForbiddenAttr);
            }
        }

        //If no user configuration object is supplied, create a configuration with the default values
        else {
            conf = {};
            for (var each in config) {
                if(config.hasOwnProperty(each)){
                    conf[each] = config[each].valueOf();
                }
            }
        }
        return conf;
    }

    initialize();

    //Function to create new sanitizer instance based on the configuration
    var HTMLPurifier = function(conf) {
        conf = validateUserConfig(conf);
        return factory(conf, DOM(window));
    };


    //Function to sanitize the dirty content
    var sanitize = function(dirty, cfg) {
        var customConfig = parseConfig(cfg);
        var result = DOM.sanitize(dirty, customConfig);
        HTMLPurifier.removed = DOM.removed;
        return result;
    };

    HTMLPurifier.isSupported = DOM.isSupported;
    HTMLPurifier.removed = "";
    ZSEC.util.defineProperty(HTMLPurifier, 'sanitize', sanitize, false, false, true); // No I18N

    return HTMLPurifier;
}));

/**
 * configValidator
 * */
'use strict'; // No I18N
ZSEC.util.defineProperty(ZSEC, 'configValidator', {}, false, false, true); // No I18N

(function(root) {

    function HTMLPurifierValidation(conf, allConfigFlags, inheritableConfig, defaultForbiddenTags, defaultForbiddenAttr) {
        var booleanFlags = addToSet({}, ["ALLOW_ARIA_ATTR", "ALLOW_DATA_ATTR", "ALLOW_UNKNOWN_PROTOCOLS", "SAFE_FOR_JQUERY", "SAFE_FOR_TEMPLATES", "WHOLE_DOCUMENT", "RETURN_DOM", "RETURN_DOM_FRAGMENT", "RETURN_DOM_IMPORT", "FORCE_BODY", "SANITIZE_DOM", "KEEP_CONTENT", "STYLE_VALIDATION", "REMOVE_ONEVENTS"]); // No I18N

        //Check for any misspelled flags
        for (var eachFlag in conf) {
            if (!(eachFlag in allConfigFlags)) {
                throw new Error("Invalid Flag in configuration! Value: " + eachFlag + ". Must be one of the following: " + JSON.stringify(["ALLOW_ARIA_ATTR", "ALLOW_DATA_ATTR", "ALLOW_UNKNOWN_PROTOCOLS", "SAFE_FOR_JQUERY", "SAFE_FOR_TEMPLATES", "WHOLE_DOCUMENT", "RETURN_DOM", "RETURN_DOM_FRAGMENT", "RETURN_DOM_IMPORT", "FORCE_BODY", "SANITIZE_DOM", "KEEP_CONTENT", "STYLE_VALIDATION", "ALLOWED_STYLE", "ALLOWED_TAGS", "ALLOWED_ATTR", "FORBID_TAGS", "FORBID_ATTR", "ADD_URI_SAFE_ATTR", "EXTENDS", "GLOBAL_APPEND_ATTRIBUTES", "GLOBAL_ATTRIBUTE_RULES", "REMOVE_ONEVENTS"])); // No I18N
            }
        }

        //Check Values of all Boolean Flags in the configuration
        for (var eachBooleanFlag in booleanFlags) {
            if (!(conf[eachBooleanFlag] === true || conf[eachBooleanFlag] === false)) {
                throw new Error("Invalid Value for '" + eachBooleanFlag + "' in the configuration. It needs to be either 'true' or 'false'") // No I18N
            }
        }

        //DATA Attributes should be removed when SAFE_FOR_TEMPLATES is set to true
        if (conf.SAFE_FOR_TEMPLATES) {
            if (conf.ALLOW_DATA_ATTR) {
                throw new Error("'ALLOW_DATA_ATTR' should not be set when 'SAFE_FOR_TEMPLATES' is true"); // No I18N
            }
        }

        //Validate value of ALLOWED_STYLE and set allowed tags/attributes accordingly
        if (conf.ALLOWED_STYLE) {
            conf.ALLOWED_STYLE = conf.ALLOWED_STYLE.toUpperCase();
            if (!(conf.ALLOWED_STYLE == "ALL" || conf.ALLOWED_STYLE == "INTERNAL" || conf.ALLOWED_STYLE == "INLINE" || conf.ALLOWED_STYLE == "NONE")) { // No I18N
                throw new Error("Invalid Value for 'ALLOWED_STYLE' in the configuration. It needs to be either 'ALL', 'INTERNAL', 'INLINE' or 'NONE'"); // No I18N
            }
        }

        //Validate ADD_URI_SAFE_ATTR in configuration
        if (conf.ADD_URI_SAFE_ATTR) {
            if (!(conf.ADD_URI_SAFE_ATTR.constructor === Array)) {
                throw new Error("Invalid Value for 'ADD_URI_SAFE_ATTR' in the configuration.It must be an Array"); // No I18N
            }
        } else {
            conf.ADD_URI_SAFE_ATTR = [];
        }

        //Validate GLOBAL_APPEND_ATTRIBUTES rules in the configuration
        if (conf.GLOBAL_APPEND_ATTRIBUTES) {
            for (var each = 0; each < conf.GLOBAL_APPEND_ATTRIBUTES.length; each++) {
                if (conf.GLOBAL_APPEND_ATTRIBUTES[each].NAME != undefined && conf.GLOBAL_APPEND_ATTRIBUTES[each].VALUE != undefined) {
                    if (conf.GLOBAL_APPEND_ATTRIBUTES[each].CRITERIA) {
                        for (var j = 0; j < conf.GLOBAL_APPEND_ATTRIBUTES[each].CRITERIA.length; j++) {
                            var eachCriteria = conf.GLOBAL_APPEND_ATTRIBUTES[each].CRITERIA[j];
                            // TODO: Improve validation checks here
                            if (!eachCriteria.NAME) {
                                throw new Error("Invalid value for MAX_LENGTH in GLOBAL_APPEND_ATTRIBUTES rules", conf.GLOBAL_APPEND_ATTRIBUTES[each]); // No I18N
                            }
                            if (eachCriteria.MAX_LENGTH && eachCriteria.MAX_LENGTH.constructor !== Number) {
                                throw new Error("Invalid value for MAX_LENGTH in GLOBAL_APPEND_ATTRIBUTES rules", conf.GLOBAL_APPEND_ATTRIBUTES[each]); // No I18N
                            }
                            if (eachCriteria.MIN_LENGTH && eachCriteria.MIN_LENGTH.constructor !== Number) {
                                throw new Error("Invalid value for MIN_LENGTH in GLOBAL_APPEND_ATTRIBUTES rules", conf.GLOBAL_APPEND_ATTRIBUTES[each]); // No I18N
                            }
                            if (eachCriteria.REGEX && eachCriteria.REGEX.constructor !== RegExp) {
                                throw new Error("Invalid value for REGEX in GLOBAL_APPEND_ATTRIBUTES rules", conf.GLOBAL_APPEND_ATTRIBUTES[each]); // No I18N
                            }
                            if (eachCriteria.LIST && eachCriteria.LIST.constructor !== Array) {
                                throw new Error("Invalid value for LIST in GLOBAL_APPEND_ATTRIBUTES rules", conf.GLOBAL_APPEND_ATTRIBUTES[each]); // No I18N
                            }
                        }
                    }
                } else {
                    throw new Error("The Attribute Name and Attribute Value must be mentioned for GLOBAL_APPEND_ATTRIBUTES rules", conf.GLOBAL_APPEND_ATTRIBUTES[each]); // No I18N
                }
            }
        } else {
            conf.GLOBAL_APPEND_ATTRIBUTES = [];
        }

        //Validate GLOBAL_ATTRIBUTE_RULES rules in the configuration
        if (conf.GLOBAL_ATTRIBUTE_RULES) {
            for (var i in conf.GLOBAL_ATTRIBUTE_RULES) {
                if (conf.GLOBAL_ATTRIBUTE_RULES.hasOwnProperty(i)) {
                    var eachValidateRule = conf.GLOBAL_ATTRIBUTE_RULES[i];
                    if (!(eachValidateRule.NAME == undefined)) {
                        if (!(eachValidateRule.ACTION == undefined)) {
                            if (eachValidateRule.ACTION != "REMOVE_ATTRIBUTE" && eachValidateRule.ACTION != "REMOVE_ATTRIBUTE_VALUE" && eachValidateRule.ACTION != "REPLACE") {
                                throw new Error("Invalid value for ACTION in GLOBAL_ATTRIBUTE_RULES rule. Must be one of 'REMOVE_ELEMENT', 'REMOVE_ATTRIBUTE', 'REMOVE_ATTRIBUTE_VALUE', or 'REPLACE'", eachValidateRule); // No I18N
                            }
                            if (eachValidateRule.MAX_LENGTH && eachValidateRule.MAX_LENGTH.constructor !== Number) {
                                throw new Error("Invalid value for MAX_LENGTH in GLOBAL_ATTRIBUTE_RULES rules", eachValidateRule); // No I18N
                            }
                            if (eachValidateRule.MIN_LENGTH && eachValidateRule.MIN_LENGTH.constructor !== Number) {
                                throw new Error("Invalid value for MIN_LENGTH in GLOBAL_ATTRIBUTE_RULES rules", eachValidateRule); // No I18N
                            }
                            if (eachValidateRule.REGEX && eachValidateRule.REGEX.constructor !== RegExp) {
                                throw new Error("Invalid value for REGEX in GLOBAL_ATTRIBUTE_RULES rules", eachValidateRule); // No I18N
                            }
                            if (eachValidateRule.LIST && eachValidateRule.LIST.constructor !== Array) {
                                throw new Error("Invalid value for LIST in GLOBAL_ATTRIBUTE_RULES rules", eachValidateRule); // No I18N
                            }
                        } else {
                            throw new Error("ACTION must be mentioned for GLOBAL_ATTRIBUTE_RULES rules", eachValidateRule); // No I18N
                        }
                    } else {
                        throw new Error("The Attribute Name must be mentioned for GLOBAL_ATTRIBUTE_RULES rules", eachValidateRule); // No I18N
                    }
                }
            }
        } else {
            conf.GLOBAL_ATTRIBUTE_RULES = {};
        }

        //Check for mismatch in style validation
        if (conf.ALLOWED_STYLE == "ALL") { // No I18N
            if (conf.FORBID_TAGS.indexOf('style') > -1 || conf.FORBID_ATTR.indexOf('style') > -1) { // No I18N
                throw new Error("You have added style to the forbidden tag/attribute list but have specified to not remove it in the 'ALLOWED_STYLE' flag by setting it to 'ALL'"); // No I18N
            }
        } else if (conf.ALLOWED_STYLE == "INLINE") { // No I18N
            if (conf.FORBID_ATTR.indexOf('style') > -1) { // No I18N
                throw new Error("You have added style to the forbidden tag/attribute list but have specified to not remove it in the 'ALLOWED_STYLE' flag by setting it to 'INLINE'"); // No I18N
            }
            if (conf.ALLOWED_TAGS.indexOf('style') > -1) { // No I18N
                throw new Error("You have added style to the allowed tag list but have specified to remove it in the 'ALLOWED_STYLE' flag by setting it to 'INLINE'"); // No I18N
            }
        } else if (conf.ALLOWED_STYLE == "INTERNAL") { // No I18N
            if (conf.FORBID_TAGS.indexOf('style') > -1) { // No I18N
                throw new Error("You have added style to the forbidden tag/attribute list but have specified to not remove it in the 'ALLOWED_STYLE' flag by setting it to 'INTERNAL'"); // No I18N
            }
            if (conf.ALLOWED_ATTR.indexOf('style') > -1) { // No I18N
                throw new Error("You have added style to the allowed attribute list but have specified to remove it in the 'ALLOWED_STYLE' flag by setting it to 'INTERNAL'"); // No I18N
            }
        } else if (conf.ALLOWED_STYLE == "NONE") { // No I18N
            if (conf.ALLOWED_TAGS.indexOf('style') > -1 || conf.ALLOWED_ATTR.indexOf('style') > -1) { // No I18N
                throw new Error("You have added style to the allowed tag/attribute list but have specified to remove it in the 'ALLOWED_STYLE' flag by setting it to 'NONE'"); // No I18N
            }
        }

        //Check for mismatches between allowed/forbidden tags/attributes
        for (var each in conf.ALLOWED_TAGS_OBJ) {
            if (each.toLowerCase() in conf.FORBID_TAGS_OBJ) {
                if (each != "style") { // No I18N
                    throw new Error("Conflict in Allowed and Forbidden Tags! Tag '" + each + "' is given in FORBID_TAGS and ALLOWED_TAGS in configuration!"); // No I18N
                }
            }
            if (each.toLowerCase() in defaultForbiddenTags) {
                throw new Error("Tag '" + each + "' is forbidden by default. The following Tags are forbidden by default: 'script','iframe' "); // No I18N
            }
        }
        for (var each in conf.ALLOWED_ATTR_OBJ) {
            if (each.toLowerCase() in conf.FORBID_ATTR_OBJ) {
                if (each != "style") { // No I18N
                    throw new Error("Conflict in Allowed and Forbidden Attributes! Attribute '" + each + "' is given in FORBID_ATTR and ALLOWED_ATTR in configuration!"); // No I18N
                }
            }
            if (each.toLowerCase() in defaultForbiddenAttr) {
                throw new Error("Attribute '" + each + "' is forbidden by default. The following Attributes are forbidden by default: "); // No I18N
            }
        }
    }

    ZSEC.util.defineProperty(root, 'HTMLPurifierValidation', HTMLPurifierValidation, false, false, true); // No I18N

})(ZSEC.configValidator);



/**
 * secureRedirector
 * */
'use strict'; // No I18N
(function(secureRedirector) {
    ZSEC.util.defineProperty(ZSEC, 'secureRedirector', secureRedirector(), true, false, false, true); // No I18N
}(function() {

    var oldIE = navigator.userAgent.indexOf('MSIE') !== -1;
    var open = window.open;
    var jsVulnCharMap = {
        '\''    : '\\x27', // No I18N
        '"'     : '\\x22',
        '`'     : '\\x60', // No I18N
        '\n'    : '\\x0A', // No I18N
        '\r'    : '\\x0D', // No I18N
        '<'     : '\\x3C',
        '>'     : '\\x3E',
        ')'     : '\\x29'
    };

    /**
     * secureRedirector accepts an element or array of elements which contains elements vulnerable to reverse tabnabbing based phishing attacks,
     * and secures them by adding an event listener to help mitigate a potential reverse tabnabbing attack.
     * It will also monitor the changes(if monitor flag set to true) in the element and add listeners to the newly added vulnerable elements.
     *
     * @param {HTMLElement|HTMLElement[]} target
     * @param {Boolean} monitor
     */
    function secureRedirector(target, monitor) {
        //For performance, any supplied object with a length attribute is assumed to be an array of elements.
        if (typeof target.length === 'undefined') {
            checkAndAddListener(target);
            if (monitor) {
                elementInsertionListener(target, secureRedirector);
            }
        } else if (typeof target !== 'string' && !(target instanceof String)) { // No I18N
            for (var i = 0; i < target.length; i++) {
                checkAndAddListener(target[i]);
                if (monitor) {
                    elementInsertionListener(target, secureRedirector);
                }
            }
        }
    }

    /**
     * it iterates over all the child elements and sets click listener for the element where reverse tabnabbing based phishing attacks are possible
     * @param   {Element} target
     * */
    function checkAndAddListener(target) {
        if (target.nodeType != 1) {
            return;
        }
        var elementName = target.nodeName;
        if (elementName == 'A' || elementName == 'a' || elementName == 'MATH' || elementName == 'math') {
            addEventListener(target, 'click', clickListener); // No I18N
        }
        var childElement = target.childNodes;
        if (childElement && childElement.length) {
            var childCount = childElement.length;
            for (var i = 0; i < childCount; i++) {
                var each = childElement[i];
                if (each.nodeType == 1) {
                    checkAndAddListener(each);
                }
            }
        }
    }

    /**
     * it sets listener for an element to capture the new element insertion, using either MutationObserver or element.addEventListener based on the browser support
     * @param   {Element} element
     * @param   {Function} callback
     * */
    function elementInsertionListener(element, callback) {
        var MutationObserver = window.MutationObserver || window.WebKitMutationObserver,
            eventListenerSupported = window.addEventListener;
        if (MutationObserver) {
            var obs = new MutationObserver(function(mutations, observer) {
                for (var i = 0; i < mutations.length; i++) {
                    var addedNodesSize = mutations[i].addedNodes.length;
                    if (addedNodesSize) {
                        var addedList = mutations[i].addedNodes;
                        for (var j = 0; j < addedNodesSize; j++) {
                            callback(addedList[j]);
                        }
                    }
                }
            });
            obs.observe(element, {
                childList: true,
                subtree: true
            });
        } else if (eventListenerSupported) {
            element.addEventListener('DOMNodeInserted', function(e) {
                callback(e.target)
            }, false);
        }
    };

    /**
     * Accepts the same arguments as window.open. If the strWindowName is not
     * equal to one of the safe targets (_top, _self or _parent), then it opens
     * the destination url using "window.open" from an injected iframe, then
     * removes the iframe. This behavior applies to all browsers except IE < 11,
     * which use "window.open" followed by setting the child window's opener to
     * null. If the strWindowName is set to some other value, the url is simply
     * opened with window.open().
     *
     * @param   {string} strUrl
     * @param   {string} [strWindowName]
     * @param   {string} [strWindowFeatures]
     * @returns {Window}
     */
    secureRedirector.open = function(strUrl, strWindowName, strWindowFeatures) {
        var child;

        if (safeTarget(strWindowName)) {
            return open.apply(window, arguments);
        } else if (!oldIE) {
            return iframeOpen(strUrl, strWindowName, strWindowFeatures);
        } else {
            // Replace child.opener for old IE to avoid appendChild errors
            // We do it for all to avoid having to sniff for specific versions
            child = open.apply(window, arguments);
            child.opener = null;
            return child;
        }
    };

    /**
     * Patches window.open() to use blankshield.open() for new window/tab targets.
     */
    secureRedirector.patch = function() {
        window.open = function() {
            return secureRedirector.open.apply(this, arguments);
        };
    };

    /**
     * An event listener that can be attached to a click event to protect against
     * reverse tabnabbing. It retrieves the target anchors href, and if the link
     * was intended to open in a new tab or window, the browser's default
     * behavior is canceled. Instead, the destination url is opened using
     * "window.open" from an injected iframe, and the iframe is removed. Except
     * for IE < 11, which uses "window.open" followed by setting the child
     * window's opener to null.
     *
     * @param {Event} e The click event for a given anchor
     */
    function clickListener(e) {
        var target, targetName, href, usedModifier;

        // Use global event object for IE8 and below to get target
        e = e || window.event;
        // Won't work for IE8 and below for cases when e.srcElement
        // refers not to the anchor, but to the element inside it e.g. an image
        target = e.currentTarget || e.srcElement;

        // Ignore anchors without an href
        href = target.getAttribute('href');
        if (!href) {
            href = target.getAttribute('xlink:href');
            if (!href) {
                return;
            }
        }

        // Ignore anchors without an unsafe target or modifier key
        usedModifier = (e.ctrlKey || e.shiftKey || e.metaKey);
        targetName = target.getAttribute('target');
        var target2 = target.getAttribute('xlink:show');
        if (!usedModifier && (!targetName || safeTarget(targetName)) && !target2) {
            return;
        }

        secureRedirector.open(href);

        // IE8 and below don't support preventDefault
        if (e.preventDefault) {
            e.preventDefault();
        } else {
            e.returnValue = false;
        }

        return false;
    }

    /**
     * A cross-browser addEventListener function that adds a listener for the
     * supplied event type to the specified target.
     *
     * @param {object}   target
     * @param {string}   type
     * @param {function} listener
     */
    function addEventListener(target, type, listener) {
        var onType, prevListener;
        // Modern browsers
        if (target.addEventListener) {
            return target.addEventListener(type, listener, false);
        }

        // Older browsers
        onType = 'on' + type; // No I18N
        if (target.attachEvent) {
            target.attachEvent(onType, listener);
        } else if (target[onType]) {
            prevListener = target[onType];
            target[onType] = function() {
                listener();
                prevListener();
            };
        } else {
            target[onType] = listener;
        }
    }

    /**
     * Replaces vulnerable characters in the given string 
     * with safe characters from the given character map
     *
     * @param   {string}  str      The string with vulnerable characters
     * @param   {Map}     charMap  Map of vulnerable characters as keys with safe characters as values
     *
     * @return  {string}           Safe string without vulnerable characters
     */
    function replaceVulnChars(str, charMap) {
        if(!charMap || !str){
            return str;
        }
        var newStr = "";
        for(var i = 0; i < str.length; i++){
            if(charMap.hasOwnProperty(str[i])){
                newStr += charMap[str[i]];
            } else {
                newStr += str[i];
            }
        }
        return newStr;    
    }

    /**
     * Opens the provided url by injecting a hidden iframe that calls
     * window.open(), then removes the iframe from the DOM.
     *
     * @param   {string} url The url to open
     * @param   {string} [strWindowName]
     * @param   {string} [strWindowFeatures]
     * @returns {Window}
     */
    function iframeOpen(url, strWindowName, strWindowFeatures) {
        var iframe, iframeDoc, script, openArgs, newWin;

        iframe = document.createElement('iframe');
        iframe.style.display = 'none';
        document.body.appendChild(iframe);
        iframeDoc = iframe.contentDocument || iframe.contentWindow.document;

        openArgs = '"' + window.encodeURI(url) + '"'; // No I18N
        if (strWindowName) {
            openArgs += ', "' + replaceVulnChars(strWindowName, jsVulnCharMap) + '"'; // No I18N
        }
        if (strWindowFeatures) {
            openArgs += ', "' + replaceVulnChars(strWindowFeatures, jsVulnCharMap) + '"'; // No I18N
        }

        script = iframeDoc.createElement('script');
        script.type = 'text/javascript';
        script.text = 'window.parent = null; window.top = null;' +
            'window.frameElement = null; var child = window.open(' + openArgs + ');' +
            'try{child.opener = null;}catch(e){}'; // No I18N
        iframeDoc.body.appendChild(script);
        newWin = iframe.contentWindow.child;

        document.body.removeChild(iframe);
        return newWin;
    }

    /**
     * Returns whether or not the given target is safe.
     *
     * @param  {string}  target
     * @return {boolean}
     */
    function safeTarget(target) {
        return target === '_top' || target === '_self' || target === '_parent'; // No I18N
    }

    if (Object.freeze) {
        Object.freeze(secureRedirector)
    }
    return secureRedirector;
}));

/**
 * TextFilter
 * */
'use strict'; // No I18N
(function() {

    //Create new TextFilter instance
    var TextFilter = {};

    //Function to Filter the given XML String
    TextFilter.filterXML = function(xmlString) {
        var xmlStringBuilder = "";
        for (var i = 0, xmlStringLength = xmlString.length; i < xmlStringLength; i++) {
            var codePoint = xmlString.codePointAt(i);
            var xmlChar = xmlString.charAt(i);
            if ((codePoint == 0x9) ||
                (codePoint == 0xA) ||
                (codePoint == 0xD) ||
                ((codePoint >= 0x20) && (codePoint <= 0xD7FF)) ||
                ((codePoint >= 0xE000) && (codePoint <= 0xFFFD)) ||
                ((codePoint >= 0x10000) && (codePoint <= 0x10FFFF))
            ) {
                xmlStringBuilder += xmlChar;
            }
            if (codePoint > 0xFFFF) {
                i++;
            }
        }
        return xmlStringBuilder;
    };

    if (Object.freeze) {
        Object.freeze(TextFilter)
    }

    ZSEC.util.defineProperty(ZSEC, 'TextFilter', TextFilter, true, false, false, true); // No I18N
})();

/**
 * URLValidator
 * */
'use strict'; // No I18N
(function() {
    var constants = {
        unsafeProtocolRegex : /^(?:\w+script|data)$/i,
        sanitizeAction : {
            ACTION_ENCODE : "ENCODE",
            ACTION_REMOVE : "REMOVE"
        }
    }

    /**
     * URLValidator is the main object that is set to ZSEC.
     * Create a new URLValidator instance and pass as argument
     * @type {Object}
     */
    var URLValidator = {};

    (function(root){

    /*--------------------------------------------------------------------------*/
    /*-----------------------Punycode.js Code Starts----------------------------*/
    /*--------------------------------------------------------------------------*/

     /**
     * The `punycode` object.
     * @name punycode
     * @type Object
     */
    var punycode,

    /** Highest positive signed 32-bit float value */
    maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

    /** Bootstring parameters */
    base = 36,
    tMin = 1,
    tMax = 26,
    skew = 38,
    damp = 700,
    initialBias = 72,
    initialN = 128, // 0x80
    delimiter = '-',  // No I18N
    // '\x2D'

    /** Regular expressions */
    regexPunycode = /^xn--/,
    regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
    regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

    /** Error messages */
    errors = {
        'overflow': 'Overflow: input needs wider integers to process', // No I18N
        'not-basic': 'Illegal input >= 0x80 (not a basic code point)', // No I18N
        'invalid-input': 'Invalid input' // No I18N
    },

    /** Convenience shortcuts */
    baseMinusTMin = base - tMin,
    floor = Math.floor,
    stringFromCharCode = String.fromCharCode,

    /** Temporary variable */
    key;

    /*--------------------------------------------------------------------------*/

    /**
     * A generic error utility function.
     * @private
     * @param {String} type The error type.
     * @returns {Error} Throws a `RangeError` with the applicable error message.
     */
    function error(type) {
        throw new RangeError(errors[type]);
    }

    /**
     * A generic `Array#map` utility function.
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} callback The function that gets called for every array
     * item.
     * @returns {Array} A new array of values returned by the callback function.
     */
    function map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
            result[length] = fn(array[length]);
        }
        return result;
    }

    /**
     * A simple `Array#map`-like wrapper to work with domain name strings or email
     * addresses.
     * @private
     * @param {String} domain The domain name or email address.
     * @param {Function} callback The function that gets called for every
     * character.
     * @returns {Array} A new string of characters returned by the callback
     * function.
     */
    function mapDomain(string, fn) {
        var parts = string.split('@');
        var result = '';
        if (parts.length > 1) {
            // In email addresses, only the domain name should be punycoded. Leave
            // the local part (i.e. everything up to `@`) intact.
            result = parts[0] + '@';
            string = parts[1];
        }
        // Avoid `split(regex)` for IE8 compatibility. See #17.
        string = string.replace(regexSeparators, '\x2E');
        var labels = string.split('.');
        var encoded = map(labels, fn).join('.');
        return result + encoded;
    }

    /**
     * Creates an array containing the numeric code points of each Unicode
     * character in the string. While JavaScript uses UCS-2 internally,
     * this function will convert a pair of surrogate halves (each of which
     * UCS-2 exposes as separate characters) into a single code point,
     * matching UTF-16.
     * @see `punycode.ucs2.encode`
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode.ucs2
     * @name decode
     * @param {String} string The Unicode input string (UCS-2).
     * @returns {Array} The new array of code points.
     */
    function ucs2decode(string) {
        var output = [],
            counter = 0,
            length = string.length,
            value,
            extra;
        while (counter < length) {
            value = string.charCodeAt(counter++);
            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                // high surrogate, and there is a next character
                extra = string.charCodeAt(counter++);
                if ((extra & 0xFC00) == 0xDC00) { // low surrogate
                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                } else {
                    // unmatched surrogate; only append this code unit, in case the next
                    // code unit is the high surrogate of a surrogate pair
                    output.push(value);
                    counter--;
                }
            } else {
                output.push(value);
            }
        }
        return output;
    }

    /**
     * Creates a string based on an array of numeric code points.
     * @see `punycode.ucs2.decode`
     * @memberOf punycode.ucs2
     * @name encode
     * @param {Array} codePoints The array of numeric code points.
     * @returns {String} The new Unicode string (UCS-2).
     */
    function ucs2encode(array) {
        return map(array, function(value) {
            var output = '';
            if (value > 0xFFFF) {
                value -= 0x10000;
                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                value = 0xDC00 | value & 0x3FF;
            }
            output += stringFromCharCode(value);
            return output;
        }).join('');
    }

    /**
     * Converts a basic code point into a digit/integer.
     * @see `digitToBasic()`
     * @private
     * @param {Number} codePoint The basic numeric code point value.
     * @returns {Number} The numeric value of a basic code point (for use in
     * representing integers) in the range `0` to `base - 1`, or `base` if
     * the code point does not represent a value.
     */
    function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
            return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
            return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
            return codePoint - 97;
        }
        return base;
    }

    /**
     * Converts a digit/integer into a basic code point.
     * @see `basicToDigit()`
     * @private
     * @param {Number} digit The numeric value of a basic code point.
     * @returns {Number} The basic code point whose value (when used for
     * representing integers) is `digit`, which needs to be in the range
     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
     * used; else, the lowercase form is used. The behavior is undefined
     * if `flag` is non-zero and `digit` has no uppercase form.
     */
    function digitToBasic(digit, flag) {
        //  0..25 map to ASCII a..z or A..Z
        // 26..35 map to ASCII 0..9
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }

    /**
     * Bias adaptation function as per section 3.4 of RFC 3492.
     * https://tools.ietf.org/html/rfc3492#section-3.4
     * @private
     */
    function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
            delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    }

    /**
     * Converts a Punycode string of ASCII-only symbols to a string of Unicode
     * symbols.
     * @memberOf punycode
     * @param {String} input The Punycode string of ASCII-only symbols.
     * @returns {String} The resulting string of Unicode symbols.
     */
    function decode(input) {
        // Don't use UCS-2
        var output = [],
            inputLength = input.length,
            out,
            i = 0,
            n = initialN,
            bias = initialBias,
            basic,
            j,
            index,
            oldi,
            w,
            k,
            digit,
            t,
            /** Cached calculation results */
            baseMinusT;

        // Handle the basic code points: let `basic` be the number of input code
        // points before the last delimiter, or `0` if there is none, then copy
        // the first basic code points to the output.

        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
            basic = 0;
        }

        for (j = 0; j < basic; ++j) {
            // if it's not a basic code point
            if (input.charCodeAt(j) >= 0x80) {
                error('not-basic');  // No I18N
            }
            output.push(input.charCodeAt(j));
        }

        // Main decoding loop: start just after the last delimiter if any basic code
        // points were copied; start at the beginning otherwise.

        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

            // `index` is the index of the next character to be consumed.
            // Decode a generalized variable-length integer into `delta`,
            // which gets added to `i`. The overflow checking is easier
            // if we increase `i` as we go, then subtract off its starting
            // value at the end to obtain `delta`.
            for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

                if (index >= inputLength) {
                    error('invalid-input'); // No I18N
                }

                digit = basicToDigit(input.charCodeAt(index++));

                if (digit >= base || digit > floor((maxInt - i) / w)) {
                    error('overflow'); // No I18N
                }

                i += digit * w;
                t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

                if (digit < t) {
                    break;
                }

                baseMinusT = base - t;
                if (w > floor(maxInt / baseMinusT)) {
                    error('overflow'); // No I18N
                }

                w *= baseMinusT;

            }

            out = output.length + 1;
            bias = adapt(i - oldi, out, oldi == 0);

            // `i` was supposed to wrap around from `out` to `0`,
            // incrementing `n` each time, so we'll fix that now:
            if (floor(i / out) > maxInt - n) {
                error('overflow'); // No I18N
            }

            n += floor(i / out);
            i %= out;

            // Insert `n` at position `i` of the output
            output.splice(i++, 0, n);

        }

        return ucs2encode(output);
    }

    /**
     * Converts a string of Unicode symbols (e.g. a domain name label) to a
     * Punycode string of ASCII-only symbols.
     * @memberOf punycode
     * @param {String} input The string of Unicode symbols.
     * @returns {String} The resulting Punycode string of ASCII-only symbols.
     */
    function encode(input) {
        var n,
            delta,
            handledCPCount,
            basicLength,
            bias,
            j,
            m,
            q,
            k,
            t,
            currentValue,
            output = [],
            /** `inputLength` will hold the number of code points in `input`. */
            inputLength,
            /** Cached calculation results */
            handledCPCountPlusOne,
            baseMinusT,
            qMinusT;

        // Convert the input in UCS-2 to Unicode
        input = ucs2decode(input);

        // Cache the length
        inputLength = input.length;

        // Initialize the state
        n = initialN;
        delta = 0;
        bias = initialBias;

        // Handle the basic code points
        for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < 0x80) {
                output.push(stringFromCharCode(currentValue));
            }
        }

        handledCPCount = basicLength = output.length;

        // `handledCPCount` is the number of code points that have been handled;
        // `basicLength` is the number of basic code points.

        // Finish the basic string - if it is not empty - with a delimiter
        if (basicLength) {
            output.push(delimiter);
        }

        // Main encoding loop:
        while (handledCPCount < inputLength) {

            // All non-basic code points < n have been handled already. Find the next
            // larger one:
            for (m = maxInt, j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue >= n && currentValue < m) {
                    m = currentValue;
                }
            }

            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
            // but guard against overflow
            handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                error('overflow'); // No I18N
            }

            delta += (m - n) * handledCPCountPlusOne;
            n = m;

            for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];

                if (currentValue < n && ++delta > maxInt) {
                    error('overflow'); // No I18N
                }

                if (currentValue == n) {
                    // Represent delta as a generalized variable-length integer
                    for (q = delta, k = base; /* no condition */; k += base) {
                        t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                        if (q < t) {
                            break;
                        }
                        qMinusT = q - t;
                        baseMinusT = base - t;
                        output.push(
                            stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                        );
                        q = floor(qMinusT / baseMinusT);
                    }

                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                    delta = 0;
                    ++handledCPCount;
                }
            }

            ++delta;
            ++n;

        }
        return output.join('');
    }

    /**
     * Converts a Punycode string representing a domain name or an email address
     * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
     * it doesn't matter if you call it on a string that has already been
     * converted to Unicode.
     * @memberOf punycode
     * @param {String} input The Punycoded domain name or email address to
     * convert to Unicode.
     * @returns {String} The Unicode representation of the given Punycode
     * string.
     */
    function toUnicode(input) {
        return mapDomain(input, function(string) {
            return regexPunycode.test(string)
                ? decode(string.slice(4).toLowerCase())
                : string;
        });
    }

    /**
     * Converts a Unicode string representing a domain name or an email address to
     * Punycode. Only the non-ASCII parts of the domain name will be converted,
     * i.e. it doesn't matter if you call it with a domain that's already in
     * ASCII.
     * @memberOf punycode
     * @param {String} input The domain name or email address to convert, as a
     * Unicode string.
     * @returns {String} The Punycode representation of the given domain name or
     * email address.
     */
    function toASCII(input) {
        return mapDomain(input, function(string) {
            return regexNonASCII.test(string)
                ? 'xn--' + encode(string) // No I18N
                : string;
        });
    }

    /*--------------------------------------------------------------------------*/

    /** Define the public API */
    punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        'version': '1.4.1', // No I18N
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        'ucs2': { // No I18N
            'decode': ucs2decode, // No I18N
            'encode': ucs2encode // No I18N
        },
        'decode': decode, // No I18N
        'encode': encode, // No I18N
        'toASCII': toASCII, // No I18N
        'toUnicode': toUnicode // No I18N
    };

    root.punycode = punycode;
    /*--------------------------------------------------------------------------*/
    /*-----------------------Punycode.js Code Ends------------------------------*/
    /*--------------------------------------------------------------------------*/
    })(URLValidator);

    /**
     * Sanitizes the given URL and returns a safe URL/Object based on the given 
     * configuration. By default, it resolves a partial URL to a complete URL, 
     * punycodes non-ASCII domain names by default, allows only http/https protocols.
     * 
     * @param  {String} userURL URL to Sanitize
     * @param  {Object} config  Custom Config for URL Sanitization
     * @return {String/Object}         Sanitized URL
     */
    URLValidator.sanitize = function(userURL, config) {

        if (!userURL) {
            //  No User URL, return empty
            return "";
        }
        //  If no config is given, use default config
        config = config || {};

        config.ALLOWED_PROTOCOLS    = config.ALLOWED_PROTOCOLS  || ["https", "http"]; // No I18N
        config.RETURN_PUNYCODE      = config.RETURN_PUNYCODE    != false;
        config.ACTION               = config.ACTION             || constants.sanitizeAction.ACTION_ENCODE;
        config.RETURN_OBJECT        = config.RETURN_OBJECT      || false;
        config.RETURN_ORIGINAL      = config.RETURN_ORIGINAL    || false;

        var anchorTag;

/*
        ////////////////////////////
        //  Original Method Start //
        ////////////////////////////
        
        //  URL is set through innerHTML and not through href property of anchor tag.
        //  This is because if a partial URL is set and got through the href property,
        //  it will only be returned as the original partial value. But setting
        //  through innerHTML and getting through href property will return
        //  the fully resolved URL.
        //
        //  Example - While in sites.zoho.com,
        //
        //  1) USING HREF PROPERTY:
        //      anchorTag.href = "/pages/page/1";
        //      return anchorTag.href;
        //
        //  This will return "/pages/page/1" in some old browsers
        //
        //  2) USING INNERHTML:
        //      divTag.innerHTML = "<a href='/pages/page/1'>Link</a>";
        //      return divTag.childNodes[0].href;
        //
        //  This will return "https://sites.zoho.com/pages/page/1" in all browsers

        //  Also, encodeURI will encode all double quotes(") but not single quotes(').
        //  So the href attribute in the innerHTML should be enclosed with double quotes
        //  to prevent the URL from breaking out of the href attribute value.

        var tempContainer = document.createElement('div');
        tempContainer.innerHTML = '<a href="' + encodeURI(userURL) + '">a</a>';
        anchorTag = tempContainer.childNodes[0];

        //////////////////////////
        //  Original Method End //
        //////////////////////////
*/      
        ///////////////////////////////////////////////////
        //  New Method Start (Method #3)                 //
        //  Tested in all browsers. See here for results //
        ///////////////////////////////////////////////////
        
        var a = document.createElement('a');
        a.href = userURL;
        anchorTag = a.cloneNode(false);

        /////////////////////////////////
        //  New Method End (Method #3) //
        /////////////////////////////////


        var protocol        = anchorTag.protocol.slice(0, -1); // This is to remove the trailing colon ':' which is returned when getting the protocol
        var domain          = anchorTag.host;
        var port            = anchorTag.port;
        var path            = anchorTag.pathname;
        var hash            = anchorTag.hash;
        var resolvedURL     = anchorTag.href;

        var isDomainSafe    = true;
        var isProtocolSafe  = true;

        //  Return in non-ASCII characters only if explicitly mentioned in config.
        //  Otherwise, return punycoded value by default
        if (!config.RETURN_PUNYCODE){
            domain = URLValidator.punycode.toUnicode(domain);
            resolvedURL = URLValidator.punycode.toUnicode(resolvedURL);
        } else {
            domain = URLValidator.punycode.toASCII(domain);
            resolvedURL = URLValidator.punycode.toASCII(resolvedURL);
        }

        // Protocol Check
        if (config.ALLOWED_PROTOCOLS){
            isProtocolSafe = false; // Should be false by default. Make it true only if it matches any of the protocol values
            if (config.ALLOWED_PROTOCOLS.constructor === Array && config.ALLOWED_PROTOCOLS.length > 0 ){
                for(var i = 0; i < config.ALLOWED_PROTOCOLS.length && isProtocolSafe != true; i++){
                    var eachProtocol = config.ALLOWED_PROTOCOLS[i];
                    if(eachProtocol.constructor === RegExp){
                        if(eachProtocol.test(protocol)){
                            isProtocolSafe = true;
                        }
                    } else if (eachProtocol.constructor === String){
                        if(eachProtocol == protocol){
                            isProtocolSafe = true;
                        }
                    }
                }
            }
        } else if (constants.unsafeProtocolRegex.test(protocol)) {
            // Matches our default unsafe protocol regex so protocol is not safe, return false
            isProtocolSafe = false;
        }

        // Domain Check
        if (config.ALLOWED_DOMAINS){
            isDomainSafe = false; // Should be false by default. Make it true only if it matches any of the domain values
            var punycodedDomain     = URLValidator.punycode.toASCII(domain);    // We need both punycoded and non-punycoded domain values
            var nonPunycodedDomain  = URLValidator.punycode.toUnicode(domain);  // to check the ALLOWED_DOMAINS list for ease of use
            if (config.ALLOWED_DOMAINS.constructor === Array && config.ALLOWED_DOMAINS.length > 0 ){
                for(var i = 0; i < config.ALLOWED_DOMAINS.length && isDomainSafe != true; i++){
                    var eachDomain = config.ALLOWED_DOMAINS[i];
                    if(eachDomain.constructor === RegExp){
                        if(eachDomain.test(punycodedDomain) || eachDomain.test(nonPunycodedDomain)){ // Check both punycoded and non-punycoded domain values
                            isDomainSafe = true;
                        }
                    } else if (eachDomain.constructor === String){
                        if(eachDomain == punycodedDomain || eachDomain == nonPunycodedDomain){ // Check both punycoded and non-punycoded domain values
                            isDomainSafe = true;
                        }
                    }
                }
            }
        }

        if(isDomainSafe){
            if(isProtocolSafe){
                if(config.RETURN_OBJECT){
                    return {
                        "PROTOCOL":     protocol, // No I18N
                        "DOMAIN":       domain, // No I18N
                        "PORT":         port, // No I18N
                        "PATH":         path, // No I18N
                        "HASH":         hash, // No I18N
                        "RESOLVED_URL": resolvedURL, // No I18N
                        "ORIGINAL_URL": userURL // No I18N
                    }
                }
                if(config.RETURN_ORIGINAL){
                    return userURL;
                }
                return resolvedURL;
            } else {
                if (config.ACTION == constants.sanitizeAction.ACTION_ENCODE) {
                    return resolvedURL.replace(/:/, "%3A");
                }
            }
        }
        return "";
    };


    URLValidator.sanitize.config = {
        ACTION              : constants.sanitizeAction.ACTION_ENCODE,
        ALLOWED_PROTOCOLS   : ["https", "http"], // No I18N
        RETURN_PUNYCODE     : true,
        RETURN_OBJECT       : false,
        RETURN_ORIGINAL     : false
    }

    if (Object.freeze) {
        URLValidator = Object.freeze(URLValidator);
    }

    ZSEC.util.defineProperty(ZSEC, 'URLValidator', URLValidator, true, false, false, true); // No I18N
})();