

/**
 * secureRedirector
 * */
'use strict'; // No I18N
(function(secureRedirector) {
    ZSEC.util.defineProperty(ZSEC, 'secureRedirector', secureRedirector(), true, false, false, true); // No I18N
}(function() {

    var oldIE = navigator.userAgent.indexOf('MSIE') !== -1;
    var open = window.open;
    var jsVulnCharMap = {
        '\''    : '\\x27', // No I18N
        '"'     : '\\x22',
        '`'     : '\\x60', // No I18N
        '\n'    : '\\x0A', // No I18N
        '\r'    : '\\x0D', // No I18N
        '<'     : '\\x3C',
        '>'     : '\\x3E',
        ')'     : '\\x29'
    };

    /**
     * secureRedirector accepts an element or array of elements which contains elements vulnerable to reverse tabnabbing based phishing attacks,
     * and secures them by adding an event listener to help mitigate a potential reverse tabnabbing attack.
     * It will also monitor the changes(if monitor flag set to true) in the element and add listeners to the newly added vulnerable elements.
     *
     * @param {HTMLElement|HTMLElement[]} target
     * @param {Boolean} monitor
     */
    function secureRedirector(target, monitor) {
        //For performance, any supplied object with a length attribute is assumed to be an array of elements.
        if (typeof target.length === 'undefined') {
            checkAndAddListener(target);
            if (monitor) {
                elementInsertionListener(target, secureRedirector);
            }
        } else if (typeof target !== 'string' && !(target instanceof String)) { // No I18N
            for (var i = 0; i < target.length; i++) {
                checkAndAddListener(target[i]);
                if (monitor) {
                    elementInsertionListener(target, secureRedirector);
                }
            }
        }
    }

    /**
     * it iterates over all the child elements and sets click listener for the element where reverse tabnabbing based phishing attacks are possible
     * @param   {Element} target
     * */
    function checkAndAddListener(target) {
        if (target.nodeType != 1) {
            return;
        }
        var elementName = target.nodeName;
        if (elementName == 'A' || elementName == 'a' || elementName == 'MATH' || elementName == 'math') {
            addEventListener(target, 'click', clickListener); // No I18N
        }
        var childElement = target.childNodes;
        if (childElement && childElement.length) {
            var childCount = childElement.length;
            for (var i = 0; i < childCount; i++) {
                var each = childElement[i];
                if (each.nodeType == 1) {
                    checkAndAddListener(each);
                }
            }
        }
    }

    /**
     * it sets listener for an element to capture the new element insertion, using either MutationObserver or element.addEventListener based on the browser support
     * @param   {Element} element
     * @param   {Function} callback
     * */
    function elementInsertionListener(element, callback) {
        var MutationObserver = window.MutationObserver || window.WebKitMutationObserver,
            eventListenerSupported = window.addEventListener;
        if (MutationObserver) {
            var obs = new MutationObserver(function(mutations, observer) {
                for (var i = 0; i < mutations.length; i++) {
                    var addedNodesSize = mutations[i].addedNodes.length;
                    if (addedNodesSize) {
                        var addedList = mutations[i].addedNodes;
                        for (var j = 0; j < addedNodesSize; j++) {
                            callback(addedList[j]);
                        }
                    }
                }
            });
            obs.observe(element, {
                childList: true,
                subtree: true
            });
        } else if (eventListenerSupported) {
            element.addEventListener('DOMNodeInserted', function(e) {
                callback(e.target)
            }, false);
        }
    };

    /**
     * Accepts the same arguments as window.open. If the strWindowName is not
     * equal to one of the safe targets (_top, _self or _parent), then it opens
     * the destination url using "window.open" from an injected iframe, then
     * removes the iframe. This behavior applies to all browsers except IE < 11,
     * which use "window.open" followed by setting the child window's opener to
     * null. If the strWindowName is set to some other value, the url is simply
     * opened with window.open().
     *
     * @param   {string} strUrl
     * @param   {string} [strWindowName]
     * @param   {string} [strWindowFeatures]
     * @returns {Window}
     */
    secureRedirector.open = function(strUrl, strWindowName, strWindowFeatures) {
        var child;

        if (safeTarget(strWindowName)) {
            return open.apply(window, arguments);
        } else if (!oldIE) {
            return iframeOpen(strUrl, strWindowName, strWindowFeatures);
        } else {
            // Replace child.opener for old IE to avoid appendChild errors
            // We do it for all to avoid having to sniff for specific versions
            child = open.apply(window, arguments);
            child.opener = null;
            return child;
        }
    };

    /**
     * Patches window.open() to use blankshield.open() for new window/tab targets.
     */
    secureRedirector.patch = function() {
        window.open = function() {
            return secureRedirector.open.apply(this, arguments);
        };
    };

    /**
     * An event listener that can be attached to a click event to protect against
     * reverse tabnabbing. It retrieves the target anchors href, and if the link
     * was intended to open in a new tab or window, the browser's default
     * behavior is canceled. Instead, the destination url is opened using
     * "window.open" from an injected iframe, and the iframe is removed. Except
     * for IE < 11, which uses "window.open" followed by setting the child
     * window's opener to null.
     *
     * @param {Event} e The click event for a given anchor
     */
    function clickListener(e) {
        var target, targetName, href, usedModifier;

        // Use global event object for IE8 and below to get target
        e = e || window.event;
        // Won't work for IE8 and below for cases when e.srcElement
        // refers not to the anchor, but to the element inside it e.g. an image
        target = e.currentTarget || e.srcElement;

        // Ignore anchors without an href
        href = target.getAttribute('href');
        if (!href) {
            href = target.getAttribute('xlink:href');
            if (!href) {
                return;
            }
        }

        // Ignore anchors without an unsafe target or modifier key
        usedModifier = (e.ctrlKey || e.shiftKey || e.metaKey);
        targetName = target.getAttribute('target');
        var target2 = target.getAttribute('xlink:show');
        if (!usedModifier && (!targetName || safeTarget(targetName)) && !target2) {
            return;
        }

        secureRedirector.open(href);

        // IE8 and below don't support preventDefault
        if (e.preventDefault) {
            e.preventDefault();
        } else {
            e.returnValue = false;
        }

        return false;
    }

    /**
     * A cross-browser addEventListener function that adds a listener for the
     * supplied event type to the specified target.
     *
     * @param {object}   target
     * @param {string}   type
     * @param {function} listener
     */
    function addEventListener(target, type, listener) {
        var onType, prevListener;
        // Modern browsers
        if (target.addEventListener) {
            return target.addEventListener(type, listener, false);
        }

        // Older browsers
        onType = 'on' + type; // No I18N
        if (target.attachEvent) {
            target.attachEvent(onType, listener);
        } else if (target[onType]) {
            prevListener = target[onType];
            target[onType] = function() {
                listener();
                prevListener();
            };
        } else {
            target[onType] = listener;
        }
    }

    /**
     * Replaces vulnerable characters in the given string 
     * with safe characters from the given character map
     *
     * @param   {string}  str      The string with vulnerable characters
     * @param   {Map}     charMap  Map of vulnerable characters as keys with safe characters as values
     *
     * @return  {string}           Safe string without vulnerable characters
     */
    function replaceVulnChars(str, charMap) {
        if(!charMap || !str){
            return str;
        }
        var newStr = "";
        for(var i = 0; i < str.length; i++){
            if(charMap.hasOwnProperty(str[i])){
                newStr += charMap[str[i]];
            } else {
                newStr += str[i];
            }
        }
        return newStr;    
    }

    /**
     * Opens the provided url by injecting a hidden iframe that calls
     * window.open(), then removes the iframe from the DOM.
     *
     * @param   {string} url The url to open
     * @param   {string} [strWindowName]
     * @param   {string} [strWindowFeatures]
     * @returns {Window}
     */
    function iframeOpen(url, strWindowName, strWindowFeatures) {
        var iframe, iframeDoc, script, openArgs, newWin;

        iframe = document.createElement('iframe');
        iframe.style.display = 'none';
        document.body.appendChild(iframe);
        iframeDoc = iframe.contentDocument || iframe.contentWindow.document;

        openArgs = '"' + window.encodeURI(url) + '"'; // No I18N
        if (strWindowName) {
            openArgs += ', "' + replaceVulnChars(strWindowName, jsVulnCharMap) + '"'; // No I18N
        }
        if (strWindowFeatures) {
            openArgs += ', "' + replaceVulnChars(strWindowFeatures, jsVulnCharMap) + '"'; // No I18N
        }

        script = iframeDoc.createElement('script');
        script.type = 'text/javascript';
        script.text = 'window.parent = null; window.top = null;' +
            'window.frameElement = null; var child = window.open(' + openArgs + ');' +
            'try{child.opener = null;}catch(e){}'; // No I18N
        iframeDoc.body.appendChild(script);
        newWin = iframe.contentWindow.child;

        document.body.removeChild(iframe);
        return newWin;
    }

    /**
     * Returns whether or not the given target is safe.
     *
     * @param  {string}  target
     * @return {boolean}
     */
    function safeTarget(target) {
        return target === '_top' || target === '_self' || target === '_parent'; // No I18N
    }

    if (Object.freeze) {
        Object.freeze(secureRedirector)
    }
    return secureRedirector;
}));